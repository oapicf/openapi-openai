/**
* OpenAI API
* The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
*
* The version of the OpenAPI document: 2.3.0
* Contact: blah+oapicf@cliffano.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "VectorStoresApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string VectorStoresApi::base = "/v1";

VectorStoresApi::VectorStoresApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void VectorStoresApi::init() {
    setupRoutes();
}

void VectorStoresApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Post(*router, base + "/vector_stores/:vector_store_id/file_batches/:batch_id/cancel", Routes::bind(&VectorStoresApi::cancel_vector_store_file_batch_handler, this));
    Routes::Post(*router, base + "/vector_stores", Routes::bind(&VectorStoresApi::create_vector_store_handler, this));
    Routes::Post(*router, base + "/vector_stores/:vector_store_id/files", Routes::bind(&VectorStoresApi::create_vector_store_file_handler, this));
    Routes::Post(*router, base + "/vector_stores/:vector_store_id/file_batches", Routes::bind(&VectorStoresApi::create_vector_store_file_batch_handler, this));
    Routes::Delete(*router, base + "/vector_stores/:vector_store_id", Routes::bind(&VectorStoresApi::delete_vector_store_handler, this));
    Routes::Delete(*router, base + "/vector_stores/:vector_store_id/files/:file_id", Routes::bind(&VectorStoresApi::delete_vector_store_file_handler, this));
    Routes::Get(*router, base + "/vector_stores/:vector_store_id", Routes::bind(&VectorStoresApi::get_vector_store_handler, this));
    Routes::Get(*router, base + "/vector_stores/:vector_store_id/files/:file_id", Routes::bind(&VectorStoresApi::get_vector_store_file_handler, this));
    Routes::Get(*router, base + "/vector_stores/:vector_store_id/file_batches/:batch_id", Routes::bind(&VectorStoresApi::get_vector_store_file_batch_handler, this));
    Routes::Get(*router, base + "/vector_stores/:vector_store_id/file_batches/:batch_id/files", Routes::bind(&VectorStoresApi::list_files_in_vector_store_batch_handler, this));
    Routes::Get(*router, base + "/vector_stores/:vector_store_id/files", Routes::bind(&VectorStoresApi::list_vector_store_files_handler, this));
    Routes::Get(*router, base + "/vector_stores", Routes::bind(&VectorStoresApi::list_vector_stores_handler, this));
    Routes::Post(*router, base + "/vector_stores/:vector_store_id", Routes::bind(&VectorStoresApi::modify_vector_store_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&VectorStoresApi::vector_stores_api_default_handler, this));
}

void VectorStoresApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> VectorStoresApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void VectorStoresApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> VectorStoresApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void VectorStoresApi::cancel_vector_store_file_batch_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto vectorStoreId = request.param(":vectorStoreId").as<std::string>();
        auto batchId = request.param(":batchId").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 1

            auto bearerAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if (!bearerAuthHeader || (bearerAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Bearer))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            std::string completeHeaderValue = bearerAuthHeader->value();
            const std::string tokenAsString(completeHeaderValue.begin() + std::string("Bearer ").length(), completeHeaderValue.end());

            HttpBearerToken bearerToken{tokenAsString};

            if (!this->bearerTokenAuthenticator.has_value() || !this->bearerTokenAuthenticator.value()(bearerToken))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            this->cancel_vector_store_file_batch(bearerToken,vectorStoreId, batchId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/vector_stores/:vector_store_id/file_batches/:batch_id/cancel" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void VectorStoresApi::create_vector_store_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        // Getting the body param
        
        CreateVectorStoreRequest createVectorStoreRequest;
        
        
        
    

        try {
            nlohmann::json::parse(request.body()).get_to(createVectorStoreRequest);
            createVectorStoreRequest.validate();
        } catch (std::exception& e) {
            this->handleParsingException(e, response);
            return;
        }

        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 1

            auto bearerAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if (!bearerAuthHeader || (bearerAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Bearer))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            std::string completeHeaderValue = bearerAuthHeader->value();
            const std::string tokenAsString(completeHeaderValue.begin() + std::string("Bearer ").length(), completeHeaderValue.end());

            HttpBearerToken bearerToken{tokenAsString};

            if (!this->bearerTokenAuthenticator.has_value() || !this->bearerTokenAuthenticator.value()(bearerToken))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            this->create_vector_store(bearerToken,createVectorStoreRequest, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/vector_stores" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void VectorStoresApi::create_vector_store_file_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto vectorStoreId = request.param(":vectorStoreId").as<std::string>();
        
        // Getting the body param
        
        CreateVectorStoreFileRequest createVectorStoreFileRequest;
        
        
        
    

        try {
            nlohmann::json::parse(request.body()).get_to(createVectorStoreFileRequest);
            createVectorStoreFileRequest.validate();
        } catch (std::exception& e) {
            this->handleParsingException(e, response);
            return;
        }

        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 1

            auto bearerAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if (!bearerAuthHeader || (bearerAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Bearer))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            std::string completeHeaderValue = bearerAuthHeader->value();
            const std::string tokenAsString(completeHeaderValue.begin() + std::string("Bearer ").length(), completeHeaderValue.end());

            HttpBearerToken bearerToken{tokenAsString};

            if (!this->bearerTokenAuthenticator.has_value() || !this->bearerTokenAuthenticator.value()(bearerToken))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            this->create_vector_store_file(bearerToken,vectorStoreId, createVectorStoreFileRequest, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/vector_stores/:vector_store_id/files" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void VectorStoresApi::create_vector_store_file_batch_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto vectorStoreId = request.param(":vectorStoreId").as<std::string>();
        
        // Getting the body param
        
        CreateVectorStoreFileBatchRequest createVectorStoreFileBatchRequest;
        
        
        
    

        try {
            nlohmann::json::parse(request.body()).get_to(createVectorStoreFileBatchRequest);
            createVectorStoreFileBatchRequest.validate();
        } catch (std::exception& e) {
            this->handleParsingException(e, response);
            return;
        }

        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 1

            auto bearerAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if (!bearerAuthHeader || (bearerAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Bearer))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            std::string completeHeaderValue = bearerAuthHeader->value();
            const std::string tokenAsString(completeHeaderValue.begin() + std::string("Bearer ").length(), completeHeaderValue.end());

            HttpBearerToken bearerToken{tokenAsString};

            if (!this->bearerTokenAuthenticator.has_value() || !this->bearerTokenAuthenticator.value()(bearerToken))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            this->create_vector_store_file_batch(bearerToken,vectorStoreId, createVectorStoreFileBatchRequest, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/vector_stores/:vector_store_id/file_batches" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void VectorStoresApi::delete_vector_store_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto vectorStoreId = request.param(":vectorStoreId").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 1

            auto bearerAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if (!bearerAuthHeader || (bearerAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Bearer))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            std::string completeHeaderValue = bearerAuthHeader->value();
            const std::string tokenAsString(completeHeaderValue.begin() + std::string("Bearer ").length(), completeHeaderValue.end());

            HttpBearerToken bearerToken{tokenAsString};

            if (!this->bearerTokenAuthenticator.has_value() || !this->bearerTokenAuthenticator.value()(bearerToken))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            this->delete_vector_store(bearerToken,vectorStoreId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/vector_stores/:vector_store_id" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void VectorStoresApi::delete_vector_store_file_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto vectorStoreId = request.param(":vectorStoreId").as<std::string>();
        auto fileId = request.param(":fileId").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 1

            auto bearerAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if (!bearerAuthHeader || (bearerAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Bearer))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            std::string completeHeaderValue = bearerAuthHeader->value();
            const std::string tokenAsString(completeHeaderValue.begin() + std::string("Bearer ").length(), completeHeaderValue.end());

            HttpBearerToken bearerToken{tokenAsString};

            if (!this->bearerTokenAuthenticator.has_value() || !this->bearerTokenAuthenticator.value()(bearerToken))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            this->delete_vector_store_file(bearerToken,vectorStoreId, fileId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/vector_stores/:vector_store_id/files/:file_id" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void VectorStoresApi::get_vector_store_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto vectorStoreId = request.param(":vectorStoreId").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 1

            auto bearerAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if (!bearerAuthHeader || (bearerAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Bearer))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            std::string completeHeaderValue = bearerAuthHeader->value();
            const std::string tokenAsString(completeHeaderValue.begin() + std::string("Bearer ").length(), completeHeaderValue.end());

            HttpBearerToken bearerToken{tokenAsString};

            if (!this->bearerTokenAuthenticator.has_value() || !this->bearerTokenAuthenticator.value()(bearerToken))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            this->get_vector_store(bearerToken,vectorStoreId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/vector_stores/:vector_store_id" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void VectorStoresApi::get_vector_store_file_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto vectorStoreId = request.param(":vectorStoreId").as<std::string>();
        auto fileId = request.param(":fileId").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 1

            auto bearerAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if (!bearerAuthHeader || (bearerAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Bearer))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            std::string completeHeaderValue = bearerAuthHeader->value();
            const std::string tokenAsString(completeHeaderValue.begin() + std::string("Bearer ").length(), completeHeaderValue.end());

            HttpBearerToken bearerToken{tokenAsString};

            if (!this->bearerTokenAuthenticator.has_value() || !this->bearerTokenAuthenticator.value()(bearerToken))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            this->get_vector_store_file(bearerToken,vectorStoreId, fileId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/vector_stores/:vector_store_id/files/:file_id" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void VectorStoresApi::get_vector_store_file_batch_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto vectorStoreId = request.param(":vectorStoreId").as<std::string>();
        auto batchId = request.param(":batchId").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 1

            auto bearerAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if (!bearerAuthHeader || (bearerAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Bearer))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            std::string completeHeaderValue = bearerAuthHeader->value();
            const std::string tokenAsString(completeHeaderValue.begin() + std::string("Bearer ").length(), completeHeaderValue.end());

            HttpBearerToken bearerToken{tokenAsString};

            if (!this->bearerTokenAuthenticator.has_value() || !this->bearerTokenAuthenticator.value()(bearerToken))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            this->get_vector_store_file_batch(bearerToken,vectorStoreId, batchId, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/vector_stores/:vector_store_id/file_batches/:batch_id" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void VectorStoresApi::list_files_in_vector_store_batch_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto vectorStoreId = request.param(":vectorStoreId").as<std::string>();
        auto batchId = request.param(":batchId").as<std::string>();
        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto orderQuery = request.query().get("order");
        std::optional<std::string> order;
        if (orderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(orderQuery.value(), valueQuery_instance)) {
                order = valueQuery_instance;
            }
        }
        auto afterQuery = request.query().get("after");
        std::optional<std::string> after;
        if (afterQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(afterQuery.value(), valueQuery_instance)) {
                after = valueQuery_instance;
            }
        }
        auto beforeQuery = request.query().get("before");
        std::optional<std::string> before;
        if (beforeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(beforeQuery.value(), valueQuery_instance)) {
                before = valueQuery_instance;
            }
        }
        auto filterQuery = request.query().get("filter");
        std::optional<std::string> filter;
        if (filterQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filterQuery.value(), valueQuery_instance)) {
                filter = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 1

            auto bearerAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if (!bearerAuthHeader || (bearerAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Bearer))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            std::string completeHeaderValue = bearerAuthHeader->value();
            const std::string tokenAsString(completeHeaderValue.begin() + std::string("Bearer ").length(), completeHeaderValue.end());

            HttpBearerToken bearerToken{tokenAsString};

            if (!this->bearerTokenAuthenticator.has_value() || !this->bearerTokenAuthenticator.value()(bearerToken))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            this->list_files_in_vector_store_batch(bearerToken,vectorStoreId, batchId, limit, order, after, before, filter, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/vector_stores/:vector_store_id/file_batches/:batch_id/files" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void VectorStoresApi::list_vector_store_files_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto vectorStoreId = request.param(":vectorStoreId").as<std::string>();
        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto orderQuery = request.query().get("order");
        std::optional<std::string> order;
        if (orderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(orderQuery.value(), valueQuery_instance)) {
                order = valueQuery_instance;
            }
        }
        auto afterQuery = request.query().get("after");
        std::optional<std::string> after;
        if (afterQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(afterQuery.value(), valueQuery_instance)) {
                after = valueQuery_instance;
            }
        }
        auto beforeQuery = request.query().get("before");
        std::optional<std::string> before;
        if (beforeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(beforeQuery.value(), valueQuery_instance)) {
                before = valueQuery_instance;
            }
        }
        auto filterQuery = request.query().get("filter");
        std::optional<std::string> filter;
        if (filterQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(filterQuery.value(), valueQuery_instance)) {
                filter = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 1

            auto bearerAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if (!bearerAuthHeader || (bearerAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Bearer))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            std::string completeHeaderValue = bearerAuthHeader->value();
            const std::string tokenAsString(completeHeaderValue.begin() + std::string("Bearer ").length(), completeHeaderValue.end());

            HttpBearerToken bearerToken{tokenAsString};

            if (!this->bearerTokenAuthenticator.has_value() || !this->bearerTokenAuthenticator.value()(bearerToken))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            this->list_vector_store_files(bearerToken,vectorStoreId, limit, order, after, before, filter, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/vector_stores/:vector_store_id/files" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void VectorStoresApi::list_vector_stores_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto orderQuery = request.query().get("order");
        std::optional<std::string> order;
        if (orderQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(orderQuery.value(), valueQuery_instance)) {
                order = valueQuery_instance;
            }
        }
        auto afterQuery = request.query().get("after");
        std::optional<std::string> after;
        if (afterQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(afterQuery.value(), valueQuery_instance)) {
                after = valueQuery_instance;
            }
        }
        auto beforeQuery = request.query().get("before");
        std::optional<std::string> before;
        if (beforeQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(beforeQuery.value(), valueQuery_instance)) {
                before = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 1

            auto bearerAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if (!bearerAuthHeader || (bearerAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Bearer))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            std::string completeHeaderValue = bearerAuthHeader->value();
            const std::string tokenAsString(completeHeaderValue.begin() + std::string("Bearer ").length(), completeHeaderValue.end());

            HttpBearerToken bearerToken{tokenAsString};

            if (!this->bearerTokenAuthenticator.has_value() || !this->bearerTokenAuthenticator.value()(bearerToken))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            this->list_vector_stores(bearerToken,limit, order, after, before, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/vector_stores" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void VectorStoresApi::modify_vector_store_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto vectorStoreId = request.param(":vectorStoreId").as<std::string>();
        
        // Getting the body param
        
        UpdateVectorStoreRequest updateVectorStoreRequest;
        
        
        
    

        try {
            nlohmann::json::parse(request.body()).get_to(updateVectorStoreRequest);
            updateVectorStoreRequest.validate();
        } catch (std::exception& e) {
            this->handleParsingException(e, response);
            return;
        }

        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 1

            auto bearerAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if (!bearerAuthHeader || (bearerAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Bearer))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            std::string completeHeaderValue = bearerAuthHeader->value();
            const std::string tokenAsString(completeHeaderValue.begin() + std::string("Bearer ").length(), completeHeaderValue.end());

            HttpBearerToken bearerToken{tokenAsString};

            if (!this->bearerTokenAuthenticator.has_value() || !this->bearerTokenAuthenticator.value()(bearerToken))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            this->modify_vector_store(bearerToken,vectorStoreId, updateVectorStoreRequest, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/vector_stores/:vector_store_id" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}


void VectorStoresApi::vector_stores_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

