/**
* OpenAI API
* APIs for sampling from and fine-tuning language models
*
* The version of the OpenAPI document: 2.0.0
* Contact: blah+oapicf@cliffano.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "CreateFineTuneRequest.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

CreateFineTuneRequest::CreateFineTuneRequest()
{
    m_Training_file = "";
    m_Validation_file = "";
    m_Validation_fileIsSet = false;
    m_ModelIsSet = false;
    m_N_epochs = 4;
    m_N_epochsIsSet = false;
    m_Batch_size = 0;
    m_Batch_sizeIsSet = false;
    m_Learning_rate_multiplier = 0.0;
    m_Learning_rate_multiplierIsSet = false;
    m_Prompt_loss_weight = 0.01;
    m_Prompt_loss_weightIsSet = false;
    m_Compute_classification_metrics = false;
    m_Compute_classification_metricsIsSet = false;
    m_Classification_n_classes = 0;
    m_Classification_n_classesIsSet = false;
    m_Classification_positive_class = "";
    m_Classification_positive_classIsSet = false;
    m_Classification_betasIsSet = false;
    m_Suffix = "";
    m_SuffixIsSet = false;
    
}

void CreateFineTuneRequest::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool CreateFineTuneRequest::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool CreateFineTuneRequest::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "CreateFineTuneRequest" : pathPrefix;

                                                 
    if (classificationBetasIsSet())
    {
        const std::vector<double>& value = m_Classification_betas;
        const std::string currentValuePath = _pathPrefix + ".classificationBetas";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const double& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
 
                i++;
            }
        }

    }
         
    if (suffixIsSet())
    {
        const std::string& value = m_Suffix;
        const std::string currentValuePath = _pathPrefix + ".suffix";
                
        
        if (value.length() < 1)
        {
            success = false;
            msg << currentValuePath << ": must be at least 1 characters long;";
        }
        if (value.length() > 40)
        {
            success = false;
            msg << currentValuePath << ": must be at most 40 characters long;";
        }

    }
    
    return success;
}

bool CreateFineTuneRequest::operator==(const CreateFineTuneRequest& rhs) const
{
    return
    
    
    (getTrainingFile() == rhs.getTrainingFile())
     &&
    
    
    ((!validationFileIsSet() && !rhs.validationFileIsSet()) || (validationFileIsSet() && rhs.validationFileIsSet() && getValidationFile() == rhs.getValidationFile())) &&
    
    
    ((!modelIsSet() && !rhs.modelIsSet()) || (modelIsSet() && rhs.modelIsSet() && getModel() == rhs.getModel())) &&
    
    
    ((!nEpochsIsSet() && !rhs.nEpochsIsSet()) || (nEpochsIsSet() && rhs.nEpochsIsSet() && getNEpochs() == rhs.getNEpochs())) &&
    
    
    ((!batchSizeIsSet() && !rhs.batchSizeIsSet()) || (batchSizeIsSet() && rhs.batchSizeIsSet() && getBatchSize() == rhs.getBatchSize())) &&
    
    
    ((!learningRateMultiplierIsSet() && !rhs.learningRateMultiplierIsSet()) || (learningRateMultiplierIsSet() && rhs.learningRateMultiplierIsSet() && getLearningRateMultiplier() == rhs.getLearningRateMultiplier())) &&
    
    
    ((!promptLossWeightIsSet() && !rhs.promptLossWeightIsSet()) || (promptLossWeightIsSet() && rhs.promptLossWeightIsSet() && getPromptLossWeight() == rhs.getPromptLossWeight())) &&
    
    
    ((!computeClassificationMetricsIsSet() && !rhs.computeClassificationMetricsIsSet()) || (computeClassificationMetricsIsSet() && rhs.computeClassificationMetricsIsSet() && isComputeClassificationMetrics() == rhs.isComputeClassificationMetrics())) &&
    
    
    ((!classificationNClassesIsSet() && !rhs.classificationNClassesIsSet()) || (classificationNClassesIsSet() && rhs.classificationNClassesIsSet() && getClassificationNClasses() == rhs.getClassificationNClasses())) &&
    
    
    ((!classificationPositiveClassIsSet() && !rhs.classificationPositiveClassIsSet()) || (classificationPositiveClassIsSet() && rhs.classificationPositiveClassIsSet() && getClassificationPositiveClass() == rhs.getClassificationPositiveClass())) &&
    
    
    ((!classificationBetasIsSet() && !rhs.classificationBetasIsSet()) || (classificationBetasIsSet() && rhs.classificationBetasIsSet() && getClassificationBetas() == rhs.getClassificationBetas())) &&
    
    
    ((!suffixIsSet() && !rhs.suffixIsSet()) || (suffixIsSet() && rhs.suffixIsSet() && getSuffix() == rhs.getSuffix()))
    
    ;
}

bool CreateFineTuneRequest::operator!=(const CreateFineTuneRequest& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const CreateFineTuneRequest& o)
{
    j = nlohmann::json::object();
    j["training_file"] = o.m_Training_file;
    if(o.validationFileIsSet())
        j["validation_file"] = o.m_Validation_file;
    if(o.modelIsSet())
        j["model"] = o.m_Model;
    if(o.nEpochsIsSet())
        j["n_epochs"] = o.m_N_epochs;
    if(o.batchSizeIsSet())
        j["batch_size"] = o.m_Batch_size;
    if(o.learningRateMultiplierIsSet())
        j["learning_rate_multiplier"] = o.m_Learning_rate_multiplier;
    if(o.promptLossWeightIsSet())
        j["prompt_loss_weight"] = o.m_Prompt_loss_weight;
    if(o.computeClassificationMetricsIsSet())
        j["compute_classification_metrics"] = o.m_Compute_classification_metrics;
    if(o.classificationNClassesIsSet())
        j["classification_n_classes"] = o.m_Classification_n_classes;
    if(o.classificationPositiveClassIsSet())
        j["classification_positive_class"] = o.m_Classification_positive_class;
    if(o.classificationBetasIsSet() || !o.m_Classification_betas.empty())
        j["classification_betas"] = o.m_Classification_betas;
    if(o.suffixIsSet())
        j["suffix"] = o.m_Suffix;
    
}

void from_json(const nlohmann::json& j, CreateFineTuneRequest& o)
{
    j.at("training_file").get_to(o.m_Training_file);
    if(j.find("validation_file") != j.end())
    {
        j.at("validation_file").get_to(o.m_Validation_file);
        o.m_Validation_fileIsSet = true;
    } 
    if(j.find("model") != j.end())
    {
        j.at("model").get_to(o.m_Model);
        o.m_ModelIsSet = true;
    } 
    if(j.find("n_epochs") != j.end())
    {
        j.at("n_epochs").get_to(o.m_N_epochs);
        o.m_N_epochsIsSet = true;
    } 
    if(j.find("batch_size") != j.end())
    {
        j.at("batch_size").get_to(o.m_Batch_size);
        o.m_Batch_sizeIsSet = true;
    } 
    if(j.find("learning_rate_multiplier") != j.end())
    {
        j.at("learning_rate_multiplier").get_to(o.m_Learning_rate_multiplier);
        o.m_Learning_rate_multiplierIsSet = true;
    } 
    if(j.find("prompt_loss_weight") != j.end())
    {
        j.at("prompt_loss_weight").get_to(o.m_Prompt_loss_weight);
        o.m_Prompt_loss_weightIsSet = true;
    } 
    if(j.find("compute_classification_metrics") != j.end())
    {
        j.at("compute_classification_metrics").get_to(o.m_Compute_classification_metrics);
        o.m_Compute_classification_metricsIsSet = true;
    } 
    if(j.find("classification_n_classes") != j.end())
    {
        j.at("classification_n_classes").get_to(o.m_Classification_n_classes);
        o.m_Classification_n_classesIsSet = true;
    } 
    if(j.find("classification_positive_class") != j.end())
    {
        j.at("classification_positive_class").get_to(o.m_Classification_positive_class);
        o.m_Classification_positive_classIsSet = true;
    } 
    if(j.find("classification_betas") != j.end())
    {
        j.at("classification_betas").get_to(o.m_Classification_betas);
        o.m_Classification_betasIsSet = true;
    } 
    if(j.find("suffix") != j.end())
    {
        j.at("suffix").get_to(o.m_Suffix);
        o.m_SuffixIsSet = true;
    } 
    
}

std::string CreateFineTuneRequest::getTrainingFile() const
{
    return m_Training_file;
}
void CreateFineTuneRequest::setTrainingFile(std::string const& value)
{
    m_Training_file = value;
}
std::string CreateFineTuneRequest::getValidationFile() const
{
    return m_Validation_file;
}
void CreateFineTuneRequest::setValidationFile(std::string const& value)
{
    m_Validation_file = value;
    m_Validation_fileIsSet = true;
}
bool CreateFineTuneRequest::validationFileIsSet() const
{
    return m_Validation_fileIsSet;
}
void CreateFineTuneRequest::unsetValidation_file()
{
    m_Validation_fileIsSet = false;
}
org::openapitools::server::model::CreateFineTuneRequest_model CreateFineTuneRequest::getModel() const
{
    return m_Model;
}
void CreateFineTuneRequest::setModel(org::openapitools::server::model::CreateFineTuneRequest_model const& value)
{
    m_Model = value;
    m_ModelIsSet = true;
}
bool CreateFineTuneRequest::modelIsSet() const
{
    return m_ModelIsSet;
}
void CreateFineTuneRequest::unsetModel()
{
    m_ModelIsSet = false;
}
int32_t CreateFineTuneRequest::getNEpochs() const
{
    return m_N_epochs;
}
void CreateFineTuneRequest::setNEpochs(int32_t const value)
{
    m_N_epochs = value;
    m_N_epochsIsSet = true;
}
bool CreateFineTuneRequest::nEpochsIsSet() const
{
    return m_N_epochsIsSet;
}
void CreateFineTuneRequest::unsetN_epochs()
{
    m_N_epochsIsSet = false;
}
int32_t CreateFineTuneRequest::getBatchSize() const
{
    return m_Batch_size;
}
void CreateFineTuneRequest::setBatchSize(int32_t const value)
{
    m_Batch_size = value;
    m_Batch_sizeIsSet = true;
}
bool CreateFineTuneRequest::batchSizeIsSet() const
{
    return m_Batch_sizeIsSet;
}
void CreateFineTuneRequest::unsetBatch_size()
{
    m_Batch_sizeIsSet = false;
}
double CreateFineTuneRequest::getLearningRateMultiplier() const
{
    return m_Learning_rate_multiplier;
}
void CreateFineTuneRequest::setLearningRateMultiplier(double const value)
{
    m_Learning_rate_multiplier = value;
    m_Learning_rate_multiplierIsSet = true;
}
bool CreateFineTuneRequest::learningRateMultiplierIsSet() const
{
    return m_Learning_rate_multiplierIsSet;
}
void CreateFineTuneRequest::unsetLearning_rate_multiplier()
{
    m_Learning_rate_multiplierIsSet = false;
}
double CreateFineTuneRequest::getPromptLossWeight() const
{
    return m_Prompt_loss_weight;
}
void CreateFineTuneRequest::setPromptLossWeight(double const value)
{
    m_Prompt_loss_weight = value;
    m_Prompt_loss_weightIsSet = true;
}
bool CreateFineTuneRequest::promptLossWeightIsSet() const
{
    return m_Prompt_loss_weightIsSet;
}
void CreateFineTuneRequest::unsetPrompt_loss_weight()
{
    m_Prompt_loss_weightIsSet = false;
}
bool CreateFineTuneRequest::isComputeClassificationMetrics() const
{
    return m_Compute_classification_metrics;
}
void CreateFineTuneRequest::setComputeClassificationMetrics(bool const value)
{
    m_Compute_classification_metrics = value;
    m_Compute_classification_metricsIsSet = true;
}
bool CreateFineTuneRequest::computeClassificationMetricsIsSet() const
{
    return m_Compute_classification_metricsIsSet;
}
void CreateFineTuneRequest::unsetCompute_classification_metrics()
{
    m_Compute_classification_metricsIsSet = false;
}
int32_t CreateFineTuneRequest::getClassificationNClasses() const
{
    return m_Classification_n_classes;
}
void CreateFineTuneRequest::setClassificationNClasses(int32_t const value)
{
    m_Classification_n_classes = value;
    m_Classification_n_classesIsSet = true;
}
bool CreateFineTuneRequest::classificationNClassesIsSet() const
{
    return m_Classification_n_classesIsSet;
}
void CreateFineTuneRequest::unsetClassification_n_classes()
{
    m_Classification_n_classesIsSet = false;
}
std::string CreateFineTuneRequest::getClassificationPositiveClass() const
{
    return m_Classification_positive_class;
}
void CreateFineTuneRequest::setClassificationPositiveClass(std::string const& value)
{
    m_Classification_positive_class = value;
    m_Classification_positive_classIsSet = true;
}
bool CreateFineTuneRequest::classificationPositiveClassIsSet() const
{
    return m_Classification_positive_classIsSet;
}
void CreateFineTuneRequest::unsetClassification_positive_class()
{
    m_Classification_positive_classIsSet = false;
}
std::vector<double> CreateFineTuneRequest::getClassificationBetas() const
{
    return m_Classification_betas;
}
void CreateFineTuneRequest::setClassificationBetas(std::vector<double> const value)
{
    m_Classification_betas = value;
    m_Classification_betasIsSet = true;
}
bool CreateFineTuneRequest::classificationBetasIsSet() const
{
    return m_Classification_betasIsSet;
}
void CreateFineTuneRequest::unsetClassification_betas()
{
    m_Classification_betasIsSet = false;
}
std::string CreateFineTuneRequest::getSuffix() const
{
    return m_Suffix;
}
void CreateFineTuneRequest::setSuffix(std::string const& value)
{
    m_Suffix = value;
    m_SuffixIsSet = true;
}
bool CreateFineTuneRequest::suffixIsSet() const
{
    return m_SuffixIsSet;
}
void CreateFineTuneRequest::unsetSuffix()
{
    m_SuffixIsSet = false;
}


} // namespace org::openapitools::server::model

