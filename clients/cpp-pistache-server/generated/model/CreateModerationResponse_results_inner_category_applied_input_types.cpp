/**
* OpenAI API
* The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
*
* The version of the OpenAPI document: 2.3.0
* Contact: blah+oapicf@cliffano.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "CreateModerationResponse_results_inner_category_applied_input_types.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

CreateModerationResponse_results_inner_category_applied_input_types::CreateModerationResponse_results_inner_category_applied_input_types()
{
    
}

void CreateModerationResponse_results_inner_category_applied_input_types::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool CreateModerationResponse_results_inner_category_applied_input_types::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool CreateModerationResponse_results_inner_category_applied_input_types::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "CreateModerationResponse_results_inner_category_applied_input_types" : pathPrefix;

         
    
    /* Hate */ {
        const std::vector<std::string>& value = m_Hate;
        const std::string currentValuePath = _pathPrefix + ".hate";
                
        success = value.validate(msg, currentValuePath) && success;
        
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
        if (
            value != "text"
        ) {
            success = false;
            msg << currentValuePath << ": has invalid value \"" << value << "\";";
        }
 
                i++;
            }
        }

    }
         
    
    /* Hate_threatening */ {
        const std::vector<std::string>& value = m_Hate_threatening;
        const std::string currentValuePath = _pathPrefix + ".hateThreatening";
                
        success = value.validate(msg, currentValuePath) && success;
        
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
        if (
            value != "text"
        ) {
            success = false;
            msg << currentValuePath << ": has invalid value \"" << value << "\";";
        }
 
                i++;
            }
        }

    }
         
    
    /* Harassment */ {
        const std::vector<std::string>& value = m_Harassment;
        const std::string currentValuePath = _pathPrefix + ".harassment";
                
        success = value.validate(msg, currentValuePath) && success;
        
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
        if (
            value != "text"
        ) {
            success = false;
            msg << currentValuePath << ": has invalid value \"" << value << "\";";
        }
 
                i++;
            }
        }

    }
         
    
    /* Harassment_threatening */ {
        const std::vector<std::string>& value = m_Harassment_threatening;
        const std::string currentValuePath = _pathPrefix + ".harassmentThreatening";
                
        success = value.validate(msg, currentValuePath) && success;
        
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
        if (
            value != "text"
        ) {
            success = false;
            msg << currentValuePath << ": has invalid value \"" << value << "\";";
        }
 
                i++;
            }
        }

    }
         
    
    /* Illicit */ {
        const std::vector<std::string>& value = m_Illicit;
        const std::string currentValuePath = _pathPrefix + ".illicit";
                
        success = value.validate(msg, currentValuePath) && success;
        
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
        if (
            value != "text"
        ) {
            success = false;
            msg << currentValuePath << ": has invalid value \"" << value << "\";";
        }
 
                i++;
            }
        }

    }
         
    
    /* Illicit_violent */ {
        const std::vector<std::string>& value = m_Illicit_violent;
        const std::string currentValuePath = _pathPrefix + ".illicitViolent";
                
        success = value.validate(msg, currentValuePath) && success;
        
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
        if (
            value != "text"
        ) {
            success = false;
            msg << currentValuePath << ": has invalid value \"" << value << "\";";
        }
 
                i++;
            }
        }

    }
         
    
    /* Self_harm */ {
        const std::vector<std::string>& value = m_Self_harm;
        const std::string currentValuePath = _pathPrefix + ".selfHarm";
                
        success = value.validate(msg, currentValuePath) && success;
        
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
        if (
            value != "text" &&
            value != "image"
        ) {
            success = false;
            msg << currentValuePath << ": has invalid value \"" << value << "\";";
        }
 
                i++;
            }
        }

    }
         
    
    /* Self_harm_intent */ {
        const std::vector<std::string>& value = m_Self_harm_intent;
        const std::string currentValuePath = _pathPrefix + ".selfHarmIntent";
                
        success = value.validate(msg, currentValuePath) && success;
        
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
        if (
            value != "text" &&
            value != "image"
        ) {
            success = false;
            msg << currentValuePath << ": has invalid value \"" << value << "\";";
        }
 
                i++;
            }
        }

    }
         
    
    /* Self_harm_instructions */ {
        const std::vector<std::string>& value = m_Self_harm_instructions;
        const std::string currentValuePath = _pathPrefix + ".selfHarmInstructions";
                
        success = value.validate(msg, currentValuePath) && success;
        
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
        if (
            value != "text" &&
            value != "image"
        ) {
            success = false;
            msg << currentValuePath << ": has invalid value \"" << value << "\";";
        }
 
                i++;
            }
        }

    }
         
    
    /* Sexual */ {
        const std::vector<std::string>& value = m_Sexual;
        const std::string currentValuePath = _pathPrefix + ".sexual";
                
        success = value.validate(msg, currentValuePath) && success;
        
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
        if (
            value != "text" &&
            value != "image"
        ) {
            success = false;
            msg << currentValuePath << ": has invalid value \"" << value << "\";";
        }
 
                i++;
            }
        }

    }
         
    
    /* Sexual_minors */ {
        const std::vector<std::string>& value = m_Sexual_minors;
        const std::string currentValuePath = _pathPrefix + ".sexualMinors";
                
        success = value.validate(msg, currentValuePath) && success;
        
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
        if (
            value != "text"
        ) {
            success = false;
            msg << currentValuePath << ": has invalid value \"" << value << "\";";
        }
 
                i++;
            }
        }

    }
         
    
    /* Violence */ {
        const std::vector<std::string>& value = m_Violence;
        const std::string currentValuePath = _pathPrefix + ".violence";
                
        success = value.validate(msg, currentValuePath) && success;
        
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
        if (
            value != "text" &&
            value != "image"
        ) {
            success = false;
            msg << currentValuePath << ": has invalid value \"" << value << "\";";
        }
 
                i++;
            }
        }

    }
         
    
    /* Violence_graphic */ {
        const std::vector<std::string>& value = m_Violence_graphic;
        const std::string currentValuePath = _pathPrefix + ".violenceGraphic";
                
        success = value.validate(msg, currentValuePath) && success;
        
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
        if (
            value != "text" &&
            value != "image"
        ) {
            success = false;
            msg << currentValuePath << ": has invalid value \"" << value << "\";";
        }
 
                i++;
            }
        }

    }
    
    return success;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::operator==(const CreateModerationResponse_results_inner_category_applied_input_types& rhs) const
{
    return
    
    
    (getHate() == rhs.getHate())
     &&
    
    (getHateThreatening() == rhs.getHateThreatening())
     &&
    
    (getHarassment() == rhs.getHarassment())
     &&
    
    (getHarassmentThreatening() == rhs.getHarassmentThreatening())
     &&
    
    (getIllicit() == rhs.getIllicit())
     &&
    
    (getIllicitViolent() == rhs.getIllicitViolent())
     &&
    
    (getSelfHarm() == rhs.getSelfHarm())
     &&
    
    (getSelfHarmIntent() == rhs.getSelfHarmIntent())
     &&
    
    (getSelfHarmInstructions() == rhs.getSelfHarmInstructions())
     &&
    
    (getSexual() == rhs.getSexual())
     &&
    
    (getSexualMinors() == rhs.getSexualMinors())
     &&
    
    (getViolence() == rhs.getViolence())
     &&
    
    (getViolenceGraphic() == rhs.getViolenceGraphic())
    
    
    ;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::operator!=(const CreateModerationResponse_results_inner_category_applied_input_types& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const CreateModerationResponse_results_inner_category_applied_input_types& o)
{
    j = nlohmann::json::object();
    j["hate"] = o.m_Hate;
    j["hate/threatening"] = o.m_Hate_threatening;
    j["harassment"] = o.m_Harassment;
    j["harassment/threatening"] = o.m_Harassment_threatening;
    j["illicit"] = o.m_Illicit;
    j["illicit/violent"] = o.m_Illicit_violent;
    j["self-harm"] = o.m_Self_harm;
    j["self-harm/intent"] = o.m_Self_harm_intent;
    j["self-harm/instructions"] = o.m_Self_harm_instructions;
    j["sexual"] = o.m_Sexual;
    j["sexual/minors"] = o.m_Sexual_minors;
    j["violence"] = o.m_Violence;
    j["violence/graphic"] = o.m_Violence_graphic;
    
}

void from_json(const nlohmann::json& j, CreateModerationResponse_results_inner_category_applied_input_types& o)
{
    j.at("hate").get_to(o.m_Hate);
    j.at("hate/threatening").get_to(o.m_Hate_threatening);
    j.at("harassment").get_to(o.m_Harassment);
    j.at("harassment/threatening").get_to(o.m_Harassment_threatening);
    j.at("illicit").get_to(o.m_Illicit);
    j.at("illicit/violent").get_to(o.m_Illicit_violent);
    j.at("self-harm").get_to(o.m_Self_harm);
    j.at("self-harm/intent").get_to(o.m_Self_harm_intent);
    j.at("self-harm/instructions").get_to(o.m_Self_harm_instructions);
    j.at("sexual").get_to(o.m_Sexual);
    j.at("sexual/minors").get_to(o.m_Sexual_minors);
    j.at("violence").get_to(o.m_Violence);
    j.at("violence/graphic").get_to(o.m_Violence_graphic);
    
}

std::vector<std::string> CreateModerationResponse_results_inner_category_applied_input_types::getHate() const
{
    return m_Hate;
}
void CreateModerationResponse_results_inner_category_applied_input_types::setHate(std::vector<std::string> const& value)
{
    m_Hate = value;
}
std::vector<std::string> CreateModerationResponse_results_inner_category_applied_input_types::getHateThreatening() const
{
    return m_Hate_threatening;
}
void CreateModerationResponse_results_inner_category_applied_input_types::setHateThreatening(std::vector<std::string> const& value)
{
    m_Hate_threatening = value;
}
std::vector<std::string> CreateModerationResponse_results_inner_category_applied_input_types::getHarassment() const
{
    return m_Harassment;
}
void CreateModerationResponse_results_inner_category_applied_input_types::setHarassment(std::vector<std::string> const& value)
{
    m_Harassment = value;
}
std::vector<std::string> CreateModerationResponse_results_inner_category_applied_input_types::getHarassmentThreatening() const
{
    return m_Harassment_threatening;
}
void CreateModerationResponse_results_inner_category_applied_input_types::setHarassmentThreatening(std::vector<std::string> const& value)
{
    m_Harassment_threatening = value;
}
std::vector<std::string> CreateModerationResponse_results_inner_category_applied_input_types::getIllicit() const
{
    return m_Illicit;
}
void CreateModerationResponse_results_inner_category_applied_input_types::setIllicit(std::vector<std::string> const& value)
{
    m_Illicit = value;
}
std::vector<std::string> CreateModerationResponse_results_inner_category_applied_input_types::getIllicitViolent() const
{
    return m_Illicit_violent;
}
void CreateModerationResponse_results_inner_category_applied_input_types::setIllicitViolent(std::vector<std::string> const& value)
{
    m_Illicit_violent = value;
}
std::vector<std::string> CreateModerationResponse_results_inner_category_applied_input_types::getSelfHarm() const
{
    return m_Self_harm;
}
void CreateModerationResponse_results_inner_category_applied_input_types::setSelfHarm(std::vector<std::string> const& value)
{
    m_Self_harm = value;
}
std::vector<std::string> CreateModerationResponse_results_inner_category_applied_input_types::getSelfHarmIntent() const
{
    return m_Self_harm_intent;
}
void CreateModerationResponse_results_inner_category_applied_input_types::setSelfHarmIntent(std::vector<std::string> const& value)
{
    m_Self_harm_intent = value;
}
std::vector<std::string> CreateModerationResponse_results_inner_category_applied_input_types::getSelfHarmInstructions() const
{
    return m_Self_harm_instructions;
}
void CreateModerationResponse_results_inner_category_applied_input_types::setSelfHarmInstructions(std::vector<std::string> const& value)
{
    m_Self_harm_instructions = value;
}
std::vector<std::string> CreateModerationResponse_results_inner_category_applied_input_types::getSexual() const
{
    return m_Sexual;
}
void CreateModerationResponse_results_inner_category_applied_input_types::setSexual(std::vector<std::string> const& value)
{
    m_Sexual = value;
}
std::vector<std::string> CreateModerationResponse_results_inner_category_applied_input_types::getSexualMinors() const
{
    return m_Sexual_minors;
}
void CreateModerationResponse_results_inner_category_applied_input_types::setSexualMinors(std::vector<std::string> const& value)
{
    m_Sexual_minors = value;
}
std::vector<std::string> CreateModerationResponse_results_inner_category_applied_input_types::getViolence() const
{
    return m_Violence;
}
void CreateModerationResponse_results_inner_category_applied_input_types::setViolence(std::vector<std::string> const& value)
{
    m_Violence = value;
}
std::vector<std::string> CreateModerationResponse_results_inner_category_applied_input_types::getViolenceGraphic() const
{
    return m_Violence_graphic;
}
void CreateModerationResponse_results_inner_category_applied_input_types::setViolenceGraphic(std::vector<std::string> const& value)
{
    m_Violence_graphic = value;
}


} // namespace org::openapitools::server::model

