/**
* OpenAI API
* The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
*
* The version of the OpenAPI document: 2.3.0
* Contact: blah+oapicf@cliffano.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "ProjectRateLimit.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

ProjectRateLimit::ProjectRateLimit()
{
    m_object = "";
    m_Id = "";
    m_Model = "";
    m_Max_requests_per_1_minute = 0;
    m_Max_tokens_per_1_minute = 0;
    m_Max_images_per_1_minute = 0;
    m_Max_images_per_1_minuteIsSet = false;
    m_Max_audio_megabytes_per_1_minute = 0;
    m_Max_audio_megabytes_per_1_minuteIsSet = false;
    m_Max_requests_per_1_day = 0;
    m_Max_requests_per_1_dayIsSet = false;
    m_Batch_1_day_max_input_tokens = 0;
    m_Batch_1_day_max_input_tokensIsSet = false;
    
}

void ProjectRateLimit::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool ProjectRateLimit::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool ProjectRateLimit::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "ProjectRateLimit" : pathPrefix;

                                        
    return success;
}

bool ProjectRateLimit::operator==(const ProjectRateLimit& rhs) const
{
    return
    
    
    (getObject() == rhs.getObject())
     &&
    
    (getId() == rhs.getId())
     &&
    
    (getModel() == rhs.getModel())
     &&
    
    (getMaxRequestsPer1Minute() == rhs.getMaxRequestsPer1Minute())
     &&
    
    (getMaxTokensPer1Minute() == rhs.getMaxTokensPer1Minute())
     &&
    
    
    ((!maxImagesPer1MinuteIsSet() && !rhs.maxImagesPer1MinuteIsSet()) || (maxImagesPer1MinuteIsSet() && rhs.maxImagesPer1MinuteIsSet() && getMaxImagesPer1Minute() == rhs.getMaxImagesPer1Minute())) &&
    
    
    ((!maxAudioMegabytesPer1MinuteIsSet() && !rhs.maxAudioMegabytesPer1MinuteIsSet()) || (maxAudioMegabytesPer1MinuteIsSet() && rhs.maxAudioMegabytesPer1MinuteIsSet() && getMaxAudioMegabytesPer1Minute() == rhs.getMaxAudioMegabytesPer1Minute())) &&
    
    
    ((!maxRequestsPer1DayIsSet() && !rhs.maxRequestsPer1DayIsSet()) || (maxRequestsPer1DayIsSet() && rhs.maxRequestsPer1DayIsSet() && getMaxRequestsPer1Day() == rhs.getMaxRequestsPer1Day())) &&
    
    
    ((!batch1DayMaxInputTokensIsSet() && !rhs.batch1DayMaxInputTokensIsSet()) || (batch1DayMaxInputTokensIsSet() && rhs.batch1DayMaxInputTokensIsSet() && getBatch1DayMaxInputTokens() == rhs.getBatch1DayMaxInputTokens()))
    
    ;
}

bool ProjectRateLimit::operator!=(const ProjectRateLimit& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const ProjectRateLimit& o)
{
    j = nlohmann::json::object();
    j["object"] = o.m_object;
    j["id"] = o.m_Id;
    j["model"] = o.m_Model;
    j["max_requests_per_1_minute"] = o.m_Max_requests_per_1_minute;
    j["max_tokens_per_1_minute"] = o.m_Max_tokens_per_1_minute;
    if(o.maxImagesPer1MinuteIsSet())
        j["max_images_per_1_minute"] = o.m_Max_images_per_1_minute;
    if(o.maxAudioMegabytesPer1MinuteIsSet())
        j["max_audio_megabytes_per_1_minute"] = o.m_Max_audio_megabytes_per_1_minute;
    if(o.maxRequestsPer1DayIsSet())
        j["max_requests_per_1_day"] = o.m_Max_requests_per_1_day;
    if(o.batch1DayMaxInputTokensIsSet())
        j["batch_1_day_max_input_tokens"] = o.m_Batch_1_day_max_input_tokens;
    
}

void from_json(const nlohmann::json& j, ProjectRateLimit& o)
{
    j.at("object").get_to(o.m_object);
    j.at("id").get_to(o.m_Id);
    j.at("model").get_to(o.m_Model);
    j.at("max_requests_per_1_minute").get_to(o.m_Max_requests_per_1_minute);
    j.at("max_tokens_per_1_minute").get_to(o.m_Max_tokens_per_1_minute);
    if(j.find("max_images_per_1_minute") != j.end())
    {
        j.at("max_images_per_1_minute").get_to(o.m_Max_images_per_1_minute);
        o.m_Max_images_per_1_minuteIsSet = true;
    } 
    if(j.find("max_audio_megabytes_per_1_minute") != j.end())
    {
        j.at("max_audio_megabytes_per_1_minute").get_to(o.m_Max_audio_megabytes_per_1_minute);
        o.m_Max_audio_megabytes_per_1_minuteIsSet = true;
    } 
    if(j.find("max_requests_per_1_day") != j.end())
    {
        j.at("max_requests_per_1_day").get_to(o.m_Max_requests_per_1_day);
        o.m_Max_requests_per_1_dayIsSet = true;
    } 
    if(j.find("batch_1_day_max_input_tokens") != j.end())
    {
        j.at("batch_1_day_max_input_tokens").get_to(o.m_Batch_1_day_max_input_tokens);
        o.m_Batch_1_day_max_input_tokensIsSet = true;
    } 
    
}

std::string ProjectRateLimit::getObject() const
{
    return m_object;
}
void ProjectRateLimit::setObject(std::string const& value)
{
    m_object = value;
}
std::string ProjectRateLimit::getId() const
{
    return m_Id;
}
void ProjectRateLimit::setId(std::string const& value)
{
    m_Id = value;
}
std::string ProjectRateLimit::getModel() const
{
    return m_Model;
}
void ProjectRateLimit::setModel(std::string const& value)
{
    m_Model = value;
}
int32_t ProjectRateLimit::getMaxRequestsPer1Minute() const
{
    return m_Max_requests_per_1_minute;
}
void ProjectRateLimit::setMaxRequestsPer1Minute(int32_t const value)
{
    m_Max_requests_per_1_minute = value;
}
int32_t ProjectRateLimit::getMaxTokensPer1Minute() const
{
    return m_Max_tokens_per_1_minute;
}
void ProjectRateLimit::setMaxTokensPer1Minute(int32_t const value)
{
    m_Max_tokens_per_1_minute = value;
}
int32_t ProjectRateLimit::getMaxImagesPer1Minute() const
{
    return m_Max_images_per_1_minute;
}
void ProjectRateLimit::setMaxImagesPer1Minute(int32_t const value)
{
    m_Max_images_per_1_minute = value;
    m_Max_images_per_1_minuteIsSet = true;
}
bool ProjectRateLimit::maxImagesPer1MinuteIsSet() const
{
    return m_Max_images_per_1_minuteIsSet;
}
void ProjectRateLimit::unsetMax_images_per_1_minute()
{
    m_Max_images_per_1_minuteIsSet = false;
}
int32_t ProjectRateLimit::getMaxAudioMegabytesPer1Minute() const
{
    return m_Max_audio_megabytes_per_1_minute;
}
void ProjectRateLimit::setMaxAudioMegabytesPer1Minute(int32_t const value)
{
    m_Max_audio_megabytes_per_1_minute = value;
    m_Max_audio_megabytes_per_1_minuteIsSet = true;
}
bool ProjectRateLimit::maxAudioMegabytesPer1MinuteIsSet() const
{
    return m_Max_audio_megabytes_per_1_minuteIsSet;
}
void ProjectRateLimit::unsetMax_audio_megabytes_per_1_minute()
{
    m_Max_audio_megabytes_per_1_minuteIsSet = false;
}
int32_t ProjectRateLimit::getMaxRequestsPer1Day() const
{
    return m_Max_requests_per_1_day;
}
void ProjectRateLimit::setMaxRequestsPer1Day(int32_t const value)
{
    m_Max_requests_per_1_day = value;
    m_Max_requests_per_1_dayIsSet = true;
}
bool ProjectRateLimit::maxRequestsPer1DayIsSet() const
{
    return m_Max_requests_per_1_dayIsSet;
}
void ProjectRateLimit::unsetMax_requests_per_1_day()
{
    m_Max_requests_per_1_dayIsSet = false;
}
int32_t ProjectRateLimit::getBatch1DayMaxInputTokens() const
{
    return m_Batch_1_day_max_input_tokens;
}
void ProjectRateLimit::setBatch1DayMaxInputTokens(int32_t const value)
{
    m_Batch_1_day_max_input_tokens = value;
    m_Batch_1_day_max_input_tokensIsSet = true;
}
bool ProjectRateLimit::batch1DayMaxInputTokensIsSet() const
{
    return m_Batch_1_day_max_input_tokensIsSet;
}
void ProjectRateLimit::unsetBatch_1_day_max_input_tokens()
{
    m_Batch_1_day_max_input_tokensIsSet = false;
}


} // namespace org::openapitools::server::model

