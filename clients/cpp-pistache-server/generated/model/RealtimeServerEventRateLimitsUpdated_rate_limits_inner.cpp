/**
* OpenAI API
* The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
*
* The version of the OpenAPI document: 2.3.0
* Contact: blah+oapicf@cliffano.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "RealtimeServerEventRateLimitsUpdated_rate_limits_inner.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

RealtimeServerEventRateLimitsUpdated_rate_limits_inner::RealtimeServerEventRateLimitsUpdated_rate_limits_inner()
{
    m_Name = "";
    m_NameIsSet = false;
    m_Limit = 0;
    m_LimitIsSet = false;
    m_Remaining = 0;
    m_RemainingIsSet = false;
    m_Reset_seconds = 0.0;
    m_Reset_secondsIsSet = false;
    
}

void RealtimeServerEventRateLimitsUpdated_rate_limits_inner::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool RealtimeServerEventRateLimitsUpdated_rate_limits_inner::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool RealtimeServerEventRateLimitsUpdated_rate_limits_inner::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "RealtimeServerEventRateLimitsUpdated_rate_limits_inner" : pathPrefix;

                    
    return success;
}

bool RealtimeServerEventRateLimitsUpdated_rate_limits_inner::operator==(const RealtimeServerEventRateLimitsUpdated_rate_limits_inner& rhs) const
{
    return
    
    
    
    ((!nameIsSet() && !rhs.nameIsSet()) || (nameIsSet() && rhs.nameIsSet() && getName() == rhs.getName())) &&
    
    
    ((!limitIsSet() && !rhs.limitIsSet()) || (limitIsSet() && rhs.limitIsSet() && getLimit() == rhs.getLimit())) &&
    
    
    ((!remainingIsSet() && !rhs.remainingIsSet()) || (remainingIsSet() && rhs.remainingIsSet() && getRemaining() == rhs.getRemaining())) &&
    
    
    ((!resetSecondsIsSet() && !rhs.resetSecondsIsSet()) || (resetSecondsIsSet() && rhs.resetSecondsIsSet() && getResetSeconds() == rhs.getResetSeconds()))
    
    ;
}

bool RealtimeServerEventRateLimitsUpdated_rate_limits_inner::operator!=(const RealtimeServerEventRateLimitsUpdated_rate_limits_inner& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const RealtimeServerEventRateLimitsUpdated_rate_limits_inner& o)
{
    j = nlohmann::json::object();
    if(o.nameIsSet())
        j["name"] = o.m_Name;
    if(o.limitIsSet())
        j["limit"] = o.m_Limit;
    if(o.remainingIsSet())
        j["remaining"] = o.m_Remaining;
    if(o.resetSecondsIsSet())
        j["reset_seconds"] = o.m_Reset_seconds;
    
}

void from_json(const nlohmann::json& j, RealtimeServerEventRateLimitsUpdated_rate_limits_inner& o)
{
    if(j.find("name") != j.end())
    {
        j.at("name").get_to(o.m_Name);
        o.m_NameIsSet = true;
    } 
    if(j.find("limit") != j.end())
    {
        j.at("limit").get_to(o.m_Limit);
        o.m_LimitIsSet = true;
    } 
    if(j.find("remaining") != j.end())
    {
        j.at("remaining").get_to(o.m_Remaining);
        o.m_RemainingIsSet = true;
    } 
    if(j.find("reset_seconds") != j.end())
    {
        j.at("reset_seconds").get_to(o.m_Reset_seconds);
        o.m_Reset_secondsIsSet = true;
    } 
    
}

std::string RealtimeServerEventRateLimitsUpdated_rate_limits_inner::getName() const
{
    return m_Name;
}
void RealtimeServerEventRateLimitsUpdated_rate_limits_inner::setName(std::string const& value)
{
    m_Name = value;
    m_NameIsSet = true;
}
bool RealtimeServerEventRateLimitsUpdated_rate_limits_inner::nameIsSet() const
{
    return m_NameIsSet;
}
void RealtimeServerEventRateLimitsUpdated_rate_limits_inner::unsetName()
{
    m_NameIsSet = false;
}
int32_t RealtimeServerEventRateLimitsUpdated_rate_limits_inner::getLimit() const
{
    return m_Limit;
}
void RealtimeServerEventRateLimitsUpdated_rate_limits_inner::setLimit(int32_t const value)
{
    m_Limit = value;
    m_LimitIsSet = true;
}
bool RealtimeServerEventRateLimitsUpdated_rate_limits_inner::limitIsSet() const
{
    return m_LimitIsSet;
}
void RealtimeServerEventRateLimitsUpdated_rate_limits_inner::unsetLimit()
{
    m_LimitIsSet = false;
}
int32_t RealtimeServerEventRateLimitsUpdated_rate_limits_inner::getRemaining() const
{
    return m_Remaining;
}
void RealtimeServerEventRateLimitsUpdated_rate_limits_inner::setRemaining(int32_t const value)
{
    m_Remaining = value;
    m_RemainingIsSet = true;
}
bool RealtimeServerEventRateLimitsUpdated_rate_limits_inner::remainingIsSet() const
{
    return m_RemainingIsSet;
}
void RealtimeServerEventRateLimitsUpdated_rate_limits_inner::unsetRemaining()
{
    m_RemainingIsSet = false;
}
double RealtimeServerEventRateLimitsUpdated_rate_limits_inner::getResetSeconds() const
{
    return m_Reset_seconds;
}
void RealtimeServerEventRateLimitsUpdated_rate_limits_inner::setResetSeconds(double const value)
{
    m_Reset_seconds = value;
    m_Reset_secondsIsSet = true;
}
bool RealtimeServerEventRateLimitsUpdated_rate_limits_inner::resetSecondsIsSet() const
{
    return m_Reset_secondsIsSet;
}
void RealtimeServerEventRateLimitsUpdated_rate_limits_inner::unsetReset_seconds()
{
    m_Reset_secondsIsSet = false;
}


} // namespace org::openapitools::server::model

