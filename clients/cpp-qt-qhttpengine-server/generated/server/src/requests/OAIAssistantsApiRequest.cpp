/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QVariantMap>
#include <QDebug>

#include "OAIHelpers.h"
#include "OAIAssistantsApiRequest.h"

namespace OpenAPI {

OAIAssistantsApiRequest::OAIAssistantsApiRequest(QHttpEngine::Socket *s, QSharedPointer<OAIAssistantsApiHandler> hdl) : QObject(s), socket(s), handler(hdl) {
    auto headers = s->headers();
    for(auto itr = headers.begin(); itr != headers.end(); itr++) {
        requestHeaders.insert(QString(itr.key()), QString(itr.value()));
    }
}

OAIAssistantsApiRequest::~OAIAssistantsApiRequest(){
    disconnect(this, nullptr, nullptr, nullptr);
    qDebug() << "OAIAssistantsApiRequest::~OAIAssistantsApiRequest()";
}

QMap<QString, QString>
OAIAssistantsApiRequest::getRequestHeaders() const {
    return requestHeaders;
}

void OAIAssistantsApiRequest::setResponseHeaders(const QMultiMap<QString, QString>& headers){
    for(auto itr = headers.begin(); itr != headers.end(); ++itr) {
        responseHeaders.insert(itr.key(), itr.value());
    }
}


QHttpEngine::Socket* OAIAssistantsApiRequest::getRawSocket(){
    return socket;
}


void OAIAssistantsApiRequest::cancelRunRequest(const QString& thread_idstr, const QString& run_idstr){
    qDebug() << "/v1/threads/{thread_id}/runs/{run_id}/cancel";
    connect(this, &OAIAssistantsApiRequest::cancelRun, handler.data(), &OAIAssistantsApiHandler::cancelRun);

    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
        QString run_id;
    fromStringValue(run_idstr, run_id);
    

    Q_EMIT cancelRun(thread_id, run_id);
}


void OAIAssistantsApiRequest::createAssistantRequest(){
    qDebug() << "/v1/assistants";
    connect(this, &OAIAssistantsApiRequest::createAssistant, handler.data(), &OAIAssistantsApiHandler::createAssistant);

    
 
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAICreateAssistantRequest oai_create_assistant_request;
    ::OpenAPI::fromJsonValue(oai_create_assistant_request, obj);
    

    Q_EMIT createAssistant(oai_create_assistant_request);
}


void OAIAssistantsApiRequest::createAssistantFileRequest(const QString& assistant_idstr){
    qDebug() << "/v1/assistants/{assistant_id}/files";
    connect(this, &OAIAssistantsApiRequest::createAssistantFile, handler.data(), &OAIAssistantsApiHandler::createAssistantFile);

    
    QString assistant_id;
    fromStringValue(assistant_idstr, assistant_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAICreateAssistantFileRequest oai_create_assistant_file_request;
    ::OpenAPI::fromJsonValue(oai_create_assistant_file_request, obj);
    

    Q_EMIT createAssistantFile(assistant_id, oai_create_assistant_file_request);
}


void OAIAssistantsApiRequest::createMessageRequest(const QString& thread_idstr){
    qDebug() << "/v1/threads/{thread_id}/messages";
    connect(this, &OAIAssistantsApiRequest::createMessage, handler.data(), &OAIAssistantsApiHandler::createMessage);

    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAICreateMessageRequest oai_create_message_request;
    ::OpenAPI::fromJsonValue(oai_create_message_request, obj);
    

    Q_EMIT createMessage(thread_id, oai_create_message_request);
}


void OAIAssistantsApiRequest::createRunRequest(const QString& thread_idstr){
    qDebug() << "/v1/threads/{thread_id}/runs";
    connect(this, &OAIAssistantsApiRequest::createRun, handler.data(), &OAIAssistantsApiHandler::createRun);

    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAICreateRunRequest oai_create_run_request;
    ::OpenAPI::fromJsonValue(oai_create_run_request, obj);
    

    Q_EMIT createRun(thread_id, oai_create_run_request);
}


void OAIAssistantsApiRequest::createThreadRequest(){
    qDebug() << "/v1/threads";
    connect(this, &OAIAssistantsApiRequest::createThread, handler.data(), &OAIAssistantsApiHandler::createThread);

    
 
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAICreateThreadRequest oai_create_thread_request;
    ::OpenAPI::fromJsonValue(oai_create_thread_request, obj);
    

    Q_EMIT createThread(oai_create_thread_request);
}


void OAIAssistantsApiRequest::createThreadAndRunRequest(){
    qDebug() << "/v1/threads/runs";
    connect(this, &OAIAssistantsApiRequest::createThreadAndRun, handler.data(), &OAIAssistantsApiHandler::createThreadAndRun);

    
 
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAICreateThreadAndRunRequest oai_create_thread_and_run_request;
    ::OpenAPI::fromJsonValue(oai_create_thread_and_run_request, obj);
    

    Q_EMIT createThreadAndRun(oai_create_thread_and_run_request);
}


void OAIAssistantsApiRequest::deleteAssistantRequest(const QString& assistant_idstr){
    qDebug() << "/v1/assistants/{assistant_id}";
    connect(this, &OAIAssistantsApiRequest::deleteAssistant, handler.data(), &OAIAssistantsApiHandler::deleteAssistant);

    
    QString assistant_id;
    fromStringValue(assistant_idstr, assistant_id);
    

    Q_EMIT deleteAssistant(assistant_id);
}


void OAIAssistantsApiRequest::deleteAssistantFileRequest(const QString& assistant_idstr, const QString& file_idstr){
    qDebug() << "/v1/assistants/{assistant_id}/files/{file_id}";
    connect(this, &OAIAssistantsApiRequest::deleteAssistantFile, handler.data(), &OAIAssistantsApiHandler::deleteAssistantFile);

    
    QString assistant_id;
    fromStringValue(assistant_idstr, assistant_id);
        QString file_id;
    fromStringValue(file_idstr, file_id);
    

    Q_EMIT deleteAssistantFile(assistant_id, file_id);
}


void OAIAssistantsApiRequest::deleteThreadRequest(const QString& thread_idstr){
    qDebug() << "/v1/threads/{thread_id}";
    connect(this, &OAIAssistantsApiRequest::deleteThread, handler.data(), &OAIAssistantsApiHandler::deleteThread);

    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
    

    Q_EMIT deleteThread(thread_id);
}


void OAIAssistantsApiRequest::getAssistantRequest(const QString& assistant_idstr){
    qDebug() << "/v1/assistants/{assistant_id}";
    connect(this, &OAIAssistantsApiRequest::getAssistant, handler.data(), &OAIAssistantsApiHandler::getAssistant);

    
    QString assistant_id;
    fromStringValue(assistant_idstr, assistant_id);
    

    Q_EMIT getAssistant(assistant_id);
}


void OAIAssistantsApiRequest::getAssistantFileRequest(const QString& assistant_idstr, const QString& file_idstr){
    qDebug() << "/v1/assistants/{assistant_id}/files/{file_id}";
    connect(this, &OAIAssistantsApiRequest::getAssistantFile, handler.data(), &OAIAssistantsApiHandler::getAssistantFile);

    
    QString assistant_id;
    fromStringValue(assistant_idstr, assistant_id);
        QString file_id;
    fromStringValue(file_idstr, file_id);
    

    Q_EMIT getAssistantFile(assistant_id, file_id);
}


void OAIAssistantsApiRequest::getMessageRequest(const QString& thread_idstr, const QString& message_idstr){
    qDebug() << "/v1/threads/{thread_id}/messages/{message_id}";
    connect(this, &OAIAssistantsApiRequest::getMessage, handler.data(), &OAIAssistantsApiHandler::getMessage);

    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
        QString message_id;
    fromStringValue(message_idstr, message_id);
    

    Q_EMIT getMessage(thread_id, message_id);
}


void OAIAssistantsApiRequest::getMessageFileRequest(const QString& thread_idstr, const QString& message_idstr, const QString& file_idstr){
    qDebug() << "/v1/threads/{thread_id}/messages/{message_id}/files/{file_id}";
    connect(this, &OAIAssistantsApiRequest::getMessageFile, handler.data(), &OAIAssistantsApiHandler::getMessageFile);

    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
        QString message_id;
    fromStringValue(message_idstr, message_id);
        QString file_id;
    fromStringValue(file_idstr, file_id);
    

    Q_EMIT getMessageFile(thread_id, message_id, file_id);
}


void OAIAssistantsApiRequest::getRunRequest(const QString& thread_idstr, const QString& run_idstr){
    qDebug() << "/v1/threads/{thread_id}/runs/{run_id}";
    connect(this, &OAIAssistantsApiRequest::getRun, handler.data(), &OAIAssistantsApiHandler::getRun);

    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
        QString run_id;
    fromStringValue(run_idstr, run_id);
    

    Q_EMIT getRun(thread_id, run_id);
}


void OAIAssistantsApiRequest::getRunStepRequest(const QString& thread_idstr, const QString& run_idstr, const QString& step_idstr){
    qDebug() << "/v1/threads/{thread_id}/runs/{run_id}/steps/{step_id}";
    connect(this, &OAIAssistantsApiRequest::getRunStep, handler.data(), &OAIAssistantsApiHandler::getRunStep);

    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
        QString run_id;
    fromStringValue(run_idstr, run_id);
        QString step_id;
    fromStringValue(step_idstr, step_id);
    

    Q_EMIT getRunStep(thread_id, run_id, step_id);
}


void OAIAssistantsApiRequest::getThreadRequest(const QString& thread_idstr){
    qDebug() << "/v1/threads/{thread_id}";
    connect(this, &OAIAssistantsApiRequest::getThread, handler.data(), &OAIAssistantsApiHandler::getThread);

    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
    

    Q_EMIT getThread(thread_id);
}


void OAIAssistantsApiRequest::listAssistantFilesRequest(const QString& assistant_idstr){
    qDebug() << "/v1/assistants/{assistant_id}/files";
    connect(this, &OAIAssistantsApiRequest::listAssistantFiles, handler.data(), &OAIAssistantsApiHandler::listAssistantFiles);

    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString order;
    if(socket->queryString().keys().contains("order")){
        fromStringValue(socket->queryString().value("order"), order);
    }
    
    QString after;
    if(socket->queryString().keys().contains("after")){
        fromStringValue(socket->queryString().value("after"), after);
    }
    
    QString before;
    if(socket->queryString().keys().contains("before")){
        fromStringValue(socket->queryString().value("before"), before);
    }
    
    QString assistant_id;
    fromStringValue(assistant_idstr, assistant_id);
    

    Q_EMIT listAssistantFiles(assistant_id, limit, order, after, before);
}


void OAIAssistantsApiRequest::listAssistantsRequest(){
    qDebug() << "/v1/assistants";
    connect(this, &OAIAssistantsApiRequest::listAssistants, handler.data(), &OAIAssistantsApiHandler::listAssistants);

    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString order;
    if(socket->queryString().keys().contains("order")){
        fromStringValue(socket->queryString().value("order"), order);
    }
    
    QString after;
    if(socket->queryString().keys().contains("after")){
        fromStringValue(socket->queryString().value("after"), after);
    }
    
    QString before;
    if(socket->queryString().keys().contains("before")){
        fromStringValue(socket->queryString().value("before"), before);
    }
    


    Q_EMIT listAssistants(limit, order, after, before);
}


void OAIAssistantsApiRequest::listMessageFilesRequest(const QString& thread_idstr, const QString& message_idstr){
    qDebug() << "/v1/threads/{thread_id}/messages/{message_id}/files";
    connect(this, &OAIAssistantsApiRequest::listMessageFiles, handler.data(), &OAIAssistantsApiHandler::listMessageFiles);

    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString order;
    if(socket->queryString().keys().contains("order")){
        fromStringValue(socket->queryString().value("order"), order);
    }
    
    QString after;
    if(socket->queryString().keys().contains("after")){
        fromStringValue(socket->queryString().value("after"), after);
    }
    
    QString before;
    if(socket->queryString().keys().contains("before")){
        fromStringValue(socket->queryString().value("before"), before);
    }
    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
        QString message_id;
    fromStringValue(message_idstr, message_id);
    

    Q_EMIT listMessageFiles(thread_id, message_id, limit, order, after, before);
}


void OAIAssistantsApiRequest::listMessagesRequest(const QString& thread_idstr){
    qDebug() << "/v1/threads/{thread_id}/messages";
    connect(this, &OAIAssistantsApiRequest::listMessages, handler.data(), &OAIAssistantsApiHandler::listMessages);

    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString order;
    if(socket->queryString().keys().contains("order")){
        fromStringValue(socket->queryString().value("order"), order);
    }
    
    QString after;
    if(socket->queryString().keys().contains("after")){
        fromStringValue(socket->queryString().value("after"), after);
    }
    
    QString before;
    if(socket->queryString().keys().contains("before")){
        fromStringValue(socket->queryString().value("before"), before);
    }
    
    QString run_id;
    if(socket->queryString().keys().contains("run_id")){
        fromStringValue(socket->queryString().value("run_id"), run_id);
    }
    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
    

    Q_EMIT listMessages(thread_id, limit, order, after, before, run_id);
}


void OAIAssistantsApiRequest::listRunStepsRequest(const QString& thread_idstr, const QString& run_idstr){
    qDebug() << "/v1/threads/{thread_id}/runs/{run_id}/steps";
    connect(this, &OAIAssistantsApiRequest::listRunSteps, handler.data(), &OAIAssistantsApiHandler::listRunSteps);

    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString order;
    if(socket->queryString().keys().contains("order")){
        fromStringValue(socket->queryString().value("order"), order);
    }
    
    QString after;
    if(socket->queryString().keys().contains("after")){
        fromStringValue(socket->queryString().value("after"), after);
    }
    
    QString before;
    if(socket->queryString().keys().contains("before")){
        fromStringValue(socket->queryString().value("before"), before);
    }
    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
        QString run_id;
    fromStringValue(run_idstr, run_id);
    

    Q_EMIT listRunSteps(thread_id, run_id, limit, order, after, before);
}


void OAIAssistantsApiRequest::listRunsRequest(const QString& thread_idstr){
    qDebug() << "/v1/threads/{thread_id}/runs";
    connect(this, &OAIAssistantsApiRequest::listRuns, handler.data(), &OAIAssistantsApiHandler::listRuns);

    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString order;
    if(socket->queryString().keys().contains("order")){
        fromStringValue(socket->queryString().value("order"), order);
    }
    
    QString after;
    if(socket->queryString().keys().contains("after")){
        fromStringValue(socket->queryString().value("after"), after);
    }
    
    QString before;
    if(socket->queryString().keys().contains("before")){
        fromStringValue(socket->queryString().value("before"), before);
    }
    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
    

    Q_EMIT listRuns(thread_id, limit, order, after, before);
}


void OAIAssistantsApiRequest::modifyAssistantRequest(const QString& assistant_idstr){
    qDebug() << "/v1/assistants/{assistant_id}";
    connect(this, &OAIAssistantsApiRequest::modifyAssistant, handler.data(), &OAIAssistantsApiHandler::modifyAssistant);

    
    QString assistant_id;
    fromStringValue(assistant_idstr, assistant_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAIModifyAssistantRequest oai_modify_assistant_request;
    ::OpenAPI::fromJsonValue(oai_modify_assistant_request, obj);
    

    Q_EMIT modifyAssistant(assistant_id, oai_modify_assistant_request);
}


void OAIAssistantsApiRequest::modifyMessageRequest(const QString& thread_idstr, const QString& message_idstr){
    qDebug() << "/v1/threads/{thread_id}/messages/{message_id}";
    connect(this, &OAIAssistantsApiRequest::modifyMessage, handler.data(), &OAIAssistantsApiHandler::modifyMessage);

    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
        QString message_id;
    fromStringValue(message_idstr, message_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAIModifyMessageRequest oai_modify_message_request;
    ::OpenAPI::fromJsonValue(oai_modify_message_request, obj);
    

    Q_EMIT modifyMessage(thread_id, message_id, oai_modify_message_request);
}


void OAIAssistantsApiRequest::modifyRunRequest(const QString& thread_idstr, const QString& run_idstr){
    qDebug() << "/v1/threads/{thread_id}/runs/{run_id}";
    connect(this, &OAIAssistantsApiRequest::modifyRun, handler.data(), &OAIAssistantsApiHandler::modifyRun);

    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
        QString run_id;
    fromStringValue(run_idstr, run_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAIModifyRunRequest oai_modify_run_request;
    ::OpenAPI::fromJsonValue(oai_modify_run_request, obj);
    

    Q_EMIT modifyRun(thread_id, run_id, oai_modify_run_request);
}


void OAIAssistantsApiRequest::modifyThreadRequest(const QString& thread_idstr){
    qDebug() << "/v1/threads/{thread_id}";
    connect(this, &OAIAssistantsApiRequest::modifyThread, handler.data(), &OAIAssistantsApiHandler::modifyThread);

    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAIModifyThreadRequest oai_modify_thread_request;
    ::OpenAPI::fromJsonValue(oai_modify_thread_request, obj);
    

    Q_EMIT modifyThread(thread_id, oai_modify_thread_request);
}


void OAIAssistantsApiRequest::submitToolOuputsToRunRequest(const QString& thread_idstr, const QString& run_idstr){
    qDebug() << "/v1/threads/{thread_id}/runs/{run_id}/submit_tool_outputs";
    connect(this, &OAIAssistantsApiRequest::submitToolOuputsToRun, handler.data(), &OAIAssistantsApiHandler::submitToolOuputsToRun);

    
    QString thread_id;
    fromStringValue(thread_idstr, thread_id);
        QString run_id;
    fromStringValue(run_idstr, run_id);
     
    
    QJsonDocument doc;
    socket->readJson(doc);
    QJsonObject obj = doc.object();
    OAISubmitToolOutputsRunRequest oai_submit_tool_outputs_run_request;
    ::OpenAPI::fromJsonValue(oai_submit_tool_outputs_run_request, obj);
    

    Q_EMIT submitToolOuputsToRun(thread_id, run_id, oai_submit_tool_outputs_run_request);
}



void OAIAssistantsApiRequest::cancelRunResponse(const OAIRunObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::createAssistantResponse(const OAIAssistantObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::createAssistantFileResponse(const OAIAssistantFileObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::createMessageResponse(const OAIMessageObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::createRunResponse(const OAIRunObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::createThreadResponse(const OAIThreadObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::createThreadAndRunResponse(const OAIRunObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::deleteAssistantResponse(const OAIDeleteAssistantResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::deleteAssistantFileResponse(const OAIDeleteAssistantFileResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::deleteThreadResponse(const OAIDeleteThreadResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::getAssistantResponse(const OAIAssistantObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::getAssistantFileResponse(const OAIAssistantFileObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::getMessageResponse(const OAIMessageObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::getMessageFileResponse(const OAIMessageFileObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::getRunResponse(const OAIRunObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::getRunStepResponse(const OAIRunStepObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::getThreadResponse(const OAIThreadObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::listAssistantFilesResponse(const OAIListAssistantFilesResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::listAssistantsResponse(const OAIListAssistantsResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::listMessageFilesResponse(const OAIListMessageFilesResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::listMessagesResponse(const OAIListMessagesResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::listRunStepsResponse(const OAIListRunStepsResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::listRunsResponse(const OAIListRunsResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::modifyAssistantResponse(const OAIAssistantObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::modifyMessageResponse(const OAIMessageObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::modifyRunResponse(const OAIRunObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::modifyThreadResponse(const OAIThreadObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::submitToolOuputsToRunResponse(const OAIRunObject& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}


void OAIAssistantsApiRequest::cancelRunError(const OAIRunObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::createAssistantError(const OAIAssistantObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::createAssistantFileError(const OAIAssistantFileObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::createMessageError(const OAIMessageObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::createRunError(const OAIRunObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::createThreadError(const OAIThreadObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::createThreadAndRunError(const OAIRunObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::deleteAssistantError(const OAIDeleteAssistantResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::deleteAssistantFileError(const OAIDeleteAssistantFileResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::deleteThreadError(const OAIDeleteThreadResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::getAssistantError(const OAIAssistantObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::getAssistantFileError(const OAIAssistantFileObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::getMessageError(const OAIMessageObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::getMessageFileError(const OAIMessageFileObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::getRunError(const OAIRunObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::getRunStepError(const OAIRunStepObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::getThreadError(const OAIThreadObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::listAssistantFilesError(const OAIListAssistantFilesResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::listAssistantsError(const OAIListAssistantsResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::listMessageFilesError(const OAIListMessageFilesResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::listMessagesError(const OAIListMessagesResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::listRunStepsError(const OAIListRunStepsResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::listRunsError(const OAIListRunsResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::modifyAssistantError(const OAIAssistantObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::modifyMessageError(const OAIMessageObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::modifyRunError(const OAIRunObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::modifyThreadError(const OAIThreadObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::submitToolOuputsToRunError(const OAIRunObject& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}


void OAIAssistantsApiRequest::sendCustomResponse(QByteArray & res, QNetworkReply::NetworkError error_type){
    Q_UNUSED(error_type); // TODO
    socket->write(res);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIAssistantsApiRequest::sendCustomResponse(QIODevice *res, QNetworkReply::NetworkError error_type){
    Q_UNUSED(error_type);  // TODO
    socket->write(res->readAll());
    if(socket->isOpen()){
        socket->close();
    }
}

}
