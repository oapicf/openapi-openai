/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QVariantMap>
#include <QDebug>

#include "OAIHelpers.h"
#include "OAIUsageApiRequest.h"

namespace OpenAPI {

OAIUsageApiRequest::OAIUsageApiRequest(QHttpEngine::Socket *s, QSharedPointer<OAIUsageApiHandler> hdl) : QObject(s), socket(s), handler(hdl) {
    auto headers = s->headers();
    for(auto itr = headers.begin(); itr != headers.end(); itr++) {
        requestHeaders.insert(QString(itr.key()), QString(itr.value()));
    }
}

OAIUsageApiRequest::~OAIUsageApiRequest(){
    disconnect(this, nullptr, nullptr, nullptr);
    qDebug() << "OAIUsageApiRequest::~OAIUsageApiRequest()";
}

QMap<QString, QString>
OAIUsageApiRequest::getRequestHeaders() const {
    return requestHeaders;
}

void OAIUsageApiRequest::setResponseHeaders(const QMultiMap<QString, QString>& headers){
    for(auto itr = headers.begin(); itr != headers.end(); ++itr) {
        responseHeaders.insert(itr.key(), itr.value());
    }
}


QHttpEngine::Socket* OAIUsageApiRequest::getRawSocket(){
    return socket;
}


void OAIUsageApiRequest::usageAudioSpeechesRequest(){
    qDebug() << "/v1/organization/usage/audio_speeches";
    connect(this, &OAIUsageApiRequest::usageAudioSpeeches, handler.data(), &OAIUsageApiHandler::usageAudioSpeeches);

    
    qint32 start_time;
    if(socket->queryString().keys().contains("start_time")){
        fromStringValue(socket->queryString().value("start_time"), start_time);
    }
    
    qint32 end_time;
    if(socket->queryString().keys().contains("end_time")){
        fromStringValue(socket->queryString().value("end_time"), end_time);
    }
    
    QString bucket_width;
    if(socket->queryString().keys().contains("bucket_width")){
        fromStringValue(socket->queryString().value("bucket_width"), bucket_width);
    }
    
    QList<QString> project_ids;
    if(socket->queryString().keys().contains("project_ids")){
        fromStringValue(socket->queryString().values("project_ids"), project_ids);
    }
    
    QList<QString> user_ids;
    if(socket->queryString().keys().contains("user_ids")){
        fromStringValue(socket->queryString().values("user_ids"), user_ids);
    }
    
    QList<QString> api_key_ids;
    if(socket->queryString().keys().contains("api_key_ids")){
        fromStringValue(socket->queryString().values("api_key_ids"), api_key_ids);
    }
    
    QList<QString> models;
    if(socket->queryString().keys().contains("models")){
        fromStringValue(socket->queryString().values("models"), models);
    }
    
    QList<QString> group_by;
    if(socket->queryString().keys().contains("group_by")){
        fromStringValue(socket->queryString().values("group_by"), group_by);
    }
    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString page;
    if(socket->queryString().keys().contains("page")){
        fromStringValue(socket->queryString().value("page"), page);
    }
    


    Q_EMIT usageAudioSpeeches(start_time, end_time, bucket_width, project_ids, user_ids, api_key_ids, models, group_by, limit, page);
}


void OAIUsageApiRequest::usageAudioTranscriptionsRequest(){
    qDebug() << "/v1/organization/usage/audio_transcriptions";
    connect(this, &OAIUsageApiRequest::usageAudioTranscriptions, handler.data(), &OAIUsageApiHandler::usageAudioTranscriptions);

    
    qint32 start_time;
    if(socket->queryString().keys().contains("start_time")){
        fromStringValue(socket->queryString().value("start_time"), start_time);
    }
    
    qint32 end_time;
    if(socket->queryString().keys().contains("end_time")){
        fromStringValue(socket->queryString().value("end_time"), end_time);
    }
    
    QString bucket_width;
    if(socket->queryString().keys().contains("bucket_width")){
        fromStringValue(socket->queryString().value("bucket_width"), bucket_width);
    }
    
    QList<QString> project_ids;
    if(socket->queryString().keys().contains("project_ids")){
        fromStringValue(socket->queryString().values("project_ids"), project_ids);
    }
    
    QList<QString> user_ids;
    if(socket->queryString().keys().contains("user_ids")){
        fromStringValue(socket->queryString().values("user_ids"), user_ids);
    }
    
    QList<QString> api_key_ids;
    if(socket->queryString().keys().contains("api_key_ids")){
        fromStringValue(socket->queryString().values("api_key_ids"), api_key_ids);
    }
    
    QList<QString> models;
    if(socket->queryString().keys().contains("models")){
        fromStringValue(socket->queryString().values("models"), models);
    }
    
    QList<QString> group_by;
    if(socket->queryString().keys().contains("group_by")){
        fromStringValue(socket->queryString().values("group_by"), group_by);
    }
    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString page;
    if(socket->queryString().keys().contains("page")){
        fromStringValue(socket->queryString().value("page"), page);
    }
    


    Q_EMIT usageAudioTranscriptions(start_time, end_time, bucket_width, project_ids, user_ids, api_key_ids, models, group_by, limit, page);
}


void OAIUsageApiRequest::usageCodeInterpreterSessionsRequest(){
    qDebug() << "/v1/organization/usage/code_interpreter_sessions";
    connect(this, &OAIUsageApiRequest::usageCodeInterpreterSessions, handler.data(), &OAIUsageApiHandler::usageCodeInterpreterSessions);

    
    qint32 start_time;
    if(socket->queryString().keys().contains("start_time")){
        fromStringValue(socket->queryString().value("start_time"), start_time);
    }
    
    qint32 end_time;
    if(socket->queryString().keys().contains("end_time")){
        fromStringValue(socket->queryString().value("end_time"), end_time);
    }
    
    QString bucket_width;
    if(socket->queryString().keys().contains("bucket_width")){
        fromStringValue(socket->queryString().value("bucket_width"), bucket_width);
    }
    
    QList<QString> project_ids;
    if(socket->queryString().keys().contains("project_ids")){
        fromStringValue(socket->queryString().values("project_ids"), project_ids);
    }
    
    QList<QString> group_by;
    if(socket->queryString().keys().contains("group_by")){
        fromStringValue(socket->queryString().values("group_by"), group_by);
    }
    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString page;
    if(socket->queryString().keys().contains("page")){
        fromStringValue(socket->queryString().value("page"), page);
    }
    


    Q_EMIT usageCodeInterpreterSessions(start_time, end_time, bucket_width, project_ids, group_by, limit, page);
}


void OAIUsageApiRequest::usageCompletionsRequest(){
    qDebug() << "/v1/organization/usage/completions";
    connect(this, &OAIUsageApiRequest::usageCompletions, handler.data(), &OAIUsageApiHandler::usageCompletions);

    
    qint32 start_time;
    if(socket->queryString().keys().contains("start_time")){
        fromStringValue(socket->queryString().value("start_time"), start_time);
    }
    
    qint32 end_time;
    if(socket->queryString().keys().contains("end_time")){
        fromStringValue(socket->queryString().value("end_time"), end_time);
    }
    
    QString bucket_width;
    if(socket->queryString().keys().contains("bucket_width")){
        fromStringValue(socket->queryString().value("bucket_width"), bucket_width);
    }
    
    QList<QString> project_ids;
    if(socket->queryString().keys().contains("project_ids")){
        fromStringValue(socket->queryString().values("project_ids"), project_ids);
    }
    
    QList<QString> user_ids;
    if(socket->queryString().keys().contains("user_ids")){
        fromStringValue(socket->queryString().values("user_ids"), user_ids);
    }
    
    QList<QString> api_key_ids;
    if(socket->queryString().keys().contains("api_key_ids")){
        fromStringValue(socket->queryString().values("api_key_ids"), api_key_ids);
    }
    
    QList<QString> models;
    if(socket->queryString().keys().contains("models")){
        fromStringValue(socket->queryString().values("models"), models);
    }
    
    bool batch;
    if(socket->queryString().keys().contains("batch")){
        fromStringValue(socket->queryString().value("batch"), batch);
    }
    
    QList<QString> group_by;
    if(socket->queryString().keys().contains("group_by")){
        fromStringValue(socket->queryString().values("group_by"), group_by);
    }
    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString page;
    if(socket->queryString().keys().contains("page")){
        fromStringValue(socket->queryString().value("page"), page);
    }
    


    Q_EMIT usageCompletions(start_time, end_time, bucket_width, project_ids, user_ids, api_key_ids, models, batch, group_by, limit, page);
}


void OAIUsageApiRequest::usageCostsRequest(){
    qDebug() << "/v1/organization/costs";
    connect(this, &OAIUsageApiRequest::usageCosts, handler.data(), &OAIUsageApiHandler::usageCosts);

    
    qint32 start_time;
    if(socket->queryString().keys().contains("start_time")){
        fromStringValue(socket->queryString().value("start_time"), start_time);
    }
    
    qint32 end_time;
    if(socket->queryString().keys().contains("end_time")){
        fromStringValue(socket->queryString().value("end_time"), end_time);
    }
    
    QString bucket_width;
    if(socket->queryString().keys().contains("bucket_width")){
        fromStringValue(socket->queryString().value("bucket_width"), bucket_width);
    }
    
    QList<QString> project_ids;
    if(socket->queryString().keys().contains("project_ids")){
        fromStringValue(socket->queryString().values("project_ids"), project_ids);
    }
    
    QList<QString> group_by;
    if(socket->queryString().keys().contains("group_by")){
        fromStringValue(socket->queryString().values("group_by"), group_by);
    }
    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString page;
    if(socket->queryString().keys().contains("page")){
        fromStringValue(socket->queryString().value("page"), page);
    }
    


    Q_EMIT usageCosts(start_time, end_time, bucket_width, project_ids, group_by, limit, page);
}


void OAIUsageApiRequest::usageEmbeddingsRequest(){
    qDebug() << "/v1/organization/usage/embeddings";
    connect(this, &OAIUsageApiRequest::usageEmbeddings, handler.data(), &OAIUsageApiHandler::usageEmbeddings);

    
    qint32 start_time;
    if(socket->queryString().keys().contains("start_time")){
        fromStringValue(socket->queryString().value("start_time"), start_time);
    }
    
    qint32 end_time;
    if(socket->queryString().keys().contains("end_time")){
        fromStringValue(socket->queryString().value("end_time"), end_time);
    }
    
    QString bucket_width;
    if(socket->queryString().keys().contains("bucket_width")){
        fromStringValue(socket->queryString().value("bucket_width"), bucket_width);
    }
    
    QList<QString> project_ids;
    if(socket->queryString().keys().contains("project_ids")){
        fromStringValue(socket->queryString().values("project_ids"), project_ids);
    }
    
    QList<QString> user_ids;
    if(socket->queryString().keys().contains("user_ids")){
        fromStringValue(socket->queryString().values("user_ids"), user_ids);
    }
    
    QList<QString> api_key_ids;
    if(socket->queryString().keys().contains("api_key_ids")){
        fromStringValue(socket->queryString().values("api_key_ids"), api_key_ids);
    }
    
    QList<QString> models;
    if(socket->queryString().keys().contains("models")){
        fromStringValue(socket->queryString().values("models"), models);
    }
    
    QList<QString> group_by;
    if(socket->queryString().keys().contains("group_by")){
        fromStringValue(socket->queryString().values("group_by"), group_by);
    }
    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString page;
    if(socket->queryString().keys().contains("page")){
        fromStringValue(socket->queryString().value("page"), page);
    }
    


    Q_EMIT usageEmbeddings(start_time, end_time, bucket_width, project_ids, user_ids, api_key_ids, models, group_by, limit, page);
}


void OAIUsageApiRequest::usageImagesRequest(){
    qDebug() << "/v1/organization/usage/images";
    connect(this, &OAIUsageApiRequest::usageImages, handler.data(), &OAIUsageApiHandler::usageImages);

    
    qint32 start_time;
    if(socket->queryString().keys().contains("start_time")){
        fromStringValue(socket->queryString().value("start_time"), start_time);
    }
    
    qint32 end_time;
    if(socket->queryString().keys().contains("end_time")){
        fromStringValue(socket->queryString().value("end_time"), end_time);
    }
    
    QString bucket_width;
    if(socket->queryString().keys().contains("bucket_width")){
        fromStringValue(socket->queryString().value("bucket_width"), bucket_width);
    }
    
    QList<QString> sources;
    if(socket->queryString().keys().contains("sources")){
        fromStringValue(socket->queryString().values("sources"), sources);
    }
    
    QList<QString> sizes;
    if(socket->queryString().keys().contains("sizes")){
        fromStringValue(socket->queryString().values("sizes"), sizes);
    }
    
    QList<QString> project_ids;
    if(socket->queryString().keys().contains("project_ids")){
        fromStringValue(socket->queryString().values("project_ids"), project_ids);
    }
    
    QList<QString> user_ids;
    if(socket->queryString().keys().contains("user_ids")){
        fromStringValue(socket->queryString().values("user_ids"), user_ids);
    }
    
    QList<QString> api_key_ids;
    if(socket->queryString().keys().contains("api_key_ids")){
        fromStringValue(socket->queryString().values("api_key_ids"), api_key_ids);
    }
    
    QList<QString> models;
    if(socket->queryString().keys().contains("models")){
        fromStringValue(socket->queryString().values("models"), models);
    }
    
    QList<QString> group_by;
    if(socket->queryString().keys().contains("group_by")){
        fromStringValue(socket->queryString().values("group_by"), group_by);
    }
    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString page;
    if(socket->queryString().keys().contains("page")){
        fromStringValue(socket->queryString().value("page"), page);
    }
    


    Q_EMIT usageImages(start_time, end_time, bucket_width, sources, sizes, project_ids, user_ids, api_key_ids, models, group_by, limit, page);
}


void OAIUsageApiRequest::usageModerationsRequest(){
    qDebug() << "/v1/organization/usage/moderations";
    connect(this, &OAIUsageApiRequest::usageModerations, handler.data(), &OAIUsageApiHandler::usageModerations);

    
    qint32 start_time;
    if(socket->queryString().keys().contains("start_time")){
        fromStringValue(socket->queryString().value("start_time"), start_time);
    }
    
    qint32 end_time;
    if(socket->queryString().keys().contains("end_time")){
        fromStringValue(socket->queryString().value("end_time"), end_time);
    }
    
    QString bucket_width;
    if(socket->queryString().keys().contains("bucket_width")){
        fromStringValue(socket->queryString().value("bucket_width"), bucket_width);
    }
    
    QList<QString> project_ids;
    if(socket->queryString().keys().contains("project_ids")){
        fromStringValue(socket->queryString().values("project_ids"), project_ids);
    }
    
    QList<QString> user_ids;
    if(socket->queryString().keys().contains("user_ids")){
        fromStringValue(socket->queryString().values("user_ids"), user_ids);
    }
    
    QList<QString> api_key_ids;
    if(socket->queryString().keys().contains("api_key_ids")){
        fromStringValue(socket->queryString().values("api_key_ids"), api_key_ids);
    }
    
    QList<QString> models;
    if(socket->queryString().keys().contains("models")){
        fromStringValue(socket->queryString().values("models"), models);
    }
    
    QList<QString> group_by;
    if(socket->queryString().keys().contains("group_by")){
        fromStringValue(socket->queryString().values("group_by"), group_by);
    }
    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString page;
    if(socket->queryString().keys().contains("page")){
        fromStringValue(socket->queryString().value("page"), page);
    }
    


    Q_EMIT usageModerations(start_time, end_time, bucket_width, project_ids, user_ids, api_key_ids, models, group_by, limit, page);
}


void OAIUsageApiRequest::usageVectorStoresRequest(){
    qDebug() << "/v1/organization/usage/vector_stores";
    connect(this, &OAIUsageApiRequest::usageVectorStores, handler.data(), &OAIUsageApiHandler::usageVectorStores);

    
    qint32 start_time;
    if(socket->queryString().keys().contains("start_time")){
        fromStringValue(socket->queryString().value("start_time"), start_time);
    }
    
    qint32 end_time;
    if(socket->queryString().keys().contains("end_time")){
        fromStringValue(socket->queryString().value("end_time"), end_time);
    }
    
    QString bucket_width;
    if(socket->queryString().keys().contains("bucket_width")){
        fromStringValue(socket->queryString().value("bucket_width"), bucket_width);
    }
    
    QList<QString> project_ids;
    if(socket->queryString().keys().contains("project_ids")){
        fromStringValue(socket->queryString().values("project_ids"), project_ids);
    }
    
    QList<QString> group_by;
    if(socket->queryString().keys().contains("group_by")){
        fromStringValue(socket->queryString().values("group_by"), group_by);
    }
    
    qint32 limit;
    if(socket->queryString().keys().contains("limit")){
        fromStringValue(socket->queryString().value("limit"), limit);
    }
    
    QString page;
    if(socket->queryString().keys().contains("page")){
        fromStringValue(socket->queryString().value("page"), page);
    }
    


    Q_EMIT usageVectorStores(start_time, end_time, bucket_width, project_ids, group_by, limit, page);
}



void OAIUsageApiRequest::usageAudioSpeechesResponse(const OAIUsageResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageAudioTranscriptionsResponse(const OAIUsageResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageCodeInterpreterSessionsResponse(const OAIUsageResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageCompletionsResponse(const OAIUsageResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageCostsResponse(const OAIUsageResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageEmbeddingsResponse(const OAIUsageResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageImagesResponse(const OAIUsageResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageModerationsResponse(const OAIUsageResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageVectorStoresResponse(const OAIUsageResponse& res){
    setSocketResponseHeaders();
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}


void OAIUsageApiRequest::usageAudioSpeechesError(const OAIUsageResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageAudioTranscriptionsError(const OAIUsageResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageCodeInterpreterSessionsError(const OAIUsageResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageCompletionsError(const OAIUsageResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageCostsError(const OAIUsageResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageEmbeddingsError(const OAIUsageResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageImagesError(const OAIUsageResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageModerationsError(const OAIUsageResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::usageVectorStoresError(const OAIUsageResponse& res, QNetworkReply::NetworkError error_type, QString& error_str){
    Q_UNUSED(error_type); // TODO: Remap error_type to QHttpEngine::Socket errors
    setSocketResponseHeaders();
    Q_UNUSED(error_str);  // response will be used instead of error string
    QJsonDocument resDoc(::OpenAPI::toJsonValue(res).toObject());
    socket->writeJson(resDoc);
    if(socket->isOpen()){
        socket->close();
    }
}


void OAIUsageApiRequest::sendCustomResponse(QByteArray & res, QNetworkReply::NetworkError error_type){
    Q_UNUSED(error_type); // TODO
    socket->write(res);
    if(socket->isOpen()){
        socket->close();
    }
}

void OAIUsageApiRequest::sendCustomResponse(QIODevice *res, QNetworkReply::NetworkError error_type){
    Q_UNUSED(error_type);  // TODO
    socket->write(res->readAll());
    if(socket->isOpen()){
        socket->close();
    }
}

}
