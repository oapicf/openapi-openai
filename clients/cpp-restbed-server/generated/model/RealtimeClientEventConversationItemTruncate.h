/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.18.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * RealtimeClientEventConversationItemTruncate.h
 *
 * Send this event to truncate a previous assistant message’s audio. The server  will produce audio faster than realtime, so this event is useful when the user  interrupts to truncate audio that has already been sent to the client but not  yet played. This will synchronize the server&#39;s understanding of the audio with  the client&#39;s playback.  Truncating audio will delete the server-side text transcript to ensure there  is not text in the context that hasn&#39;t been heard by the user.  If successful, the server will respond with a &#x60;conversation.item.truncated&#x60;  event.  
 */

#ifndef RealtimeClientEventConversationItemTruncate_H_
#define RealtimeClientEventConversationItemTruncate_H_



#include <string>
#include <memory>
#include <vector>
#include <array>
#include <boost/property_tree/ptree.hpp>
#include "helpers.h"

namespace org {
namespace openapitools {
namespace server {
namespace model {

/// <summary>
/// Send this event to truncate a previous assistant message’s audio. The server  will produce audio faster than realtime, so this event is useful when the user  interrupts to truncate audio that has already been sent to the client but not  yet played. This will synchronize the server&#39;s understanding of the audio with  the client&#39;s playback.  Truncating audio will delete the server-side text transcript to ensure there  is not text in the context that hasn&#39;t been heard by the user.  If successful, the server will respond with a &#x60;conversation.item.truncated&#x60;  event.  
/// </summary>
class  RealtimeClientEventConversationItemTruncate 
{
public:
    RealtimeClientEventConversationItemTruncate() = default;
    explicit RealtimeClientEventConversationItemTruncate(boost::property_tree::ptree const& pt);
    virtual ~RealtimeClientEventConversationItemTruncate() = default;

    RealtimeClientEventConversationItemTruncate(const RealtimeClientEventConversationItemTruncate& other) = default; // copy constructor
    RealtimeClientEventConversationItemTruncate(RealtimeClientEventConversationItemTruncate&& other) noexcept = default; // move constructor

    RealtimeClientEventConversationItemTruncate& operator=(const RealtimeClientEventConversationItemTruncate& other) = default; // copy assignment
    RealtimeClientEventConversationItemTruncate& operator=(RealtimeClientEventConversationItemTruncate&& other) noexcept = default; // move assignment

    std::string toJsonString(bool prettyJson = false) const;
    void fromJsonString(std::string const& jsonString);
    boost::property_tree::ptree toPropertyTree() const;
    void fromPropertyTree(boost::property_tree::ptree const& pt);


    /////////////////////////////////////////////
    /// RealtimeClientEventConversationItemTruncate members

    /// <summary>
    /// Optional client-generated ID used to identify this event.
    /// </summary>
    std::string getEventId() const;
    void setEventId(std::string value);

    /// <summary>
    /// The event type, must be &#x60;conversation.item.truncate&#x60;.
    /// </summary>
    std::string getType() const;
    void setType(std::string value);

    /// <summary>
    /// The ID of the assistant message item to truncate. Only assistant message  items can be truncated. 
    /// </summary>
    std::string getItemId() const;
    void setItemId(std::string value);

    /// <summary>
    /// The index of the content part to truncate. Set this to 0.
    /// </summary>
    int32_t getContentIndex() const;
    void setContentIndex(int32_t value);

    /// <summary>
    /// Inclusive duration up to which audio is truncated, in milliseconds. If  the audio_end_ms is greater than the actual audio duration, the server  will respond with an error. 
    /// </summary>
    int32_t getAudioEndMs() const;
    void setAudioEndMs(int32_t value);

protected:
    std::string m_Event_id = "";
    std::string m_Type = "";
    std::string m_Item_id = "";
    int32_t m_Content_index = 0;
    int32_t m_Audio_end_ms = 0;
};

std::vector<RealtimeClientEventConversationItemTruncate> createRealtimeClientEventConversationItemTruncateVectorFromJsonString(const std::string& json);

template<>
inline boost::property_tree::ptree toPt<RealtimeClientEventConversationItemTruncate>(const RealtimeClientEventConversationItemTruncate& val) {
    return val.toPropertyTree();
}

template<>
inline RealtimeClientEventConversationItemTruncate fromPt<RealtimeClientEventConversationItemTruncate>(const boost::property_tree::ptree& pt) {
    RealtimeClientEventConversationItemTruncate ret;
    ret.fromPropertyTree(pt);
    return ret;
}

}
}
}
}

#endif /* RealtimeClientEventConversationItemTruncate_H_ */
