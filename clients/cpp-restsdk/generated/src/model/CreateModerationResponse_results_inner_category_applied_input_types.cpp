/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.18.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/CreateModerationResponse_results_inner_category_applied_input_types.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

CreateModerationResponse_results_inner_category_applied_input_types::CreateModerationResponse_results_inner_category_applied_input_types()
{
    m_HateIsSet = false;
    m_Hate_threateningIsSet = false;
    m_HarassmentIsSet = false;
    m_Harassment_threateningIsSet = false;
    m_IllicitIsSet = false;
    m_Illicit_violentIsSet = false;
    m_Self_harmIsSet = false;
    m_Self_harm_intentIsSet = false;
    m_Self_harm_instructionsIsSet = false;
    m_SexualIsSet = false;
    m_Sexual_minorsIsSet = false;
    m_ViolenceIsSet = false;
    m_Violence_graphicIsSet = false;
}

CreateModerationResponse_results_inner_category_applied_input_types::~CreateModerationResponse_results_inner_category_applied_input_types()
{
}

void CreateModerationResponse_results_inner_category_applied_input_types::validate()
{
    // TODO: implement validation
}

web::json::value CreateModerationResponse_results_inner_category_applied_input_types::toJson() const
{
    web::json::value val = web::json::value::object();
    if(m_HateIsSet)
    {
        
        std::vector<utility::string_t> refVal = fromHateEnum(m_Hate);
        val[utility::conversions::to_string_t(_XPLATSTR("hate"))] = ModelBase::toJson(refVal);
        
    }
    if(m_Hate_threateningIsSet)
    {
        
        std::vector<utility::string_t> refVal = fromHate_threateningEnum(m_Hate_threatening);
        val[utility::conversions::to_string_t(_XPLATSTR("hate/threatening"))] = ModelBase::toJson(refVal);
        
    }
    if(m_HarassmentIsSet)
    {
        
        std::vector<utility::string_t> refVal = fromHarassmentEnum(m_Harassment);
        val[utility::conversions::to_string_t(_XPLATSTR("harassment"))] = ModelBase::toJson(refVal);
        
    }
    if(m_Harassment_threateningIsSet)
    {
        
        std::vector<utility::string_t> refVal = fromHarassment_threateningEnum(m_Harassment_threatening);
        val[utility::conversions::to_string_t(_XPLATSTR("harassment/threatening"))] = ModelBase::toJson(refVal);
        
    }
    if(m_IllicitIsSet)
    {
        
        std::vector<utility::string_t> refVal = fromIllicitEnum(m_Illicit);
        val[utility::conversions::to_string_t(_XPLATSTR("illicit"))] = ModelBase::toJson(refVal);
        
    }
    if(m_Illicit_violentIsSet)
    {
        
        std::vector<utility::string_t> refVal = fromIllicit_violentEnum(m_Illicit_violent);
        val[utility::conversions::to_string_t(_XPLATSTR("illicit/violent"))] = ModelBase::toJson(refVal);
        
    }
    if(m_Self_harmIsSet)
    {
        
        std::vector<utility::string_t> refVal = fromSelf_harmEnum(m_Self_harm);
        val[utility::conversions::to_string_t(_XPLATSTR("self-harm"))] = ModelBase::toJson(refVal);
        
    }
    if(m_Self_harm_intentIsSet)
    {
        
        std::vector<utility::string_t> refVal = fromSelf_harm_intentEnum(m_Self_harm_intent);
        val[utility::conversions::to_string_t(_XPLATSTR("self-harm/intent"))] = ModelBase::toJson(refVal);
        
    }
    if(m_Self_harm_instructionsIsSet)
    {
        
        std::vector<utility::string_t> refVal = fromSelf_harm_instructionsEnum(m_Self_harm_instructions);
        val[utility::conversions::to_string_t(_XPLATSTR("self-harm/instructions"))] = ModelBase::toJson(refVal);
        
    }
    if(m_SexualIsSet)
    {
        
        std::vector<utility::string_t> refVal = fromSexualEnum(m_Sexual);
        val[utility::conversions::to_string_t(_XPLATSTR("sexual"))] = ModelBase::toJson(refVal);
        
    }
    if(m_Sexual_minorsIsSet)
    {
        
        std::vector<utility::string_t> refVal = fromSexual_minorsEnum(m_Sexual_minors);
        val[utility::conversions::to_string_t(_XPLATSTR("sexual/minors"))] = ModelBase::toJson(refVal);
        
    }
    if(m_ViolenceIsSet)
    {
        
        std::vector<utility::string_t> refVal = fromViolenceEnum(m_Violence);
        val[utility::conversions::to_string_t(_XPLATSTR("violence"))] = ModelBase::toJson(refVal);
        
    }
    if(m_Violence_graphicIsSet)
    {
        
        std::vector<utility::string_t> refVal = fromViolence_graphicEnum(m_Violence_graphic);
        val[utility::conversions::to_string_t(_XPLATSTR("violence/graphic"))] = ModelBase::toJson(refVal);
        
    }

    return val;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::fromJson(const web::json::value& val)
{
    bool ok = true;
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("hate"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("hate")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setHate;
            ok &= ModelBase::fromJson(fieldValue, refVal_setHate);
            
            setHate(toHateEnum(refVal_setHate));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("hate/threatening"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("hate/threatening")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setHateThreatening;
            ok &= ModelBase::fromJson(fieldValue, refVal_setHateThreatening);
            
            setHateThreatening(toHate_threateningEnum(refVal_setHateThreatening));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("harassment"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("harassment")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setHarassment;
            ok &= ModelBase::fromJson(fieldValue, refVal_setHarassment);
            
            setHarassment(toHarassmentEnum(refVal_setHarassment));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("harassment/threatening"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("harassment/threatening")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setHarassmentThreatening;
            ok &= ModelBase::fromJson(fieldValue, refVal_setHarassmentThreatening);
            
            setHarassmentThreatening(toHarassment_threateningEnum(refVal_setHarassmentThreatening));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("illicit"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("illicit")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setIllicit;
            ok &= ModelBase::fromJson(fieldValue, refVal_setIllicit);
            
            setIllicit(toIllicitEnum(refVal_setIllicit));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("illicit/violent"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("illicit/violent")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setIllicitViolent;
            ok &= ModelBase::fromJson(fieldValue, refVal_setIllicitViolent);
            
            setIllicitViolent(toIllicit_violentEnum(refVal_setIllicitViolent));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("self-harm"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("self-harm")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setSelfHarm;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSelfHarm);
            
            setSelfHarm(toSelf_harmEnum(refVal_setSelfHarm));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("self-harm/intent"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("self-harm/intent")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setSelfHarmIntent;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSelfHarmIntent);
            
            setSelfHarmIntent(toSelf_harm_intentEnum(refVal_setSelfHarmIntent));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("self-harm/instructions"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("self-harm/instructions")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setSelfHarmInstructions;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSelfHarmInstructions);
            
            setSelfHarmInstructions(toSelf_harm_instructionsEnum(refVal_setSelfHarmInstructions));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("sexual"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("sexual")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setSexual;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSexual);
            
            setSexual(toSexualEnum(refVal_setSexual));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("sexual/minors"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("sexual/minors")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setSexualMinors;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSexualMinors);
            
            setSexualMinors(toSexual_minorsEnum(refVal_setSexualMinors));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("violence"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("violence")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setViolence;
            ok &= ModelBase::fromJson(fieldValue, refVal_setViolence);
            
            setViolence(toViolenceEnum(refVal_setViolence));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("violence/graphic"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("violence/graphic")));
        if(!fieldValue.is_null())
        {
            std::vector<utility::string_t> refVal_setViolenceGraphic;
            ok &= ModelBase::fromJson(fieldValue, refVal_setViolenceGraphic);
            
            setViolenceGraphic(toViolence_graphicEnum(refVal_setViolenceGraphic));
            
        }
    }
    return ok;
}

void CreateModerationResponse_results_inner_category_applied_input_types::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(_XPLATSTR(".")))
    {
        namePrefix += utility::conversions::to_string_t(_XPLATSTR("."));
    }
    if(m_HateIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("hate")), fromHateEnum(m_Hate)));
            }
    if(m_Hate_threateningIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("hate/threatening")), fromHate_threateningEnum(m_Hate_threatening)));
            }
    if(m_HarassmentIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("harassment")), fromHarassmentEnum(m_Harassment)));
            }
    if(m_Harassment_threateningIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("harassment/threatening")), fromHarassment_threateningEnum(m_Harassment_threatening)));
            }
    if(m_IllicitIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("illicit")), fromIllicitEnum(m_Illicit)));
            }
    if(m_Illicit_violentIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("illicit/violent")), fromIllicit_violentEnum(m_Illicit_violent)));
            }
    if(m_Self_harmIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("self-harm")), fromSelf_harmEnum(m_Self_harm)));
            }
    if(m_Self_harm_intentIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("self-harm/intent")), fromSelf_harm_intentEnum(m_Self_harm_intent)));
            }
    if(m_Self_harm_instructionsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("self-harm/instructions")), fromSelf_harm_instructionsEnum(m_Self_harm_instructions)));
            }
    if(m_SexualIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("sexual")), fromSexualEnum(m_Sexual)));
            }
    if(m_Sexual_minorsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("sexual/minors")), fromSexual_minorsEnum(m_Sexual_minors)));
            }
    if(m_ViolenceIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("violence")), fromViolenceEnum(m_Violence)));
            }
    if(m_Violence_graphicIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("violence/graphic")), fromViolence_graphicEnum(m_Violence_graphic)));
            }
}

bool CreateModerationResponse_results_inner_category_applied_input_types::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(_XPLATSTR(".")))
    {
        namePrefix += utility::conversions::to_string_t(_XPLATSTR("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("hate"))))
    {
        std::vector<utility::string_t> refVal_setHate;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("hate"))), refVal_setHate );
        setHate(toHateEnum(refVal_setHate));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("hate/threatening"))))
    {
        std::vector<utility::string_t> refVal_setHateThreatening;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("hate/threatening"))), refVal_setHateThreatening );
        setHateThreatening(toHate_threateningEnum(refVal_setHateThreatening));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("harassment"))))
    {
        std::vector<utility::string_t> refVal_setHarassment;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("harassment"))), refVal_setHarassment );
        setHarassment(toHarassmentEnum(refVal_setHarassment));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("harassment/threatening"))))
    {
        std::vector<utility::string_t> refVal_setHarassmentThreatening;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("harassment/threatening"))), refVal_setHarassmentThreatening );
        setHarassmentThreatening(toHarassment_threateningEnum(refVal_setHarassmentThreatening));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("illicit"))))
    {
        std::vector<utility::string_t> refVal_setIllicit;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("illicit"))), refVal_setIllicit );
        setIllicit(toIllicitEnum(refVal_setIllicit));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("illicit/violent"))))
    {
        std::vector<utility::string_t> refVal_setIllicitViolent;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("illicit/violent"))), refVal_setIllicitViolent );
        setIllicitViolent(toIllicit_violentEnum(refVal_setIllicitViolent));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("self-harm"))))
    {
        std::vector<utility::string_t> refVal_setSelfHarm;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("self-harm"))), refVal_setSelfHarm );
        setSelfHarm(toSelf_harmEnum(refVal_setSelfHarm));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("self-harm/intent"))))
    {
        std::vector<utility::string_t> refVal_setSelfHarmIntent;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("self-harm/intent"))), refVal_setSelfHarmIntent );
        setSelfHarmIntent(toSelf_harm_intentEnum(refVal_setSelfHarmIntent));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("self-harm/instructions"))))
    {
        std::vector<utility::string_t> refVal_setSelfHarmInstructions;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("self-harm/instructions"))), refVal_setSelfHarmInstructions );
        setSelfHarmInstructions(toSelf_harm_instructionsEnum(refVal_setSelfHarmInstructions));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("sexual"))))
    {
        std::vector<utility::string_t> refVal_setSexual;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("sexual"))), refVal_setSexual );
        setSexual(toSexualEnum(refVal_setSexual));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("sexual/minors"))))
    {
        std::vector<utility::string_t> refVal_setSexualMinors;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("sexual/minors"))), refVal_setSexualMinors );
        setSexualMinors(toSexual_minorsEnum(refVal_setSexualMinors));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("violence"))))
    {
        std::vector<utility::string_t> refVal_setViolence;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("violence"))), refVal_setViolence );
        setViolence(toViolenceEnum(refVal_setViolence));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("violence/graphic"))))
    {
        std::vector<utility::string_t> refVal_setViolenceGraphic;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("violence/graphic"))), refVal_setViolenceGraphic );
        setViolenceGraphic(toViolence_graphicEnum(refVal_setViolenceGraphic));
    }
    return ok;
}

CreateModerationResponse_results_inner_category_applied_input_types::HateEnum CreateModerationResponse_results_inner_category_applied_input_types::toHateEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("text")) {
        return HateEnum::TEXT;
    }
    
    throw std::invalid_argument("Invalid value for conversion to std::vector<HateEnum>");
}

const utility::string_t CreateModerationResponse_results_inner_category_applied_input_types::fromHateEnum(const HateEnum value) const
{
    switch(value)
    {
        
        case HateEnum::TEXT: return utility::conversions::to_string_t("text");
        
    }
}

std::vector<utility::string_t> CreateModerationResponse_results_inner_category_applied_input_types::fromHateEnum(const std::vector<HateEnum>& value) const
{
    std::vector<utility::string_t> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(fromHateEnum(*it));
    }
    return ret;
}

std::vector<CreateModerationResponse_results_inner_category_applied_input_types::HateEnum> CreateModerationResponse_results_inner_category_applied_input_types::toHateEnum(const std::vector<utility::string_t>& value) const
{
    std::vector<HateEnum> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(toHateEnum(*it));
    }
    return ret;
}
CreateModerationResponse_results_inner_category_applied_input_types::Hate_threateningEnum CreateModerationResponse_results_inner_category_applied_input_types::toHate_threateningEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("text")) {
        return Hate_threateningEnum::TEXT;
    }
    
    throw std::invalid_argument("Invalid value for conversion to std::vector<Hate_threateningEnum>");
}

const utility::string_t CreateModerationResponse_results_inner_category_applied_input_types::fromHate_threateningEnum(const Hate_threateningEnum value) const
{
    switch(value)
    {
        
        case Hate_threateningEnum::TEXT: return utility::conversions::to_string_t("text");
        
    }
}

std::vector<utility::string_t> CreateModerationResponse_results_inner_category_applied_input_types::fromHate_threateningEnum(const std::vector<Hate_threateningEnum>& value) const
{
    std::vector<utility::string_t> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(fromHate_threateningEnum(*it));
    }
    return ret;
}

std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Hate_threateningEnum> CreateModerationResponse_results_inner_category_applied_input_types::toHate_threateningEnum(const std::vector<utility::string_t>& value) const
{
    std::vector<Hate_threateningEnum> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(toHate_threateningEnum(*it));
    }
    return ret;
}
CreateModerationResponse_results_inner_category_applied_input_types::HarassmentEnum CreateModerationResponse_results_inner_category_applied_input_types::toHarassmentEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("text")) {
        return HarassmentEnum::TEXT;
    }
    
    throw std::invalid_argument("Invalid value for conversion to std::vector<HarassmentEnum>");
}

const utility::string_t CreateModerationResponse_results_inner_category_applied_input_types::fromHarassmentEnum(const HarassmentEnum value) const
{
    switch(value)
    {
        
        case HarassmentEnum::TEXT: return utility::conversions::to_string_t("text");
        
    }
}

std::vector<utility::string_t> CreateModerationResponse_results_inner_category_applied_input_types::fromHarassmentEnum(const std::vector<HarassmentEnum>& value) const
{
    std::vector<utility::string_t> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(fromHarassmentEnum(*it));
    }
    return ret;
}

std::vector<CreateModerationResponse_results_inner_category_applied_input_types::HarassmentEnum> CreateModerationResponse_results_inner_category_applied_input_types::toHarassmentEnum(const std::vector<utility::string_t>& value) const
{
    std::vector<HarassmentEnum> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(toHarassmentEnum(*it));
    }
    return ret;
}
CreateModerationResponse_results_inner_category_applied_input_types::Harassment_threateningEnum CreateModerationResponse_results_inner_category_applied_input_types::toHarassment_threateningEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("text")) {
        return Harassment_threateningEnum::TEXT;
    }
    
    throw std::invalid_argument("Invalid value for conversion to std::vector<Harassment_threateningEnum>");
}

const utility::string_t CreateModerationResponse_results_inner_category_applied_input_types::fromHarassment_threateningEnum(const Harassment_threateningEnum value) const
{
    switch(value)
    {
        
        case Harassment_threateningEnum::TEXT: return utility::conversions::to_string_t("text");
        
    }
}

std::vector<utility::string_t> CreateModerationResponse_results_inner_category_applied_input_types::fromHarassment_threateningEnum(const std::vector<Harassment_threateningEnum>& value) const
{
    std::vector<utility::string_t> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(fromHarassment_threateningEnum(*it));
    }
    return ret;
}

std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Harassment_threateningEnum> CreateModerationResponse_results_inner_category_applied_input_types::toHarassment_threateningEnum(const std::vector<utility::string_t>& value) const
{
    std::vector<Harassment_threateningEnum> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(toHarassment_threateningEnum(*it));
    }
    return ret;
}
CreateModerationResponse_results_inner_category_applied_input_types::IllicitEnum CreateModerationResponse_results_inner_category_applied_input_types::toIllicitEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("text")) {
        return IllicitEnum::TEXT;
    }
    
    throw std::invalid_argument("Invalid value for conversion to std::vector<IllicitEnum>");
}

const utility::string_t CreateModerationResponse_results_inner_category_applied_input_types::fromIllicitEnum(const IllicitEnum value) const
{
    switch(value)
    {
        
        case IllicitEnum::TEXT: return utility::conversions::to_string_t("text");
        
    }
}

std::vector<utility::string_t> CreateModerationResponse_results_inner_category_applied_input_types::fromIllicitEnum(const std::vector<IllicitEnum>& value) const
{
    std::vector<utility::string_t> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(fromIllicitEnum(*it));
    }
    return ret;
}

std::vector<CreateModerationResponse_results_inner_category_applied_input_types::IllicitEnum> CreateModerationResponse_results_inner_category_applied_input_types::toIllicitEnum(const std::vector<utility::string_t>& value) const
{
    std::vector<IllicitEnum> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(toIllicitEnum(*it));
    }
    return ret;
}
CreateModerationResponse_results_inner_category_applied_input_types::Illicit_violentEnum CreateModerationResponse_results_inner_category_applied_input_types::toIllicit_violentEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("text")) {
        return Illicit_violentEnum::TEXT;
    }
    
    throw std::invalid_argument("Invalid value for conversion to std::vector<Illicit_violentEnum>");
}

const utility::string_t CreateModerationResponse_results_inner_category_applied_input_types::fromIllicit_violentEnum(const Illicit_violentEnum value) const
{
    switch(value)
    {
        
        case Illicit_violentEnum::TEXT: return utility::conversions::to_string_t("text");
        
    }
}

std::vector<utility::string_t> CreateModerationResponse_results_inner_category_applied_input_types::fromIllicit_violentEnum(const std::vector<Illicit_violentEnum>& value) const
{
    std::vector<utility::string_t> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(fromIllicit_violentEnum(*it));
    }
    return ret;
}

std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Illicit_violentEnum> CreateModerationResponse_results_inner_category_applied_input_types::toIllicit_violentEnum(const std::vector<utility::string_t>& value) const
{
    std::vector<Illicit_violentEnum> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(toIllicit_violentEnum(*it));
    }
    return ret;
}
CreateModerationResponse_results_inner_category_applied_input_types::Self_harmEnum CreateModerationResponse_results_inner_category_applied_input_types::toSelf_harmEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("text")) {
        return Self_harmEnum::TEXT;
    }
    
    if (value == utility::conversions::to_string_t("image")) {
        return Self_harmEnum::IMAGE;
    }
    
    throw std::invalid_argument("Invalid value for conversion to std::vector<Self_harmEnum>");
}

const utility::string_t CreateModerationResponse_results_inner_category_applied_input_types::fromSelf_harmEnum(const Self_harmEnum value) const
{
    switch(value)
    {
        
        case Self_harmEnum::TEXT: return utility::conversions::to_string_t("text");
        
        case Self_harmEnum::IMAGE: return utility::conversions::to_string_t("image");
        
    }
}

std::vector<utility::string_t> CreateModerationResponse_results_inner_category_applied_input_types::fromSelf_harmEnum(const std::vector<Self_harmEnum>& value) const
{
    std::vector<utility::string_t> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(fromSelf_harmEnum(*it));
    }
    return ret;
}

std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Self_harmEnum> CreateModerationResponse_results_inner_category_applied_input_types::toSelf_harmEnum(const std::vector<utility::string_t>& value) const
{
    std::vector<Self_harmEnum> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(toSelf_harmEnum(*it));
    }
    return ret;
}
CreateModerationResponse_results_inner_category_applied_input_types::Self_harm_intentEnum CreateModerationResponse_results_inner_category_applied_input_types::toSelf_harm_intentEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("text")) {
        return Self_harm_intentEnum::TEXT;
    }
    
    if (value == utility::conversions::to_string_t("image")) {
        return Self_harm_intentEnum::IMAGE;
    }
    
    throw std::invalid_argument("Invalid value for conversion to std::vector<Self_harm_intentEnum>");
}

const utility::string_t CreateModerationResponse_results_inner_category_applied_input_types::fromSelf_harm_intentEnum(const Self_harm_intentEnum value) const
{
    switch(value)
    {
        
        case Self_harm_intentEnum::TEXT: return utility::conversions::to_string_t("text");
        
        case Self_harm_intentEnum::IMAGE: return utility::conversions::to_string_t("image");
        
    }
}

std::vector<utility::string_t> CreateModerationResponse_results_inner_category_applied_input_types::fromSelf_harm_intentEnum(const std::vector<Self_harm_intentEnum>& value) const
{
    std::vector<utility::string_t> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(fromSelf_harm_intentEnum(*it));
    }
    return ret;
}

std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Self_harm_intentEnum> CreateModerationResponse_results_inner_category_applied_input_types::toSelf_harm_intentEnum(const std::vector<utility::string_t>& value) const
{
    std::vector<Self_harm_intentEnum> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(toSelf_harm_intentEnum(*it));
    }
    return ret;
}
CreateModerationResponse_results_inner_category_applied_input_types::Self_harm_instructionsEnum CreateModerationResponse_results_inner_category_applied_input_types::toSelf_harm_instructionsEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("text")) {
        return Self_harm_instructionsEnum::TEXT;
    }
    
    if (value == utility::conversions::to_string_t("image")) {
        return Self_harm_instructionsEnum::IMAGE;
    }
    
    throw std::invalid_argument("Invalid value for conversion to std::vector<Self_harm_instructionsEnum>");
}

const utility::string_t CreateModerationResponse_results_inner_category_applied_input_types::fromSelf_harm_instructionsEnum(const Self_harm_instructionsEnum value) const
{
    switch(value)
    {
        
        case Self_harm_instructionsEnum::TEXT: return utility::conversions::to_string_t("text");
        
        case Self_harm_instructionsEnum::IMAGE: return utility::conversions::to_string_t("image");
        
    }
}

std::vector<utility::string_t> CreateModerationResponse_results_inner_category_applied_input_types::fromSelf_harm_instructionsEnum(const std::vector<Self_harm_instructionsEnum>& value) const
{
    std::vector<utility::string_t> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(fromSelf_harm_instructionsEnum(*it));
    }
    return ret;
}

std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Self_harm_instructionsEnum> CreateModerationResponse_results_inner_category_applied_input_types::toSelf_harm_instructionsEnum(const std::vector<utility::string_t>& value) const
{
    std::vector<Self_harm_instructionsEnum> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(toSelf_harm_instructionsEnum(*it));
    }
    return ret;
}
CreateModerationResponse_results_inner_category_applied_input_types::SexualEnum CreateModerationResponse_results_inner_category_applied_input_types::toSexualEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("text")) {
        return SexualEnum::TEXT;
    }
    
    if (value == utility::conversions::to_string_t("image")) {
        return SexualEnum::IMAGE;
    }
    
    throw std::invalid_argument("Invalid value for conversion to std::vector<SexualEnum>");
}

const utility::string_t CreateModerationResponse_results_inner_category_applied_input_types::fromSexualEnum(const SexualEnum value) const
{
    switch(value)
    {
        
        case SexualEnum::TEXT: return utility::conversions::to_string_t("text");
        
        case SexualEnum::IMAGE: return utility::conversions::to_string_t("image");
        
    }
}

std::vector<utility::string_t> CreateModerationResponse_results_inner_category_applied_input_types::fromSexualEnum(const std::vector<SexualEnum>& value) const
{
    std::vector<utility::string_t> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(fromSexualEnum(*it));
    }
    return ret;
}

std::vector<CreateModerationResponse_results_inner_category_applied_input_types::SexualEnum> CreateModerationResponse_results_inner_category_applied_input_types::toSexualEnum(const std::vector<utility::string_t>& value) const
{
    std::vector<SexualEnum> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(toSexualEnum(*it));
    }
    return ret;
}
CreateModerationResponse_results_inner_category_applied_input_types::Sexual_minorsEnum CreateModerationResponse_results_inner_category_applied_input_types::toSexual_minorsEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("text")) {
        return Sexual_minorsEnum::TEXT;
    }
    
    throw std::invalid_argument("Invalid value for conversion to std::vector<Sexual_minorsEnum>");
}

const utility::string_t CreateModerationResponse_results_inner_category_applied_input_types::fromSexual_minorsEnum(const Sexual_minorsEnum value) const
{
    switch(value)
    {
        
        case Sexual_minorsEnum::TEXT: return utility::conversions::to_string_t("text");
        
    }
}

std::vector<utility::string_t> CreateModerationResponse_results_inner_category_applied_input_types::fromSexual_minorsEnum(const std::vector<Sexual_minorsEnum>& value) const
{
    std::vector<utility::string_t> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(fromSexual_minorsEnum(*it));
    }
    return ret;
}

std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Sexual_minorsEnum> CreateModerationResponse_results_inner_category_applied_input_types::toSexual_minorsEnum(const std::vector<utility::string_t>& value) const
{
    std::vector<Sexual_minorsEnum> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(toSexual_minorsEnum(*it));
    }
    return ret;
}
CreateModerationResponse_results_inner_category_applied_input_types::ViolenceEnum CreateModerationResponse_results_inner_category_applied_input_types::toViolenceEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("text")) {
        return ViolenceEnum::TEXT;
    }
    
    if (value == utility::conversions::to_string_t("image")) {
        return ViolenceEnum::IMAGE;
    }
    
    throw std::invalid_argument("Invalid value for conversion to std::vector<ViolenceEnum>");
}

const utility::string_t CreateModerationResponse_results_inner_category_applied_input_types::fromViolenceEnum(const ViolenceEnum value) const
{
    switch(value)
    {
        
        case ViolenceEnum::TEXT: return utility::conversions::to_string_t("text");
        
        case ViolenceEnum::IMAGE: return utility::conversions::to_string_t("image");
        
    }
}

std::vector<utility::string_t> CreateModerationResponse_results_inner_category_applied_input_types::fromViolenceEnum(const std::vector<ViolenceEnum>& value) const
{
    std::vector<utility::string_t> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(fromViolenceEnum(*it));
    }
    return ret;
}

std::vector<CreateModerationResponse_results_inner_category_applied_input_types::ViolenceEnum> CreateModerationResponse_results_inner_category_applied_input_types::toViolenceEnum(const std::vector<utility::string_t>& value) const
{
    std::vector<ViolenceEnum> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(toViolenceEnum(*it));
    }
    return ret;
}
CreateModerationResponse_results_inner_category_applied_input_types::Violence_graphicEnum CreateModerationResponse_results_inner_category_applied_input_types::toViolence_graphicEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("text")) {
        return Violence_graphicEnum::TEXT;
    }
    
    if (value == utility::conversions::to_string_t("image")) {
        return Violence_graphicEnum::IMAGE;
    }
    
    throw std::invalid_argument("Invalid value for conversion to std::vector<Violence_graphicEnum>");
}

const utility::string_t CreateModerationResponse_results_inner_category_applied_input_types::fromViolence_graphicEnum(const Violence_graphicEnum value) const
{
    switch(value)
    {
        
        case Violence_graphicEnum::TEXT: return utility::conversions::to_string_t("text");
        
        case Violence_graphicEnum::IMAGE: return utility::conversions::to_string_t("image");
        
    }
}

std::vector<utility::string_t> CreateModerationResponse_results_inner_category_applied_input_types::fromViolence_graphicEnum(const std::vector<Violence_graphicEnum>& value) const
{
    std::vector<utility::string_t> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(fromViolence_graphicEnum(*it));
    }
    return ret;
}

std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Violence_graphicEnum> CreateModerationResponse_results_inner_category_applied_input_types::toViolence_graphicEnum(const std::vector<utility::string_t>& value) const
{
    std::vector<Violence_graphicEnum> ret;
    for (auto it = value.begin(); it != value.end(); it++) {
        ret.push_back(toViolence_graphicEnum(*it));
    }
    return ret;
}

std::vector<CreateModerationResponse_results_inner_category_applied_input_types::HateEnum> CreateModerationResponse_results_inner_category_applied_input_types::getHate() const
{
    return m_Hate;
}


void CreateModerationResponse_results_inner_category_applied_input_types::setHate(const std::vector<HateEnum> value)
{
    m_Hate = value;
    m_HateIsSet = true;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::hateIsSet() const
{
    return m_HateIsSet;
}

void CreateModerationResponse_results_inner_category_applied_input_types::unsetHate()
{
    m_HateIsSet = false;
}
std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Hate_threateningEnum> CreateModerationResponse_results_inner_category_applied_input_types::getHateThreatening() const
{
    return m_Hate_threatening;
}


void CreateModerationResponse_results_inner_category_applied_input_types::setHateThreatening(const std::vector<Hate_threateningEnum> value)
{
    m_Hate_threatening = value;
    m_Hate_threateningIsSet = true;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::hateThreateningIsSet() const
{
    return m_Hate_threateningIsSet;
}

void CreateModerationResponse_results_inner_category_applied_input_types::unsetHate_threatening()
{
    m_Hate_threateningIsSet = false;
}
std::vector<CreateModerationResponse_results_inner_category_applied_input_types::HarassmentEnum> CreateModerationResponse_results_inner_category_applied_input_types::getHarassment() const
{
    return m_Harassment;
}


void CreateModerationResponse_results_inner_category_applied_input_types::setHarassment(const std::vector<HarassmentEnum> value)
{
    m_Harassment = value;
    m_HarassmentIsSet = true;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::harassmentIsSet() const
{
    return m_HarassmentIsSet;
}

void CreateModerationResponse_results_inner_category_applied_input_types::unsetHarassment()
{
    m_HarassmentIsSet = false;
}
std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Harassment_threateningEnum> CreateModerationResponse_results_inner_category_applied_input_types::getHarassmentThreatening() const
{
    return m_Harassment_threatening;
}


void CreateModerationResponse_results_inner_category_applied_input_types::setHarassmentThreatening(const std::vector<Harassment_threateningEnum> value)
{
    m_Harassment_threatening = value;
    m_Harassment_threateningIsSet = true;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::harassmentThreateningIsSet() const
{
    return m_Harassment_threateningIsSet;
}

void CreateModerationResponse_results_inner_category_applied_input_types::unsetHarassment_threatening()
{
    m_Harassment_threateningIsSet = false;
}
std::vector<CreateModerationResponse_results_inner_category_applied_input_types::IllicitEnum> CreateModerationResponse_results_inner_category_applied_input_types::getIllicit() const
{
    return m_Illicit;
}


void CreateModerationResponse_results_inner_category_applied_input_types::setIllicit(const std::vector<IllicitEnum> value)
{
    m_Illicit = value;
    m_IllicitIsSet = true;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::illicitIsSet() const
{
    return m_IllicitIsSet;
}

void CreateModerationResponse_results_inner_category_applied_input_types::unsetIllicit()
{
    m_IllicitIsSet = false;
}
std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Illicit_violentEnum> CreateModerationResponse_results_inner_category_applied_input_types::getIllicitViolent() const
{
    return m_Illicit_violent;
}


void CreateModerationResponse_results_inner_category_applied_input_types::setIllicitViolent(const std::vector<Illicit_violentEnum> value)
{
    m_Illicit_violent = value;
    m_Illicit_violentIsSet = true;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::illicitViolentIsSet() const
{
    return m_Illicit_violentIsSet;
}

void CreateModerationResponse_results_inner_category_applied_input_types::unsetIllicit_violent()
{
    m_Illicit_violentIsSet = false;
}
std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Self_harmEnum> CreateModerationResponse_results_inner_category_applied_input_types::getSelfHarm() const
{
    return m_Self_harm;
}


void CreateModerationResponse_results_inner_category_applied_input_types::setSelfHarm(const std::vector<Self_harmEnum> value)
{
    m_Self_harm = value;
    m_Self_harmIsSet = true;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::selfHarmIsSet() const
{
    return m_Self_harmIsSet;
}

void CreateModerationResponse_results_inner_category_applied_input_types::unsetSelf_harm()
{
    m_Self_harmIsSet = false;
}
std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Self_harm_intentEnum> CreateModerationResponse_results_inner_category_applied_input_types::getSelfHarmIntent() const
{
    return m_Self_harm_intent;
}


void CreateModerationResponse_results_inner_category_applied_input_types::setSelfHarmIntent(const std::vector<Self_harm_intentEnum> value)
{
    m_Self_harm_intent = value;
    m_Self_harm_intentIsSet = true;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::selfHarmIntentIsSet() const
{
    return m_Self_harm_intentIsSet;
}

void CreateModerationResponse_results_inner_category_applied_input_types::unsetSelf_harm_intent()
{
    m_Self_harm_intentIsSet = false;
}
std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Self_harm_instructionsEnum> CreateModerationResponse_results_inner_category_applied_input_types::getSelfHarmInstructions() const
{
    return m_Self_harm_instructions;
}


void CreateModerationResponse_results_inner_category_applied_input_types::setSelfHarmInstructions(const std::vector<Self_harm_instructionsEnum> value)
{
    m_Self_harm_instructions = value;
    m_Self_harm_instructionsIsSet = true;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::selfHarmInstructionsIsSet() const
{
    return m_Self_harm_instructionsIsSet;
}

void CreateModerationResponse_results_inner_category_applied_input_types::unsetSelf_harm_instructions()
{
    m_Self_harm_instructionsIsSet = false;
}
std::vector<CreateModerationResponse_results_inner_category_applied_input_types::SexualEnum> CreateModerationResponse_results_inner_category_applied_input_types::getSexual() const
{
    return m_Sexual;
}


void CreateModerationResponse_results_inner_category_applied_input_types::setSexual(const std::vector<SexualEnum> value)
{
    m_Sexual = value;
    m_SexualIsSet = true;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::sexualIsSet() const
{
    return m_SexualIsSet;
}

void CreateModerationResponse_results_inner_category_applied_input_types::unsetSexual()
{
    m_SexualIsSet = false;
}
std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Sexual_minorsEnum> CreateModerationResponse_results_inner_category_applied_input_types::getSexualMinors() const
{
    return m_Sexual_minors;
}


void CreateModerationResponse_results_inner_category_applied_input_types::setSexualMinors(const std::vector<Sexual_minorsEnum> value)
{
    m_Sexual_minors = value;
    m_Sexual_minorsIsSet = true;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::sexualMinorsIsSet() const
{
    return m_Sexual_minorsIsSet;
}

void CreateModerationResponse_results_inner_category_applied_input_types::unsetSexual_minors()
{
    m_Sexual_minorsIsSet = false;
}
std::vector<CreateModerationResponse_results_inner_category_applied_input_types::ViolenceEnum> CreateModerationResponse_results_inner_category_applied_input_types::getViolence() const
{
    return m_Violence;
}


void CreateModerationResponse_results_inner_category_applied_input_types::setViolence(const std::vector<ViolenceEnum> value)
{
    m_Violence = value;
    m_ViolenceIsSet = true;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::violenceIsSet() const
{
    return m_ViolenceIsSet;
}

void CreateModerationResponse_results_inner_category_applied_input_types::unsetViolence()
{
    m_ViolenceIsSet = false;
}
std::vector<CreateModerationResponse_results_inner_category_applied_input_types::Violence_graphicEnum> CreateModerationResponse_results_inner_category_applied_input_types::getViolenceGraphic() const
{
    return m_Violence_graphic;
}


void CreateModerationResponse_results_inner_category_applied_input_types::setViolenceGraphic(const std::vector<Violence_graphicEnum> value)
{
    m_Violence_graphic = value;
    m_Violence_graphicIsSet = true;
}

bool CreateModerationResponse_results_inner_category_applied_input_types::violenceGraphicIsSet() const
{
    return m_Violence_graphicIsSet;
}

void CreateModerationResponse_results_inner_category_applied_input_types::unsetViolence_graphic()
{
    m_Violence_graphicIsSet = false;
}

}
}
}
}


