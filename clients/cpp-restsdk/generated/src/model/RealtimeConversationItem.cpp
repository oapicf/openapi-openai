/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.18.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/RealtimeConversationItem.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

RealtimeConversationItem::RealtimeConversationItem()
{
    m_Id = utility::conversions::to_string_t("");
    m_IdIsSet = false;
    m_TypeIsSet = false;
    m_objectIsSet = false;
    m_StatusIsSet = false;
    m_RoleIsSet = false;
    m_ContentIsSet = false;
    m_Call_id = utility::conversions::to_string_t("");
    m_Call_idIsSet = false;
    m_Name = utility::conversions::to_string_t("");
    m_NameIsSet = false;
    m_Arguments = utility::conversions::to_string_t("");
    m_ArgumentsIsSet = false;
    m_Output = utility::conversions::to_string_t("");
    m_OutputIsSet = false;
}

RealtimeConversationItem::~RealtimeConversationItem()
{
}

void RealtimeConversationItem::validate()
{
    // TODO: implement validation
}

web::json::value RealtimeConversationItem::toJson() const
{
    web::json::value val = web::json::value::object();
    if(m_IdIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("id"))] = ModelBase::toJson(m_Id);
    }
    if(m_TypeIsSet)
    {
        
        utility::string_t refVal = fromTypeEnum(m_Type);
        val[utility::conversions::to_string_t(_XPLATSTR("type"))] = ModelBase::toJson(refVal);
        
    }
    if(m_objectIsSet)
    {
        
        utility::string_t refVal = fromObjectEnum(m_object);
        val[utility::conversions::to_string_t(_XPLATSTR("object"))] = ModelBase::toJson(refVal);
        
    }
    if(m_StatusIsSet)
    {
        
        utility::string_t refVal = fromStatusEnum(m_Status);
        val[utility::conversions::to_string_t(_XPLATSTR("status"))] = ModelBase::toJson(refVal);
        
    }
    if(m_RoleIsSet)
    {
        
        utility::string_t refVal = fromRoleEnum(m_Role);
        val[utility::conversions::to_string_t(_XPLATSTR("role"))] = ModelBase::toJson(refVal);
        
    }
    if(m_ContentIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("content"))] = ModelBase::toJson(m_Content);
    }
    if(m_Call_idIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("call_id"))] = ModelBase::toJson(m_Call_id);
    }
    if(m_NameIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("name"))] = ModelBase::toJson(m_Name);
    }
    if(m_ArgumentsIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("arguments"))] = ModelBase::toJson(m_Arguments);
    }
    if(m_OutputIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("output"))] = ModelBase::toJson(m_Output);
    }

    return val;
}

bool RealtimeConversationItem::fromJson(const web::json::value& val)
{
    bool ok = true;
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("id"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("id")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setId);
            setId(refVal_setId);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("type"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("type")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setType;
            ok &= ModelBase::fromJson(fieldValue, refVal_setType);
            
            setType(toTypeEnum(refVal_setType));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("object"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("object")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setObject;
            ok &= ModelBase::fromJson(fieldValue, refVal_setObject);
            
            setObject(toObjectEnum(refVal_setObject));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("status"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("status")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setStatus;
            ok &= ModelBase::fromJson(fieldValue, refVal_setStatus);
            
            setStatus(toStatusEnum(refVal_setStatus));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("role"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("role")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setRole;
            ok &= ModelBase::fromJson(fieldValue, refVal_setRole);
            
            setRole(toRoleEnum(refVal_setRole));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("content"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("content")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<RealtimeConversationItem_content_inner>> refVal_setContent;
            ok &= ModelBase::fromJson(fieldValue, refVal_setContent);
            setContent(refVal_setContent);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("call_id"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("call_id")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setCallId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCallId);
            setCallId(refVal_setCallId);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("name"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("name")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setName;
            ok &= ModelBase::fromJson(fieldValue, refVal_setName);
            setName(refVal_setName);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("arguments"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("arguments")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setArguments;
            ok &= ModelBase::fromJson(fieldValue, refVal_setArguments);
            setArguments(refVal_setArguments);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("output"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("output")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setOutput;
            ok &= ModelBase::fromJson(fieldValue, refVal_setOutput);
            setOutput(refVal_setOutput);
            
        }
    }
    return ok;
}

void RealtimeConversationItem::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(_XPLATSTR(".")))
    {
        namePrefix += utility::conversions::to_string_t(_XPLATSTR("."));
    }
    if(m_IdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("id")), m_Id));
    }
    if(m_TypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("type")), fromTypeEnum(m_Type)));
    }
    if(m_objectIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("object")), fromObjectEnum(m_object)));
    }
    if(m_StatusIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("status")), fromStatusEnum(m_Status)));
    }
    if(m_RoleIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("role")), fromRoleEnum(m_Role)));
    }
    if(m_ContentIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("content")), m_Content));
    }
    if(m_Call_idIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("call_id")), m_Call_id));
    }
    if(m_NameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("name")), m_Name));
    }
    if(m_ArgumentsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("arguments")), m_Arguments));
    }
    if(m_OutputIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("output")), m_Output));
    }
}

bool RealtimeConversationItem::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(_XPLATSTR(".")))
    {
        namePrefix += utility::conversions::to_string_t(_XPLATSTR("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("id"))))
    {
        utility::string_t refVal_setId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("id"))), refVal_setId );
        setId(refVal_setId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("type"))))
    {
        utility::string_t refVal_setType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("type"))), refVal_setType );
        setType(toTypeEnum(refVal_setType));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("object"))))
    {
        utility::string_t refVal_setObject;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("object"))), refVal_setObject );
        setObject(toObjectEnum(refVal_setObject));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("status"))))
    {
        utility::string_t refVal_setStatus;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("status"))), refVal_setStatus );
        setStatus(toStatusEnum(refVal_setStatus));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("role"))))
    {
        utility::string_t refVal_setRole;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("role"))), refVal_setRole );
        setRole(toRoleEnum(refVal_setRole));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("content"))))
    {
        std::vector<std::shared_ptr<RealtimeConversationItem_content_inner>> refVal_setContent;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("content"))), refVal_setContent );
        setContent(refVal_setContent);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("call_id"))))
    {
        utility::string_t refVal_setCallId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("call_id"))), refVal_setCallId );
        setCallId(refVal_setCallId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("name"))))
    {
        utility::string_t refVal_setName;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("name"))), refVal_setName );
        setName(refVal_setName);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("arguments"))))
    {
        utility::string_t refVal_setArguments;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("arguments"))), refVal_setArguments );
        setArguments(refVal_setArguments);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("output"))))
    {
        utility::string_t refVal_setOutput;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("output"))), refVal_setOutput );
        setOutput(refVal_setOutput);
    }
    return ok;
}

RealtimeConversationItem::TypeEnum RealtimeConversationItem::toTypeEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("message")) {
        return TypeEnum::MESSAGE;
    }
    
    if (value == utility::conversions::to_string_t("function_call")) {
        return TypeEnum::FUNCTION_CALL;
    }
    
    if (value == utility::conversions::to_string_t("function_call_output")) {
        return TypeEnum::FUNCTION_CALL_OUTPUT;
    }
    
    throw std::invalid_argument("Invalid value for conversion to TypeEnum");
}


const utility::string_t RealtimeConversationItem::fromTypeEnum(const TypeEnum value) const
{
    switch(value)
    {
        
        case TypeEnum::MESSAGE: return utility::conversions::to_string_t("message");
        
        case TypeEnum::FUNCTION_CALL: return utility::conversions::to_string_t("function_call");
        
        case TypeEnum::FUNCTION_CALL_OUTPUT: return utility::conversions::to_string_t("function_call_output");
        
    }
}

RealtimeConversationItem::ObjectEnum RealtimeConversationItem::toObjectEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("realtime.item")) {
        return ObjectEnum::REALTIME_ITEM;
    }
    
    throw std::invalid_argument("Invalid value for conversion to ObjectEnum");
}


const utility::string_t RealtimeConversationItem::fromObjectEnum(const ObjectEnum value) const
{
    switch(value)
    {
        
        case ObjectEnum::REALTIME_ITEM: return utility::conversions::to_string_t("realtime.item");
        
    }
}

RealtimeConversationItem::StatusEnum RealtimeConversationItem::toStatusEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("completed")) {
        return StatusEnum::COMPLETED;
    }
    
    if (value == utility::conversions::to_string_t("incomplete")) {
        return StatusEnum::INCOMPLETE;
    }
    
    throw std::invalid_argument("Invalid value for conversion to StatusEnum");
}


const utility::string_t RealtimeConversationItem::fromStatusEnum(const StatusEnum value) const
{
    switch(value)
    {
        
        case StatusEnum::COMPLETED: return utility::conversions::to_string_t("completed");
        
        case StatusEnum::INCOMPLETE: return utility::conversions::to_string_t("incomplete");
        
    }
}

RealtimeConversationItem::RoleEnum RealtimeConversationItem::toRoleEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("user")) {
        return RoleEnum::USER;
    }
    
    if (value == utility::conversions::to_string_t("assistant")) {
        return RoleEnum::ASSISTANT;
    }
    
    if (value == utility::conversions::to_string_t("system")) {
        return RoleEnum::SYSTEM;
    }
    
    throw std::invalid_argument("Invalid value for conversion to RoleEnum");
}


const utility::string_t RealtimeConversationItem::fromRoleEnum(const RoleEnum value) const
{
    switch(value)
    {
        
        case RoleEnum::USER: return utility::conversions::to_string_t("user");
        
        case RoleEnum::ASSISTANT: return utility::conversions::to_string_t("assistant");
        
        case RoleEnum::SYSTEM: return utility::conversions::to_string_t("system");
        
    }
}


utility::string_t RealtimeConversationItem::getId() const
{
    return m_Id;
}


void RealtimeConversationItem::setId(const utility::string_t& value)
{
    m_Id = value;
    m_IdIsSet = true;
}

bool RealtimeConversationItem::idIsSet() const
{
    return m_IdIsSet;
}

void RealtimeConversationItem::unsetId()
{
    m_IdIsSet = false;
}
RealtimeConversationItem::TypeEnum RealtimeConversationItem::getType() const
{
    return m_Type;
}


void RealtimeConversationItem::setType(const TypeEnum value)
{
    m_Type = value;
    m_TypeIsSet = true;
}

bool RealtimeConversationItem::typeIsSet() const
{
    return m_TypeIsSet;
}

void RealtimeConversationItem::unsetType()
{
    m_TypeIsSet = false;
}
RealtimeConversationItem::ObjectEnum RealtimeConversationItem::getObject() const
{
    return m_object;
}


void RealtimeConversationItem::setObject(const ObjectEnum value)
{
    m_object = value;
    m_objectIsSet = true;
}

bool RealtimeConversationItem::objectIsSet() const
{
    return m_objectIsSet;
}

void RealtimeConversationItem::unsetobject()
{
    m_objectIsSet = false;
}
RealtimeConversationItem::StatusEnum RealtimeConversationItem::getStatus() const
{
    return m_Status;
}


void RealtimeConversationItem::setStatus(const StatusEnum value)
{
    m_Status = value;
    m_StatusIsSet = true;
}

bool RealtimeConversationItem::statusIsSet() const
{
    return m_StatusIsSet;
}

void RealtimeConversationItem::unsetStatus()
{
    m_StatusIsSet = false;
}
RealtimeConversationItem::RoleEnum RealtimeConversationItem::getRole() const
{
    return m_Role;
}


void RealtimeConversationItem::setRole(const RoleEnum value)
{
    m_Role = value;
    m_RoleIsSet = true;
}

bool RealtimeConversationItem::roleIsSet() const
{
    return m_RoleIsSet;
}

void RealtimeConversationItem::unsetRole()
{
    m_RoleIsSet = false;
}
std::vector<std::shared_ptr<RealtimeConversationItem_content_inner>> RealtimeConversationItem::getContent() const
{
    return m_Content;
}


void RealtimeConversationItem::setContent(const std::vector<std::shared_ptr<RealtimeConversationItem_content_inner>>& value)
{
    m_Content = value;
    m_ContentIsSet = true;
}

bool RealtimeConversationItem::contentIsSet() const
{
    return m_ContentIsSet;
}

void RealtimeConversationItem::unsetContent()
{
    m_ContentIsSet = false;
}
utility::string_t RealtimeConversationItem::getCallId() const
{
    return m_Call_id;
}


void RealtimeConversationItem::setCallId(const utility::string_t& value)
{
    m_Call_id = value;
    m_Call_idIsSet = true;
}

bool RealtimeConversationItem::callIdIsSet() const
{
    return m_Call_idIsSet;
}

void RealtimeConversationItem::unsetCall_id()
{
    m_Call_idIsSet = false;
}
utility::string_t RealtimeConversationItem::getName() const
{
    return m_Name;
}


void RealtimeConversationItem::setName(const utility::string_t& value)
{
    m_Name = value;
    m_NameIsSet = true;
}

bool RealtimeConversationItem::nameIsSet() const
{
    return m_NameIsSet;
}

void RealtimeConversationItem::unsetName()
{
    m_NameIsSet = false;
}
utility::string_t RealtimeConversationItem::getArguments() const
{
    return m_Arguments;
}


void RealtimeConversationItem::setArguments(const utility::string_t& value)
{
    m_Arguments = value;
    m_ArgumentsIsSet = true;
}

bool RealtimeConversationItem::argumentsIsSet() const
{
    return m_ArgumentsIsSet;
}

void RealtimeConversationItem::unsetArguments()
{
    m_ArgumentsIsSet = false;
}
utility::string_t RealtimeConversationItem::getOutput() const
{
    return m_Output;
}


void RealtimeConversationItem::setOutput(const utility::string_t& value)
{
    m_Output = value;
    m_OutputIsSet = true;
}

bool RealtimeConversationItem::outputIsSet() const
{
    return m_OutputIsSet;
}

void RealtimeConversationItem::unsetOutput()
{
    m_OutputIsSet = false;
}

}
}
}
}


