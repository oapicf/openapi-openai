/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * OpenAPI spec version: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * https://github.com/OpenAPITools/openapi-generator
 * Do not edit the class manually.
 */

#include "OpenAPIAssistantsApiOperations.h"

#include "OpenAPIModule.h"
#include "OpenAPIHelpers.h"

#include "Dom/JsonObject.h"
#include "Templates/SharedPointer.h"
#include "HttpModule.h"
#include "PlatformHttp.h"

namespace OpenAPI
{

FString OpenAPIAssistantsApi::CancelRunRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) },
	{ TEXT("run_id"), FStringFormatArg(ToUrlString(RunId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}/runs/{run_id}/cancel"), PathParams);

	return Path;
}

void OpenAPIAssistantsApi::CancelRunRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIAssistantsApi::CancelRunResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::CancelRunResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::CreateAssistantRequest::ComputePath() const
{
	FString Path(TEXT("/assistants"));
	return Path;
}

void OpenAPIAssistantsApi::CreateAssistantRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPICreateAssistantRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICreateAssistantRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICreateAssistantRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIAssistantsApi::CreateAssistantResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::CreateAssistantResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::CreateMessageRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}/messages"), PathParams);

	return Path;
}

void OpenAPIAssistantsApi::CreateMessageRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPICreateMessageRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICreateMessageRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICreateMessageRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIAssistantsApi::CreateMessageResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::CreateMessageResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIAssistantsApi::CreateRunRequest::IncludeEnum& Value)
{
	switch (Value)
	{
	case OpenAPIAssistantsApi::CreateRunRequest::IncludeEnum::StepDetailsToolCallsFileSearchResultsContent:
		return TEXT("step_details.tool_calls[*].file_search.results[*].content");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIAssistantsApi::CreateRunRequest::IncludeEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIAssistantsApi::CreateRunRequest::EnumToString(const OpenAPIAssistantsApi::CreateRunRequest::IncludeEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIAssistantsApi::CreateRunRequest::IncludeEnum& Value)
{
	static TMap<FString, OpenAPIAssistantsApi::CreateRunRequest::IncludeEnum> StringToEnum = { 
		{ TEXT("step_details.tool_calls[*].file_search.results[*].content"), OpenAPIAssistantsApi::CreateRunRequest::IncludeEnum::StepDetailsToolCallsFileSearchResultsContent }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIAssistantsApi::CreateRunRequest::EnumFromString(const FString& EnumAsString, OpenAPIAssistantsApi::CreateRunRequest::IncludeEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIAssistantsApi::CreateRunRequest::IncludeEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIAssistantsApi::CreateRunRequest::IncludeEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIAssistantsApi::CreateRunRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}/runs"), PathParams);

	TArray<FString> QueryParams;
	if(Include.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(Include.GetValue(), TEXT("include[]")));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIAssistantsApi::CreateRunRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPICreateRunRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICreateRunRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICreateRunRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIAssistantsApi::CreateRunResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::CreateRunResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::CreateThreadRequest::ComputePath() const
{
	FString Path(TEXT("/threads"));
	return Path;
}

void OpenAPIAssistantsApi::CreateThreadRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		if (OpenAPICreateThreadRequest.IsSet())
		{
			WriteJsonValue(Writer, OpenAPICreateThreadRequest.GetValue());
		}
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICreateThreadRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICreateThreadRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIAssistantsApi::CreateThreadResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::CreateThreadResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::CreateThreadAndRunRequest::ComputePath() const
{
	FString Path(TEXT("/threads/runs"));
	return Path;
}

void OpenAPIAssistantsApi::CreateThreadAndRunRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPICreateThreadAndRunRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICreateThreadAndRunRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICreateThreadAndRunRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIAssistantsApi::CreateThreadAndRunResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::CreateThreadAndRunResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::DeleteAssistantRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("assistant_id"), FStringFormatArg(ToUrlString(AssistantId)) } };

	FString Path = FString::Format(TEXT("/assistants/{assistant_id}"), PathParams);

	return Path;
}

void OpenAPIAssistantsApi::DeleteAssistantRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

}

void OpenAPIAssistantsApi::DeleteAssistantResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::DeleteAssistantResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::DeleteMessageRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) },
	{ TEXT("message_id"), FStringFormatArg(ToUrlString(MessageId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}/messages/{message_id}"), PathParams);

	return Path;
}

void OpenAPIAssistantsApi::DeleteMessageRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

}

void OpenAPIAssistantsApi::DeleteMessageResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::DeleteMessageResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::DeleteThreadRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}"), PathParams);

	return Path;
}

void OpenAPIAssistantsApi::DeleteThreadRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

}

void OpenAPIAssistantsApi::DeleteThreadResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::DeleteThreadResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::GetAssistantRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("assistant_id"), FStringFormatArg(ToUrlString(AssistantId)) } };

	FString Path = FString::Format(TEXT("/assistants/{assistant_id}"), PathParams);

	return Path;
}

void OpenAPIAssistantsApi::GetAssistantRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIAssistantsApi::GetAssistantResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::GetAssistantResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::GetMessageRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) },
	{ TEXT("message_id"), FStringFormatArg(ToUrlString(MessageId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}/messages/{message_id}"), PathParams);

	return Path;
}

void OpenAPIAssistantsApi::GetMessageRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIAssistantsApi::GetMessageResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::GetMessageResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::GetRunRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) },
	{ TEXT("run_id"), FStringFormatArg(ToUrlString(RunId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}/runs/{run_id}"), PathParams);

	return Path;
}

void OpenAPIAssistantsApi::GetRunRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIAssistantsApi::GetRunResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::GetRunResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIAssistantsApi::GetRunStepRequest::IncludeEnum& Value)
{
	switch (Value)
	{
	case OpenAPIAssistantsApi::GetRunStepRequest::IncludeEnum::StepDetailsToolCallsFileSearchResultsContent:
		return TEXT("step_details.tool_calls[*].file_search.results[*].content");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIAssistantsApi::GetRunStepRequest::IncludeEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIAssistantsApi::GetRunStepRequest::EnumToString(const OpenAPIAssistantsApi::GetRunStepRequest::IncludeEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIAssistantsApi::GetRunStepRequest::IncludeEnum& Value)
{
	static TMap<FString, OpenAPIAssistantsApi::GetRunStepRequest::IncludeEnum> StringToEnum = { 
		{ TEXT("step_details.tool_calls[*].file_search.results[*].content"), OpenAPIAssistantsApi::GetRunStepRequest::IncludeEnum::StepDetailsToolCallsFileSearchResultsContent }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIAssistantsApi::GetRunStepRequest::EnumFromString(const FString& EnumAsString, OpenAPIAssistantsApi::GetRunStepRequest::IncludeEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIAssistantsApi::GetRunStepRequest::IncludeEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIAssistantsApi::GetRunStepRequest::IncludeEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIAssistantsApi::GetRunStepRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) },
	{ TEXT("run_id"), FStringFormatArg(ToUrlString(RunId)) },
	{ TEXT("step_id"), FStringFormatArg(ToUrlString(StepId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}/runs/{run_id}/steps/{step_id}"), PathParams);

	TArray<FString> QueryParams;
	if(Include.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(Include.GetValue(), TEXT("include[]")));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIAssistantsApi::GetRunStepRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIAssistantsApi::GetRunStepResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::GetRunStepResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::GetThreadRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}"), PathParams);

	return Path;
}

void OpenAPIAssistantsApi::GetThreadRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIAssistantsApi::GetThreadResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::GetThreadResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIAssistantsApi::ListAssistantsRequest::OrderEnum& Value)
{
	switch (Value)
	{
	case OpenAPIAssistantsApi::ListAssistantsRequest::OrderEnum::Asc:
		return TEXT("asc");
	case OpenAPIAssistantsApi::ListAssistantsRequest::OrderEnum::Desc:
		return TEXT("desc");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIAssistantsApi::ListAssistantsRequest::OrderEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIAssistantsApi::ListAssistantsRequest::EnumToString(const OpenAPIAssistantsApi::ListAssistantsRequest::OrderEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIAssistantsApi::ListAssistantsRequest::OrderEnum& Value)
{
	static TMap<FString, OpenAPIAssistantsApi::ListAssistantsRequest::OrderEnum> StringToEnum = { 
		{ TEXT("asc"), OpenAPIAssistantsApi::ListAssistantsRequest::OrderEnum::Asc },
		{ TEXT("desc"), OpenAPIAssistantsApi::ListAssistantsRequest::OrderEnum::Desc }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIAssistantsApi::ListAssistantsRequest::EnumFromString(const FString& EnumAsString, OpenAPIAssistantsApi::ListAssistantsRequest::OrderEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIAssistantsApi::ListAssistantsRequest::OrderEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIAssistantsApi::ListAssistantsRequest::OrderEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIAssistantsApi::ListAssistantsRequest::ComputePath() const
{
	FString Path(TEXT("/assistants"));
	TArray<FString> QueryParams;
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Order.IsSet())
	{
		QueryParams.Add(FString(TEXT("order=")) + ToUrlString(Order.GetValue()));
	}
	if(After.IsSet())
	{
		QueryParams.Add(FString(TEXT("after=")) + ToUrlString(After.GetValue()));
	}
	if(Before.IsSet())
	{
		QueryParams.Add(FString(TEXT("before=")) + ToUrlString(Before.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIAssistantsApi::ListAssistantsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIAssistantsApi::ListAssistantsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::ListAssistantsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIAssistantsApi::ListMessagesRequest::OrderEnum& Value)
{
	switch (Value)
	{
	case OpenAPIAssistantsApi::ListMessagesRequest::OrderEnum::Asc:
		return TEXT("asc");
	case OpenAPIAssistantsApi::ListMessagesRequest::OrderEnum::Desc:
		return TEXT("desc");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIAssistantsApi::ListMessagesRequest::OrderEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIAssistantsApi::ListMessagesRequest::EnumToString(const OpenAPIAssistantsApi::ListMessagesRequest::OrderEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIAssistantsApi::ListMessagesRequest::OrderEnum& Value)
{
	static TMap<FString, OpenAPIAssistantsApi::ListMessagesRequest::OrderEnum> StringToEnum = { 
		{ TEXT("asc"), OpenAPIAssistantsApi::ListMessagesRequest::OrderEnum::Asc },
		{ TEXT("desc"), OpenAPIAssistantsApi::ListMessagesRequest::OrderEnum::Desc }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIAssistantsApi::ListMessagesRequest::EnumFromString(const FString& EnumAsString, OpenAPIAssistantsApi::ListMessagesRequest::OrderEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIAssistantsApi::ListMessagesRequest::OrderEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIAssistantsApi::ListMessagesRequest::OrderEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIAssistantsApi::ListMessagesRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}/messages"), PathParams);

	TArray<FString> QueryParams;
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Order.IsSet())
	{
		QueryParams.Add(FString(TEXT("order=")) + ToUrlString(Order.GetValue()));
	}
	if(After.IsSet())
	{
		QueryParams.Add(FString(TEXT("after=")) + ToUrlString(After.GetValue()));
	}
	if(Before.IsSet())
	{
		QueryParams.Add(FString(TEXT("before=")) + ToUrlString(Before.GetValue()));
	}
	if(RunId.IsSet())
	{
		QueryParams.Add(FString(TEXT("run_id=")) + ToUrlString(RunId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIAssistantsApi::ListMessagesRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIAssistantsApi::ListMessagesResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::ListMessagesResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIAssistantsApi::ListRunStepsRequest::OrderEnum& Value)
{
	switch (Value)
	{
	case OpenAPIAssistantsApi::ListRunStepsRequest::OrderEnum::Asc:
		return TEXT("asc");
	case OpenAPIAssistantsApi::ListRunStepsRequest::OrderEnum::Desc:
		return TEXT("desc");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIAssistantsApi::ListRunStepsRequest::OrderEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIAssistantsApi::ListRunStepsRequest::EnumToString(const OpenAPIAssistantsApi::ListRunStepsRequest::OrderEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIAssistantsApi::ListRunStepsRequest::OrderEnum& Value)
{
	static TMap<FString, OpenAPIAssistantsApi::ListRunStepsRequest::OrderEnum> StringToEnum = { 
		{ TEXT("asc"), OpenAPIAssistantsApi::ListRunStepsRequest::OrderEnum::Asc },
		{ TEXT("desc"), OpenAPIAssistantsApi::ListRunStepsRequest::OrderEnum::Desc }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIAssistantsApi::ListRunStepsRequest::EnumFromString(const FString& EnumAsString, OpenAPIAssistantsApi::ListRunStepsRequest::OrderEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIAssistantsApi::ListRunStepsRequest::OrderEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIAssistantsApi::ListRunStepsRequest::OrderEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

inline FString ToString(const OpenAPIAssistantsApi::ListRunStepsRequest::IncludeEnum& Value)
{
	switch (Value)
	{
	case OpenAPIAssistantsApi::ListRunStepsRequest::IncludeEnum::StepDetailsToolCallsFileSearchResultsContent:
		return TEXT("step_details.tool_calls[*].file_search.results[*].content");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIAssistantsApi::ListRunStepsRequest::IncludeEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIAssistantsApi::ListRunStepsRequest::EnumToString(const OpenAPIAssistantsApi::ListRunStepsRequest::IncludeEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIAssistantsApi::ListRunStepsRequest::IncludeEnum& Value)
{
	static TMap<FString, OpenAPIAssistantsApi::ListRunStepsRequest::IncludeEnum> StringToEnum = { 
		{ TEXT("step_details.tool_calls[*].file_search.results[*].content"), OpenAPIAssistantsApi::ListRunStepsRequest::IncludeEnum::StepDetailsToolCallsFileSearchResultsContent }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIAssistantsApi::ListRunStepsRequest::EnumFromString(const FString& EnumAsString, OpenAPIAssistantsApi::ListRunStepsRequest::IncludeEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIAssistantsApi::ListRunStepsRequest::IncludeEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIAssistantsApi::ListRunStepsRequest::IncludeEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIAssistantsApi::ListRunStepsRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) },
	{ TEXT("run_id"), FStringFormatArg(ToUrlString(RunId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}/runs/{run_id}/steps"), PathParams);

	TArray<FString> QueryParams;
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Order.IsSet())
	{
		QueryParams.Add(FString(TEXT("order=")) + ToUrlString(Order.GetValue()));
	}
	if(After.IsSet())
	{
		QueryParams.Add(FString(TEXT("after=")) + ToUrlString(After.GetValue()));
	}
	if(Before.IsSet())
	{
		QueryParams.Add(FString(TEXT("before=")) + ToUrlString(Before.GetValue()));
	}
	if(Include.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(Include.GetValue(), TEXT("include[]")));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIAssistantsApi::ListRunStepsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIAssistantsApi::ListRunStepsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::ListRunStepsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIAssistantsApi::ListRunsRequest::OrderEnum& Value)
{
	switch (Value)
	{
	case OpenAPIAssistantsApi::ListRunsRequest::OrderEnum::Asc:
		return TEXT("asc");
	case OpenAPIAssistantsApi::ListRunsRequest::OrderEnum::Desc:
		return TEXT("desc");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIAssistantsApi::ListRunsRequest::OrderEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIAssistantsApi::ListRunsRequest::EnumToString(const OpenAPIAssistantsApi::ListRunsRequest::OrderEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIAssistantsApi::ListRunsRequest::OrderEnum& Value)
{
	static TMap<FString, OpenAPIAssistantsApi::ListRunsRequest::OrderEnum> StringToEnum = { 
		{ TEXT("asc"), OpenAPIAssistantsApi::ListRunsRequest::OrderEnum::Asc },
		{ TEXT("desc"), OpenAPIAssistantsApi::ListRunsRequest::OrderEnum::Desc }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIAssistantsApi::ListRunsRequest::EnumFromString(const FString& EnumAsString, OpenAPIAssistantsApi::ListRunsRequest::OrderEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIAssistantsApi::ListRunsRequest::OrderEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIAssistantsApi::ListRunsRequest::OrderEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIAssistantsApi::ListRunsRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}/runs"), PathParams);

	TArray<FString> QueryParams;
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Order.IsSet())
	{
		QueryParams.Add(FString(TEXT("order=")) + ToUrlString(Order.GetValue()));
	}
	if(After.IsSet())
	{
		QueryParams.Add(FString(TEXT("after=")) + ToUrlString(After.GetValue()));
	}
	if(Before.IsSet())
	{
		QueryParams.Add(FString(TEXT("before=")) + ToUrlString(Before.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIAssistantsApi::ListRunsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIAssistantsApi::ListRunsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::ListRunsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::ModifyAssistantRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("assistant_id"), FStringFormatArg(ToUrlString(AssistantId)) } };

	FString Path = FString::Format(TEXT("/assistants/{assistant_id}"), PathParams);

	return Path;
}

void OpenAPIAssistantsApi::ModifyAssistantRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIModifyAssistantRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIModifyAssistantRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIModifyAssistantRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIAssistantsApi::ModifyAssistantResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::ModifyAssistantResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::ModifyMessageRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) },
	{ TEXT("message_id"), FStringFormatArg(ToUrlString(MessageId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}/messages/{message_id}"), PathParams);

	return Path;
}

void OpenAPIAssistantsApi::ModifyMessageRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIModifyMessageRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIModifyMessageRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIModifyMessageRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIAssistantsApi::ModifyMessageResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::ModifyMessageResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::ModifyRunRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) },
	{ TEXT("run_id"), FStringFormatArg(ToUrlString(RunId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}/runs/{run_id}"), PathParams);

	return Path;
}

void OpenAPIAssistantsApi::ModifyRunRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIModifyRunRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIModifyRunRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIModifyRunRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIAssistantsApi::ModifyRunResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::ModifyRunResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::ModifyThreadRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}"), PathParams);

	return Path;
}

void OpenAPIAssistantsApi::ModifyThreadRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIModifyThreadRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIModifyThreadRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIModifyThreadRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIAssistantsApi::ModifyThreadResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::ModifyThreadResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPIAssistantsApi::SubmitToolOuputsToRunRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("thread_id"), FStringFormatArg(ToUrlString(ThreadId)) },
	{ TEXT("run_id"), FStringFormatArg(ToUrlString(RunId)) } };

	FString Path = FString::Format(TEXT("/threads/{thread_id}/runs/{run_id}/submit_tool_outputs"), PathParams);

	return Path;
}

void OpenAPIAssistantsApi::SubmitToolOuputsToRunRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPISubmitToolOutputsRunRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPISubmitToolOutputsRunRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPISubmitToolOutputsRunRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIAssistantsApi::SubmitToolOuputsToRunResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("OK"));
		break;
	}
}

bool OpenAPIAssistantsApi::SubmitToolOuputsToRunResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

}
