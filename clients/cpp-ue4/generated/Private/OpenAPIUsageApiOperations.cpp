/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * OpenAPI spec version: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * https://github.com/OpenAPITools/openapi-generator
 * Do not edit the class manually.
 */

#include "OpenAPIUsageApiOperations.h"

#include "OpenAPIModule.h"
#include "OpenAPIHelpers.h"

#include "Dom/JsonObject.h"
#include "Templates/SharedPointer.h"
#include "HttpModule.h"
#include "PlatformHttp.h"

namespace OpenAPI
{

inline FString ToString(const OpenAPIUsageApi::UsageAudioSpeechesRequest::BucketWidthEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageAudioSpeechesRequest::BucketWidthEnum::_1m:
		return TEXT("1m");
	case OpenAPIUsageApi::UsageAudioSpeechesRequest::BucketWidthEnum::_1h:
		return TEXT("1h");
	case OpenAPIUsageApi::UsageAudioSpeechesRequest::BucketWidthEnum::_1d:
		return TEXT("1d");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageAudioSpeechesRequest::BucketWidthEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageAudioSpeechesRequest::EnumToString(const OpenAPIUsageApi::UsageAudioSpeechesRequest::BucketWidthEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageAudioSpeechesRequest::BucketWidthEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageAudioSpeechesRequest::BucketWidthEnum> StringToEnum = { 
		{ TEXT("1m"), OpenAPIUsageApi::UsageAudioSpeechesRequest::BucketWidthEnum::_1m },
		{ TEXT("1h"), OpenAPIUsageApi::UsageAudioSpeechesRequest::BucketWidthEnum::_1h },
		{ TEXT("1d"), OpenAPIUsageApi::UsageAudioSpeechesRequest::BucketWidthEnum::_1d }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageAudioSpeechesRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageAudioSpeechesRequest::BucketWidthEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageAudioSpeechesRequest::BucketWidthEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageAudioSpeechesRequest::BucketWidthEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

inline FString ToString(const OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum::ProjectId:
		return TEXT("project_id");
	case OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum::UserId:
		return TEXT("user_id");
	case OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum::ApiKeyId:
		return TEXT("api_key_id");
	case OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum::Model:
		return TEXT("model");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageAudioSpeechesRequest::EnumToString(const OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum> StringToEnum = { 
		{ TEXT("project_id"), OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum::ProjectId },
		{ TEXT("user_id"), OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum::UserId },
		{ TEXT("api_key_id"), OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum::ApiKeyId },
		{ TEXT("model"), OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum::Model }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageAudioSpeechesRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageAudioSpeechesRequest::GroupByEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIUsageApi::UsageAudioSpeechesRequest::ComputePath() const
{
	FString Path(TEXT("/organization/usage/audio_speeches"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("start_time=")) + ToUrlString(StartTime));
	if(EndTime.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_time=")) + ToUrlString(EndTime.GetValue()));
	}
	if(BucketWidth.IsSet())
	{
		QueryParams.Add(FString(TEXT("bucket_width=")) + ToUrlString(BucketWidth.GetValue()));
	}
	if(ProjectIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ProjectIds.GetValue(), TEXT("project_ids")));
	}
	if(UserIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(UserIds.GetValue(), TEXT("user_ids")));
	}
	if(ApiKeyIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ApiKeyIds.GetValue(), TEXT("api_key_ids")));
	}
	if(Models.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(Models.GetValue(), TEXT("models")));
	}
	if(GroupBy.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(GroupBy.GetValue(), TEXT("group_by")));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Page.IsSet())
	{
		QueryParams.Add(FString(TEXT("page=")) + ToUrlString(Page.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsageApi::UsageAudioSpeechesRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIUsageApi::UsageAudioSpeechesResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Usage data retrieved successfully."));
		break;
	}
}

bool OpenAPIUsageApi::UsageAudioSpeechesResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIUsageApi::UsageAudioTranscriptionsRequest::BucketWidthEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageAudioTranscriptionsRequest::BucketWidthEnum::_1m:
		return TEXT("1m");
	case OpenAPIUsageApi::UsageAudioTranscriptionsRequest::BucketWidthEnum::_1h:
		return TEXT("1h");
	case OpenAPIUsageApi::UsageAudioTranscriptionsRequest::BucketWidthEnum::_1d:
		return TEXT("1d");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageAudioTranscriptionsRequest::BucketWidthEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageAudioTranscriptionsRequest::EnumToString(const OpenAPIUsageApi::UsageAudioTranscriptionsRequest::BucketWidthEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageAudioTranscriptionsRequest::BucketWidthEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageAudioTranscriptionsRequest::BucketWidthEnum> StringToEnum = { 
		{ TEXT("1m"), OpenAPIUsageApi::UsageAudioTranscriptionsRequest::BucketWidthEnum::_1m },
		{ TEXT("1h"), OpenAPIUsageApi::UsageAudioTranscriptionsRequest::BucketWidthEnum::_1h },
		{ TEXT("1d"), OpenAPIUsageApi::UsageAudioTranscriptionsRequest::BucketWidthEnum::_1d }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageAudioTranscriptionsRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageAudioTranscriptionsRequest::BucketWidthEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageAudioTranscriptionsRequest::BucketWidthEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageAudioTranscriptionsRequest::BucketWidthEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

inline FString ToString(const OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum::ProjectId:
		return TEXT("project_id");
	case OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum::UserId:
		return TEXT("user_id");
	case OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum::ApiKeyId:
		return TEXT("api_key_id");
	case OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum::Model:
		return TEXT("model");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageAudioTranscriptionsRequest::EnumToString(const OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum> StringToEnum = { 
		{ TEXT("project_id"), OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum::ProjectId },
		{ TEXT("user_id"), OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum::UserId },
		{ TEXT("api_key_id"), OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum::ApiKeyId },
		{ TEXT("model"), OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum::Model }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageAudioTranscriptionsRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageAudioTranscriptionsRequest::GroupByEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIUsageApi::UsageAudioTranscriptionsRequest::ComputePath() const
{
	FString Path(TEXT("/organization/usage/audio_transcriptions"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("start_time=")) + ToUrlString(StartTime));
	if(EndTime.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_time=")) + ToUrlString(EndTime.GetValue()));
	}
	if(BucketWidth.IsSet())
	{
		QueryParams.Add(FString(TEXT("bucket_width=")) + ToUrlString(BucketWidth.GetValue()));
	}
	if(ProjectIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ProjectIds.GetValue(), TEXT("project_ids")));
	}
	if(UserIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(UserIds.GetValue(), TEXT("user_ids")));
	}
	if(ApiKeyIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ApiKeyIds.GetValue(), TEXT("api_key_ids")));
	}
	if(Models.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(Models.GetValue(), TEXT("models")));
	}
	if(GroupBy.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(GroupBy.GetValue(), TEXT("group_by")));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Page.IsSet())
	{
		QueryParams.Add(FString(TEXT("page=")) + ToUrlString(Page.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsageApi::UsageAudioTranscriptionsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIUsageApi::UsageAudioTranscriptionsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Usage data retrieved successfully."));
		break;
	}
}

bool OpenAPIUsageApi::UsageAudioTranscriptionsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::BucketWidthEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::BucketWidthEnum::_1m:
		return TEXT("1m");
	case OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::BucketWidthEnum::_1h:
		return TEXT("1h");
	case OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::BucketWidthEnum::_1d:
		return TEXT("1d");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::BucketWidthEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::EnumToString(const OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::BucketWidthEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::BucketWidthEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::BucketWidthEnum> StringToEnum = { 
		{ TEXT("1m"), OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::BucketWidthEnum::_1m },
		{ TEXT("1h"), OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::BucketWidthEnum::_1h },
		{ TEXT("1d"), OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::BucketWidthEnum::_1d }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::BucketWidthEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::BucketWidthEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::BucketWidthEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

inline FString ToString(const OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::GroupByEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::GroupByEnum::ProjectId:
		return TEXT("project_id");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::GroupByEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::EnumToString(const OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::GroupByEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::GroupByEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::GroupByEnum> StringToEnum = { 
		{ TEXT("project_id"), OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::GroupByEnum::ProjectId }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::GroupByEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::GroupByEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::GroupByEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::ComputePath() const
{
	FString Path(TEXT("/organization/usage/code_interpreter_sessions"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("start_time=")) + ToUrlString(StartTime));
	if(EndTime.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_time=")) + ToUrlString(EndTime.GetValue()));
	}
	if(BucketWidth.IsSet())
	{
		QueryParams.Add(FString(TEXT("bucket_width=")) + ToUrlString(BucketWidth.GetValue()));
	}
	if(ProjectIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ProjectIds.GetValue(), TEXT("project_ids")));
	}
	if(GroupBy.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(GroupBy.GetValue(), TEXT("group_by")));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Page.IsSet())
	{
		QueryParams.Add(FString(TEXT("page=")) + ToUrlString(Page.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsageApi::UsageCodeInterpreterSessionsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIUsageApi::UsageCodeInterpreterSessionsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Usage data retrieved successfully."));
		break;
	}
}

bool OpenAPIUsageApi::UsageCodeInterpreterSessionsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIUsageApi::UsageCompletionsRequest::BucketWidthEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageCompletionsRequest::BucketWidthEnum::_1m:
		return TEXT("1m");
	case OpenAPIUsageApi::UsageCompletionsRequest::BucketWidthEnum::_1h:
		return TEXT("1h");
	case OpenAPIUsageApi::UsageCompletionsRequest::BucketWidthEnum::_1d:
		return TEXT("1d");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageCompletionsRequest::BucketWidthEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageCompletionsRequest::EnumToString(const OpenAPIUsageApi::UsageCompletionsRequest::BucketWidthEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageCompletionsRequest::BucketWidthEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageCompletionsRequest::BucketWidthEnum> StringToEnum = { 
		{ TEXT("1m"), OpenAPIUsageApi::UsageCompletionsRequest::BucketWidthEnum::_1m },
		{ TEXT("1h"), OpenAPIUsageApi::UsageCompletionsRequest::BucketWidthEnum::_1h },
		{ TEXT("1d"), OpenAPIUsageApi::UsageCompletionsRequest::BucketWidthEnum::_1d }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageCompletionsRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageCompletionsRequest::BucketWidthEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageCompletionsRequest::BucketWidthEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageCompletionsRequest::BucketWidthEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

inline FString ToString(const OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum::ProjectId:
		return TEXT("project_id");
	case OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum::UserId:
		return TEXT("user_id");
	case OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum::ApiKeyId:
		return TEXT("api_key_id");
	case OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum::Model:
		return TEXT("model");
	case OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum::Batch:
		return TEXT("batch");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageCompletionsRequest::EnumToString(const OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum> StringToEnum = { 
		{ TEXT("project_id"), OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum::ProjectId },
		{ TEXT("user_id"), OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum::UserId },
		{ TEXT("api_key_id"), OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum::ApiKeyId },
		{ TEXT("model"), OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum::Model },
		{ TEXT("batch"), OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum::Batch }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageCompletionsRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageCompletionsRequest::GroupByEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIUsageApi::UsageCompletionsRequest::ComputePath() const
{
	FString Path(TEXT("/organization/usage/completions"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("start_time=")) + ToUrlString(StartTime));
	if(EndTime.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_time=")) + ToUrlString(EndTime.GetValue()));
	}
	if(BucketWidth.IsSet())
	{
		QueryParams.Add(FString(TEXT("bucket_width=")) + ToUrlString(BucketWidth.GetValue()));
	}
	if(ProjectIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ProjectIds.GetValue(), TEXT("project_ids")));
	}
	if(UserIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(UserIds.GetValue(), TEXT("user_ids")));
	}
	if(ApiKeyIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ApiKeyIds.GetValue(), TEXT("api_key_ids")));
	}
	if(Models.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(Models.GetValue(), TEXT("models")));
	}
	if(Batch.IsSet())
	{
		QueryParams.Add(FString(TEXT("batch=")) + ToUrlString(Batch.GetValue()));
	}
	if(GroupBy.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(GroupBy.GetValue(), TEXT("group_by")));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Page.IsSet())
	{
		QueryParams.Add(FString(TEXT("page=")) + ToUrlString(Page.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsageApi::UsageCompletionsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIUsageApi::UsageCompletionsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Usage data retrieved successfully."));
		break;
	}
}

bool OpenAPIUsageApi::UsageCompletionsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIUsageApi::UsageCostsRequest::BucketWidthEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageCostsRequest::BucketWidthEnum::_1d:
		return TEXT("1d");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageCostsRequest::BucketWidthEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageCostsRequest::EnumToString(const OpenAPIUsageApi::UsageCostsRequest::BucketWidthEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageCostsRequest::BucketWidthEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageCostsRequest::BucketWidthEnum> StringToEnum = { 
		{ TEXT("1d"), OpenAPIUsageApi::UsageCostsRequest::BucketWidthEnum::_1d }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageCostsRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageCostsRequest::BucketWidthEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageCostsRequest::BucketWidthEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageCostsRequest::BucketWidthEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

inline FString ToString(const OpenAPIUsageApi::UsageCostsRequest::GroupByEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageCostsRequest::GroupByEnum::ProjectId:
		return TEXT("project_id");
	case OpenAPIUsageApi::UsageCostsRequest::GroupByEnum::LineItem:
		return TEXT("line_item");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageCostsRequest::GroupByEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageCostsRequest::EnumToString(const OpenAPIUsageApi::UsageCostsRequest::GroupByEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageCostsRequest::GroupByEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageCostsRequest::GroupByEnum> StringToEnum = { 
		{ TEXT("project_id"), OpenAPIUsageApi::UsageCostsRequest::GroupByEnum::ProjectId },
		{ TEXT("line_item"), OpenAPIUsageApi::UsageCostsRequest::GroupByEnum::LineItem }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageCostsRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageCostsRequest::GroupByEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageCostsRequest::GroupByEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageCostsRequest::GroupByEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIUsageApi::UsageCostsRequest::ComputePath() const
{
	FString Path(TEXT("/organization/costs"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("start_time=")) + ToUrlString(StartTime));
	if(EndTime.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_time=")) + ToUrlString(EndTime.GetValue()));
	}
	if(BucketWidth.IsSet())
	{
		QueryParams.Add(FString(TEXT("bucket_width=")) + ToUrlString(BucketWidth.GetValue()));
	}
	if(ProjectIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ProjectIds.GetValue(), TEXT("project_ids")));
	}
	if(GroupBy.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(GroupBy.GetValue(), TEXT("group_by")));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Page.IsSet())
	{
		QueryParams.Add(FString(TEXT("page=")) + ToUrlString(Page.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsageApi::UsageCostsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIUsageApi::UsageCostsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Costs data retrieved successfully."));
		break;
	}
}

bool OpenAPIUsageApi::UsageCostsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIUsageApi::UsageEmbeddingsRequest::BucketWidthEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageEmbeddingsRequest::BucketWidthEnum::_1m:
		return TEXT("1m");
	case OpenAPIUsageApi::UsageEmbeddingsRequest::BucketWidthEnum::_1h:
		return TEXT("1h");
	case OpenAPIUsageApi::UsageEmbeddingsRequest::BucketWidthEnum::_1d:
		return TEXT("1d");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageEmbeddingsRequest::BucketWidthEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageEmbeddingsRequest::EnumToString(const OpenAPIUsageApi::UsageEmbeddingsRequest::BucketWidthEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageEmbeddingsRequest::BucketWidthEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageEmbeddingsRequest::BucketWidthEnum> StringToEnum = { 
		{ TEXT("1m"), OpenAPIUsageApi::UsageEmbeddingsRequest::BucketWidthEnum::_1m },
		{ TEXT("1h"), OpenAPIUsageApi::UsageEmbeddingsRequest::BucketWidthEnum::_1h },
		{ TEXT("1d"), OpenAPIUsageApi::UsageEmbeddingsRequest::BucketWidthEnum::_1d }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageEmbeddingsRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageEmbeddingsRequest::BucketWidthEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageEmbeddingsRequest::BucketWidthEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageEmbeddingsRequest::BucketWidthEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

inline FString ToString(const OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum::ProjectId:
		return TEXT("project_id");
	case OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum::UserId:
		return TEXT("user_id");
	case OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum::ApiKeyId:
		return TEXT("api_key_id");
	case OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum::Model:
		return TEXT("model");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageEmbeddingsRequest::EnumToString(const OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum> StringToEnum = { 
		{ TEXT("project_id"), OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum::ProjectId },
		{ TEXT("user_id"), OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum::UserId },
		{ TEXT("api_key_id"), OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum::ApiKeyId },
		{ TEXT("model"), OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum::Model }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageEmbeddingsRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageEmbeddingsRequest::GroupByEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIUsageApi::UsageEmbeddingsRequest::ComputePath() const
{
	FString Path(TEXT("/organization/usage/embeddings"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("start_time=")) + ToUrlString(StartTime));
	if(EndTime.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_time=")) + ToUrlString(EndTime.GetValue()));
	}
	if(BucketWidth.IsSet())
	{
		QueryParams.Add(FString(TEXT("bucket_width=")) + ToUrlString(BucketWidth.GetValue()));
	}
	if(ProjectIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ProjectIds.GetValue(), TEXT("project_ids")));
	}
	if(UserIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(UserIds.GetValue(), TEXT("user_ids")));
	}
	if(ApiKeyIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ApiKeyIds.GetValue(), TEXT("api_key_ids")));
	}
	if(Models.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(Models.GetValue(), TEXT("models")));
	}
	if(GroupBy.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(GroupBy.GetValue(), TEXT("group_by")));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Page.IsSet())
	{
		QueryParams.Add(FString(TEXT("page=")) + ToUrlString(Page.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsageApi::UsageEmbeddingsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIUsageApi::UsageEmbeddingsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Usage data retrieved successfully."));
		break;
	}
}

bool OpenAPIUsageApi::UsageEmbeddingsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIUsageApi::UsageImagesRequest::BucketWidthEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageImagesRequest::BucketWidthEnum::_1m:
		return TEXT("1m");
	case OpenAPIUsageApi::UsageImagesRequest::BucketWidthEnum::_1h:
		return TEXT("1h");
	case OpenAPIUsageApi::UsageImagesRequest::BucketWidthEnum::_1d:
		return TEXT("1d");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageImagesRequest::BucketWidthEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageImagesRequest::EnumToString(const OpenAPIUsageApi::UsageImagesRequest::BucketWidthEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageImagesRequest::BucketWidthEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageImagesRequest::BucketWidthEnum> StringToEnum = { 
		{ TEXT("1m"), OpenAPIUsageApi::UsageImagesRequest::BucketWidthEnum::_1m },
		{ TEXT("1h"), OpenAPIUsageApi::UsageImagesRequest::BucketWidthEnum::_1h },
		{ TEXT("1d"), OpenAPIUsageApi::UsageImagesRequest::BucketWidthEnum::_1d }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageImagesRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageImagesRequest::BucketWidthEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageImagesRequest::BucketWidthEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageImagesRequest::BucketWidthEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

inline FString ToString(const OpenAPIUsageApi::UsageImagesRequest::SourcesEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageImagesRequest::SourcesEnum::ImageGeneration:
		return TEXT("image.generation");
	case OpenAPIUsageApi::UsageImagesRequest::SourcesEnum::ImageEdit:
		return TEXT("image.edit");
	case OpenAPIUsageApi::UsageImagesRequest::SourcesEnum::ImageVariation:
		return TEXT("image.variation");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageImagesRequest::SourcesEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageImagesRequest::EnumToString(const OpenAPIUsageApi::UsageImagesRequest::SourcesEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageImagesRequest::SourcesEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageImagesRequest::SourcesEnum> StringToEnum = { 
		{ TEXT("image.generation"), OpenAPIUsageApi::UsageImagesRequest::SourcesEnum::ImageGeneration },
		{ TEXT("image.edit"), OpenAPIUsageApi::UsageImagesRequest::SourcesEnum::ImageEdit },
		{ TEXT("image.variation"), OpenAPIUsageApi::UsageImagesRequest::SourcesEnum::ImageVariation }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageImagesRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageImagesRequest::SourcesEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageImagesRequest::SourcesEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageImagesRequest::SourcesEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

inline FString ToString(const OpenAPIUsageApi::UsageImagesRequest::SizesEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageImagesRequest::SizesEnum::_256x256:
		return TEXT("256x256");
	case OpenAPIUsageApi::UsageImagesRequest::SizesEnum::_512x512:
		return TEXT("512x512");
	case OpenAPIUsageApi::UsageImagesRequest::SizesEnum::_1024x1024:
		return TEXT("1024x1024");
	case OpenAPIUsageApi::UsageImagesRequest::SizesEnum::_1792x1792:
		return TEXT("1792x1792");
	case OpenAPIUsageApi::UsageImagesRequest::SizesEnum::_1024x1792:
		return TEXT("1024x1792");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageImagesRequest::SizesEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageImagesRequest::EnumToString(const OpenAPIUsageApi::UsageImagesRequest::SizesEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageImagesRequest::SizesEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageImagesRequest::SizesEnum> StringToEnum = { 
		{ TEXT("256x256"), OpenAPIUsageApi::UsageImagesRequest::SizesEnum::_256x256 },
		{ TEXT("512x512"), OpenAPIUsageApi::UsageImagesRequest::SizesEnum::_512x512 },
		{ TEXT("1024x1024"), OpenAPIUsageApi::UsageImagesRequest::SizesEnum::_1024x1024 },
		{ TEXT("1792x1792"), OpenAPIUsageApi::UsageImagesRequest::SizesEnum::_1792x1792 },
		{ TEXT("1024x1792"), OpenAPIUsageApi::UsageImagesRequest::SizesEnum::_1024x1792 }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageImagesRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageImagesRequest::SizesEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageImagesRequest::SizesEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageImagesRequest::SizesEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

inline FString ToString(const OpenAPIUsageApi::UsageImagesRequest::GroupByEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageImagesRequest::GroupByEnum::ProjectId:
		return TEXT("project_id");
	case OpenAPIUsageApi::UsageImagesRequest::GroupByEnum::UserId:
		return TEXT("user_id");
	case OpenAPIUsageApi::UsageImagesRequest::GroupByEnum::ApiKeyId:
		return TEXT("api_key_id");
	case OpenAPIUsageApi::UsageImagesRequest::GroupByEnum::Model:
		return TEXT("model");
	case OpenAPIUsageApi::UsageImagesRequest::GroupByEnum::Size:
		return TEXT("size");
	case OpenAPIUsageApi::UsageImagesRequest::GroupByEnum::Source:
		return TEXT("source");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageImagesRequest::GroupByEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageImagesRequest::EnumToString(const OpenAPIUsageApi::UsageImagesRequest::GroupByEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageImagesRequest::GroupByEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageImagesRequest::GroupByEnum> StringToEnum = { 
		{ TEXT("project_id"), OpenAPIUsageApi::UsageImagesRequest::GroupByEnum::ProjectId },
		{ TEXT("user_id"), OpenAPIUsageApi::UsageImagesRequest::GroupByEnum::UserId },
		{ TEXT("api_key_id"), OpenAPIUsageApi::UsageImagesRequest::GroupByEnum::ApiKeyId },
		{ TEXT("model"), OpenAPIUsageApi::UsageImagesRequest::GroupByEnum::Model },
		{ TEXT("size"), OpenAPIUsageApi::UsageImagesRequest::GroupByEnum::Size },
		{ TEXT("source"), OpenAPIUsageApi::UsageImagesRequest::GroupByEnum::Source }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageImagesRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageImagesRequest::GroupByEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageImagesRequest::GroupByEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageImagesRequest::GroupByEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIUsageApi::UsageImagesRequest::ComputePath() const
{
	FString Path(TEXT("/organization/usage/images"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("start_time=")) + ToUrlString(StartTime));
	if(EndTime.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_time=")) + ToUrlString(EndTime.GetValue()));
	}
	if(BucketWidth.IsSet())
	{
		QueryParams.Add(FString(TEXT("bucket_width=")) + ToUrlString(BucketWidth.GetValue()));
	}
	if(Sources.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(Sources.GetValue(), TEXT("sources")));
	}
	if(Sizes.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(Sizes.GetValue(), TEXT("sizes")));
	}
	if(ProjectIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ProjectIds.GetValue(), TEXT("project_ids")));
	}
	if(UserIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(UserIds.GetValue(), TEXT("user_ids")));
	}
	if(ApiKeyIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ApiKeyIds.GetValue(), TEXT("api_key_ids")));
	}
	if(Models.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(Models.GetValue(), TEXT("models")));
	}
	if(GroupBy.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(GroupBy.GetValue(), TEXT("group_by")));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Page.IsSet())
	{
		QueryParams.Add(FString(TEXT("page=")) + ToUrlString(Page.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsageApi::UsageImagesRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIUsageApi::UsageImagesResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Usage data retrieved successfully."));
		break;
	}
}

bool OpenAPIUsageApi::UsageImagesResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIUsageApi::UsageModerationsRequest::BucketWidthEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageModerationsRequest::BucketWidthEnum::_1m:
		return TEXT("1m");
	case OpenAPIUsageApi::UsageModerationsRequest::BucketWidthEnum::_1h:
		return TEXT("1h");
	case OpenAPIUsageApi::UsageModerationsRequest::BucketWidthEnum::_1d:
		return TEXT("1d");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageModerationsRequest::BucketWidthEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageModerationsRequest::EnumToString(const OpenAPIUsageApi::UsageModerationsRequest::BucketWidthEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageModerationsRequest::BucketWidthEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageModerationsRequest::BucketWidthEnum> StringToEnum = { 
		{ TEXT("1m"), OpenAPIUsageApi::UsageModerationsRequest::BucketWidthEnum::_1m },
		{ TEXT("1h"), OpenAPIUsageApi::UsageModerationsRequest::BucketWidthEnum::_1h },
		{ TEXT("1d"), OpenAPIUsageApi::UsageModerationsRequest::BucketWidthEnum::_1d }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageModerationsRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageModerationsRequest::BucketWidthEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageModerationsRequest::BucketWidthEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageModerationsRequest::BucketWidthEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

inline FString ToString(const OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum::ProjectId:
		return TEXT("project_id");
	case OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum::UserId:
		return TEXT("user_id");
	case OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum::ApiKeyId:
		return TEXT("api_key_id");
	case OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum::Model:
		return TEXT("model");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageModerationsRequest::EnumToString(const OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum> StringToEnum = { 
		{ TEXT("project_id"), OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum::ProjectId },
		{ TEXT("user_id"), OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum::UserId },
		{ TEXT("api_key_id"), OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum::ApiKeyId },
		{ TEXT("model"), OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum::Model }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageModerationsRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageModerationsRequest::GroupByEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIUsageApi::UsageModerationsRequest::ComputePath() const
{
	FString Path(TEXT("/organization/usage/moderations"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("start_time=")) + ToUrlString(StartTime));
	if(EndTime.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_time=")) + ToUrlString(EndTime.GetValue()));
	}
	if(BucketWidth.IsSet())
	{
		QueryParams.Add(FString(TEXT("bucket_width=")) + ToUrlString(BucketWidth.GetValue()));
	}
	if(ProjectIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ProjectIds.GetValue(), TEXT("project_ids")));
	}
	if(UserIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(UserIds.GetValue(), TEXT("user_ids")));
	}
	if(ApiKeyIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ApiKeyIds.GetValue(), TEXT("api_key_ids")));
	}
	if(Models.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(Models.GetValue(), TEXT("models")));
	}
	if(GroupBy.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(GroupBy.GetValue(), TEXT("group_by")));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Page.IsSet())
	{
		QueryParams.Add(FString(TEXT("page=")) + ToUrlString(Page.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsageApi::UsageModerationsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIUsageApi::UsageModerationsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Usage data retrieved successfully."));
		break;
	}
}

bool OpenAPIUsageApi::UsageModerationsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

inline FString ToString(const OpenAPIUsageApi::UsageVectorStoresRequest::BucketWidthEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageVectorStoresRequest::BucketWidthEnum::_1m:
		return TEXT("1m");
	case OpenAPIUsageApi::UsageVectorStoresRequest::BucketWidthEnum::_1h:
		return TEXT("1h");
	case OpenAPIUsageApi::UsageVectorStoresRequest::BucketWidthEnum::_1d:
		return TEXT("1d");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageVectorStoresRequest::BucketWidthEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageVectorStoresRequest::EnumToString(const OpenAPIUsageApi::UsageVectorStoresRequest::BucketWidthEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageVectorStoresRequest::BucketWidthEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageVectorStoresRequest::BucketWidthEnum> StringToEnum = { 
		{ TEXT("1m"), OpenAPIUsageApi::UsageVectorStoresRequest::BucketWidthEnum::_1m },
		{ TEXT("1h"), OpenAPIUsageApi::UsageVectorStoresRequest::BucketWidthEnum::_1h },
		{ TEXT("1d"), OpenAPIUsageApi::UsageVectorStoresRequest::BucketWidthEnum::_1d }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageVectorStoresRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageVectorStoresRequest::BucketWidthEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageVectorStoresRequest::BucketWidthEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageVectorStoresRequest::BucketWidthEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

inline FString ToString(const OpenAPIUsageApi::UsageVectorStoresRequest::GroupByEnum& Value)
{
	switch (Value)
	{
	case OpenAPIUsageApi::UsageVectorStoresRequest::GroupByEnum::ProjectId:
		return TEXT("project_id");
	}

	UE_LOG(LogOpenAPI, Error, TEXT("Invalid OpenAPIUsageApi::UsageVectorStoresRequest::GroupByEnum Value (%d)"), (int)Value);
	return TEXT("");
}

FString OpenAPIUsageApi::UsageVectorStoresRequest::EnumToString(const OpenAPIUsageApi::UsageVectorStoresRequest::GroupByEnum& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, OpenAPIUsageApi::UsageVectorStoresRequest::GroupByEnum& Value)
{
	static TMap<FString, OpenAPIUsageApi::UsageVectorStoresRequest::GroupByEnum> StringToEnum = { 
		{ TEXT("project_id"), OpenAPIUsageApi::UsageVectorStoresRequest::GroupByEnum::ProjectId }, };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool OpenAPIUsageApi::UsageVectorStoresRequest::EnumFromString(const FString& EnumAsString, OpenAPIUsageApi::UsageVectorStoresRequest::GroupByEnum& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const OpenAPIUsageApi::UsageVectorStoresRequest::GroupByEnum& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, OpenAPIUsageApi::UsageVectorStoresRequest::GroupByEnum& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	return false;
}

FString OpenAPIUsageApi::UsageVectorStoresRequest::ComputePath() const
{
	FString Path(TEXT("/organization/usage/vector_stores"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("start_time=")) + ToUrlString(StartTime));
	if(EndTime.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_time=")) + ToUrlString(EndTime.GetValue()));
	}
	if(BucketWidth.IsSet())
	{
		QueryParams.Add(FString(TEXT("bucket_width=")) + ToUrlString(BucketWidth.GetValue()));
	}
	if(ProjectIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ProjectIds.GetValue(), TEXT("project_ids")));
	}
	if(GroupBy.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(GroupBy.GetValue(), TEXT("group_by")));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Page.IsSet())
	{
		QueryParams.Add(FString(TEXT("page=")) + ToUrlString(Page.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIUsageApi::UsageVectorStoresRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPIUsageApi::UsageVectorStoresResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Usage data retrieved successfully."));
		break;
	}
}

bool OpenAPIUsageApi::UsageVectorStoresResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

}
