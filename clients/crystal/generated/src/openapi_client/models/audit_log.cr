# #OpenAI API
#
##The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
#
#The version of the OpenAPI document: 2.3.0
#Contact: blah+oapicf@cliffano.com
#Generated by: https://openapi-generator.tech
#Generator version: 7.18.0
#

require "big"
require "json"
require "yaml"
require "time"

module OpenAPIClient
  # A log of a user action or configuration change within this organization.
  class AuditLog
    include JSON::Serializable
    include YAML::Serializable

    # Required properties
    # The ID of this log.
    @[JSON::Field(key: "id", type: String, nillable: false, emit_null: false)]
    property id : String

    @[JSON::Field(key: "type", type: AuditLogEventType, nillable: false, emit_null: false)]
    property _type : AuditLogEventType

    # The Unix timestamp (in seconds) of the event.
    @[JSON::Field(key: "effective_at", type: Int32, nillable: false, emit_null: false)]
    property effective_at : Int32

    @[JSON::Field(key: "actor", type: AuditLogActor, nillable: false, emit_null: false)]
    property actor : AuditLogActor

    # Optional properties
    @[JSON::Field(key: "project", type: AuditLogProject?, nillable: true, emit_null: false)]
    property project : AuditLogProject?

    @[JSON::Field(key: "api_key.created", type: AuditLogApiKeyCreated?, nillable: true, emit_null: false)]
    property api_key_created : AuditLogApiKeyCreated?

    @[JSON::Field(key: "api_key.updated", type: AuditLogApiKeyUpdated?, nillable: true, emit_null: false)]
    property api_key_updated : AuditLogApiKeyUpdated?

    @[JSON::Field(key: "api_key.deleted", type: AuditLogApiKeyDeleted?, nillable: true, emit_null: false)]
    property api_key_deleted : AuditLogApiKeyDeleted?

    @[JSON::Field(key: "invite.sent", type: AuditLogInviteSent?, nillable: true, emit_null: false)]
    property invite_sent : AuditLogInviteSent?

    @[JSON::Field(key: "invite.accepted", type: AuditLogInviteAccepted?, nillable: true, emit_null: false)]
    property invite_accepted : AuditLogInviteAccepted?

    @[JSON::Field(key: "invite.deleted", type: AuditLogInviteAccepted?, nillable: true, emit_null: false)]
    property invite_deleted : AuditLogInviteAccepted?

    @[JSON::Field(key: "login.failed", type: AuditLogLoginFailed?, nillable: true, emit_null: false)]
    property login_failed : AuditLogLoginFailed?

    @[JSON::Field(key: "logout.failed", type: AuditLogLoginFailed?, nillable: true, emit_null: false)]
    property logout_failed : AuditLogLoginFailed?

    @[JSON::Field(key: "organization.updated", type: AuditLogOrganizationUpdated?, nillable: true, emit_null: false)]
    property organization_updated : AuditLogOrganizationUpdated?

    @[JSON::Field(key: "project.created", type: AuditLogProjectCreated?, nillable: true, emit_null: false)]
    property project_created : AuditLogProjectCreated?

    @[JSON::Field(key: "project.updated", type: AuditLogProjectUpdated?, nillable: true, emit_null: false)]
    property project_updated : AuditLogProjectUpdated?

    @[JSON::Field(key: "project.archived", type: AuditLogProjectArchived?, nillable: true, emit_null: false)]
    property project_archived : AuditLogProjectArchived?

    @[JSON::Field(key: "rate_limit.updated", type: AuditLogRateLimitUpdated?, nillable: true, emit_null: false)]
    property rate_limit_updated : AuditLogRateLimitUpdated?

    @[JSON::Field(key: "rate_limit.deleted", type: AuditLogRateLimitDeleted?, nillable: true, emit_null: false)]
    property rate_limit_deleted : AuditLogRateLimitDeleted?

    @[JSON::Field(key: "service_account.created", type: AuditLogServiceAccountCreated?, nillable: true, emit_null: false)]
    property service_account_created : AuditLogServiceAccountCreated?

    @[JSON::Field(key: "service_account.updated", type: AuditLogServiceAccountUpdated?, nillable: true, emit_null: false)]
    property service_account_updated : AuditLogServiceAccountUpdated?

    @[JSON::Field(key: "service_account.deleted", type: AuditLogServiceAccountDeleted?, nillable: true, emit_null: false)]
    property service_account_deleted : AuditLogServiceAccountDeleted?

    @[JSON::Field(key: "user.added", type: AuditLogUserAdded?, nillable: true, emit_null: false)]
    property user_added : AuditLogUserAdded?

    @[JSON::Field(key: "user.updated", type: AuditLogUserUpdated?, nillable: true, emit_null: false)]
    property user_updated : AuditLogUserUpdated?

    @[JSON::Field(key: "user.deleted", type: AuditLogUserDeleted?, nillable: true, emit_null: false)]
    property user_deleted : AuditLogUserDeleted?

    abstract class EnumAttributeValidator
      def valid?(value)
        !value || @allowable_values.includes?(value)
      end

      def message
        "invalid value for \"#{@attribute}\", must be one of #{@allowable_values}."
      end

      def to(_type, value)
        case _type
        when Int32
          value.to_i32
        when Int64
          value.to_i64
        when Float32
          value.to_f32
        when Float64
          value.to_f64
        else
          value.to_s
        end
      end
    end


    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(@id : String, @_type : AuditLogEventType, @effective_at : Int32, @actor : AuditLogActor, @project : AuditLogProject? = nil, @api_key_created : AuditLogApiKeyCreated? = nil, @api_key_updated : AuditLogApiKeyUpdated? = nil, @api_key_deleted : AuditLogApiKeyDeleted? = nil, @invite_sent : AuditLogInviteSent? = nil, @invite_accepted : AuditLogInviteAccepted? = nil, @invite_deleted : AuditLogInviteAccepted? = nil, @login_failed : AuditLogLoginFailed? = nil, @logout_failed : AuditLogLoginFailed? = nil, @organization_updated : AuditLogOrganizationUpdated? = nil, @project_created : AuditLogProjectCreated? = nil, @project_updated : AuditLogProjectUpdated? = nil, @project_archived : AuditLogProjectArchived? = nil, @rate_limit_updated : AuditLogRateLimitUpdated? = nil, @rate_limit_deleted : AuditLogRateLimitDeleted? = nil, @service_account_created : AuditLogServiceAccountCreated? = nil, @service_account_updated : AuditLogServiceAccountUpdated? = nil, @service_account_deleted : AuditLogServiceAccountDeleted? = nil, @user_added : AuditLogUserAdded? = nil, @user_updated : AuditLogUserUpdated? = nil, @user_deleted : AuditLogUserDeleted? = nil)
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array(String).new
      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      true
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(other)
      return true if self.same?(other)
      self.class == other.class &&
          id == other.id &&
          _type == other._type &&
          effective_at == other.effective_at &&
          project == other.project &&
          actor == other.actor &&
          api_key_created == other.api_key_created &&
          api_key_updated == other.api_key_updated &&
          api_key_deleted == other.api_key_deleted &&
          invite_sent == other.invite_sent &&
          invite_accepted == other.invite_accepted &&
          invite_deleted == other.invite_deleted &&
          login_failed == other.login_failed &&
          logout_failed == other.logout_failed &&
          organization_updated == other.organization_updated &&
          project_created == other.project_created &&
          project_updated == other.project_updated &&
          project_archived == other.project_archived &&
          rate_limit_updated == other.rate_limit_updated &&
          rate_limit_deleted == other.rate_limit_deleted &&
          service_account_created == other.service_account_created &&
          service_account_updated == other.service_account_updated &&
          service_account_deleted == other.service_account_deleted &&
          user_added == other.user_added &&
          user_updated == other.user_updated &&
          user_deleted == other.user_deleted
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(other)
      self == other
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [id, _type, effective_at, project, actor, api_key_created, api_key_updated, api_key_deleted, invite_sent, invite_accepted, invite_deleted, login_failed, logout_failed, organization_updated, project_created, project_updated, project_archived, rate_limit_updated, rate_limit_deleted, service_account_created, service_account_updated, service_account_deleted, user_added, user_updated, user_deleted].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def self.build_from_hash(attributes)
      new.build_from_hash(attributes)
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.openapi_types.each_pair do |key, type|
        if !attributes[self.class.attribute_map[key]]? && self.class.openapi_nullable.includes?(key)
          self.send("#{key}=", nil)
        elsif type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :Time
        Time.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :Boolean
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        ({} of Symbol => String).tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        # models (e.g. Pet) or oneOf
        klass = OpenAPIClient.const_get(type)
        klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_h.to_s
    end

    # to_body is an alias to to_h (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_h
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_h
      hash = NetboxClient::RecursiveHash.new
      hash["id"] = _to_h(id)
      hash["type"] = _to_h(_type)
      hash["effective_at"] = _to_h(effective_at)
      hash["project"] = _to_h(project)
      hash["actor"] = _to_h(actor)
      hash["api_key.created"] = _to_h(api_key_created)
      hash["api_key.updated"] = _to_h(api_key_updated)
      hash["api_key.deleted"] = _to_h(api_key_deleted)
      hash["invite.sent"] = _to_h(invite_sent)
      hash["invite.accepted"] = _to_h(invite_accepted)
      hash["invite.deleted"] = _to_h(invite_deleted)
      hash["login.failed"] = _to_h(login_failed)
      hash["logout.failed"] = _to_h(logout_failed)
      hash["organization.updated"] = _to_h(organization_updated)
      hash["project.created"] = _to_h(project_created)
      hash["project.updated"] = _to_h(project_updated)
      hash["project.archived"] = _to_h(project_archived)
      hash["rate_limit.updated"] = _to_h(rate_limit_updated)
      hash["rate_limit.deleted"] = _to_h(rate_limit_deleted)
      hash["service_account.created"] = _to_h(service_account_created)
      hash["service_account.updated"] = _to_h(service_account_updated)
      hash["service_account.deleted"] = _to_h(service_account_deleted)
      hash["user.added"] = _to_h(user_added)
      hash["user.updated"] = _to_h(user_updated)
      hash["user.deleted"] = _to_h(user_deleted)
      hash.to_h
    end

    # Outputs non-array value in the form of hash
    # For object, use to_h. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    private def _to_h(value)
      if value.is_a?(Hash)
        hash = NetboxClient::RecursiveHash.new
        value.each { |k, v| hash[k] = _to_h(v) }
        hash
      elsif value.is_a?(Array)
        value.compact.map { |v| _to_h(v) }
      elsif value.responds_to?(:to_h)
        value.to_h
      else
        value
      end
    end

  end

end
