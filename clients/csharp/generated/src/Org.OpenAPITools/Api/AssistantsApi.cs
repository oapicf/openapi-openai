// <auto-generated>
/*
 * OpenAI API
 *
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: blah+oapicf@cliffano.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IAssistantsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        AssistantsApiEvents Events { get; }

        /// <summary>
        /// Cancels a run that is &#x60;in_progress&#x60;.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to which this run belongs.</param>
        /// <param name="runId">The ID of the run to cancel.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICancelRunApiResponse"/>&gt;</returns>
        Task<ICancelRunApiResponse> CancelRunAsync(string threadId, string runId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Cancels a run that is &#x60;in_progress&#x60;.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the thread to which this run belongs.</param>
        /// <param name="runId">The ID of the run to cancel.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICancelRunApiResponse"/>?&gt;</returns>
        Task<ICancelRunApiResponse?> CancelRunOrDefaultAsync(string threadId, string runId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an assistant with a model and instructions.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAssistantRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateAssistantApiResponse"/>&gt;</returns>
        Task<ICreateAssistantApiResponse> CreateAssistantAsync(CreateAssistantRequest createAssistantRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an assistant with a model and instructions.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="createAssistantRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateAssistantApiResponse"/>?&gt;</returns>
        Task<ICreateAssistantApiResponse?> CreateAssistantOrDefaultAsync(CreateAssistantRequest createAssistantRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants).
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assistantId">The ID of the assistant for which to create a File. </param>
        /// <param name="createAssistantFileRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateAssistantFileApiResponse"/>&gt;</returns>
        Task<ICreateAssistantFileApiResponse> CreateAssistantFileAsync(string assistantId, CreateAssistantFileRequest createAssistantFileRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants).
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="assistantId">The ID of the assistant for which to create a File. </param>
        /// <param name="createAssistantFileRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateAssistantFileApiResponse"/>?&gt;</returns>
        Task<ICreateAssistantFileApiResponse?> CreateAssistantFileOrDefaultAsync(string assistantId, CreateAssistantFileRequest createAssistantFileRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a message.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) to create a message for.</param>
        /// <param name="createMessageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateMessageApiResponse"/>&gt;</returns>
        Task<ICreateMessageApiResponse> CreateMessageAsync(string threadId, CreateMessageRequest createMessageRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a message.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) to create a message for.</param>
        /// <param name="createMessageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateMessageApiResponse"/>?&gt;</returns>
        Task<ICreateMessageApiResponse?> CreateMessageOrDefaultAsync(string threadId, CreateMessageRequest createMessageRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a run.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to run.</param>
        /// <param name="createRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRunApiResponse"/>&gt;</returns>
        Task<ICreateRunApiResponse> CreateRunAsync(string threadId, CreateRunRequest createRunRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a run.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the thread to run.</param>
        /// <param name="createRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRunApiResponse"/>?&gt;</returns>
        Task<ICreateRunApiResponse?> CreateRunOrDefaultAsync(string threadId, CreateRunRequest createRunRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a thread.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createThreadRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateThreadApiResponse"/>&gt;</returns>
        Task<ICreateThreadApiResponse> CreateThreadAsync(Option<CreateThreadRequest> createThreadRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a thread.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="createThreadRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateThreadApiResponse"/>?&gt;</returns>
        Task<ICreateThreadApiResponse?> CreateThreadOrDefaultAsync(Option<CreateThreadRequest> createThreadRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a thread and run it in one request.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createThreadAndRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateThreadAndRunApiResponse"/>&gt;</returns>
        Task<ICreateThreadAndRunApiResponse> CreateThreadAndRunAsync(CreateThreadAndRunRequest createThreadAndRunRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a thread and run it in one request.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="createThreadAndRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateThreadAndRunApiResponse"/>?&gt;</returns>
        Task<ICreateThreadAndRunApiResponse?> CreateThreadAndRunOrDefaultAsync(CreateThreadAndRunRequest createThreadAndRunRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an assistant.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assistantId">The ID of the assistant to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAssistantApiResponse"/>&gt;</returns>
        Task<IDeleteAssistantApiResponse> DeleteAssistantAsync(string assistantId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an assistant.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="assistantId">The ID of the assistant to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAssistantApiResponse"/>?&gt;</returns>
        Task<IDeleteAssistantApiResponse?> DeleteAssistantOrDefaultAsync(string assistantId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an assistant file.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assistantId">The ID of the assistant that the file belongs to.</param>
        /// <param name="fileId">The ID of the file to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAssistantFileApiResponse"/>&gt;</returns>
        Task<IDeleteAssistantFileApiResponse> DeleteAssistantFileAsync(string assistantId, string fileId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an assistant file.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="assistantId">The ID of the assistant that the file belongs to.</param>
        /// <param name="fileId">The ID of the file to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAssistantFileApiResponse"/>?&gt;</returns>
        Task<IDeleteAssistantFileApiResponse?> DeleteAssistantFileOrDefaultAsync(string assistantId, string fileId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a thread.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteThreadApiResponse"/>&gt;</returns>
        Task<IDeleteThreadApiResponse> DeleteThreadAsync(string threadId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a thread.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the thread to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteThreadApiResponse"/>?&gt;</returns>
        Task<IDeleteThreadApiResponse?> DeleteThreadOrDefaultAsync(string threadId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves an assistant.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assistantId">The ID of the assistant to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAssistantApiResponse"/>&gt;</returns>
        Task<IGetAssistantApiResponse> GetAssistantAsync(string assistantId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves an assistant.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="assistantId">The ID of the assistant to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAssistantApiResponse"/>?&gt;</returns>
        Task<IGetAssistantApiResponse?> GetAssistantOrDefaultAsync(string assistantId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves an AssistantFile.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assistantId">The ID of the assistant who the file belongs to.</param>
        /// <param name="fileId">The ID of the file we&#39;re getting.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAssistantFileApiResponse"/>&gt;</returns>
        Task<IGetAssistantFileApiResponse> GetAssistantFileAsync(string assistantId, string fileId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves an AssistantFile.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="assistantId">The ID of the assistant who the file belongs to.</param>
        /// <param name="fileId">The ID of the file we&#39;re getting.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAssistantFileApiResponse"/>?&gt;</returns>
        Task<IGetAssistantFileApiResponse?> GetAssistantFileOrDefaultAsync(string assistantId, string fileId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieve a message.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) to which this message belongs.</param>
        /// <param name="messageId">The ID of the message to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageApiResponse"/>&gt;</returns>
        Task<IGetMessageApiResponse> GetMessageAsync(string threadId, string messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieve a message.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) to which this message belongs.</param>
        /// <param name="messageId">The ID of the message to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageApiResponse"/>?&gt;</returns>
        Task<IGetMessageApiResponse?> GetMessageOrDefaultAsync(string threadId, string messageId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves a message file.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to which the message and File belong.</param>
        /// <param name="messageId">The ID of the message the file belongs to.</param>
        /// <param name="fileId">The ID of the file being retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageFileApiResponse"/>&gt;</returns>
        Task<IGetMessageFileApiResponse> GetMessageFileAsync(string threadId, string messageId, string fileId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves a message file.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the thread to which the message and File belong.</param>
        /// <param name="messageId">The ID of the message the file belongs to.</param>
        /// <param name="fileId">The ID of the file being retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageFileApiResponse"/>?&gt;</returns>
        Task<IGetMessageFileApiResponse?> GetMessageFileOrDefaultAsync(string threadId, string messageId, string fileId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves a run.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) that was run.</param>
        /// <param name="runId">The ID of the run to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRunApiResponse"/>&gt;</returns>
        Task<IGetRunApiResponse> GetRunAsync(string threadId, string runId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves a run.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) that was run.</param>
        /// <param name="runId">The ID of the run to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRunApiResponse"/>?&gt;</returns>
        Task<IGetRunApiResponse?> GetRunOrDefaultAsync(string threadId, string runId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves a run step.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to which the run and run step belongs.</param>
        /// <param name="runId">The ID of the run to which the run step belongs.</param>
        /// <param name="stepId">The ID of the run step to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRunStepApiResponse"/>&gt;</returns>
        Task<IGetRunStepApiResponse> GetRunStepAsync(string threadId, string runId, string stepId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves a run step.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the thread to which the run and run step belongs.</param>
        /// <param name="runId">The ID of the run to which the run step belongs.</param>
        /// <param name="stepId">The ID of the run step to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRunStepApiResponse"/>?&gt;</returns>
        Task<IGetRunStepApiResponse?> GetRunStepOrDefaultAsync(string threadId, string runId, string stepId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves a thread.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetThreadApiResponse"/>&gt;</returns>
        Task<IGetThreadApiResponse> GetThreadAsync(string threadId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves a thread.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the thread to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetThreadApiResponse"/>?&gt;</returns>
        Task<IGetThreadApiResponse?> GetThreadOrDefaultAsync(string threadId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a list of assistant files.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assistantId">The ID of the assistant the file belongs to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListAssistantFilesApiResponse"/>&gt;</returns>
        Task<IListAssistantFilesApiResponse> ListAssistantFilesAsync(string assistantId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a list of assistant files.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="assistantId">The ID of the assistant the file belongs to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListAssistantFilesApiResponse"/>?&gt;</returns>
        Task<IListAssistantFilesApiResponse?> ListAssistantFilesOrDefaultAsync(string assistantId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a list of assistants.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListAssistantsApiResponse"/>&gt;</returns>
        Task<IListAssistantsApiResponse> ListAssistantsAsync(Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a list of assistants.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListAssistantsApiResponse"/>?&gt;</returns>
        Task<IListAssistantsApiResponse?> ListAssistantsOrDefaultAsync(Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a list of message files.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread that the message and files belong to.</param>
        /// <param name="messageId">The ID of the message that the files belongs to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListMessageFilesApiResponse"/>&gt;</returns>
        Task<IListMessageFilesApiResponse> ListMessageFilesAsync(string threadId, string messageId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a list of message files.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the thread that the message and files belong to.</param>
        /// <param name="messageId">The ID of the message that the files belongs to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListMessageFilesApiResponse"/>?&gt;</returns>
        Task<IListMessageFilesApiResponse?> ListMessageFilesOrDefaultAsync(string threadId, string messageId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a list of messages for a given thread.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) the messages belong to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="runId">Filter messages by the run ID that generated them.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListMessagesApiResponse"/>&gt;</returns>
        Task<IListMessagesApiResponse> ListMessagesAsync(string threadId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, Option<string> runId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a list of messages for a given thread.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) the messages belong to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="runId">Filter messages by the run ID that generated them.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListMessagesApiResponse"/>?&gt;</returns>
        Task<IListMessagesApiResponse?> ListMessagesOrDefaultAsync(string threadId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, Option<string> runId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a list of run steps belonging to a run.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread the run and run steps belong to.</param>
        /// <param name="runId">The ID of the run the run steps belong to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListRunStepsApiResponse"/>&gt;</returns>
        Task<IListRunStepsApiResponse> ListRunStepsAsync(string threadId, string runId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a list of run steps belonging to a run.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the thread the run and run steps belong to.</param>
        /// <param name="runId">The ID of the run the run steps belong to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListRunStepsApiResponse"/>?&gt;</returns>
        Task<IListRunStepsApiResponse?> ListRunStepsOrDefaultAsync(string threadId, string runId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a list of runs belonging to a thread.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread the run belongs to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListRunsApiResponse"/>&gt;</returns>
        Task<IListRunsApiResponse> ListRunsAsync(string threadId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Returns a list of runs belonging to a thread.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the thread the run belongs to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListRunsApiResponse"/>?&gt;</returns>
        Task<IListRunsApiResponse?> ListRunsOrDefaultAsync(string threadId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Modifies an assistant.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assistantId">The ID of the assistant to modify.</param>
        /// <param name="modifyAssistantRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyAssistantApiResponse"/>&gt;</returns>
        Task<IModifyAssistantApiResponse> ModifyAssistantAsync(string assistantId, ModifyAssistantRequest modifyAssistantRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Modifies an assistant.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="assistantId">The ID of the assistant to modify.</param>
        /// <param name="modifyAssistantRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyAssistantApiResponse"/>?&gt;</returns>
        Task<IModifyAssistantApiResponse?> ModifyAssistantOrDefaultAsync(string assistantId, ModifyAssistantRequest modifyAssistantRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Modifies a message.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to which this message belongs.</param>
        /// <param name="messageId">The ID of the message to modify.</param>
        /// <param name="modifyMessageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyMessageApiResponse"/>&gt;</returns>
        Task<IModifyMessageApiResponse> ModifyMessageAsync(string threadId, string messageId, ModifyMessageRequest modifyMessageRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Modifies a message.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the thread to which this message belongs.</param>
        /// <param name="messageId">The ID of the message to modify.</param>
        /// <param name="modifyMessageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyMessageApiResponse"/>?&gt;</returns>
        Task<IModifyMessageApiResponse?> ModifyMessageOrDefaultAsync(string threadId, string messageId, ModifyMessageRequest modifyMessageRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Modifies a run.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) that was run.</param>
        /// <param name="runId">The ID of the run to modify.</param>
        /// <param name="modifyRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyRunApiResponse"/>&gt;</returns>
        Task<IModifyRunApiResponse> ModifyRunAsync(string threadId, string runId, ModifyRunRequest modifyRunRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Modifies a run.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) that was run.</param>
        /// <param name="runId">The ID of the run to modify.</param>
        /// <param name="modifyRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyRunApiResponse"/>?&gt;</returns>
        Task<IModifyRunApiResponse?> ModifyRunOrDefaultAsync(string threadId, string runId, ModifyRunRequest modifyRunRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Modifies a thread.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified.</param>
        /// <param name="modifyThreadRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyThreadApiResponse"/>&gt;</returns>
        Task<IModifyThreadApiResponse> ModifyThreadAsync(string threadId, ModifyThreadRequest modifyThreadRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Modifies a thread.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified.</param>
        /// <param name="modifyThreadRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyThreadApiResponse"/>?&gt;</returns>
        Task<IModifyThreadApiResponse?> ModifyThreadOrDefaultAsync(string threadId, ModifyThreadRequest modifyThreadRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// When a run has the &#x60;status: \&quot;requires_action\&quot;&#x60; and &#x60;required_action.type&#x60; is &#x60;submit_tool_outputs&#x60;, this endpoint can be used to submit the outputs from the tool calls once they&#39;re all completed. All outputs must be submitted in a single request. 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) to which this run belongs.</param>
        /// <param name="runId">The ID of the run that requires the tool output submission.</param>
        /// <param name="submitToolOutputsRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubmitToolOuputsToRunApiResponse"/>&gt;</returns>
        Task<ISubmitToolOuputsToRunApiResponse> SubmitToolOuputsToRunAsync(string threadId, string runId, SubmitToolOutputsRunRequest submitToolOutputsRunRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// When a run has the &#x60;status: \&quot;requires_action\&quot;&#x60; and &#x60;required_action.type&#x60; is &#x60;submit_tool_outputs&#x60;, this endpoint can be used to submit the outputs from the tool calls once they&#39;re all completed. All outputs must be submitted in a single request. 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) to which this run belongs.</param>
        /// <param name="runId">The ID of the run that requires the tool output submission.</param>
        /// <param name="submitToolOutputsRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubmitToolOuputsToRunApiResponse"/>?&gt;</returns>
        Task<ISubmitToolOuputsToRunApiResponse?> SubmitToolOuputsToRunOrDefaultAsync(string threadId, string runId, SubmitToolOutputsRunRequest submitToolOutputsRunRequest, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICancelRunApiResponse"/>
    /// </summary>
    public interface ICancelRunApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.RunObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICreateAssistantApiResponse"/>
    /// </summary>
    public interface ICreateAssistantApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.AssistantObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICreateAssistantFileApiResponse"/>
    /// </summary>
    public interface ICreateAssistantFileApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.AssistantFileObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICreateMessageApiResponse"/>
    /// </summary>
    public interface ICreateMessageApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.MessageObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICreateRunApiResponse"/>
    /// </summary>
    public interface ICreateRunApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.RunObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICreateThreadApiResponse"/>
    /// </summary>
    public interface ICreateThreadApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ThreadObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ICreateThreadAndRunApiResponse"/>
    /// </summary>
    public interface ICreateThreadAndRunApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.RunObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteAssistantApiResponse"/>
    /// </summary>
    public interface IDeleteAssistantApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.DeleteAssistantResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteAssistantFileApiResponse"/>
    /// </summary>
    public interface IDeleteAssistantFileApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.DeleteAssistantFileResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteThreadApiResponse"/>
    /// </summary>
    public interface IDeleteThreadApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.DeleteThreadResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetAssistantApiResponse"/>
    /// </summary>
    public interface IGetAssistantApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.AssistantObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetAssistantFileApiResponse"/>
    /// </summary>
    public interface IGetAssistantFileApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.AssistantFileObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetMessageApiResponse"/>
    /// </summary>
    public interface IGetMessageApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.MessageObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetMessageFileApiResponse"/>
    /// </summary>
    public interface IGetMessageFileApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.MessageFileObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetRunApiResponse"/>
    /// </summary>
    public interface IGetRunApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.RunObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetRunStepApiResponse"/>
    /// </summary>
    public interface IGetRunStepApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.RunStepObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetThreadApiResponse"/>
    /// </summary>
    public interface IGetThreadApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ThreadObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListAssistantFilesApiResponse"/>
    /// </summary>
    public interface IListAssistantFilesApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ListAssistantFilesResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListAssistantsApiResponse"/>
    /// </summary>
    public interface IListAssistantsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ListAssistantsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListMessageFilesApiResponse"/>
    /// </summary>
    public interface IListMessageFilesApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ListMessageFilesResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListMessagesApiResponse"/>
    /// </summary>
    public interface IListMessagesApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ListMessagesResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListRunStepsApiResponse"/>
    /// </summary>
    public interface IListRunStepsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ListRunStepsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListRunsApiResponse"/>
    /// </summary>
    public interface IListRunsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ListRunsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IModifyAssistantApiResponse"/>
    /// </summary>
    public interface IModifyAssistantApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.AssistantObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IModifyMessageApiResponse"/>
    /// </summary>
    public interface IModifyMessageApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.MessageObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IModifyRunApiResponse"/>
    /// </summary>
    public interface IModifyRunApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.RunObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IModifyThreadApiResponse"/>
    /// </summary>
    public interface IModifyThreadApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.ThreadObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="ISubmitToolOuputsToRunApiResponse"/>
    /// </summary>
    public interface ISubmitToolOuputsToRunApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.RunObject?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class AssistantsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCancelRun;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCancelRun;

        internal void ExecuteOnCancelRun(AssistantsApi.CancelRunApiResponse apiResponse)
        {
            OnCancelRun?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCancelRun(Exception exception)
        {
            OnErrorCancelRun?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateAssistant;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateAssistant;

        internal void ExecuteOnCreateAssistant(AssistantsApi.CreateAssistantApiResponse apiResponse)
        {
            OnCreateAssistant?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateAssistant(Exception exception)
        {
            OnErrorCreateAssistant?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateAssistantFile;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateAssistantFile;

        internal void ExecuteOnCreateAssistantFile(AssistantsApi.CreateAssistantFileApiResponse apiResponse)
        {
            OnCreateAssistantFile?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateAssistantFile(Exception exception)
        {
            OnErrorCreateAssistantFile?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateMessage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateMessage;

        internal void ExecuteOnCreateMessage(AssistantsApi.CreateMessageApiResponse apiResponse)
        {
            OnCreateMessage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateMessage(Exception exception)
        {
            OnErrorCreateMessage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateRun;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateRun;

        internal void ExecuteOnCreateRun(AssistantsApi.CreateRunApiResponse apiResponse)
        {
            OnCreateRun?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateRun(Exception exception)
        {
            OnErrorCreateRun?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateThread;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateThread;

        internal void ExecuteOnCreateThread(AssistantsApi.CreateThreadApiResponse apiResponse)
        {
            OnCreateThread?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateThread(Exception exception)
        {
            OnErrorCreateThread?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateThreadAndRun;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateThreadAndRun;

        internal void ExecuteOnCreateThreadAndRun(AssistantsApi.CreateThreadAndRunApiResponse apiResponse)
        {
            OnCreateThreadAndRun?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateThreadAndRun(Exception exception)
        {
            OnErrorCreateThreadAndRun?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteAssistant;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteAssistant;

        internal void ExecuteOnDeleteAssistant(AssistantsApi.DeleteAssistantApiResponse apiResponse)
        {
            OnDeleteAssistant?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteAssistant(Exception exception)
        {
            OnErrorDeleteAssistant?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteAssistantFile;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteAssistantFile;

        internal void ExecuteOnDeleteAssistantFile(AssistantsApi.DeleteAssistantFileApiResponse apiResponse)
        {
            OnDeleteAssistantFile?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteAssistantFile(Exception exception)
        {
            OnErrorDeleteAssistantFile?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteThread;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteThread;

        internal void ExecuteOnDeleteThread(AssistantsApi.DeleteThreadApiResponse apiResponse)
        {
            OnDeleteThread?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteThread(Exception exception)
        {
            OnErrorDeleteThread?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetAssistant;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetAssistant;

        internal void ExecuteOnGetAssistant(AssistantsApi.GetAssistantApiResponse apiResponse)
        {
            OnGetAssistant?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAssistant(Exception exception)
        {
            OnErrorGetAssistant?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetAssistantFile;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetAssistantFile;

        internal void ExecuteOnGetAssistantFile(AssistantsApi.GetAssistantFileApiResponse apiResponse)
        {
            OnGetAssistantFile?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetAssistantFile(Exception exception)
        {
            OnErrorGetAssistantFile?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetMessage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetMessage;

        internal void ExecuteOnGetMessage(AssistantsApi.GetMessageApiResponse apiResponse)
        {
            OnGetMessage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMessage(Exception exception)
        {
            OnErrorGetMessage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetMessageFile;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetMessageFile;

        internal void ExecuteOnGetMessageFile(AssistantsApi.GetMessageFileApiResponse apiResponse)
        {
            OnGetMessageFile?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMessageFile(Exception exception)
        {
            OnErrorGetMessageFile?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetRun;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetRun;

        internal void ExecuteOnGetRun(AssistantsApi.GetRunApiResponse apiResponse)
        {
            OnGetRun?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetRun(Exception exception)
        {
            OnErrorGetRun?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetRunStep;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetRunStep;

        internal void ExecuteOnGetRunStep(AssistantsApi.GetRunStepApiResponse apiResponse)
        {
            OnGetRunStep?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetRunStep(Exception exception)
        {
            OnErrorGetRunStep?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetThread;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetThread;

        internal void ExecuteOnGetThread(AssistantsApi.GetThreadApiResponse apiResponse)
        {
            OnGetThread?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetThread(Exception exception)
        {
            OnErrorGetThread?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListAssistantFiles;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListAssistantFiles;

        internal void ExecuteOnListAssistantFiles(AssistantsApi.ListAssistantFilesApiResponse apiResponse)
        {
            OnListAssistantFiles?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListAssistantFiles(Exception exception)
        {
            OnErrorListAssistantFiles?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListAssistants;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListAssistants;

        internal void ExecuteOnListAssistants(AssistantsApi.ListAssistantsApiResponse apiResponse)
        {
            OnListAssistants?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListAssistants(Exception exception)
        {
            OnErrorListAssistants?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListMessageFiles;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListMessageFiles;

        internal void ExecuteOnListMessageFiles(AssistantsApi.ListMessageFilesApiResponse apiResponse)
        {
            OnListMessageFiles?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListMessageFiles(Exception exception)
        {
            OnErrorListMessageFiles?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListMessages;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListMessages;

        internal void ExecuteOnListMessages(AssistantsApi.ListMessagesApiResponse apiResponse)
        {
            OnListMessages?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListMessages(Exception exception)
        {
            OnErrorListMessages?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListRunSteps;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListRunSteps;

        internal void ExecuteOnListRunSteps(AssistantsApi.ListRunStepsApiResponse apiResponse)
        {
            OnListRunSteps?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListRunSteps(Exception exception)
        {
            OnErrorListRunSteps?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListRuns;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListRuns;

        internal void ExecuteOnListRuns(AssistantsApi.ListRunsApiResponse apiResponse)
        {
            OnListRuns?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListRuns(Exception exception)
        {
            OnErrorListRuns?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnModifyAssistant;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorModifyAssistant;

        internal void ExecuteOnModifyAssistant(AssistantsApi.ModifyAssistantApiResponse apiResponse)
        {
            OnModifyAssistant?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorModifyAssistant(Exception exception)
        {
            OnErrorModifyAssistant?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnModifyMessage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorModifyMessage;

        internal void ExecuteOnModifyMessage(AssistantsApi.ModifyMessageApiResponse apiResponse)
        {
            OnModifyMessage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorModifyMessage(Exception exception)
        {
            OnErrorModifyMessage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnModifyRun;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorModifyRun;

        internal void ExecuteOnModifyRun(AssistantsApi.ModifyRunApiResponse apiResponse)
        {
            OnModifyRun?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorModifyRun(Exception exception)
        {
            OnErrorModifyRun?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnModifyThread;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorModifyThread;

        internal void ExecuteOnModifyThread(AssistantsApi.ModifyThreadApiResponse apiResponse)
        {
            OnModifyThread?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorModifyThread(Exception exception)
        {
            OnErrorModifyThread?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSubmitToolOuputsToRun;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSubmitToolOuputsToRun;

        internal void ExecuteOnSubmitToolOuputsToRun(AssistantsApi.SubmitToolOuputsToRunApiResponse apiResponse)
        {
            OnSubmitToolOuputsToRun?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSubmitToolOuputsToRun(Exception exception)
        {
            OnErrorSubmitToolOuputsToRun?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class AssistantsApi : IAssistantsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<AssistantsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public AssistantsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AssistantsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AssistantsApi(ILogger<AssistantsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, AssistantsApiEvents assistantsApiEvents,
            TokenProvider<BearerToken> bearerTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<AssistantsApi>();
            HttpClient = httpClient;
            Events = assistantsApiEvents;
            BearerTokenProvider = bearerTokenProvider;
        }

        partial void FormatCancelRun(ref string threadId, ref string runId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <returns></returns>
        private void ValidateCancelRun(string threadId, string runId)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));

            if (runId == null)
                throw new ArgumentNullException(nameof(runId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        private void AfterCancelRunDefaultImplementation(ICancelRunApiResponse apiResponseLocalVar, string threadId, string runId)
        {
            bool suppressDefaultLog = false;
            AfterCancelRun(ref suppressDefaultLog, apiResponseLocalVar, threadId, runId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        partial void AfterCancelRun(ref bool suppressDefaultLog, ICancelRunApiResponse apiResponseLocalVar, string threadId, string runId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        private void OnErrorCancelRunDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string runId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCancelRun(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, runId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        partial void OnErrorCancelRun(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string runId);

        /// <summary>
        /// Cancels a run that is &#x60;in_progress&#x60;. 
        /// </summary>
        /// <param name="threadId">The ID of the thread to which this run belongs.</param>
        /// <param name="runId">The ID of the run to cancel.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICancelRunApiResponse"/>&gt;</returns>
        public async Task<ICancelRunApiResponse?> CancelRunOrDefaultAsync(string threadId, string runId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CancelRunAsync(threadId, runId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Cancels a run that is &#x60;in_progress&#x60;. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to which this run belongs.</param>
        /// <param name="runId">The ID of the run to cancel.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICancelRunApiResponse"/>&gt;</returns>
        public async Task<ICancelRunApiResponse> CancelRunAsync(string threadId, string runId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCancelRun(threadId, runId);

                FormatCancelRun(ref threadId, ref runId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}/runs/{run_id}/cancel"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}/runs/{run_id}/cancel");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brun_id%7D", Uri.EscapeDataString(runId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CancelRunApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CancelRunApiResponse>();
                        CancelRunApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}/runs/{run_id}/cancel", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCancelRunDefaultImplementation(apiResponseLocalVar, threadId, runId);

                        Events.ExecuteOnCancelRun(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCancelRunDefaultImplementation(e, "/threads/{thread_id}/runs/{run_id}/cancel", uriBuilderLocalVar.Path, threadId, runId);
                Events.ExecuteOnErrorCancelRun(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CancelRunApiResponse"/>
        /// </summary>
        public partial class CancelRunApiResponse : Org.OpenAPITools.Client.ApiResponse, ICancelRunApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CancelRunApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CancelRunApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CancelRunApiResponse(ILogger<CancelRunApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CancelRunApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CancelRunApiResponse(ILogger<CancelRunApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.RunObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.RunObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.RunObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateAssistant(CreateAssistantRequest createAssistantRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="createAssistantRequest"></param>
        /// <returns></returns>
        private void ValidateCreateAssistant(CreateAssistantRequest createAssistantRequest)
        {
            if (createAssistantRequest == null)
                throw new ArgumentNullException(nameof(createAssistantRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createAssistantRequest"></param>
        private void AfterCreateAssistantDefaultImplementation(ICreateAssistantApiResponse apiResponseLocalVar, CreateAssistantRequest createAssistantRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateAssistant(ref suppressDefaultLog, apiResponseLocalVar, createAssistantRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createAssistantRequest"></param>
        partial void AfterCreateAssistant(ref bool suppressDefaultLog, ICreateAssistantApiResponse apiResponseLocalVar, CreateAssistantRequest createAssistantRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createAssistantRequest"></param>
        private void OnErrorCreateAssistantDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CreateAssistantRequest createAssistantRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateAssistant(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, createAssistantRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createAssistantRequest"></param>
        partial void OnErrorCreateAssistant(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CreateAssistantRequest createAssistantRequest);

        /// <summary>
        /// Create an assistant with a model and instructions. 
        /// </summary>
        /// <param name="createAssistantRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateAssistantApiResponse"/>&gt;</returns>
        public async Task<ICreateAssistantApiResponse?> CreateAssistantOrDefaultAsync(CreateAssistantRequest createAssistantRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateAssistantAsync(createAssistantRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create an assistant with a model and instructions. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createAssistantRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateAssistantApiResponse"/>&gt;</returns>
        public async Task<ICreateAssistantApiResponse> CreateAssistantAsync(CreateAssistantRequest createAssistantRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateAssistant(createAssistantRequest);

                FormatCreateAssistant(createAssistantRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/assistants"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/assistants");

                    httpRequestMessageLocalVar.Content = (createAssistantRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createAssistantRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateAssistantApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateAssistantApiResponse>();
                        CreateAssistantApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/assistants", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateAssistantDefaultImplementation(apiResponseLocalVar, createAssistantRequest);

                        Events.ExecuteOnCreateAssistant(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateAssistantDefaultImplementation(e, "/assistants", uriBuilderLocalVar.Path, createAssistantRequest);
                Events.ExecuteOnErrorCreateAssistant(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateAssistantApiResponse"/>
        /// </summary>
        public partial class CreateAssistantApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateAssistantApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateAssistantApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateAssistantApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateAssistantApiResponse(ILogger<CreateAssistantApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateAssistantApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateAssistantApiResponse(ILogger<CreateAssistantApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.AssistantObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.AssistantObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.AssistantObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateAssistantFile(ref string assistantId, CreateAssistantFileRequest createAssistantFileRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="assistantId"></param>
        /// <param name="createAssistantFileRequest"></param>
        /// <returns></returns>
        private void ValidateCreateAssistantFile(string assistantId, CreateAssistantFileRequest createAssistantFileRequest)
        {
            if (assistantId == null)
                throw new ArgumentNullException(nameof(assistantId));

            if (createAssistantFileRequest == null)
                throw new ArgumentNullException(nameof(createAssistantFileRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="createAssistantFileRequest"></param>
        private void AfterCreateAssistantFileDefaultImplementation(ICreateAssistantFileApiResponse apiResponseLocalVar, string assistantId, CreateAssistantFileRequest createAssistantFileRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateAssistantFile(ref suppressDefaultLog, apiResponseLocalVar, assistantId, createAssistantFileRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="createAssistantFileRequest"></param>
        partial void AfterCreateAssistantFile(ref bool suppressDefaultLog, ICreateAssistantFileApiResponse apiResponseLocalVar, string assistantId, CreateAssistantFileRequest createAssistantFileRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="createAssistantFileRequest"></param>
        private void OnErrorCreateAssistantFileDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assistantId, CreateAssistantFileRequest createAssistantFileRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateAssistantFile(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, assistantId, createAssistantFileRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="createAssistantFileRequest"></param>
        partial void OnErrorCreateAssistantFile(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assistantId, CreateAssistantFileRequest createAssistantFileRequest);

        /// <summary>
        /// Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants). 
        /// </summary>
        /// <param name="assistantId">The ID of the assistant for which to create a File. </param>
        /// <param name="createAssistantFileRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateAssistantFileApiResponse"/>&gt;</returns>
        public async Task<ICreateAssistantFileApiResponse?> CreateAssistantFileOrDefaultAsync(string assistantId, CreateAssistantFileRequest createAssistantFileRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateAssistantFileAsync(assistantId, createAssistantFileRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants). 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assistantId">The ID of the assistant for which to create a File. </param>
        /// <param name="createAssistantFileRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateAssistantFileApiResponse"/>&gt;</returns>
        public async Task<ICreateAssistantFileApiResponse> CreateAssistantFileAsync(string assistantId, CreateAssistantFileRequest createAssistantFileRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateAssistantFile(assistantId, createAssistantFileRequest);

                FormatCreateAssistantFile(ref assistantId, createAssistantFileRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/assistants/{assistant_id}/files"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/assistants/{assistant_id}/files");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bassistant_id%7D", Uri.EscapeDataString(assistantId.ToString()));

                    httpRequestMessageLocalVar.Content = (createAssistantFileRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createAssistantFileRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateAssistantFileApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateAssistantFileApiResponse>();
                        CreateAssistantFileApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/assistants/{assistant_id}/files", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateAssistantFileDefaultImplementation(apiResponseLocalVar, assistantId, createAssistantFileRequest);

                        Events.ExecuteOnCreateAssistantFile(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateAssistantFileDefaultImplementation(e, "/assistants/{assistant_id}/files", uriBuilderLocalVar.Path, assistantId, createAssistantFileRequest);
                Events.ExecuteOnErrorCreateAssistantFile(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateAssistantFileApiResponse"/>
        /// </summary>
        public partial class CreateAssistantFileApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateAssistantFileApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateAssistantFileApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateAssistantFileApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateAssistantFileApiResponse(ILogger<CreateAssistantFileApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateAssistantFileApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateAssistantFileApiResponse(ILogger<CreateAssistantFileApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.AssistantFileObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.AssistantFileObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.AssistantFileObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateMessage(ref string threadId, CreateMessageRequest createMessageRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="createMessageRequest"></param>
        /// <returns></returns>
        private void ValidateCreateMessage(string threadId, CreateMessageRequest createMessageRequest)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));

            if (createMessageRequest == null)
                throw new ArgumentNullException(nameof(createMessageRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="createMessageRequest"></param>
        private void AfterCreateMessageDefaultImplementation(ICreateMessageApiResponse apiResponseLocalVar, string threadId, CreateMessageRequest createMessageRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateMessage(ref suppressDefaultLog, apiResponseLocalVar, threadId, createMessageRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="createMessageRequest"></param>
        partial void AfterCreateMessage(ref bool suppressDefaultLog, ICreateMessageApiResponse apiResponseLocalVar, string threadId, CreateMessageRequest createMessageRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="createMessageRequest"></param>
        private void OnErrorCreateMessageDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, CreateMessageRequest createMessageRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateMessage(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, createMessageRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="createMessageRequest"></param>
        partial void OnErrorCreateMessage(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, CreateMessageRequest createMessageRequest);

        /// <summary>
        /// Create a message. 
        /// </summary>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) to create a message for.</param>
        /// <param name="createMessageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateMessageApiResponse"/>&gt;</returns>
        public async Task<ICreateMessageApiResponse?> CreateMessageOrDefaultAsync(string threadId, CreateMessageRequest createMessageRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateMessageAsync(threadId, createMessageRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create a message. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) to create a message for.</param>
        /// <param name="createMessageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateMessageApiResponse"/>&gt;</returns>
        public async Task<ICreateMessageApiResponse> CreateMessageAsync(string threadId, CreateMessageRequest createMessageRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateMessage(threadId, createMessageRequest);

                FormatCreateMessage(ref threadId, createMessageRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}/messages"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}/messages");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));

                    httpRequestMessageLocalVar.Content = (createMessageRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createMessageRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateMessageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateMessageApiResponse>();
                        CreateMessageApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}/messages", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateMessageDefaultImplementation(apiResponseLocalVar, threadId, createMessageRequest);

                        Events.ExecuteOnCreateMessage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateMessageDefaultImplementation(e, "/threads/{thread_id}/messages", uriBuilderLocalVar.Path, threadId, createMessageRequest);
                Events.ExecuteOnErrorCreateMessage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateMessageApiResponse"/>
        /// </summary>
        public partial class CreateMessageApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateMessageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateMessageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateMessageApiResponse(ILogger<CreateMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateMessageApiResponse(ILogger<CreateMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.MessageObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.MessageObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.MessageObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateRun(ref string threadId, CreateRunRequest createRunRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="createRunRequest"></param>
        /// <returns></returns>
        private void ValidateCreateRun(string threadId, CreateRunRequest createRunRequest)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));

            if (createRunRequest == null)
                throw new ArgumentNullException(nameof(createRunRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="createRunRequest"></param>
        private void AfterCreateRunDefaultImplementation(ICreateRunApiResponse apiResponseLocalVar, string threadId, CreateRunRequest createRunRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateRun(ref suppressDefaultLog, apiResponseLocalVar, threadId, createRunRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="createRunRequest"></param>
        partial void AfterCreateRun(ref bool suppressDefaultLog, ICreateRunApiResponse apiResponseLocalVar, string threadId, CreateRunRequest createRunRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="createRunRequest"></param>
        private void OnErrorCreateRunDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, CreateRunRequest createRunRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateRun(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, createRunRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="createRunRequest"></param>
        partial void OnErrorCreateRun(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, CreateRunRequest createRunRequest);

        /// <summary>
        /// Create a run. 
        /// </summary>
        /// <param name="threadId">The ID of the thread to run.</param>
        /// <param name="createRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRunApiResponse"/>&gt;</returns>
        public async Task<ICreateRunApiResponse?> CreateRunOrDefaultAsync(string threadId, CreateRunRequest createRunRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateRunAsync(threadId, createRunRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create a run. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to run.</param>
        /// <param name="createRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRunApiResponse"/>&gt;</returns>
        public async Task<ICreateRunApiResponse> CreateRunAsync(string threadId, CreateRunRequest createRunRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateRun(threadId, createRunRequest);

                FormatCreateRun(ref threadId, createRunRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}/runs"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}/runs");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));

                    httpRequestMessageLocalVar.Content = (createRunRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createRunRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateRunApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateRunApiResponse>();
                        CreateRunApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}/runs", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateRunDefaultImplementation(apiResponseLocalVar, threadId, createRunRequest);

                        Events.ExecuteOnCreateRun(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateRunDefaultImplementation(e, "/threads/{thread_id}/runs", uriBuilderLocalVar.Path, threadId, createRunRequest);
                Events.ExecuteOnErrorCreateRun(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateRunApiResponse"/>
        /// </summary>
        public partial class CreateRunApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateRunApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateRunApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateRunApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateRunApiResponse(ILogger<CreateRunApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateRunApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateRunApiResponse(ILogger<CreateRunApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.RunObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.RunObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.RunObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateThread(Option<CreateThreadRequest> createThreadRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="createThreadRequest"></param>
        /// <returns></returns>
        private void ValidateCreateThread(Option<CreateThreadRequest> createThreadRequest)
        {
            if (createThreadRequest.IsSet && createThreadRequest.Value == null)
                throw new ArgumentNullException(nameof(createThreadRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createThreadRequest"></param>
        private void AfterCreateThreadDefaultImplementation(ICreateThreadApiResponse apiResponseLocalVar, Option<CreateThreadRequest> createThreadRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateThread(ref suppressDefaultLog, apiResponseLocalVar, createThreadRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createThreadRequest"></param>
        partial void AfterCreateThread(ref bool suppressDefaultLog, ICreateThreadApiResponse apiResponseLocalVar, Option<CreateThreadRequest> createThreadRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createThreadRequest"></param>
        private void OnErrorCreateThreadDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<CreateThreadRequest> createThreadRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateThread(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, createThreadRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createThreadRequest"></param>
        partial void OnErrorCreateThread(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<CreateThreadRequest> createThreadRequest);

        /// <summary>
        /// Create a thread. 
        /// </summary>
        /// <param name="createThreadRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateThreadApiResponse"/>&gt;</returns>
        public async Task<ICreateThreadApiResponse?> CreateThreadOrDefaultAsync(Option<CreateThreadRequest> createThreadRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateThreadAsync(createThreadRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create a thread. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createThreadRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateThreadApiResponse"/>&gt;</returns>
        public async Task<ICreateThreadApiResponse> CreateThreadAsync(Option<CreateThreadRequest> createThreadRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateThread(createThreadRequest);

                FormatCreateThread(createThreadRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads");

                    if (createThreadRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (createThreadRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createThreadRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateThreadApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateThreadApiResponse>();
                        CreateThreadApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateThreadDefaultImplementation(apiResponseLocalVar, createThreadRequest);

                        Events.ExecuteOnCreateThread(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateThreadDefaultImplementation(e, "/threads", uriBuilderLocalVar.Path, createThreadRequest);
                Events.ExecuteOnErrorCreateThread(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateThreadApiResponse"/>
        /// </summary>
        public partial class CreateThreadApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateThreadApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateThreadApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateThreadApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateThreadApiResponse(ILogger<CreateThreadApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateThreadApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateThreadApiResponse(ILogger<CreateThreadApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ThreadObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ThreadObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ThreadObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateThreadAndRun(CreateThreadAndRunRequest createThreadAndRunRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="createThreadAndRunRequest"></param>
        /// <returns></returns>
        private void ValidateCreateThreadAndRun(CreateThreadAndRunRequest createThreadAndRunRequest)
        {
            if (createThreadAndRunRequest == null)
                throw new ArgumentNullException(nameof(createThreadAndRunRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createThreadAndRunRequest"></param>
        private void AfterCreateThreadAndRunDefaultImplementation(ICreateThreadAndRunApiResponse apiResponseLocalVar, CreateThreadAndRunRequest createThreadAndRunRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateThreadAndRun(ref suppressDefaultLog, apiResponseLocalVar, createThreadAndRunRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createThreadAndRunRequest"></param>
        partial void AfterCreateThreadAndRun(ref bool suppressDefaultLog, ICreateThreadAndRunApiResponse apiResponseLocalVar, CreateThreadAndRunRequest createThreadAndRunRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createThreadAndRunRequest"></param>
        private void OnErrorCreateThreadAndRunDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CreateThreadAndRunRequest createThreadAndRunRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateThreadAndRun(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, createThreadAndRunRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createThreadAndRunRequest"></param>
        partial void OnErrorCreateThreadAndRun(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CreateThreadAndRunRequest createThreadAndRunRequest);

        /// <summary>
        /// Create a thread and run it in one request. 
        /// </summary>
        /// <param name="createThreadAndRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateThreadAndRunApiResponse"/>&gt;</returns>
        public async Task<ICreateThreadAndRunApiResponse?> CreateThreadAndRunOrDefaultAsync(CreateThreadAndRunRequest createThreadAndRunRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateThreadAndRunAsync(createThreadAndRunRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create a thread and run it in one request. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createThreadAndRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateThreadAndRunApiResponse"/>&gt;</returns>
        public async Task<ICreateThreadAndRunApiResponse> CreateThreadAndRunAsync(CreateThreadAndRunRequest createThreadAndRunRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateThreadAndRun(createThreadAndRunRequest);

                FormatCreateThreadAndRun(createThreadAndRunRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/runs"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/runs");

                    httpRequestMessageLocalVar.Content = (createThreadAndRunRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createThreadAndRunRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateThreadAndRunApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateThreadAndRunApiResponse>();
                        CreateThreadAndRunApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/runs", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateThreadAndRunDefaultImplementation(apiResponseLocalVar, createThreadAndRunRequest);

                        Events.ExecuteOnCreateThreadAndRun(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateThreadAndRunDefaultImplementation(e, "/threads/runs", uriBuilderLocalVar.Path, createThreadAndRunRequest);
                Events.ExecuteOnErrorCreateThreadAndRun(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateThreadAndRunApiResponse"/>
        /// </summary>
        public partial class CreateThreadAndRunApiResponse : Org.OpenAPITools.Client.ApiResponse, ICreateThreadAndRunApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateThreadAndRunApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateThreadAndRunApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateThreadAndRunApiResponse(ILogger<CreateThreadAndRunApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateThreadAndRunApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateThreadAndRunApiResponse(ILogger<CreateThreadAndRunApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.RunObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.RunObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.RunObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteAssistant(ref string assistantId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="assistantId"></param>
        /// <returns></returns>
        private void ValidateDeleteAssistant(string assistantId)
        {
            if (assistantId == null)
                throw new ArgumentNullException(nameof(assistantId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assistantId"></param>
        private void AfterDeleteAssistantDefaultImplementation(IDeleteAssistantApiResponse apiResponseLocalVar, string assistantId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteAssistant(ref suppressDefaultLog, apiResponseLocalVar, assistantId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assistantId"></param>
        partial void AfterDeleteAssistant(ref bool suppressDefaultLog, IDeleteAssistantApiResponse apiResponseLocalVar, string assistantId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assistantId"></param>
        private void OnErrorDeleteAssistantDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assistantId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteAssistant(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, assistantId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assistantId"></param>
        partial void OnErrorDeleteAssistant(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assistantId);

        /// <summary>
        /// Delete an assistant. 
        /// </summary>
        /// <param name="assistantId">The ID of the assistant to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAssistantApiResponse"/>&gt;</returns>
        public async Task<IDeleteAssistantApiResponse?> DeleteAssistantOrDefaultAsync(string assistantId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteAssistantAsync(assistantId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete an assistant. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assistantId">The ID of the assistant to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAssistantApiResponse"/>&gt;</returns>
        public async Task<IDeleteAssistantApiResponse> DeleteAssistantAsync(string assistantId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteAssistant(assistantId);

                FormatDeleteAssistant(ref assistantId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/assistants/{assistant_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/assistants/{assistant_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bassistant_id%7D", Uri.EscapeDataString(assistantId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteAssistantApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteAssistantApiResponse>();
                        DeleteAssistantApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/assistants/{assistant_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteAssistantDefaultImplementation(apiResponseLocalVar, assistantId);

                        Events.ExecuteOnDeleteAssistant(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteAssistantDefaultImplementation(e, "/assistants/{assistant_id}", uriBuilderLocalVar.Path, assistantId);
                Events.ExecuteOnErrorDeleteAssistant(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteAssistantApiResponse"/>
        /// </summary>
        public partial class DeleteAssistantApiResponse : Org.OpenAPITools.Client.ApiResponse, IDeleteAssistantApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteAssistantApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteAssistantApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteAssistantApiResponse(ILogger<DeleteAssistantApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteAssistantApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteAssistantApiResponse(ILogger<DeleteAssistantApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.DeleteAssistantResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.DeleteAssistantResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.DeleteAssistantResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteAssistantFile(ref string assistantId, ref string fileId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="assistantId"></param>
        /// <param name="fileId"></param>
        /// <returns></returns>
        private void ValidateDeleteAssistantFile(string assistantId, string fileId)
        {
            if (assistantId == null)
                throw new ArgumentNullException(nameof(assistantId));

            if (fileId == null)
                throw new ArgumentNullException(nameof(fileId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="fileId"></param>
        private void AfterDeleteAssistantFileDefaultImplementation(IDeleteAssistantFileApiResponse apiResponseLocalVar, string assistantId, string fileId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteAssistantFile(ref suppressDefaultLog, apiResponseLocalVar, assistantId, fileId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="fileId"></param>
        partial void AfterDeleteAssistantFile(ref bool suppressDefaultLog, IDeleteAssistantFileApiResponse apiResponseLocalVar, string assistantId, string fileId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="fileId"></param>
        private void OnErrorDeleteAssistantFileDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assistantId, string fileId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteAssistantFile(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, assistantId, fileId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="fileId"></param>
        partial void OnErrorDeleteAssistantFile(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assistantId, string fileId);

        /// <summary>
        /// Delete an assistant file. 
        /// </summary>
        /// <param name="assistantId">The ID of the assistant that the file belongs to.</param>
        /// <param name="fileId">The ID of the file to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAssistantFileApiResponse"/>&gt;</returns>
        public async Task<IDeleteAssistantFileApiResponse?> DeleteAssistantFileOrDefaultAsync(string assistantId, string fileId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteAssistantFileAsync(assistantId, fileId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete an assistant file. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assistantId">The ID of the assistant that the file belongs to.</param>
        /// <param name="fileId">The ID of the file to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteAssistantFileApiResponse"/>&gt;</returns>
        public async Task<IDeleteAssistantFileApiResponse> DeleteAssistantFileAsync(string assistantId, string fileId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteAssistantFile(assistantId, fileId);

                FormatDeleteAssistantFile(ref assistantId, ref fileId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/assistants/{assistant_id}/files/{file_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/assistants/{assistant_id}/files/{file_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bassistant_id%7D", Uri.EscapeDataString(assistantId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bfile_id%7D", Uri.EscapeDataString(fileId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteAssistantFileApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteAssistantFileApiResponse>();
                        DeleteAssistantFileApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/assistants/{assistant_id}/files/{file_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteAssistantFileDefaultImplementation(apiResponseLocalVar, assistantId, fileId);

                        Events.ExecuteOnDeleteAssistantFile(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteAssistantFileDefaultImplementation(e, "/assistants/{assistant_id}/files/{file_id}", uriBuilderLocalVar.Path, assistantId, fileId);
                Events.ExecuteOnErrorDeleteAssistantFile(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteAssistantFileApiResponse"/>
        /// </summary>
        public partial class DeleteAssistantFileApiResponse : Org.OpenAPITools.Client.ApiResponse, IDeleteAssistantFileApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteAssistantFileApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteAssistantFileApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteAssistantFileApiResponse(ILogger<DeleteAssistantFileApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteAssistantFileApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteAssistantFileApiResponse(ILogger<DeleteAssistantFileApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.DeleteAssistantFileResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.DeleteAssistantFileResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.DeleteAssistantFileResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteThread(ref string threadId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <returns></returns>
        private void ValidateDeleteThread(string threadId)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        private void AfterDeleteThreadDefaultImplementation(IDeleteThreadApiResponse apiResponseLocalVar, string threadId)
        {
            bool suppressDefaultLog = false;
            AfterDeleteThread(ref suppressDefaultLog, apiResponseLocalVar, threadId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        partial void AfterDeleteThread(ref bool suppressDefaultLog, IDeleteThreadApiResponse apiResponseLocalVar, string threadId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        private void OnErrorDeleteThreadDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteThread(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        partial void OnErrorDeleteThread(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId);

        /// <summary>
        /// Delete a thread. 
        /// </summary>
        /// <param name="threadId">The ID of the thread to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteThreadApiResponse"/>&gt;</returns>
        public async Task<IDeleteThreadApiResponse?> DeleteThreadOrDefaultAsync(string threadId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteThreadAsync(threadId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete a thread. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to delete.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteThreadApiResponse"/>&gt;</returns>
        public async Task<IDeleteThreadApiResponse> DeleteThreadAsync(string threadId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteThread(threadId);

                FormatDeleteThread(ref threadId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteThreadApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteThreadApiResponse>();
                        DeleteThreadApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteThreadDefaultImplementation(apiResponseLocalVar, threadId);

                        Events.ExecuteOnDeleteThread(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteThreadDefaultImplementation(e, "/threads/{thread_id}", uriBuilderLocalVar.Path, threadId);
                Events.ExecuteOnErrorDeleteThread(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteThreadApiResponse"/>
        /// </summary>
        public partial class DeleteThreadApiResponse : Org.OpenAPITools.Client.ApiResponse, IDeleteThreadApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteThreadApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteThreadApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteThreadApiResponse(ILogger<DeleteThreadApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteThreadApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteThreadApiResponse(ILogger<DeleteThreadApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.DeleteThreadResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.DeleteThreadResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.DeleteThreadResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAssistant(ref string assistantId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="assistantId"></param>
        /// <returns></returns>
        private void ValidateGetAssistant(string assistantId)
        {
            if (assistantId == null)
                throw new ArgumentNullException(nameof(assistantId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assistantId"></param>
        private void AfterGetAssistantDefaultImplementation(IGetAssistantApiResponse apiResponseLocalVar, string assistantId)
        {
            bool suppressDefaultLog = false;
            AfterGetAssistant(ref suppressDefaultLog, apiResponseLocalVar, assistantId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assistantId"></param>
        partial void AfterGetAssistant(ref bool suppressDefaultLog, IGetAssistantApiResponse apiResponseLocalVar, string assistantId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assistantId"></param>
        private void OnErrorGetAssistantDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assistantId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAssistant(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, assistantId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assistantId"></param>
        partial void OnErrorGetAssistant(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assistantId);

        /// <summary>
        /// Retrieves an assistant. 
        /// </summary>
        /// <param name="assistantId">The ID of the assistant to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAssistantApiResponse"/>&gt;</returns>
        public async Task<IGetAssistantApiResponse?> GetAssistantOrDefaultAsync(string assistantId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAssistantAsync(assistantId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Retrieves an assistant. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assistantId">The ID of the assistant to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAssistantApiResponse"/>&gt;</returns>
        public async Task<IGetAssistantApiResponse> GetAssistantAsync(string assistantId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAssistant(assistantId);

                FormatGetAssistant(ref assistantId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/assistants/{assistant_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/assistants/{assistant_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bassistant_id%7D", Uri.EscapeDataString(assistantId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetAssistantApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAssistantApiResponse>();
                        GetAssistantApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/assistants/{assistant_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetAssistantDefaultImplementation(apiResponseLocalVar, assistantId);

                        Events.ExecuteOnGetAssistant(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAssistantDefaultImplementation(e, "/assistants/{assistant_id}", uriBuilderLocalVar.Path, assistantId);
                Events.ExecuteOnErrorGetAssistant(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAssistantApiResponse"/>
        /// </summary>
        public partial class GetAssistantApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetAssistantApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAssistantApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAssistantApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAssistantApiResponse(ILogger<GetAssistantApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetAssistantApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAssistantApiResponse(ILogger<GetAssistantApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.AssistantObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.AssistantObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.AssistantObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetAssistantFile(ref string assistantId, ref string fileId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="assistantId"></param>
        /// <param name="fileId"></param>
        /// <returns></returns>
        private void ValidateGetAssistantFile(string assistantId, string fileId)
        {
            if (assistantId == null)
                throw new ArgumentNullException(nameof(assistantId));

            if (fileId == null)
                throw new ArgumentNullException(nameof(fileId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="fileId"></param>
        private void AfterGetAssistantFileDefaultImplementation(IGetAssistantFileApiResponse apiResponseLocalVar, string assistantId, string fileId)
        {
            bool suppressDefaultLog = false;
            AfterGetAssistantFile(ref suppressDefaultLog, apiResponseLocalVar, assistantId, fileId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="fileId"></param>
        partial void AfterGetAssistantFile(ref bool suppressDefaultLog, IGetAssistantFileApiResponse apiResponseLocalVar, string assistantId, string fileId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="fileId"></param>
        private void OnErrorGetAssistantFileDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assistantId, string fileId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetAssistantFile(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, assistantId, fileId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="fileId"></param>
        partial void OnErrorGetAssistantFile(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assistantId, string fileId);

        /// <summary>
        /// Retrieves an AssistantFile. 
        /// </summary>
        /// <param name="assistantId">The ID of the assistant who the file belongs to.</param>
        /// <param name="fileId">The ID of the file we&#39;re getting.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAssistantFileApiResponse"/>&gt;</returns>
        public async Task<IGetAssistantFileApiResponse?> GetAssistantFileOrDefaultAsync(string assistantId, string fileId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetAssistantFileAsync(assistantId, fileId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Retrieves an AssistantFile. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assistantId">The ID of the assistant who the file belongs to.</param>
        /// <param name="fileId">The ID of the file we&#39;re getting.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetAssistantFileApiResponse"/>&gt;</returns>
        public async Task<IGetAssistantFileApiResponse> GetAssistantFileAsync(string assistantId, string fileId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetAssistantFile(assistantId, fileId);

                FormatGetAssistantFile(ref assistantId, ref fileId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/assistants/{assistant_id}/files/{file_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/assistants/{assistant_id}/files/{file_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bassistant_id%7D", Uri.EscapeDataString(assistantId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bfile_id%7D", Uri.EscapeDataString(fileId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetAssistantFileApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetAssistantFileApiResponse>();
                        GetAssistantFileApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/assistants/{assistant_id}/files/{file_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetAssistantFileDefaultImplementation(apiResponseLocalVar, assistantId, fileId);

                        Events.ExecuteOnGetAssistantFile(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetAssistantFileDefaultImplementation(e, "/assistants/{assistant_id}/files/{file_id}", uriBuilderLocalVar.Path, assistantId, fileId);
                Events.ExecuteOnErrorGetAssistantFile(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetAssistantFileApiResponse"/>
        /// </summary>
        public partial class GetAssistantFileApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetAssistantFileApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetAssistantFileApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetAssistantFileApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAssistantFileApiResponse(ILogger<GetAssistantFileApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetAssistantFileApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetAssistantFileApiResponse(ILogger<GetAssistantFileApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.AssistantFileObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.AssistantFileObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.AssistantFileObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetMessage(ref string threadId, ref string messageId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <returns></returns>
        private void ValidateGetMessage(string threadId, string messageId)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));

            if (messageId == null)
                throw new ArgumentNullException(nameof(messageId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        private void AfterGetMessageDefaultImplementation(IGetMessageApiResponse apiResponseLocalVar, string threadId, string messageId)
        {
            bool suppressDefaultLog = false;
            AfterGetMessage(ref suppressDefaultLog, apiResponseLocalVar, threadId, messageId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        partial void AfterGetMessage(ref bool suppressDefaultLog, IGetMessageApiResponse apiResponseLocalVar, string threadId, string messageId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        private void OnErrorGetMessageDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string messageId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetMessage(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, messageId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        partial void OnErrorGetMessage(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string messageId);

        /// <summary>
        /// Retrieve a message. 
        /// </summary>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) to which this message belongs.</param>
        /// <param name="messageId">The ID of the message to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageApiResponse"/>&gt;</returns>
        public async Task<IGetMessageApiResponse?> GetMessageOrDefaultAsync(string threadId, string messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMessageAsync(threadId, messageId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Retrieve a message. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) to which this message belongs.</param>
        /// <param name="messageId">The ID of the message to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageApiResponse"/>&gt;</returns>
        public async Task<IGetMessageApiResponse> GetMessageAsync(string threadId, string messageId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetMessage(threadId, messageId);

                FormatGetMessage(ref threadId, ref messageId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}/messages/{message_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}/messages/{message_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bmessage_id%7D", Uri.EscapeDataString(messageId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetMessageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMessageApiResponse>();
                        GetMessageApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}/messages/{message_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetMessageDefaultImplementation(apiResponseLocalVar, threadId, messageId);

                        Events.ExecuteOnGetMessage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMessageDefaultImplementation(e, "/threads/{thread_id}/messages/{message_id}", uriBuilderLocalVar.Path, threadId, messageId);
                Events.ExecuteOnErrorGetMessage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMessageApiResponse"/>
        /// </summary>
        public partial class GetMessageApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetMessageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMessageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMessageApiResponse(ILogger<GetMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMessageApiResponse(ILogger<GetMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.MessageObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.MessageObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.MessageObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetMessageFile(ref string threadId, ref string messageId, ref string fileId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <param name="fileId"></param>
        /// <returns></returns>
        private void ValidateGetMessageFile(string threadId, string messageId, string fileId)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));

            if (messageId == null)
                throw new ArgumentNullException(nameof(messageId));

            if (fileId == null)
                throw new ArgumentNullException(nameof(fileId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <param name="fileId"></param>
        private void AfterGetMessageFileDefaultImplementation(IGetMessageFileApiResponse apiResponseLocalVar, string threadId, string messageId, string fileId)
        {
            bool suppressDefaultLog = false;
            AfterGetMessageFile(ref suppressDefaultLog, apiResponseLocalVar, threadId, messageId, fileId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <param name="fileId"></param>
        partial void AfterGetMessageFile(ref bool suppressDefaultLog, IGetMessageFileApiResponse apiResponseLocalVar, string threadId, string messageId, string fileId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <param name="fileId"></param>
        private void OnErrorGetMessageFileDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string messageId, string fileId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetMessageFile(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, messageId, fileId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <param name="fileId"></param>
        partial void OnErrorGetMessageFile(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string messageId, string fileId);

        /// <summary>
        /// Retrieves a message file. 
        /// </summary>
        /// <param name="threadId">The ID of the thread to which the message and File belong.</param>
        /// <param name="messageId">The ID of the message the file belongs to.</param>
        /// <param name="fileId">The ID of the file being retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageFileApiResponse"/>&gt;</returns>
        public async Task<IGetMessageFileApiResponse?> GetMessageFileOrDefaultAsync(string threadId, string messageId, string fileId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMessageFileAsync(threadId, messageId, fileId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Retrieves a message file. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to which the message and File belong.</param>
        /// <param name="messageId">The ID of the message the file belongs to.</param>
        /// <param name="fileId">The ID of the file being retrieved.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMessageFileApiResponse"/>&gt;</returns>
        public async Task<IGetMessageFileApiResponse> GetMessageFileAsync(string threadId, string messageId, string fileId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetMessageFile(threadId, messageId, fileId);

                FormatGetMessageFile(ref threadId, ref messageId, ref fileId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}/messages/{message_id}/files/{file_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}/messages/{message_id}/files/{file_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bmessage_id%7D", Uri.EscapeDataString(messageId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bfile_id%7D", Uri.EscapeDataString(fileId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetMessageFileApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMessageFileApiResponse>();
                        GetMessageFileApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}/messages/{message_id}/files/{file_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetMessageFileDefaultImplementation(apiResponseLocalVar, threadId, messageId, fileId);

                        Events.ExecuteOnGetMessageFile(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMessageFileDefaultImplementation(e, "/threads/{thread_id}/messages/{message_id}/files/{file_id}", uriBuilderLocalVar.Path, threadId, messageId, fileId);
                Events.ExecuteOnErrorGetMessageFile(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMessageFileApiResponse"/>
        /// </summary>
        public partial class GetMessageFileApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetMessageFileApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMessageFileApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMessageFileApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMessageFileApiResponse(ILogger<GetMessageFileApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetMessageFileApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMessageFileApiResponse(ILogger<GetMessageFileApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.MessageFileObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.MessageFileObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.MessageFileObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetRun(ref string threadId, ref string runId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <returns></returns>
        private void ValidateGetRun(string threadId, string runId)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));

            if (runId == null)
                throw new ArgumentNullException(nameof(runId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        private void AfterGetRunDefaultImplementation(IGetRunApiResponse apiResponseLocalVar, string threadId, string runId)
        {
            bool suppressDefaultLog = false;
            AfterGetRun(ref suppressDefaultLog, apiResponseLocalVar, threadId, runId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        partial void AfterGetRun(ref bool suppressDefaultLog, IGetRunApiResponse apiResponseLocalVar, string threadId, string runId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        private void OnErrorGetRunDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string runId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetRun(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, runId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        partial void OnErrorGetRun(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string runId);

        /// <summary>
        /// Retrieves a run. 
        /// </summary>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) that was run.</param>
        /// <param name="runId">The ID of the run to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRunApiResponse"/>&gt;</returns>
        public async Task<IGetRunApiResponse?> GetRunOrDefaultAsync(string threadId, string runId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetRunAsync(threadId, runId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Retrieves a run. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) that was run.</param>
        /// <param name="runId">The ID of the run to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRunApiResponse"/>&gt;</returns>
        public async Task<IGetRunApiResponse> GetRunAsync(string threadId, string runId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetRun(threadId, runId);

                FormatGetRun(ref threadId, ref runId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}/runs/{run_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}/runs/{run_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brun_id%7D", Uri.EscapeDataString(runId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetRunApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetRunApiResponse>();
                        GetRunApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}/runs/{run_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetRunDefaultImplementation(apiResponseLocalVar, threadId, runId);

                        Events.ExecuteOnGetRun(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetRunDefaultImplementation(e, "/threads/{thread_id}/runs/{run_id}", uriBuilderLocalVar.Path, threadId, runId);
                Events.ExecuteOnErrorGetRun(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetRunApiResponse"/>
        /// </summary>
        public partial class GetRunApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetRunApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetRunApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetRunApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetRunApiResponse(ILogger<GetRunApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetRunApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetRunApiResponse(ILogger<GetRunApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.RunObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.RunObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.RunObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetRunStep(ref string threadId, ref string runId, ref string stepId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="stepId"></param>
        /// <returns></returns>
        private void ValidateGetRunStep(string threadId, string runId, string stepId)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));

            if (runId == null)
                throw new ArgumentNullException(nameof(runId));

            if (stepId == null)
                throw new ArgumentNullException(nameof(stepId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="stepId"></param>
        private void AfterGetRunStepDefaultImplementation(IGetRunStepApiResponse apiResponseLocalVar, string threadId, string runId, string stepId)
        {
            bool suppressDefaultLog = false;
            AfterGetRunStep(ref suppressDefaultLog, apiResponseLocalVar, threadId, runId, stepId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="stepId"></param>
        partial void AfterGetRunStep(ref bool suppressDefaultLog, IGetRunStepApiResponse apiResponseLocalVar, string threadId, string runId, string stepId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="stepId"></param>
        private void OnErrorGetRunStepDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string runId, string stepId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetRunStep(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, runId, stepId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="stepId"></param>
        partial void OnErrorGetRunStep(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string runId, string stepId);

        /// <summary>
        /// Retrieves a run step. 
        /// </summary>
        /// <param name="threadId">The ID of the thread to which the run and run step belongs.</param>
        /// <param name="runId">The ID of the run to which the run step belongs.</param>
        /// <param name="stepId">The ID of the run step to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRunStepApiResponse"/>&gt;</returns>
        public async Task<IGetRunStepApiResponse?> GetRunStepOrDefaultAsync(string threadId, string runId, string stepId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetRunStepAsync(threadId, runId, stepId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Retrieves a run step. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to which the run and run step belongs.</param>
        /// <param name="runId">The ID of the run to which the run step belongs.</param>
        /// <param name="stepId">The ID of the run step to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRunStepApiResponse"/>&gt;</returns>
        public async Task<IGetRunStepApiResponse> GetRunStepAsync(string threadId, string runId, string stepId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetRunStep(threadId, runId, stepId);

                FormatGetRunStep(ref threadId, ref runId, ref stepId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}/runs/{run_id}/steps/{step_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}/runs/{run_id}/steps/{step_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brun_id%7D", Uri.EscapeDataString(runId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bstep_id%7D", Uri.EscapeDataString(stepId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetRunStepApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetRunStepApiResponse>();
                        GetRunStepApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}/runs/{run_id}/steps/{step_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetRunStepDefaultImplementation(apiResponseLocalVar, threadId, runId, stepId);

                        Events.ExecuteOnGetRunStep(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetRunStepDefaultImplementation(e, "/threads/{thread_id}/runs/{run_id}/steps/{step_id}", uriBuilderLocalVar.Path, threadId, runId, stepId);
                Events.ExecuteOnErrorGetRunStep(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetRunStepApiResponse"/>
        /// </summary>
        public partial class GetRunStepApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetRunStepApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetRunStepApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetRunStepApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetRunStepApiResponse(ILogger<GetRunStepApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetRunStepApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetRunStepApiResponse(ILogger<GetRunStepApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.RunStepObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.RunStepObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.RunStepObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetThread(ref string threadId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <returns></returns>
        private void ValidateGetThread(string threadId)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        private void AfterGetThreadDefaultImplementation(IGetThreadApiResponse apiResponseLocalVar, string threadId)
        {
            bool suppressDefaultLog = false;
            AfterGetThread(ref suppressDefaultLog, apiResponseLocalVar, threadId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        partial void AfterGetThread(ref bool suppressDefaultLog, IGetThreadApiResponse apiResponseLocalVar, string threadId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        private void OnErrorGetThreadDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetThread(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        partial void OnErrorGetThread(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId);

        /// <summary>
        /// Retrieves a thread. 
        /// </summary>
        /// <param name="threadId">The ID of the thread to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetThreadApiResponse"/>&gt;</returns>
        public async Task<IGetThreadApiResponse?> GetThreadOrDefaultAsync(string threadId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetThreadAsync(threadId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Retrieves a thread. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to retrieve.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetThreadApiResponse"/>&gt;</returns>
        public async Task<IGetThreadApiResponse> GetThreadAsync(string threadId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetThread(threadId);

                FormatGetThread(ref threadId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetThreadApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetThreadApiResponse>();
                        GetThreadApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetThreadDefaultImplementation(apiResponseLocalVar, threadId);

                        Events.ExecuteOnGetThread(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetThreadDefaultImplementation(e, "/threads/{thread_id}", uriBuilderLocalVar.Path, threadId);
                Events.ExecuteOnErrorGetThread(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetThreadApiResponse"/>
        /// </summary>
        public partial class GetThreadApiResponse : Org.OpenAPITools.Client.ApiResponse, IGetThreadApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetThreadApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetThreadApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetThreadApiResponse(ILogger<GetThreadApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetThreadApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetThreadApiResponse(ILogger<GetThreadApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ThreadObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ThreadObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ThreadObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListAssistantFiles(ref string assistantId, ref Option<int> limit, ref Option<string> order, ref Option<string> after, ref Option<string> before);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="assistantId"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        /// <returns></returns>
        private void ValidateListAssistantFiles(string assistantId, Option<string> order, Option<string> after, Option<string> before)
        {
            if (assistantId == null)
                throw new ArgumentNullException(nameof(assistantId));

            if (order.IsSet && order.Value == null)
                throw new ArgumentNullException(nameof(order));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));

            if (before.IsSet && before.Value == null)
                throw new ArgumentNullException(nameof(before));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        private void AfterListAssistantFilesDefaultImplementation(IListAssistantFilesApiResponse apiResponseLocalVar, string assistantId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before)
        {
            bool suppressDefaultLog = false;
            AfterListAssistantFiles(ref suppressDefaultLog, apiResponseLocalVar, assistantId, limit, order, after, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        partial void AfterListAssistantFiles(ref bool suppressDefaultLog, IListAssistantFilesApiResponse apiResponseLocalVar, string assistantId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        private void OnErrorListAssistantFilesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assistantId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListAssistantFiles(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, assistantId, limit, order, after, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        partial void OnErrorListAssistantFiles(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assistantId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before);

        /// <summary>
        /// Returns a list of assistant files. 
        /// </summary>
        /// <param name="assistantId">The ID of the assistant the file belongs to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListAssistantFilesApiResponse"/>&gt;</returns>
        public async Task<IListAssistantFilesApiResponse?> ListAssistantFilesOrDefaultAsync(string assistantId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListAssistantFilesAsync(assistantId, limit, order, after, before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Returns a list of assistant files. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assistantId">The ID of the assistant the file belongs to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListAssistantFilesApiResponse"/>&gt;</returns>
        public async Task<IListAssistantFilesApiResponse> ListAssistantFilesAsync(string assistantId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListAssistantFiles(assistantId, order, after, before);

                FormatListAssistantFiles(ref assistantId, ref limit, ref order, ref after, ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/assistants/{assistant_id}/files"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/assistants/{assistant_id}/files");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bassistant_id%7D", Uri.EscapeDataString(assistantId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (order.IsSet)
                        parseQueryStringLocalVar["order"] = ClientUtils.ParameterToString(order.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListAssistantFilesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListAssistantFilesApiResponse>();
                        ListAssistantFilesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/assistants/{assistant_id}/files", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListAssistantFilesDefaultImplementation(apiResponseLocalVar, assistantId, limit, order, after, before);

                        Events.ExecuteOnListAssistantFiles(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListAssistantFilesDefaultImplementation(e, "/assistants/{assistant_id}/files", uriBuilderLocalVar.Path, assistantId, limit, order, after, before);
                Events.ExecuteOnErrorListAssistantFiles(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListAssistantFilesApiResponse"/>
        /// </summary>
        public partial class ListAssistantFilesApiResponse : Org.OpenAPITools.Client.ApiResponse, IListAssistantFilesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListAssistantFilesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListAssistantFilesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListAssistantFilesApiResponse(ILogger<ListAssistantFilesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListAssistantFilesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListAssistantFilesApiResponse(ILogger<ListAssistantFilesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ListAssistantFilesResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ListAssistantFilesResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ListAssistantFilesResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListAssistants(ref Option<int> limit, ref Option<string> order, ref Option<string> after, ref Option<string> before);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        /// <returns></returns>
        private void ValidateListAssistants(Option<string> order, Option<string> after, Option<string> before)
        {
            if (order.IsSet && order.Value == null)
                throw new ArgumentNullException(nameof(order));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));

            if (before.IsSet && before.Value == null)
                throw new ArgumentNullException(nameof(before));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        private void AfterListAssistantsDefaultImplementation(IListAssistantsApiResponse apiResponseLocalVar, Option<int> limit, Option<string> order, Option<string> after, Option<string> before)
        {
            bool suppressDefaultLog = false;
            AfterListAssistants(ref suppressDefaultLog, apiResponseLocalVar, limit, order, after, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        partial void AfterListAssistants(ref bool suppressDefaultLog, IListAssistantsApiResponse apiResponseLocalVar, Option<int> limit, Option<string> order, Option<string> after, Option<string> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        private void OnErrorListAssistantsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> limit, Option<string> order, Option<string> after, Option<string> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListAssistants(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, limit, order, after, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        partial void OnErrorListAssistants(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int> limit, Option<string> order, Option<string> after, Option<string> before);

        /// <summary>
        /// Returns a list of assistants. 
        /// </summary>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListAssistantsApiResponse"/>&gt;</returns>
        public async Task<IListAssistantsApiResponse?> ListAssistantsOrDefaultAsync(Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListAssistantsAsync(limit, order, after, before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Returns a list of assistants. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListAssistantsApiResponse"/>&gt;</returns>
        public async Task<IListAssistantsApiResponse> ListAssistantsAsync(Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListAssistants(order, after, before);

                FormatListAssistants(ref limit, ref order, ref after, ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/assistants"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/assistants");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (order.IsSet)
                        parseQueryStringLocalVar["order"] = ClientUtils.ParameterToString(order.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListAssistantsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListAssistantsApiResponse>();
                        ListAssistantsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/assistants", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListAssistantsDefaultImplementation(apiResponseLocalVar, limit, order, after, before);

                        Events.ExecuteOnListAssistants(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListAssistantsDefaultImplementation(e, "/assistants", uriBuilderLocalVar.Path, limit, order, after, before);
                Events.ExecuteOnErrorListAssistants(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListAssistantsApiResponse"/>
        /// </summary>
        public partial class ListAssistantsApiResponse : Org.OpenAPITools.Client.ApiResponse, IListAssistantsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListAssistantsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListAssistantsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListAssistantsApiResponse(ILogger<ListAssistantsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListAssistantsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListAssistantsApiResponse(ILogger<ListAssistantsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ListAssistantsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ListAssistantsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ListAssistantsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListMessageFiles(ref string threadId, ref string messageId, ref Option<int> limit, ref Option<string> order, ref Option<string> after, ref Option<string> before);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        /// <returns></returns>
        private void ValidateListMessageFiles(string threadId, string messageId, Option<string> order, Option<string> after, Option<string> before)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));

            if (messageId == null)
                throw new ArgumentNullException(nameof(messageId));

            if (order.IsSet && order.Value == null)
                throw new ArgumentNullException(nameof(order));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));

            if (before.IsSet && before.Value == null)
                throw new ArgumentNullException(nameof(before));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        private void AfterListMessageFilesDefaultImplementation(IListMessageFilesApiResponse apiResponseLocalVar, string threadId, string messageId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before)
        {
            bool suppressDefaultLog = false;
            AfterListMessageFiles(ref suppressDefaultLog, apiResponseLocalVar, threadId, messageId, limit, order, after, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        partial void AfterListMessageFiles(ref bool suppressDefaultLog, IListMessageFilesApiResponse apiResponseLocalVar, string threadId, string messageId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        private void OnErrorListMessageFilesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string messageId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListMessageFiles(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, messageId, limit, order, after, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        partial void OnErrorListMessageFiles(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string messageId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before);

        /// <summary>
        /// Returns a list of message files. 
        /// </summary>
        /// <param name="threadId">The ID of the thread that the message and files belong to.</param>
        /// <param name="messageId">The ID of the message that the files belongs to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListMessageFilesApiResponse"/>&gt;</returns>
        public async Task<IListMessageFilesApiResponse?> ListMessageFilesOrDefaultAsync(string threadId, string messageId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListMessageFilesAsync(threadId, messageId, limit, order, after, before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Returns a list of message files. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread that the message and files belong to.</param>
        /// <param name="messageId">The ID of the message that the files belongs to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListMessageFilesApiResponse"/>&gt;</returns>
        public async Task<IListMessageFilesApiResponse> ListMessageFilesAsync(string threadId, string messageId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListMessageFiles(threadId, messageId, order, after, before);

                FormatListMessageFiles(ref threadId, ref messageId, ref limit, ref order, ref after, ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}/messages/{message_id}/files"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}/messages/{message_id}/files");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bmessage_id%7D", Uri.EscapeDataString(messageId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (order.IsSet)
                        parseQueryStringLocalVar["order"] = ClientUtils.ParameterToString(order.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListMessageFilesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListMessageFilesApiResponse>();
                        ListMessageFilesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}/messages/{message_id}/files", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListMessageFilesDefaultImplementation(apiResponseLocalVar, threadId, messageId, limit, order, after, before);

                        Events.ExecuteOnListMessageFiles(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListMessageFilesDefaultImplementation(e, "/threads/{thread_id}/messages/{message_id}/files", uriBuilderLocalVar.Path, threadId, messageId, limit, order, after, before);
                Events.ExecuteOnErrorListMessageFiles(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListMessageFilesApiResponse"/>
        /// </summary>
        public partial class ListMessageFilesApiResponse : Org.OpenAPITools.Client.ApiResponse, IListMessageFilesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListMessageFilesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListMessageFilesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListMessageFilesApiResponse(ILogger<ListMessageFilesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListMessageFilesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListMessageFilesApiResponse(ILogger<ListMessageFilesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ListMessageFilesResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ListMessageFilesResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ListMessageFilesResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListMessages(ref string threadId, ref Option<int> limit, ref Option<string> order, ref Option<string> after, ref Option<string> before, ref Option<string> runId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        /// <param name="runId"></param>
        /// <returns></returns>
        private void ValidateListMessages(string threadId, Option<string> order, Option<string> after, Option<string> before, Option<string> runId)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));

            if (order.IsSet && order.Value == null)
                throw new ArgumentNullException(nameof(order));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));

            if (before.IsSet && before.Value == null)
                throw new ArgumentNullException(nameof(before));

            if (runId.IsSet && runId.Value == null)
                throw new ArgumentNullException(nameof(runId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        /// <param name="runId"></param>
        private void AfterListMessagesDefaultImplementation(IListMessagesApiResponse apiResponseLocalVar, string threadId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before, Option<string> runId)
        {
            bool suppressDefaultLog = false;
            AfterListMessages(ref suppressDefaultLog, apiResponseLocalVar, threadId, limit, order, after, before, runId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        /// <param name="runId"></param>
        partial void AfterListMessages(ref bool suppressDefaultLog, IListMessagesApiResponse apiResponseLocalVar, string threadId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before, Option<string> runId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        /// <param name="runId"></param>
        private void OnErrorListMessagesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before, Option<string> runId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListMessages(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, limit, order, after, before, runId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        /// <param name="runId"></param>
        partial void OnErrorListMessages(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before, Option<string> runId);

        /// <summary>
        /// Returns a list of messages for a given thread. 
        /// </summary>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) the messages belong to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="runId">Filter messages by the run ID that generated them.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListMessagesApiResponse"/>&gt;</returns>
        public async Task<IListMessagesApiResponse?> ListMessagesOrDefaultAsync(string threadId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, Option<string> runId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListMessagesAsync(threadId, limit, order, after, before, runId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Returns a list of messages for a given thread. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) the messages belong to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="runId">Filter messages by the run ID that generated them.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListMessagesApiResponse"/>&gt;</returns>
        public async Task<IListMessagesApiResponse> ListMessagesAsync(string threadId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, Option<string> runId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListMessages(threadId, order, after, before, runId);

                FormatListMessages(ref threadId, ref limit, ref order, ref after, ref before, ref runId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}/messages"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}/messages");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (order.IsSet)
                        parseQueryStringLocalVar["order"] = ClientUtils.ParameterToString(order.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    if (runId.IsSet)
                        parseQueryStringLocalVar["run_id"] = ClientUtils.ParameterToString(runId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListMessagesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListMessagesApiResponse>();
                        ListMessagesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}/messages", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListMessagesDefaultImplementation(apiResponseLocalVar, threadId, limit, order, after, before, runId);

                        Events.ExecuteOnListMessages(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListMessagesDefaultImplementation(e, "/threads/{thread_id}/messages", uriBuilderLocalVar.Path, threadId, limit, order, after, before, runId);
                Events.ExecuteOnErrorListMessages(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListMessagesApiResponse"/>
        /// </summary>
        public partial class ListMessagesApiResponse : Org.OpenAPITools.Client.ApiResponse, IListMessagesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListMessagesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListMessagesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListMessagesApiResponse(ILogger<ListMessagesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListMessagesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListMessagesApiResponse(ILogger<ListMessagesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ListMessagesResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ListMessagesResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ListMessagesResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListRunSteps(ref string threadId, ref string runId, ref Option<int> limit, ref Option<string> order, ref Option<string> after, ref Option<string> before);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        /// <returns></returns>
        private void ValidateListRunSteps(string threadId, string runId, Option<string> order, Option<string> after, Option<string> before)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));

            if (runId == null)
                throw new ArgumentNullException(nameof(runId));

            if (order.IsSet && order.Value == null)
                throw new ArgumentNullException(nameof(order));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));

            if (before.IsSet && before.Value == null)
                throw new ArgumentNullException(nameof(before));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        private void AfterListRunStepsDefaultImplementation(IListRunStepsApiResponse apiResponseLocalVar, string threadId, string runId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before)
        {
            bool suppressDefaultLog = false;
            AfterListRunSteps(ref suppressDefaultLog, apiResponseLocalVar, threadId, runId, limit, order, after, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        partial void AfterListRunSteps(ref bool suppressDefaultLog, IListRunStepsApiResponse apiResponseLocalVar, string threadId, string runId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        private void OnErrorListRunStepsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string runId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListRunSteps(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, runId, limit, order, after, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        partial void OnErrorListRunSteps(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string runId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before);

        /// <summary>
        /// Returns a list of run steps belonging to a run. 
        /// </summary>
        /// <param name="threadId">The ID of the thread the run and run steps belong to.</param>
        /// <param name="runId">The ID of the run the run steps belong to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListRunStepsApiResponse"/>&gt;</returns>
        public async Task<IListRunStepsApiResponse?> ListRunStepsOrDefaultAsync(string threadId, string runId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListRunStepsAsync(threadId, runId, limit, order, after, before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Returns a list of run steps belonging to a run. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread the run and run steps belong to.</param>
        /// <param name="runId">The ID of the run the run steps belong to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListRunStepsApiResponse"/>&gt;</returns>
        public async Task<IListRunStepsApiResponse> ListRunStepsAsync(string threadId, string runId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListRunSteps(threadId, runId, order, after, before);

                FormatListRunSteps(ref threadId, ref runId, ref limit, ref order, ref after, ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}/runs/{run_id}/steps"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}/runs/{run_id}/steps");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brun_id%7D", Uri.EscapeDataString(runId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (order.IsSet)
                        parseQueryStringLocalVar["order"] = ClientUtils.ParameterToString(order.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListRunStepsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListRunStepsApiResponse>();
                        ListRunStepsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}/runs/{run_id}/steps", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListRunStepsDefaultImplementation(apiResponseLocalVar, threadId, runId, limit, order, after, before);

                        Events.ExecuteOnListRunSteps(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListRunStepsDefaultImplementation(e, "/threads/{thread_id}/runs/{run_id}/steps", uriBuilderLocalVar.Path, threadId, runId, limit, order, after, before);
                Events.ExecuteOnErrorListRunSteps(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListRunStepsApiResponse"/>
        /// </summary>
        public partial class ListRunStepsApiResponse : Org.OpenAPITools.Client.ApiResponse, IListRunStepsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListRunStepsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListRunStepsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListRunStepsApiResponse(ILogger<ListRunStepsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListRunStepsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListRunStepsApiResponse(ILogger<ListRunStepsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ListRunStepsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ListRunStepsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ListRunStepsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListRuns(ref string threadId, ref Option<int> limit, ref Option<string> order, ref Option<string> after, ref Option<string> before);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        /// <returns></returns>
        private void ValidateListRuns(string threadId, Option<string> order, Option<string> after, Option<string> before)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));

            if (order.IsSet && order.Value == null)
                throw new ArgumentNullException(nameof(order));

            if (after.IsSet && after.Value == null)
                throw new ArgumentNullException(nameof(after));

            if (before.IsSet && before.Value == null)
                throw new ArgumentNullException(nameof(before));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        private void AfterListRunsDefaultImplementation(IListRunsApiResponse apiResponseLocalVar, string threadId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before)
        {
            bool suppressDefaultLog = false;
            AfterListRuns(ref suppressDefaultLog, apiResponseLocalVar, threadId, limit, order, after, before);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        partial void AfterListRuns(ref bool suppressDefaultLog, IListRunsApiResponse apiResponseLocalVar, string threadId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        private void OnErrorListRunsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListRuns(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, limit, order, after, before);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="limit"></param>
        /// <param name="order"></param>
        /// <param name="after"></param>
        /// <param name="before"></param>
        partial void OnErrorListRuns(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, Option<int> limit, Option<string> order, Option<string> after, Option<string> before);

        /// <summary>
        /// Returns a list of runs belonging to a thread. 
        /// </summary>
        /// <param name="threadId">The ID of the thread the run belongs to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListRunsApiResponse"/>&gt;</returns>
        public async Task<IListRunsApiResponse?> ListRunsOrDefaultAsync(string threadId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListRunsAsync(threadId, limit, order, after, before, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Returns a list of runs belonging to a thread. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread the run belongs to.</param>
        /// <param name="limit">A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)</param>
        /// <param name="order">Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)</param>
        /// <param name="after">A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)</param>
        /// <param name="before">A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListRunsApiResponse"/>&gt;</returns>
        public async Task<IListRunsApiResponse> ListRunsAsync(string threadId, Option<int> limit = default, Option<string> order = default, Option<string> after = default, Option<string> before = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListRuns(threadId, order, after, before);

                FormatListRuns(ref threadId, ref limit, ref order, ref after, ref before);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}/runs"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}/runs");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (order.IsSet)
                        parseQueryStringLocalVar["order"] = ClientUtils.ParameterToString(order.Value);

                    if (after.IsSet)
                        parseQueryStringLocalVar["after"] = ClientUtils.ParameterToString(after.Value);

                    if (before.IsSet)
                        parseQueryStringLocalVar["before"] = ClientUtils.ParameterToString(before.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListRunsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListRunsApiResponse>();
                        ListRunsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}/runs", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListRunsDefaultImplementation(apiResponseLocalVar, threadId, limit, order, after, before);

                        Events.ExecuteOnListRuns(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListRunsDefaultImplementation(e, "/threads/{thread_id}/runs", uriBuilderLocalVar.Path, threadId, limit, order, after, before);
                Events.ExecuteOnErrorListRuns(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListRunsApiResponse"/>
        /// </summary>
        public partial class ListRunsApiResponse : Org.OpenAPITools.Client.ApiResponse, IListRunsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListRunsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListRunsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListRunsApiResponse(ILogger<ListRunsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListRunsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListRunsApiResponse(ILogger<ListRunsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ListRunsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ListRunsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ListRunsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatModifyAssistant(ref string assistantId, ModifyAssistantRequest modifyAssistantRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="assistantId"></param>
        /// <param name="modifyAssistantRequest"></param>
        /// <returns></returns>
        private void ValidateModifyAssistant(string assistantId, ModifyAssistantRequest modifyAssistantRequest)
        {
            if (assistantId == null)
                throw new ArgumentNullException(nameof(assistantId));

            if (modifyAssistantRequest == null)
                throw new ArgumentNullException(nameof(modifyAssistantRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="modifyAssistantRequest"></param>
        private void AfterModifyAssistantDefaultImplementation(IModifyAssistantApiResponse apiResponseLocalVar, string assistantId, ModifyAssistantRequest modifyAssistantRequest)
        {
            bool suppressDefaultLog = false;
            AfterModifyAssistant(ref suppressDefaultLog, apiResponseLocalVar, assistantId, modifyAssistantRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="modifyAssistantRequest"></param>
        partial void AfterModifyAssistant(ref bool suppressDefaultLog, IModifyAssistantApiResponse apiResponseLocalVar, string assistantId, ModifyAssistantRequest modifyAssistantRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="modifyAssistantRequest"></param>
        private void OnErrorModifyAssistantDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assistantId, ModifyAssistantRequest modifyAssistantRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorModifyAssistant(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, assistantId, modifyAssistantRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="assistantId"></param>
        /// <param name="modifyAssistantRequest"></param>
        partial void OnErrorModifyAssistant(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string assistantId, ModifyAssistantRequest modifyAssistantRequest);

        /// <summary>
        /// Modifies an assistant. 
        /// </summary>
        /// <param name="assistantId">The ID of the assistant to modify.</param>
        /// <param name="modifyAssistantRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyAssistantApiResponse"/>&gt;</returns>
        public async Task<IModifyAssistantApiResponse?> ModifyAssistantOrDefaultAsync(string assistantId, ModifyAssistantRequest modifyAssistantRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ModifyAssistantAsync(assistantId, modifyAssistantRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Modifies an assistant. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="assistantId">The ID of the assistant to modify.</param>
        /// <param name="modifyAssistantRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyAssistantApiResponse"/>&gt;</returns>
        public async Task<IModifyAssistantApiResponse> ModifyAssistantAsync(string assistantId, ModifyAssistantRequest modifyAssistantRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateModifyAssistant(assistantId, modifyAssistantRequest);

                FormatModifyAssistant(ref assistantId, modifyAssistantRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/assistants/{assistant_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/assistants/{assistant_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bassistant_id%7D", Uri.EscapeDataString(assistantId.ToString()));

                    httpRequestMessageLocalVar.Content = (modifyAssistantRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(modifyAssistantRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ModifyAssistantApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ModifyAssistantApiResponse>();
                        ModifyAssistantApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/assistants/{assistant_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterModifyAssistantDefaultImplementation(apiResponseLocalVar, assistantId, modifyAssistantRequest);

                        Events.ExecuteOnModifyAssistant(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorModifyAssistantDefaultImplementation(e, "/assistants/{assistant_id}", uriBuilderLocalVar.Path, assistantId, modifyAssistantRequest);
                Events.ExecuteOnErrorModifyAssistant(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ModifyAssistantApiResponse"/>
        /// </summary>
        public partial class ModifyAssistantApiResponse : Org.OpenAPITools.Client.ApiResponse, IModifyAssistantApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ModifyAssistantApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ModifyAssistantApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ModifyAssistantApiResponse(ILogger<ModifyAssistantApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ModifyAssistantApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ModifyAssistantApiResponse(ILogger<ModifyAssistantApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.AssistantObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.AssistantObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.AssistantObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatModifyMessage(ref string threadId, ref string messageId, ModifyMessageRequest modifyMessageRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <param name="modifyMessageRequest"></param>
        /// <returns></returns>
        private void ValidateModifyMessage(string threadId, string messageId, ModifyMessageRequest modifyMessageRequest)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));

            if (messageId == null)
                throw new ArgumentNullException(nameof(messageId));

            if (modifyMessageRequest == null)
                throw new ArgumentNullException(nameof(modifyMessageRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <param name="modifyMessageRequest"></param>
        private void AfterModifyMessageDefaultImplementation(IModifyMessageApiResponse apiResponseLocalVar, string threadId, string messageId, ModifyMessageRequest modifyMessageRequest)
        {
            bool suppressDefaultLog = false;
            AfterModifyMessage(ref suppressDefaultLog, apiResponseLocalVar, threadId, messageId, modifyMessageRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <param name="modifyMessageRequest"></param>
        partial void AfterModifyMessage(ref bool suppressDefaultLog, IModifyMessageApiResponse apiResponseLocalVar, string threadId, string messageId, ModifyMessageRequest modifyMessageRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <param name="modifyMessageRequest"></param>
        private void OnErrorModifyMessageDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string messageId, ModifyMessageRequest modifyMessageRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorModifyMessage(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, messageId, modifyMessageRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="messageId"></param>
        /// <param name="modifyMessageRequest"></param>
        partial void OnErrorModifyMessage(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string messageId, ModifyMessageRequest modifyMessageRequest);

        /// <summary>
        /// Modifies a message. 
        /// </summary>
        /// <param name="threadId">The ID of the thread to which this message belongs.</param>
        /// <param name="messageId">The ID of the message to modify.</param>
        /// <param name="modifyMessageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyMessageApiResponse"/>&gt;</returns>
        public async Task<IModifyMessageApiResponse?> ModifyMessageOrDefaultAsync(string threadId, string messageId, ModifyMessageRequest modifyMessageRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ModifyMessageAsync(threadId, messageId, modifyMessageRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Modifies a message. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to which this message belongs.</param>
        /// <param name="messageId">The ID of the message to modify.</param>
        /// <param name="modifyMessageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyMessageApiResponse"/>&gt;</returns>
        public async Task<IModifyMessageApiResponse> ModifyMessageAsync(string threadId, string messageId, ModifyMessageRequest modifyMessageRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateModifyMessage(threadId, messageId, modifyMessageRequest);

                FormatModifyMessage(ref threadId, ref messageId, modifyMessageRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}/messages/{message_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}/messages/{message_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bmessage_id%7D", Uri.EscapeDataString(messageId.ToString()));

                    httpRequestMessageLocalVar.Content = (modifyMessageRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(modifyMessageRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ModifyMessageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ModifyMessageApiResponse>();
                        ModifyMessageApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}/messages/{message_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterModifyMessageDefaultImplementation(apiResponseLocalVar, threadId, messageId, modifyMessageRequest);

                        Events.ExecuteOnModifyMessage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorModifyMessageDefaultImplementation(e, "/threads/{thread_id}/messages/{message_id}", uriBuilderLocalVar.Path, threadId, messageId, modifyMessageRequest);
                Events.ExecuteOnErrorModifyMessage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ModifyMessageApiResponse"/>
        /// </summary>
        public partial class ModifyMessageApiResponse : Org.OpenAPITools.Client.ApiResponse, IModifyMessageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ModifyMessageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ModifyMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ModifyMessageApiResponse(ILogger<ModifyMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ModifyMessageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ModifyMessageApiResponse(ILogger<ModifyMessageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.MessageObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.MessageObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.MessageObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatModifyRun(ref string threadId, ref string runId, ModifyRunRequest modifyRunRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="modifyRunRequest"></param>
        /// <returns></returns>
        private void ValidateModifyRun(string threadId, string runId, ModifyRunRequest modifyRunRequest)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));

            if (runId == null)
                throw new ArgumentNullException(nameof(runId));

            if (modifyRunRequest == null)
                throw new ArgumentNullException(nameof(modifyRunRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="modifyRunRequest"></param>
        private void AfterModifyRunDefaultImplementation(IModifyRunApiResponse apiResponseLocalVar, string threadId, string runId, ModifyRunRequest modifyRunRequest)
        {
            bool suppressDefaultLog = false;
            AfterModifyRun(ref suppressDefaultLog, apiResponseLocalVar, threadId, runId, modifyRunRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="modifyRunRequest"></param>
        partial void AfterModifyRun(ref bool suppressDefaultLog, IModifyRunApiResponse apiResponseLocalVar, string threadId, string runId, ModifyRunRequest modifyRunRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="modifyRunRequest"></param>
        private void OnErrorModifyRunDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string runId, ModifyRunRequest modifyRunRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorModifyRun(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, runId, modifyRunRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="modifyRunRequest"></param>
        partial void OnErrorModifyRun(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string runId, ModifyRunRequest modifyRunRequest);

        /// <summary>
        /// Modifies a run. 
        /// </summary>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) that was run.</param>
        /// <param name="runId">The ID of the run to modify.</param>
        /// <param name="modifyRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyRunApiResponse"/>&gt;</returns>
        public async Task<IModifyRunApiResponse?> ModifyRunOrDefaultAsync(string threadId, string runId, ModifyRunRequest modifyRunRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ModifyRunAsync(threadId, runId, modifyRunRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Modifies a run. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) that was run.</param>
        /// <param name="runId">The ID of the run to modify.</param>
        /// <param name="modifyRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyRunApiResponse"/>&gt;</returns>
        public async Task<IModifyRunApiResponse> ModifyRunAsync(string threadId, string runId, ModifyRunRequest modifyRunRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateModifyRun(threadId, runId, modifyRunRequest);

                FormatModifyRun(ref threadId, ref runId, modifyRunRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}/runs/{run_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}/runs/{run_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brun_id%7D", Uri.EscapeDataString(runId.ToString()));

                    httpRequestMessageLocalVar.Content = (modifyRunRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(modifyRunRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ModifyRunApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ModifyRunApiResponse>();
                        ModifyRunApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}/runs/{run_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterModifyRunDefaultImplementation(apiResponseLocalVar, threadId, runId, modifyRunRequest);

                        Events.ExecuteOnModifyRun(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorModifyRunDefaultImplementation(e, "/threads/{thread_id}/runs/{run_id}", uriBuilderLocalVar.Path, threadId, runId, modifyRunRequest);
                Events.ExecuteOnErrorModifyRun(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ModifyRunApiResponse"/>
        /// </summary>
        public partial class ModifyRunApiResponse : Org.OpenAPITools.Client.ApiResponse, IModifyRunApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ModifyRunApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ModifyRunApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ModifyRunApiResponse(ILogger<ModifyRunApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ModifyRunApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ModifyRunApiResponse(ILogger<ModifyRunApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.RunObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.RunObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.RunObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatModifyThread(ref string threadId, ModifyThreadRequest modifyThreadRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="modifyThreadRequest"></param>
        /// <returns></returns>
        private void ValidateModifyThread(string threadId, ModifyThreadRequest modifyThreadRequest)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));

            if (modifyThreadRequest == null)
                throw new ArgumentNullException(nameof(modifyThreadRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="modifyThreadRequest"></param>
        private void AfterModifyThreadDefaultImplementation(IModifyThreadApiResponse apiResponseLocalVar, string threadId, ModifyThreadRequest modifyThreadRequest)
        {
            bool suppressDefaultLog = false;
            AfterModifyThread(ref suppressDefaultLog, apiResponseLocalVar, threadId, modifyThreadRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="modifyThreadRequest"></param>
        partial void AfterModifyThread(ref bool suppressDefaultLog, IModifyThreadApiResponse apiResponseLocalVar, string threadId, ModifyThreadRequest modifyThreadRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="modifyThreadRequest"></param>
        private void OnErrorModifyThreadDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, ModifyThreadRequest modifyThreadRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorModifyThread(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, modifyThreadRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="modifyThreadRequest"></param>
        partial void OnErrorModifyThread(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, ModifyThreadRequest modifyThreadRequest);

        /// <summary>
        /// Modifies a thread. 
        /// </summary>
        /// <param name="threadId">The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified.</param>
        /// <param name="modifyThreadRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyThreadApiResponse"/>&gt;</returns>
        public async Task<IModifyThreadApiResponse?> ModifyThreadOrDefaultAsync(string threadId, ModifyThreadRequest modifyThreadRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ModifyThreadAsync(threadId, modifyThreadRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Modifies a thread. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified.</param>
        /// <param name="modifyThreadRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IModifyThreadApiResponse"/>&gt;</returns>
        public async Task<IModifyThreadApiResponse> ModifyThreadAsync(string threadId, ModifyThreadRequest modifyThreadRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateModifyThread(threadId, modifyThreadRequest);

                FormatModifyThread(ref threadId, modifyThreadRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));

                    httpRequestMessageLocalVar.Content = (modifyThreadRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(modifyThreadRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ModifyThreadApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ModifyThreadApiResponse>();
                        ModifyThreadApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterModifyThreadDefaultImplementation(apiResponseLocalVar, threadId, modifyThreadRequest);

                        Events.ExecuteOnModifyThread(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorModifyThreadDefaultImplementation(e, "/threads/{thread_id}", uriBuilderLocalVar.Path, threadId, modifyThreadRequest);
                Events.ExecuteOnErrorModifyThread(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ModifyThreadApiResponse"/>
        /// </summary>
        public partial class ModifyThreadApiResponse : Org.OpenAPITools.Client.ApiResponse, IModifyThreadApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ModifyThreadApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ModifyThreadApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ModifyThreadApiResponse(ILogger<ModifyThreadApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ModifyThreadApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ModifyThreadApiResponse(ILogger<ModifyThreadApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.ThreadObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.ThreadObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.ThreadObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSubmitToolOuputsToRun(ref string threadId, ref string runId, SubmitToolOutputsRunRequest submitToolOutputsRunRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="submitToolOutputsRunRequest"></param>
        /// <returns></returns>
        private void ValidateSubmitToolOuputsToRun(string threadId, string runId, SubmitToolOutputsRunRequest submitToolOutputsRunRequest)
        {
            if (threadId == null)
                throw new ArgumentNullException(nameof(threadId));

            if (runId == null)
                throw new ArgumentNullException(nameof(runId));

            if (submitToolOutputsRunRequest == null)
                throw new ArgumentNullException(nameof(submitToolOutputsRunRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="submitToolOutputsRunRequest"></param>
        private void AfterSubmitToolOuputsToRunDefaultImplementation(ISubmitToolOuputsToRunApiResponse apiResponseLocalVar, string threadId, string runId, SubmitToolOutputsRunRequest submitToolOutputsRunRequest)
        {
            bool suppressDefaultLog = false;
            AfterSubmitToolOuputsToRun(ref suppressDefaultLog, apiResponseLocalVar, threadId, runId, submitToolOutputsRunRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="submitToolOutputsRunRequest"></param>
        partial void AfterSubmitToolOuputsToRun(ref bool suppressDefaultLog, ISubmitToolOuputsToRunApiResponse apiResponseLocalVar, string threadId, string runId, SubmitToolOutputsRunRequest submitToolOutputsRunRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="submitToolOutputsRunRequest"></param>
        private void OnErrorSubmitToolOuputsToRunDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string runId, SubmitToolOutputsRunRequest submitToolOutputsRunRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSubmitToolOuputsToRun(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, threadId, runId, submitToolOutputsRunRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="threadId"></param>
        /// <param name="runId"></param>
        /// <param name="submitToolOutputsRunRequest"></param>
        partial void OnErrorSubmitToolOuputsToRun(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string threadId, string runId, SubmitToolOutputsRunRequest submitToolOutputsRunRequest);

        /// <summary>
        /// When a run has the &#x60;status: \&quot;requires_action\&quot;&#x60; and &#x60;required_action.type&#x60; is &#x60;submit_tool_outputs&#x60;, this endpoint can be used to submit the outputs from the tool calls once they&#39;re all completed. All outputs must be submitted in a single request.  
        /// </summary>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) to which this run belongs.</param>
        /// <param name="runId">The ID of the run that requires the tool output submission.</param>
        /// <param name="submitToolOutputsRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubmitToolOuputsToRunApiResponse"/>&gt;</returns>
        public async Task<ISubmitToolOuputsToRunApiResponse?> SubmitToolOuputsToRunOrDefaultAsync(string threadId, string runId, SubmitToolOutputsRunRequest submitToolOutputsRunRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SubmitToolOuputsToRunAsync(threadId, runId, submitToolOutputsRunRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// When a run has the &#x60;status: \&quot;requires_action\&quot;&#x60; and &#x60;required_action.type&#x60; is &#x60;submit_tool_outputs&#x60;, this endpoint can be used to submit the outputs from the tool calls once they&#39;re all completed. All outputs must be submitted in a single request.  
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="threadId">The ID of the [thread](/docs/api-reference/threads) to which this run belongs.</param>
        /// <param name="runId">The ID of the run that requires the tool output submission.</param>
        /// <param name="submitToolOutputsRunRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISubmitToolOuputsToRunApiResponse"/>&gt;</returns>
        public async Task<ISubmitToolOuputsToRunApiResponse> SubmitToolOuputsToRunAsync(string threadId, string runId, SubmitToolOutputsRunRequest submitToolOutputsRunRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSubmitToolOuputsToRun(threadId, runId, submitToolOutputsRunRequest);

                FormatSubmitToolOuputsToRun(ref threadId, ref runId, submitToolOutputsRunRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/threads/{thread_id}/runs/{run_id}/submit_tool_outputs"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/threads/{thread_id}/runs/{run_id}/submit_tool_outputs");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bthread_id%7D", Uri.EscapeDataString(threadId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Brun_id%7D", Uri.EscapeDataString(runId.ToString()));

                    httpRequestMessageLocalVar.Content = (submitToolOutputsRunRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(submitToolOutputsRunRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SubmitToolOuputsToRunApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SubmitToolOuputsToRunApiResponse>();
                        SubmitToolOuputsToRunApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/threads/{thread_id}/runs/{run_id}/submit_tool_outputs", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSubmitToolOuputsToRunDefaultImplementation(apiResponseLocalVar, threadId, runId, submitToolOutputsRunRequest);

                        Events.ExecuteOnSubmitToolOuputsToRun(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSubmitToolOuputsToRunDefaultImplementation(e, "/threads/{thread_id}/runs/{run_id}/submit_tool_outputs", uriBuilderLocalVar.Path, threadId, runId, submitToolOutputsRunRequest);
                Events.ExecuteOnErrorSubmitToolOuputsToRun(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SubmitToolOuputsToRunApiResponse"/>
        /// </summary>
        public partial class SubmitToolOuputsToRunApiResponse : Org.OpenAPITools.Client.ApiResponse, ISubmitToolOuputsToRunApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SubmitToolOuputsToRunApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SubmitToolOuputsToRunApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SubmitToolOuputsToRunApiResponse(ILogger<SubmitToolOuputsToRunApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SubmitToolOuputsToRunApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SubmitToolOuputsToRunApiResponse(ILogger<SubmitToolOuputsToRunApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.RunObject? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.RunObject>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.RunObject? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
