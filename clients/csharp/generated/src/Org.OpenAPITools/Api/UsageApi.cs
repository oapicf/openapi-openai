// <auto-generated>
/*
 * OpenAI API
 *
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;
using System.Diagnostics.CodeAnalysis;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IUsageApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        UsageApiEvents Events { get; }

        /// <summary>
        /// Get audio speeches usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageAudioSpeechesApiResponse"/>&gt;</returns>
        Task<IUsageAudioSpeechesApiResponse> UsageAudioSpeechesAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get audio speeches usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageAudioSpeechesApiResponse"/>?&gt;</returns>
        Task<IUsageAudioSpeechesApiResponse?> UsageAudioSpeechesOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get audio transcriptions usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageAudioTranscriptionsApiResponse"/>&gt;</returns>
        Task<IUsageAudioTranscriptionsApiResponse> UsageAudioTranscriptionsAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get audio transcriptions usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageAudioTranscriptionsApiResponse"/>?&gt;</returns>
        Task<IUsageAudioTranscriptionsApiResponse?> UsageAudioTranscriptionsOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get code interpreter sessions usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageCodeInterpreterSessionsApiResponse"/>&gt;</returns>
        Task<IUsageCodeInterpreterSessionsApiResponse> UsageCodeInterpreterSessionsAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get code interpreter sessions usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageCodeInterpreterSessionsApiResponse"/>?&gt;</returns>
        Task<IUsageCodeInterpreterSessionsApiResponse?> UsageCodeInterpreterSessionsOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get completions usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="batch">If &#x60;true&#x60;, return batch jobs only. If &#x60;false&#x60;, return non-batch jobs only. By default, return both.  (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;batch&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageCompletionsApiResponse"/>&gt;</returns>
        Task<IUsageCompletionsApiResponse> UsageCompletionsAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<bool> batch = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get completions usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="batch">If &#x60;true&#x60;, return batch jobs only. If &#x60;false&#x60;, return non-batch jobs only. By default, return both.  (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;batch&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageCompletionsApiResponse"/>?&gt;</returns>
        Task<IUsageCompletionsApiResponse?> UsageCompletionsOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<bool> batch = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get costs details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently only &#x60;1d&#x60; is supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only costs for these projects. (optional)</param>
        /// <param name="groupBy">Group the costs by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;line_item&#x60; and any combination of them. (optional)</param>
        /// <param name="limit">A limit on the number of buckets to be returned. Limit can range between 1 and 180, and the default is 7.  (optional, default to 7)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageCostsApiResponse"/>&gt;</returns>
        Task<IUsageCostsApiResponse> UsageCostsAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get costs details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently only &#x60;1d&#x60; is supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only costs for these projects. (optional)</param>
        /// <param name="groupBy">Group the costs by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;line_item&#x60; and any combination of them. (optional)</param>
        /// <param name="limit">A limit on the number of buckets to be returned. Limit can range between 1 and 180, and the default is 7.  (optional, default to 7)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageCostsApiResponse"/>?&gt;</returns>
        Task<IUsageCostsApiResponse?> UsageCostsOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get embeddings usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageEmbeddingsApiResponse"/>&gt;</returns>
        Task<IUsageEmbeddingsApiResponse> UsageEmbeddingsAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get embeddings usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageEmbeddingsApiResponse"/>?&gt;</returns>
        Task<IUsageEmbeddingsApiResponse?> UsageEmbeddingsOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get images usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="sources">Return only usages for these sources. Possible values are &#x60;image.generation&#x60;, &#x60;image.edit&#x60;, &#x60;image.variation&#x60; or any combination of them. (optional)</param>
        /// <param name="sizes">Return only usages for these image sizes. Possible values are &#x60;256x256&#x60;, &#x60;512x512&#x60;, &#x60;1024x1024&#x60;, &#x60;1792x1792&#x60;, &#x60;1024x1792&#x60; or any combination of them. (optional)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;size&#x60;, &#x60;source&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageImagesApiResponse"/>&gt;</returns>
        Task<IUsageImagesApiResponse> UsageImagesAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> sources = default, Option<List<string>> sizes = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get images usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="sources">Return only usages for these sources. Possible values are &#x60;image.generation&#x60;, &#x60;image.edit&#x60;, &#x60;image.variation&#x60; or any combination of them. (optional)</param>
        /// <param name="sizes">Return only usages for these image sizes. Possible values are &#x60;256x256&#x60;, &#x60;512x512&#x60;, &#x60;1024x1024&#x60;, &#x60;1792x1792&#x60;, &#x60;1024x1792&#x60; or any combination of them. (optional)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;size&#x60;, &#x60;source&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageImagesApiResponse"/>?&gt;</returns>
        Task<IUsageImagesApiResponse?> UsageImagesOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> sources = default, Option<List<string>> sizes = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get moderations usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageModerationsApiResponse"/>&gt;</returns>
        Task<IUsageModerationsApiResponse> UsageModerationsAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get moderations usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageModerationsApiResponse"/>?&gt;</returns>
        Task<IUsageModerationsApiResponse?> UsageModerationsOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get vector stores usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageVectorStoresApiResponse"/>&gt;</returns>
        Task<IUsageVectorStoresApiResponse> UsageVectorStoresAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get vector stores usage details for the organization.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageVectorStoresApiResponse"/>?&gt;</returns>
        Task<IUsageVectorStoresApiResponse?> UsageVectorStoresOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IUsageAudioSpeechesApiResponse"/>
    /// </summary>
    public interface IUsageAudioSpeechesApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.UsageResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUsageAudioTranscriptionsApiResponse"/>
    /// </summary>
    public interface IUsageAudioTranscriptionsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.UsageResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUsageCodeInterpreterSessionsApiResponse"/>
    /// </summary>
    public interface IUsageCodeInterpreterSessionsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.UsageResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUsageCompletionsApiResponse"/>
    /// </summary>
    public interface IUsageCompletionsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.UsageResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUsageCostsApiResponse"/>
    /// </summary>
    public interface IUsageCostsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.UsageResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUsageEmbeddingsApiResponse"/>
    /// </summary>
    public interface IUsageEmbeddingsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.UsageResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUsageImagesApiResponse"/>
    /// </summary>
    public interface IUsageImagesApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.UsageResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUsageModerationsApiResponse"/>
    /// </summary>
    public interface IUsageModerationsApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.UsageResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUsageVectorStoresApiResponse"/>
    /// </summary>
    public interface IUsageVectorStoresApiResponse : Org.OpenAPITools.Client.IApiResponse, IOk<Org.OpenAPITools.Model.UsageResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class UsageApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUsageAudioSpeeches;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUsageAudioSpeeches;

        internal void ExecuteOnUsageAudioSpeeches(UsageApi.UsageAudioSpeechesApiResponse apiResponse)
        {
            OnUsageAudioSpeeches?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUsageAudioSpeeches(Exception exception)
        {
            OnErrorUsageAudioSpeeches?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUsageAudioTranscriptions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUsageAudioTranscriptions;

        internal void ExecuteOnUsageAudioTranscriptions(UsageApi.UsageAudioTranscriptionsApiResponse apiResponse)
        {
            OnUsageAudioTranscriptions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUsageAudioTranscriptions(Exception exception)
        {
            OnErrorUsageAudioTranscriptions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUsageCodeInterpreterSessions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUsageCodeInterpreterSessions;

        internal void ExecuteOnUsageCodeInterpreterSessions(UsageApi.UsageCodeInterpreterSessionsApiResponse apiResponse)
        {
            OnUsageCodeInterpreterSessions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUsageCodeInterpreterSessions(Exception exception)
        {
            OnErrorUsageCodeInterpreterSessions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUsageCompletions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUsageCompletions;

        internal void ExecuteOnUsageCompletions(UsageApi.UsageCompletionsApiResponse apiResponse)
        {
            OnUsageCompletions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUsageCompletions(Exception exception)
        {
            OnErrorUsageCompletions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUsageCosts;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUsageCosts;

        internal void ExecuteOnUsageCosts(UsageApi.UsageCostsApiResponse apiResponse)
        {
            OnUsageCosts?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUsageCosts(Exception exception)
        {
            OnErrorUsageCosts?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUsageEmbeddings;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUsageEmbeddings;

        internal void ExecuteOnUsageEmbeddings(UsageApi.UsageEmbeddingsApiResponse apiResponse)
        {
            OnUsageEmbeddings?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUsageEmbeddings(Exception exception)
        {
            OnErrorUsageEmbeddings?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUsageImages;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUsageImages;

        internal void ExecuteOnUsageImages(UsageApi.UsageImagesApiResponse apiResponse)
        {
            OnUsageImages?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUsageImages(Exception exception)
        {
            OnErrorUsageImages?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUsageModerations;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUsageModerations;

        internal void ExecuteOnUsageModerations(UsageApi.UsageModerationsApiResponse apiResponse)
        {
            OnUsageModerations?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUsageModerations(Exception exception)
        {
            OnErrorUsageModerations?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUsageVectorStores;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUsageVectorStores;

        internal void ExecuteOnUsageVectorStores(UsageApi.UsageVectorStoresApiResponse apiResponse)
        {
            OnUsageVectorStores?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUsageVectorStores(Exception exception)
        {
            OnErrorUsageVectorStores?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class UsageApi : IUsageApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<UsageApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public UsageApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="UsageApi"/> class.
        /// </summary>
        /// <returns></returns>
        public UsageApi(ILogger<UsageApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, UsageApiEvents usageApiEvents,
            TokenProvider<BearerToken> bearerTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<UsageApi>();
            HttpClient = httpClient;
            Events = usageApiEvents;
            BearerTokenProvider = bearerTokenProvider;
        }

        partial void FormatUsageAudioSpeeches(ref int startTime, ref Option<int> endTime, ref Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, ref Option<int> limit, ref Option<string> page);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="page"></param>
        /// <returns></returns>
        private void ValidateUsageAudioSpeeches(Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<string> page)
        {
            if (bucketWidth.IsSet && bucketWidth.Value == null)
                throw new ArgumentNullException(nameof(bucketWidth));

            if (projectIds.IsSet && projectIds.Value == null)
                throw new ArgumentNullException(nameof(projectIds));

            if (userIds.IsSet && userIds.Value == null)
                throw new ArgumentNullException(nameof(userIds));

            if (apiKeyIds.IsSet && apiKeyIds.Value == null)
                throw new ArgumentNullException(nameof(apiKeyIds));

            if (models.IsSet && models.Value == null)
                throw new ArgumentNullException(nameof(models));

            if (groupBy.IsSet && groupBy.Value == null)
                throw new ArgumentNullException(nameof(groupBy));

            if (page.IsSet && page.Value == null)
                throw new ArgumentNullException(nameof(page));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void AfterUsageAudioSpeechesDefaultImplementation(IUsageAudioSpeechesApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLog = false;
            AfterUsageAudioSpeeches(ref suppressDefaultLog, apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void AfterUsageAudioSpeeches(ref bool suppressDefaultLog, IUsageAudioSpeechesApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void OnErrorUsageAudioSpeechesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUsageAudioSpeeches(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void OnErrorUsageAudioSpeeches(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Get audio speeches usage details for the organization. 
        /// </summary>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageAudioSpeechesApiResponse"/>&gt;</returns>
        public async Task<IUsageAudioSpeechesApiResponse?> UsageAudioSpeechesOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UsageAudioSpeechesAsync(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get audio speeches usage details for the organization. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageAudioSpeechesApiResponse"/>&gt;</returns>
        public async Task<IUsageAudioSpeechesApiResponse> UsageAudioSpeechesAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUsageAudioSpeeches(bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, page);

                FormatUsageAudioSpeeches(ref startTime, ref endTime, ref bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, ref limit, ref page);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/organization/usage/audio_speeches"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/organization/usage/audio_speeches");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start_time"] = ClientUtils.ParameterToString(startTime);

                    if (endTime.IsSet)
                        parseQueryStringLocalVar["end_time"] = ClientUtils.ParameterToString(endTime.Value);

                    if (bucketWidth.IsSet)
                        parseQueryStringLocalVar["bucket_width"] = ClientUtils.ParameterToString(bucketWidth.Value);

                    if (projectIds.IsSet)
                        parseQueryStringLocalVar["project_ids"] = ClientUtils.ParameterToString(projectIds.Value);

                    if (userIds.IsSet)
                        parseQueryStringLocalVar["user_ids"] = ClientUtils.ParameterToString(userIds.Value);

                    if (apiKeyIds.IsSet)
                        parseQueryStringLocalVar["api_key_ids"] = ClientUtils.ParameterToString(apiKeyIds.Value);

                    if (models.IsSet)
                        parseQueryStringLocalVar["models"] = ClientUtils.ParameterToString(models.Value);

                    if (groupBy.IsSet)
                        parseQueryStringLocalVar["group_by"] = ClientUtils.ParameterToString(groupBy.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UsageAudioSpeechesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UsageAudioSpeechesApiResponse>();
                        UsageAudioSpeechesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/organization/usage/audio_speeches", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUsageAudioSpeechesDefaultImplementation(apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);

                        Events.ExecuteOnUsageAudioSpeeches(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUsageAudioSpeechesDefaultImplementation(e, "/organization/usage/audio_speeches", uriBuilderLocalVar.Path, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);
                Events.ExecuteOnErrorUsageAudioSpeeches(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UsageAudioSpeechesApiResponse"/>
        /// </summary>
        public partial class UsageAudioSpeechesApiResponse : Org.OpenAPITools.Client.ApiResponse, IUsageAudioSpeechesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UsageAudioSpeechesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UsageAudioSpeechesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageAudioSpeechesApiResponse(ILogger<UsageAudioSpeechesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UsageAudioSpeechesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageAudioSpeechesApiResponse(ILogger<UsageAudioSpeechesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.UsageResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.UsageResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.UsageResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUsageAudioTranscriptions(ref int startTime, ref Option<int> endTime, ref Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, ref Option<int> limit, ref Option<string> page);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="page"></param>
        /// <returns></returns>
        private void ValidateUsageAudioTranscriptions(Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<string> page)
        {
            if (bucketWidth.IsSet && bucketWidth.Value == null)
                throw new ArgumentNullException(nameof(bucketWidth));

            if (projectIds.IsSet && projectIds.Value == null)
                throw new ArgumentNullException(nameof(projectIds));

            if (userIds.IsSet && userIds.Value == null)
                throw new ArgumentNullException(nameof(userIds));

            if (apiKeyIds.IsSet && apiKeyIds.Value == null)
                throw new ArgumentNullException(nameof(apiKeyIds));

            if (models.IsSet && models.Value == null)
                throw new ArgumentNullException(nameof(models));

            if (groupBy.IsSet && groupBy.Value == null)
                throw new ArgumentNullException(nameof(groupBy));

            if (page.IsSet && page.Value == null)
                throw new ArgumentNullException(nameof(page));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void AfterUsageAudioTranscriptionsDefaultImplementation(IUsageAudioTranscriptionsApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLog = false;
            AfterUsageAudioTranscriptions(ref suppressDefaultLog, apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void AfterUsageAudioTranscriptions(ref bool suppressDefaultLog, IUsageAudioTranscriptionsApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void OnErrorUsageAudioTranscriptionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUsageAudioTranscriptions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void OnErrorUsageAudioTranscriptions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Get audio transcriptions usage details for the organization. 
        /// </summary>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageAudioTranscriptionsApiResponse"/>&gt;</returns>
        public async Task<IUsageAudioTranscriptionsApiResponse?> UsageAudioTranscriptionsOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UsageAudioTranscriptionsAsync(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get audio transcriptions usage details for the organization. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageAudioTranscriptionsApiResponse"/>&gt;</returns>
        public async Task<IUsageAudioTranscriptionsApiResponse> UsageAudioTranscriptionsAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUsageAudioTranscriptions(bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, page);

                FormatUsageAudioTranscriptions(ref startTime, ref endTime, ref bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, ref limit, ref page);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/organization/usage/audio_transcriptions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/organization/usage/audio_transcriptions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start_time"] = ClientUtils.ParameterToString(startTime);

                    if (endTime.IsSet)
                        parseQueryStringLocalVar["end_time"] = ClientUtils.ParameterToString(endTime.Value);

                    if (bucketWidth.IsSet)
                        parseQueryStringLocalVar["bucket_width"] = ClientUtils.ParameterToString(bucketWidth.Value);

                    if (projectIds.IsSet)
                        parseQueryStringLocalVar["project_ids"] = ClientUtils.ParameterToString(projectIds.Value);

                    if (userIds.IsSet)
                        parseQueryStringLocalVar["user_ids"] = ClientUtils.ParameterToString(userIds.Value);

                    if (apiKeyIds.IsSet)
                        parseQueryStringLocalVar["api_key_ids"] = ClientUtils.ParameterToString(apiKeyIds.Value);

                    if (models.IsSet)
                        parseQueryStringLocalVar["models"] = ClientUtils.ParameterToString(models.Value);

                    if (groupBy.IsSet)
                        parseQueryStringLocalVar["group_by"] = ClientUtils.ParameterToString(groupBy.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UsageAudioTranscriptionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UsageAudioTranscriptionsApiResponse>();
                        UsageAudioTranscriptionsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/organization/usage/audio_transcriptions", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUsageAudioTranscriptionsDefaultImplementation(apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);

                        Events.ExecuteOnUsageAudioTranscriptions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUsageAudioTranscriptionsDefaultImplementation(e, "/organization/usage/audio_transcriptions", uriBuilderLocalVar.Path, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);
                Events.ExecuteOnErrorUsageAudioTranscriptions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UsageAudioTranscriptionsApiResponse"/>
        /// </summary>
        public partial class UsageAudioTranscriptionsApiResponse : Org.OpenAPITools.Client.ApiResponse, IUsageAudioTranscriptionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UsageAudioTranscriptionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UsageAudioTranscriptionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageAudioTranscriptionsApiResponse(ILogger<UsageAudioTranscriptionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UsageAudioTranscriptionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageAudioTranscriptionsApiResponse(ILogger<UsageAudioTranscriptionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.UsageResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.UsageResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.UsageResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUsageCodeInterpreterSessions(ref int startTime, ref Option<int> endTime, ref Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, ref Option<int> limit, ref Option<string> page);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="groupBy"></param>
        /// <param name="page"></param>
        /// <returns></returns>
        private void ValidateUsageCodeInterpreterSessions(Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, Option<string> page)
        {
            if (bucketWidth.IsSet && bucketWidth.Value == null)
                throw new ArgumentNullException(nameof(bucketWidth));

            if (projectIds.IsSet && projectIds.Value == null)
                throw new ArgumentNullException(nameof(projectIds));

            if (groupBy.IsSet && groupBy.Value == null)
                throw new ArgumentNullException(nameof(groupBy));

            if (page.IsSet && page.Value == null)
                throw new ArgumentNullException(nameof(page));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void AfterUsageCodeInterpreterSessionsDefaultImplementation(IUsageCodeInterpreterSessionsApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLog = false;
            AfterUsageCodeInterpreterSessions(ref suppressDefaultLog, apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, groupBy, limit, page);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void AfterUsageCodeInterpreterSessions(ref bool suppressDefaultLog, IUsageCodeInterpreterSessionsApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void OnErrorUsageCodeInterpreterSessionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUsageCodeInterpreterSessions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, startTime, endTime, bucketWidth, projectIds, groupBy, limit, page);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void OnErrorUsageCodeInterpreterSessions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Get code interpreter sessions usage details for the organization. 
        /// </summary>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageCodeInterpreterSessionsApiResponse"/>&gt;</returns>
        public async Task<IUsageCodeInterpreterSessionsApiResponse?> UsageCodeInterpreterSessionsOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UsageCodeInterpreterSessionsAsync(startTime, endTime, bucketWidth, projectIds, groupBy, limit, page, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get code interpreter sessions usage details for the organization. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageCodeInterpreterSessionsApiResponse"/>&gt;</returns>
        public async Task<IUsageCodeInterpreterSessionsApiResponse> UsageCodeInterpreterSessionsAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUsageCodeInterpreterSessions(bucketWidth, projectIds, groupBy, page);

                FormatUsageCodeInterpreterSessions(ref startTime, ref endTime, ref bucketWidth, projectIds, groupBy, ref limit, ref page);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/organization/usage/code_interpreter_sessions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/organization/usage/code_interpreter_sessions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start_time"] = ClientUtils.ParameterToString(startTime);

                    if (endTime.IsSet)
                        parseQueryStringLocalVar["end_time"] = ClientUtils.ParameterToString(endTime.Value);

                    if (bucketWidth.IsSet)
                        parseQueryStringLocalVar["bucket_width"] = ClientUtils.ParameterToString(bucketWidth.Value);

                    if (projectIds.IsSet)
                        parseQueryStringLocalVar["project_ids"] = ClientUtils.ParameterToString(projectIds.Value);

                    if (groupBy.IsSet)
                        parseQueryStringLocalVar["group_by"] = ClientUtils.ParameterToString(groupBy.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UsageCodeInterpreterSessionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UsageCodeInterpreterSessionsApiResponse>();
                        UsageCodeInterpreterSessionsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/organization/usage/code_interpreter_sessions", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUsageCodeInterpreterSessionsDefaultImplementation(apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, groupBy, limit, page);

                        Events.ExecuteOnUsageCodeInterpreterSessions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUsageCodeInterpreterSessionsDefaultImplementation(e, "/organization/usage/code_interpreter_sessions", uriBuilderLocalVar.Path, startTime, endTime, bucketWidth, projectIds, groupBy, limit, page);
                Events.ExecuteOnErrorUsageCodeInterpreterSessions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UsageCodeInterpreterSessionsApiResponse"/>
        /// </summary>
        public partial class UsageCodeInterpreterSessionsApiResponse : Org.OpenAPITools.Client.ApiResponse, IUsageCodeInterpreterSessionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UsageCodeInterpreterSessionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UsageCodeInterpreterSessionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageCodeInterpreterSessionsApiResponse(ILogger<UsageCodeInterpreterSessionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UsageCodeInterpreterSessionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageCodeInterpreterSessionsApiResponse(ILogger<UsageCodeInterpreterSessionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.UsageResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.UsageResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.UsageResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUsageCompletions(ref int startTime, ref Option<int> endTime, ref Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, ref Option<bool> batch, Option<List<string>> groupBy, ref Option<int> limit, ref Option<string> page);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="page"></param>
        /// <returns></returns>
        private void ValidateUsageCompletions(Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<string> page)
        {
            if (bucketWidth.IsSet && bucketWidth.Value == null)
                throw new ArgumentNullException(nameof(bucketWidth));

            if (projectIds.IsSet && projectIds.Value == null)
                throw new ArgumentNullException(nameof(projectIds));

            if (userIds.IsSet && userIds.Value == null)
                throw new ArgumentNullException(nameof(userIds));

            if (apiKeyIds.IsSet && apiKeyIds.Value == null)
                throw new ArgumentNullException(nameof(apiKeyIds));

            if (models.IsSet && models.Value == null)
                throw new ArgumentNullException(nameof(models));

            if (groupBy.IsSet && groupBy.Value == null)
                throw new ArgumentNullException(nameof(groupBy));

            if (page.IsSet && page.Value == null)
                throw new ArgumentNullException(nameof(page));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="batch"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void AfterUsageCompletionsDefaultImplementation(IUsageCompletionsApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<bool> batch, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLog = false;
            AfterUsageCompletions(ref suppressDefaultLog, apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, batch, groupBy, limit, page);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="batch"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void AfterUsageCompletions(ref bool suppressDefaultLog, IUsageCompletionsApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<bool> batch, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="batch"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void OnErrorUsageCompletionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<bool> batch, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUsageCompletions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, batch, groupBy, limit, page);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="batch"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void OnErrorUsageCompletions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<bool> batch, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Get completions usage details for the organization. 
        /// </summary>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="batch">If &#x60;true&#x60;, return batch jobs only. If &#x60;false&#x60;, return non-batch jobs only. By default, return both.  (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;batch&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageCompletionsApiResponse"/>&gt;</returns>
        public async Task<IUsageCompletionsApiResponse?> UsageCompletionsOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<bool> batch = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UsageCompletionsAsync(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, batch, groupBy, limit, page, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get completions usage details for the organization. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="batch">If &#x60;true&#x60;, return batch jobs only. If &#x60;false&#x60;, return non-batch jobs only. By default, return both.  (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;batch&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageCompletionsApiResponse"/>&gt;</returns>
        public async Task<IUsageCompletionsApiResponse> UsageCompletionsAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<bool> batch = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUsageCompletions(bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, page);

                FormatUsageCompletions(ref startTime, ref endTime, ref bucketWidth, projectIds, userIds, apiKeyIds, models, ref batch, groupBy, ref limit, ref page);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/organization/usage/completions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/organization/usage/completions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start_time"] = ClientUtils.ParameterToString(startTime);

                    if (endTime.IsSet)
                        parseQueryStringLocalVar["end_time"] = ClientUtils.ParameterToString(endTime.Value);

                    if (bucketWidth.IsSet)
                        parseQueryStringLocalVar["bucket_width"] = ClientUtils.ParameterToString(bucketWidth.Value);

                    if (projectIds.IsSet)
                        parseQueryStringLocalVar["project_ids"] = ClientUtils.ParameterToString(projectIds.Value);

                    if (userIds.IsSet)
                        parseQueryStringLocalVar["user_ids"] = ClientUtils.ParameterToString(userIds.Value);

                    if (apiKeyIds.IsSet)
                        parseQueryStringLocalVar["api_key_ids"] = ClientUtils.ParameterToString(apiKeyIds.Value);

                    if (models.IsSet)
                        parseQueryStringLocalVar["models"] = ClientUtils.ParameterToString(models.Value);

                    if (batch.IsSet)
                        parseQueryStringLocalVar["batch"] = ClientUtils.ParameterToString(batch.Value);

                    if (groupBy.IsSet)
                        parseQueryStringLocalVar["group_by"] = ClientUtils.ParameterToString(groupBy.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UsageCompletionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UsageCompletionsApiResponse>();
                        UsageCompletionsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/organization/usage/completions", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUsageCompletionsDefaultImplementation(apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, batch, groupBy, limit, page);

                        Events.ExecuteOnUsageCompletions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUsageCompletionsDefaultImplementation(e, "/organization/usage/completions", uriBuilderLocalVar.Path, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, batch, groupBy, limit, page);
                Events.ExecuteOnErrorUsageCompletions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UsageCompletionsApiResponse"/>
        /// </summary>
        public partial class UsageCompletionsApiResponse : Org.OpenAPITools.Client.ApiResponse, IUsageCompletionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UsageCompletionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UsageCompletionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageCompletionsApiResponse(ILogger<UsageCompletionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UsageCompletionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageCompletionsApiResponse(ILogger<UsageCompletionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.UsageResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.UsageResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.UsageResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUsageCosts(ref int startTime, ref Option<int> endTime, ref Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, ref Option<int> limit, ref Option<string> page);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="groupBy"></param>
        /// <param name="page"></param>
        /// <returns></returns>
        private void ValidateUsageCosts(Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, Option<string> page)
        {
            if (bucketWidth.IsSet && bucketWidth.Value == null)
                throw new ArgumentNullException(nameof(bucketWidth));

            if (projectIds.IsSet && projectIds.Value == null)
                throw new ArgumentNullException(nameof(projectIds));

            if (groupBy.IsSet && groupBy.Value == null)
                throw new ArgumentNullException(nameof(groupBy));

            if (page.IsSet && page.Value == null)
                throw new ArgumentNullException(nameof(page));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void AfterUsageCostsDefaultImplementation(IUsageCostsApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLog = false;
            AfterUsageCosts(ref suppressDefaultLog, apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, groupBy, limit, page);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void AfterUsageCosts(ref bool suppressDefaultLog, IUsageCostsApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void OnErrorUsageCostsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUsageCosts(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, startTime, endTime, bucketWidth, projectIds, groupBy, limit, page);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void OnErrorUsageCosts(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Get costs details for the organization. 
        /// </summary>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently only &#x60;1d&#x60; is supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only costs for these projects. (optional)</param>
        /// <param name="groupBy">Group the costs by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;line_item&#x60; and any combination of them. (optional)</param>
        /// <param name="limit">A limit on the number of buckets to be returned. Limit can range between 1 and 180, and the default is 7.  (optional, default to 7)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageCostsApiResponse"/>&gt;</returns>
        public async Task<IUsageCostsApiResponse?> UsageCostsOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UsageCostsAsync(startTime, endTime, bucketWidth, projectIds, groupBy, limit, page, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get costs details for the organization. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently only &#x60;1d&#x60; is supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only costs for these projects. (optional)</param>
        /// <param name="groupBy">Group the costs by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;line_item&#x60; and any combination of them. (optional)</param>
        /// <param name="limit">A limit on the number of buckets to be returned. Limit can range between 1 and 180, and the default is 7.  (optional, default to 7)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageCostsApiResponse"/>&gt;</returns>
        public async Task<IUsageCostsApiResponse> UsageCostsAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUsageCosts(bucketWidth, projectIds, groupBy, page);

                FormatUsageCosts(ref startTime, ref endTime, ref bucketWidth, projectIds, groupBy, ref limit, ref page);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/organization/costs"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/organization/costs");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start_time"] = ClientUtils.ParameterToString(startTime);

                    if (endTime.IsSet)
                        parseQueryStringLocalVar["end_time"] = ClientUtils.ParameterToString(endTime.Value);

                    if (bucketWidth.IsSet)
                        parseQueryStringLocalVar["bucket_width"] = ClientUtils.ParameterToString(bucketWidth.Value);

                    if (projectIds.IsSet)
                        parseQueryStringLocalVar["project_ids"] = ClientUtils.ParameterToString(projectIds.Value);

                    if (groupBy.IsSet)
                        parseQueryStringLocalVar["group_by"] = ClientUtils.ParameterToString(groupBy.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UsageCostsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UsageCostsApiResponse>();
                        UsageCostsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/organization/costs", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUsageCostsDefaultImplementation(apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, groupBy, limit, page);

                        Events.ExecuteOnUsageCosts(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUsageCostsDefaultImplementation(e, "/organization/costs", uriBuilderLocalVar.Path, startTime, endTime, bucketWidth, projectIds, groupBy, limit, page);
                Events.ExecuteOnErrorUsageCosts(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UsageCostsApiResponse"/>
        /// </summary>
        public partial class UsageCostsApiResponse : Org.OpenAPITools.Client.ApiResponse, IUsageCostsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UsageCostsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UsageCostsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageCostsApiResponse(ILogger<UsageCostsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UsageCostsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageCostsApiResponse(ILogger<UsageCostsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.UsageResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.UsageResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.UsageResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUsageEmbeddings(ref int startTime, ref Option<int> endTime, ref Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, ref Option<int> limit, ref Option<string> page);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="page"></param>
        /// <returns></returns>
        private void ValidateUsageEmbeddings(Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<string> page)
        {
            if (bucketWidth.IsSet && bucketWidth.Value == null)
                throw new ArgumentNullException(nameof(bucketWidth));

            if (projectIds.IsSet && projectIds.Value == null)
                throw new ArgumentNullException(nameof(projectIds));

            if (userIds.IsSet && userIds.Value == null)
                throw new ArgumentNullException(nameof(userIds));

            if (apiKeyIds.IsSet && apiKeyIds.Value == null)
                throw new ArgumentNullException(nameof(apiKeyIds));

            if (models.IsSet && models.Value == null)
                throw new ArgumentNullException(nameof(models));

            if (groupBy.IsSet && groupBy.Value == null)
                throw new ArgumentNullException(nameof(groupBy));

            if (page.IsSet && page.Value == null)
                throw new ArgumentNullException(nameof(page));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void AfterUsageEmbeddingsDefaultImplementation(IUsageEmbeddingsApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLog = false;
            AfterUsageEmbeddings(ref suppressDefaultLog, apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void AfterUsageEmbeddings(ref bool suppressDefaultLog, IUsageEmbeddingsApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void OnErrorUsageEmbeddingsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUsageEmbeddings(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void OnErrorUsageEmbeddings(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Get embeddings usage details for the organization. 
        /// </summary>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageEmbeddingsApiResponse"/>&gt;</returns>
        public async Task<IUsageEmbeddingsApiResponse?> UsageEmbeddingsOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UsageEmbeddingsAsync(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get embeddings usage details for the organization. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageEmbeddingsApiResponse"/>&gt;</returns>
        public async Task<IUsageEmbeddingsApiResponse> UsageEmbeddingsAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUsageEmbeddings(bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, page);

                FormatUsageEmbeddings(ref startTime, ref endTime, ref bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, ref limit, ref page);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/organization/usage/embeddings"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/organization/usage/embeddings");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start_time"] = ClientUtils.ParameterToString(startTime);

                    if (endTime.IsSet)
                        parseQueryStringLocalVar["end_time"] = ClientUtils.ParameterToString(endTime.Value);

                    if (bucketWidth.IsSet)
                        parseQueryStringLocalVar["bucket_width"] = ClientUtils.ParameterToString(bucketWidth.Value);

                    if (projectIds.IsSet)
                        parseQueryStringLocalVar["project_ids"] = ClientUtils.ParameterToString(projectIds.Value);

                    if (userIds.IsSet)
                        parseQueryStringLocalVar["user_ids"] = ClientUtils.ParameterToString(userIds.Value);

                    if (apiKeyIds.IsSet)
                        parseQueryStringLocalVar["api_key_ids"] = ClientUtils.ParameterToString(apiKeyIds.Value);

                    if (models.IsSet)
                        parseQueryStringLocalVar["models"] = ClientUtils.ParameterToString(models.Value);

                    if (groupBy.IsSet)
                        parseQueryStringLocalVar["group_by"] = ClientUtils.ParameterToString(groupBy.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UsageEmbeddingsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UsageEmbeddingsApiResponse>();
                        UsageEmbeddingsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/organization/usage/embeddings", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUsageEmbeddingsDefaultImplementation(apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);

                        Events.ExecuteOnUsageEmbeddings(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUsageEmbeddingsDefaultImplementation(e, "/organization/usage/embeddings", uriBuilderLocalVar.Path, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);
                Events.ExecuteOnErrorUsageEmbeddings(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UsageEmbeddingsApiResponse"/>
        /// </summary>
        public partial class UsageEmbeddingsApiResponse : Org.OpenAPITools.Client.ApiResponse, IUsageEmbeddingsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UsageEmbeddingsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UsageEmbeddingsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageEmbeddingsApiResponse(ILogger<UsageEmbeddingsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UsageEmbeddingsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageEmbeddingsApiResponse(ILogger<UsageEmbeddingsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.UsageResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.UsageResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.UsageResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUsageImages(ref int startTime, ref Option<int> endTime, ref Option<string> bucketWidth, Option<List<string>> sources, Option<List<string>> sizes, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, ref Option<int> limit, ref Option<string> page);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="bucketWidth"></param>
        /// <param name="sources"></param>
        /// <param name="sizes"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="page"></param>
        /// <returns></returns>
        private void ValidateUsageImages(Option<string> bucketWidth, Option<List<string>> sources, Option<List<string>> sizes, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<string> page)
        {
            if (bucketWidth.IsSet && bucketWidth.Value == null)
                throw new ArgumentNullException(nameof(bucketWidth));

            if (sources.IsSet && sources.Value == null)
                throw new ArgumentNullException(nameof(sources));

            if (sizes.IsSet && sizes.Value == null)
                throw new ArgumentNullException(nameof(sizes));

            if (projectIds.IsSet && projectIds.Value == null)
                throw new ArgumentNullException(nameof(projectIds));

            if (userIds.IsSet && userIds.Value == null)
                throw new ArgumentNullException(nameof(userIds));

            if (apiKeyIds.IsSet && apiKeyIds.Value == null)
                throw new ArgumentNullException(nameof(apiKeyIds));

            if (models.IsSet && models.Value == null)
                throw new ArgumentNullException(nameof(models));

            if (groupBy.IsSet && groupBy.Value == null)
                throw new ArgumentNullException(nameof(groupBy));

            if (page.IsSet && page.Value == null)
                throw new ArgumentNullException(nameof(page));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="sources"></param>
        /// <param name="sizes"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void AfterUsageImagesDefaultImplementation(IUsageImagesApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> sources, Option<List<string>> sizes, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLog = false;
            AfterUsageImages(ref suppressDefaultLog, apiResponseLocalVar, startTime, endTime, bucketWidth, sources, sizes, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="sources"></param>
        /// <param name="sizes"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void AfterUsageImages(ref bool suppressDefaultLog, IUsageImagesApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> sources, Option<List<string>> sizes, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="sources"></param>
        /// <param name="sizes"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void OnErrorUsageImagesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> sources, Option<List<string>> sizes, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUsageImages(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, startTime, endTime, bucketWidth, sources, sizes, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="sources"></param>
        /// <param name="sizes"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void OnErrorUsageImages(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> sources, Option<List<string>> sizes, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Get images usage details for the organization. 
        /// </summary>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="sources">Return only usages for these sources. Possible values are &#x60;image.generation&#x60;, &#x60;image.edit&#x60;, &#x60;image.variation&#x60; or any combination of them. (optional)</param>
        /// <param name="sizes">Return only usages for these image sizes. Possible values are &#x60;256x256&#x60;, &#x60;512x512&#x60;, &#x60;1024x1024&#x60;, &#x60;1792x1792&#x60;, &#x60;1024x1792&#x60; or any combination of them. (optional)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;size&#x60;, &#x60;source&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageImagesApiResponse"/>&gt;</returns>
        public async Task<IUsageImagesApiResponse?> UsageImagesOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> sources = default, Option<List<string>> sizes = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UsageImagesAsync(startTime, endTime, bucketWidth, sources, sizes, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get images usage details for the organization. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="sources">Return only usages for these sources. Possible values are &#x60;image.generation&#x60;, &#x60;image.edit&#x60;, &#x60;image.variation&#x60; or any combination of them. (optional)</param>
        /// <param name="sizes">Return only usages for these image sizes. Possible values are &#x60;256x256&#x60;, &#x60;512x512&#x60;, &#x60;1024x1024&#x60;, &#x60;1792x1792&#x60;, &#x60;1024x1792&#x60; or any combination of them. (optional)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;size&#x60;, &#x60;source&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageImagesApiResponse"/>&gt;</returns>
        public async Task<IUsageImagesApiResponse> UsageImagesAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> sources = default, Option<List<string>> sizes = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUsageImages(bucketWidth, sources, sizes, projectIds, userIds, apiKeyIds, models, groupBy, page);

                FormatUsageImages(ref startTime, ref endTime, ref bucketWidth, sources, sizes, projectIds, userIds, apiKeyIds, models, groupBy, ref limit, ref page);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/organization/usage/images"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/organization/usage/images");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start_time"] = ClientUtils.ParameterToString(startTime);

                    if (endTime.IsSet)
                        parseQueryStringLocalVar["end_time"] = ClientUtils.ParameterToString(endTime.Value);

                    if (bucketWidth.IsSet)
                        parseQueryStringLocalVar["bucket_width"] = ClientUtils.ParameterToString(bucketWidth.Value);

                    if (sources.IsSet)
                        parseQueryStringLocalVar["sources"] = ClientUtils.ParameterToString(sources.Value);

                    if (sizes.IsSet)
                        parseQueryStringLocalVar["sizes"] = ClientUtils.ParameterToString(sizes.Value);

                    if (projectIds.IsSet)
                        parseQueryStringLocalVar["project_ids"] = ClientUtils.ParameterToString(projectIds.Value);

                    if (userIds.IsSet)
                        parseQueryStringLocalVar["user_ids"] = ClientUtils.ParameterToString(userIds.Value);

                    if (apiKeyIds.IsSet)
                        parseQueryStringLocalVar["api_key_ids"] = ClientUtils.ParameterToString(apiKeyIds.Value);

                    if (models.IsSet)
                        parseQueryStringLocalVar["models"] = ClientUtils.ParameterToString(models.Value);

                    if (groupBy.IsSet)
                        parseQueryStringLocalVar["group_by"] = ClientUtils.ParameterToString(groupBy.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UsageImagesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UsageImagesApiResponse>();
                        UsageImagesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/organization/usage/images", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUsageImagesDefaultImplementation(apiResponseLocalVar, startTime, endTime, bucketWidth, sources, sizes, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);

                        Events.ExecuteOnUsageImages(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUsageImagesDefaultImplementation(e, "/organization/usage/images", uriBuilderLocalVar.Path, startTime, endTime, bucketWidth, sources, sizes, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);
                Events.ExecuteOnErrorUsageImages(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UsageImagesApiResponse"/>
        /// </summary>
        public partial class UsageImagesApiResponse : Org.OpenAPITools.Client.ApiResponse, IUsageImagesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UsageImagesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UsageImagesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageImagesApiResponse(ILogger<UsageImagesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UsageImagesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageImagesApiResponse(ILogger<UsageImagesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.UsageResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.UsageResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.UsageResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUsageModerations(ref int startTime, ref Option<int> endTime, ref Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, ref Option<int> limit, ref Option<string> page);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="page"></param>
        /// <returns></returns>
        private void ValidateUsageModerations(Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<string> page)
        {
            if (bucketWidth.IsSet && bucketWidth.Value == null)
                throw new ArgumentNullException(nameof(bucketWidth));

            if (projectIds.IsSet && projectIds.Value == null)
                throw new ArgumentNullException(nameof(projectIds));

            if (userIds.IsSet && userIds.Value == null)
                throw new ArgumentNullException(nameof(userIds));

            if (apiKeyIds.IsSet && apiKeyIds.Value == null)
                throw new ArgumentNullException(nameof(apiKeyIds));

            if (models.IsSet && models.Value == null)
                throw new ArgumentNullException(nameof(models));

            if (groupBy.IsSet && groupBy.Value == null)
                throw new ArgumentNullException(nameof(groupBy));

            if (page.IsSet && page.Value == null)
                throw new ArgumentNullException(nameof(page));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void AfterUsageModerationsDefaultImplementation(IUsageModerationsApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLog = false;
            AfterUsageModerations(ref suppressDefaultLog, apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void AfterUsageModerations(ref bool suppressDefaultLog, IUsageModerationsApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void OnErrorUsageModerationsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUsageModerations(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="userIds"></param>
        /// <param name="apiKeyIds"></param>
        /// <param name="models"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void OnErrorUsageModerations(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> userIds, Option<List<string>> apiKeyIds, Option<List<string>> models, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Get moderations usage details for the organization. 
        /// </summary>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageModerationsApiResponse"/>&gt;</returns>
        public async Task<IUsageModerationsApiResponse?> UsageModerationsOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UsageModerationsAsync(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get moderations usage details for the organization. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="userIds">Return only usage for these users. (optional)</param>
        /// <param name="apiKeyIds">Return only usage for these API keys. (optional)</param>
        /// <param name="models">Return only usage for these models. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageModerationsApiResponse"/>&gt;</returns>
        public async Task<IUsageModerationsApiResponse> UsageModerationsAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> userIds = default, Option<List<string>> apiKeyIds = default, Option<List<string>> models = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUsageModerations(bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, page);

                FormatUsageModerations(ref startTime, ref endTime, ref bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, ref limit, ref page);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/organization/usage/moderations"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/organization/usage/moderations");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start_time"] = ClientUtils.ParameterToString(startTime);

                    if (endTime.IsSet)
                        parseQueryStringLocalVar["end_time"] = ClientUtils.ParameterToString(endTime.Value);

                    if (bucketWidth.IsSet)
                        parseQueryStringLocalVar["bucket_width"] = ClientUtils.ParameterToString(bucketWidth.Value);

                    if (projectIds.IsSet)
                        parseQueryStringLocalVar["project_ids"] = ClientUtils.ParameterToString(projectIds.Value);

                    if (userIds.IsSet)
                        parseQueryStringLocalVar["user_ids"] = ClientUtils.ParameterToString(userIds.Value);

                    if (apiKeyIds.IsSet)
                        parseQueryStringLocalVar["api_key_ids"] = ClientUtils.ParameterToString(apiKeyIds.Value);

                    if (models.IsSet)
                        parseQueryStringLocalVar["models"] = ClientUtils.ParameterToString(models.Value);

                    if (groupBy.IsSet)
                        parseQueryStringLocalVar["group_by"] = ClientUtils.ParameterToString(groupBy.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UsageModerationsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UsageModerationsApiResponse>();
                        UsageModerationsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/organization/usage/moderations", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUsageModerationsDefaultImplementation(apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);

                        Events.ExecuteOnUsageModerations(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUsageModerationsDefaultImplementation(e, "/organization/usage/moderations", uriBuilderLocalVar.Path, startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page);
                Events.ExecuteOnErrorUsageModerations(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UsageModerationsApiResponse"/>
        /// </summary>
        public partial class UsageModerationsApiResponse : Org.OpenAPITools.Client.ApiResponse, IUsageModerationsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UsageModerationsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UsageModerationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageModerationsApiResponse(ILogger<UsageModerationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UsageModerationsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageModerationsApiResponse(ILogger<UsageModerationsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.UsageResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.UsageResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.UsageResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUsageVectorStores(ref int startTime, ref Option<int> endTime, ref Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, ref Option<int> limit, ref Option<string> page);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="groupBy"></param>
        /// <param name="page"></param>
        /// <returns></returns>
        private void ValidateUsageVectorStores(Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, Option<string> page)
        {
            if (bucketWidth.IsSet && bucketWidth.Value == null)
                throw new ArgumentNullException(nameof(bucketWidth));

            if (projectIds.IsSet && projectIds.Value == null)
                throw new ArgumentNullException(nameof(projectIds));

            if (groupBy.IsSet && groupBy.Value == null)
                throw new ArgumentNullException(nameof(groupBy));

            if (page.IsSet && page.Value == null)
                throw new ArgumentNullException(nameof(page));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void AfterUsageVectorStoresDefaultImplementation(IUsageVectorStoresApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLog = false;
            AfterUsageVectorStores(ref suppressDefaultLog, apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, groupBy, limit, page);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void AfterUsageVectorStores(ref bool suppressDefaultLog, IUsageVectorStoresApiResponse apiResponseLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        private void OnErrorUsageVectorStoresDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, Option<int> limit, Option<string> page)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUsageVectorStores(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, startTime, endTime, bucketWidth, projectIds, groupBy, limit, page);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="startTime"></param>
        /// <param name="endTime"></param>
        /// <param name="bucketWidth"></param>
        /// <param name="projectIds"></param>
        /// <param name="groupBy"></param>
        /// <param name="limit"></param>
        /// <param name="page"></param>
        partial void OnErrorUsageVectorStores(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int startTime, Option<int> endTime, Option<string> bucketWidth, Option<List<string>> projectIds, Option<List<string>> groupBy, Option<int> limit, Option<string> page);

        /// <summary>
        /// Get vector stores usage details for the organization. 
        /// </summary>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageVectorStoresApiResponse"/>&gt;</returns>
        public async Task<IUsageVectorStoresApiResponse?> UsageVectorStoresOrDefaultAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UsageVectorStoresAsync(startTime, endTime, bucketWidth, projectIds, groupBy, limit, page, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get vector stores usage details for the organization. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="startTime">Start time (Unix seconds) of the query time range, inclusive.</param>
        /// <param name="endTime">End time (Unix seconds) of the query time range, exclusive. (optional)</param>
        /// <param name="bucketWidth">Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;. (optional, default to 1d)</param>
        /// <param name="projectIds">Return only usage for these projects. (optional)</param>
        /// <param name="groupBy">Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;. (optional)</param>
        /// <param name="limit">Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440  (optional)</param>
        /// <param name="page">A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUsageVectorStoresApiResponse"/>&gt;</returns>
        public async Task<IUsageVectorStoresApiResponse> UsageVectorStoresAsync(int startTime, Option<int> endTime = default, Option<string> bucketWidth = default, Option<List<string>> projectIds = default, Option<List<string>> groupBy = default, Option<int> limit = default, Option<string> page = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUsageVectorStores(bucketWidth, projectIds, groupBy, page);

                FormatUsageVectorStores(ref startTime, ref endTime, ref bucketWidth, projectIds, groupBy, ref limit, ref page);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/organization/usage/vector_stores"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/organization/usage/vector_stores");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["start_time"] = ClientUtils.ParameterToString(startTime);

                    if (endTime.IsSet)
                        parseQueryStringLocalVar["end_time"] = ClientUtils.ParameterToString(endTime.Value);

                    if (bucketWidth.IsSet)
                        parseQueryStringLocalVar["bucket_width"] = ClientUtils.ParameterToString(bucketWidth.Value);

                    if (projectIds.IsSet)
                        parseQueryStringLocalVar["project_ids"] = ClientUtils.ParameterToString(projectIds.Value);

                    if (groupBy.IsSet)
                        parseQueryStringLocalVar["group_by"] = ClientUtils.ParameterToString(groupBy.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UsageVectorStoresApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UsageVectorStoresApiResponse>();
                        UsageVectorStoresApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/organization/usage/vector_stores", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUsageVectorStoresDefaultImplementation(apiResponseLocalVar, startTime, endTime, bucketWidth, projectIds, groupBy, limit, page);

                        Events.ExecuteOnUsageVectorStores(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUsageVectorStoresDefaultImplementation(e, "/organization/usage/vector_stores", uriBuilderLocalVar.Path, startTime, endTime, bucketWidth, projectIds, groupBy, limit, page);
                Events.ExecuteOnErrorUsageVectorStores(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UsageVectorStoresApiResponse"/>
        /// </summary>
        public partial class UsageVectorStoresApiResponse : Org.OpenAPITools.Client.ApiResponse, IUsageVectorStoresApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UsageVectorStoresApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UsageVectorStoresApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageVectorStoresApiResponse(ILogger<UsageVectorStoresApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UsageVectorStoresApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UsageVectorStoresApiResponse(ILogger<UsageVectorStoresApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Org.OpenAPITools.Model.UsageResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Org.OpenAPITools.Model.UsageResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Org.OpenAPITools.Model.UsageResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
