// <auto-generated>
/*
 * OpenAI API
 *
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Org.OpenAPITools.Client;

namespace Org.OpenAPITools.Model
{
    /// <summary>
    /// Breakdown of tokens used in a completion.
    /// </summary>
    public partial class CompletionUsageCompletionTokensDetails : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CompletionUsageCompletionTokensDetails" /> class.
        /// </summary>
        /// <param name="acceptedPredictionTokens">When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion. </param>
        /// <param name="audioTokens">Audio input tokens generated by the model.</param>
        /// <param name="reasoningTokens">Tokens generated by the model for reasoning.</param>
        /// <param name="rejectedPredictionTokens">When using Predicted Outputs, the number of tokens in the prediction that did not appear in the completion. However, like reasoning tokens, these tokens are still counted in the total completion tokens for purposes of billing, output, and context window limits. </param>
        [JsonConstructor]
        public CompletionUsageCompletionTokensDetails(Option<int?> acceptedPredictionTokens = default, Option<int?> audioTokens = default, Option<int?> reasoningTokens = default, Option<int?> rejectedPredictionTokens = default)
        {
            AcceptedPredictionTokensOption = acceptedPredictionTokens;
            AudioTokensOption = audioTokens;
            ReasoningTokensOption = reasoningTokens;
            RejectedPredictionTokensOption = rejectedPredictionTokens;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Used to track the state of AcceptedPredictionTokens
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> AcceptedPredictionTokensOption { get; private set; }

        /// <summary>
        /// When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion. 
        /// </summary>
        /// <value>When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion. </value>
        [JsonPropertyName("accepted_prediction_tokens")]
        public int? AcceptedPredictionTokens { get { return this.AcceptedPredictionTokensOption; } set { this.AcceptedPredictionTokensOption = new(value); } }

        /// <summary>
        /// Used to track the state of AudioTokens
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> AudioTokensOption { get; private set; }

        /// <summary>
        /// Audio input tokens generated by the model.
        /// </summary>
        /// <value>Audio input tokens generated by the model.</value>
        [JsonPropertyName("audio_tokens")]
        public int? AudioTokens { get { return this.AudioTokensOption; } set { this.AudioTokensOption = new(value); } }

        /// <summary>
        /// Used to track the state of ReasoningTokens
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> ReasoningTokensOption { get; private set; }

        /// <summary>
        /// Tokens generated by the model for reasoning.
        /// </summary>
        /// <value>Tokens generated by the model for reasoning.</value>
        [JsonPropertyName("reasoning_tokens")]
        public int? ReasoningTokens { get { return this.ReasoningTokensOption; } set { this.ReasoningTokensOption = new(value); } }

        /// <summary>
        /// Used to track the state of RejectedPredictionTokens
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> RejectedPredictionTokensOption { get; private set; }

        /// <summary>
        /// When using Predicted Outputs, the number of tokens in the prediction that did not appear in the completion. However, like reasoning tokens, these tokens are still counted in the total completion tokens for purposes of billing, output, and context window limits. 
        /// </summary>
        /// <value>When using Predicted Outputs, the number of tokens in the prediction that did not appear in the completion. However, like reasoning tokens, these tokens are still counted in the total completion tokens for purposes of billing, output, and context window limits. </value>
        [JsonPropertyName("rejected_prediction_tokens")]
        public int? RejectedPredictionTokens { get { return this.RejectedPredictionTokensOption; } set { this.RejectedPredictionTokensOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class CompletionUsageCompletionTokensDetails {\n");
            sb.Append("  AcceptedPredictionTokens: ").Append(AcceptedPredictionTokens).Append("\n");
            sb.Append("  AudioTokens: ").Append(AudioTokens).Append("\n");
            sb.Append("  ReasoningTokens: ").Append(ReasoningTokens).Append("\n");
            sb.Append("  RejectedPredictionTokens: ").Append(RejectedPredictionTokens).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="CompletionUsageCompletionTokensDetails" />
    /// </summary>
    public class CompletionUsageCompletionTokensDetailsJsonConverter : JsonConverter<CompletionUsageCompletionTokensDetails>
    {
        /// <summary>
        /// Deserializes json to <see cref="CompletionUsageCompletionTokensDetails" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override CompletionUsageCompletionTokensDetails Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<int?> acceptedPredictionTokens = default;
            Option<int?> audioTokens = default;
            Option<int?> reasoningTokens = default;
            Option<int?> rejectedPredictionTokens = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "accepted_prediction_tokens":
                            acceptedPredictionTokens = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "audio_tokens":
                            audioTokens = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "reasoning_tokens":
                            reasoningTokens = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "rejected_prediction_tokens":
                            rejectedPredictionTokens = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (acceptedPredictionTokens.IsSet && acceptedPredictionTokens.Value == null)
                throw new ArgumentNullException(nameof(acceptedPredictionTokens), "Property is not nullable for class CompletionUsageCompletionTokensDetails.");

            if (audioTokens.IsSet && audioTokens.Value == null)
                throw new ArgumentNullException(nameof(audioTokens), "Property is not nullable for class CompletionUsageCompletionTokensDetails.");

            if (reasoningTokens.IsSet && reasoningTokens.Value == null)
                throw new ArgumentNullException(nameof(reasoningTokens), "Property is not nullable for class CompletionUsageCompletionTokensDetails.");

            if (rejectedPredictionTokens.IsSet && rejectedPredictionTokens.Value == null)
                throw new ArgumentNullException(nameof(rejectedPredictionTokens), "Property is not nullable for class CompletionUsageCompletionTokensDetails.");

            return new CompletionUsageCompletionTokensDetails(acceptedPredictionTokens, audioTokens, reasoningTokens, rejectedPredictionTokens);
        }

        /// <summary>
        /// Serializes a <see cref="CompletionUsageCompletionTokensDetails" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="completionUsageCompletionTokensDetails"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, CompletionUsageCompletionTokensDetails completionUsageCompletionTokensDetails, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, completionUsageCompletionTokensDetails, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="CompletionUsageCompletionTokensDetails" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="completionUsageCompletionTokensDetails"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, CompletionUsageCompletionTokensDetails completionUsageCompletionTokensDetails, JsonSerializerOptions jsonSerializerOptions)
        {
            if (completionUsageCompletionTokensDetails.AcceptedPredictionTokensOption.IsSet)
                writer.WriteNumber("accepted_prediction_tokens", completionUsageCompletionTokensDetails.AcceptedPredictionTokensOption.Value!.Value);

            if (completionUsageCompletionTokensDetails.AudioTokensOption.IsSet)
                writer.WriteNumber("audio_tokens", completionUsageCompletionTokensDetails.AudioTokensOption.Value!.Value);

            if (completionUsageCompletionTokensDetails.ReasoningTokensOption.IsSet)
                writer.WriteNumber("reasoning_tokens", completionUsageCompletionTokensDetails.ReasoningTokensOption.Value!.Value);

            if (completionUsageCompletionTokensDetails.RejectedPredictionTokensOption.IsSet)
                writer.WriteNumber("rejected_prediction_tokens", completionUsageCompletionTokensDetails.RejectedPredictionTokensOption.Value!.Value);
        }
    }
}
