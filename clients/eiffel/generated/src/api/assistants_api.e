note
 description:"[
		OpenAI API
 		The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
  		The version of the OpenAPI document: 2.0.0
 	    Contact: blah+oapicf@cliffano.com

  	NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

 		 Do not edit the class manually.
 	]"
	date: "$Date$"
	revision: "$Revision$"
	EIS:"Eiffel openapi generator", "src=https://openapi-generator.tech", "protocol=uri"

class
	ASSISTANTS_API

inherit

    API_I


feature -- API Access


	assistant (assistant_id: STRING_32): detachable ASSISTANT_OBJECT
			-- Retrieves an assistant.
			-- 
			-- 
			-- argument: assistant_id The ID of the assistant to retrieve. (required)
			-- 
			-- 
			-- Result ASSISTANT_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/assistants/{assistant_id}"
			l_path.replace_substring_all ("{"+"assistant_id"+"}", api_client.url_encode (assistant_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ASSISTANT_OBJECT } l_response.data ({ ASSISTANT_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	assistant_file (assistant_id: STRING_32; file_id: STRING_32): detachable ASSISTANT_FILE_OBJECT
			-- Retrieves an AssistantFile.
			-- 
			-- 
			-- argument: assistant_id The ID of the assistant who the file belongs to. (required)
			-- 
			-- argument: file_id The ID of the file we&#39;re getting. (required)
			-- 
			-- 
			-- Result ASSISTANT_FILE_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/assistants/{assistant_id}/files/{file_id}"
			l_path.replace_substring_all ("{"+"assistant_id"+"}", api_client.url_encode (assistant_id.out))
			l_path.replace_substring_all ("{"+"file_id"+"}", api_client.url_encode (file_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ASSISTANT_FILE_OBJECT } l_response.data ({ ASSISTANT_FILE_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	cancel_run (thread_id: STRING_32; run_id: STRING_32): detachable RUN_OBJECT
			-- Cancels a run that is &#x60;in_progress&#x60;.
			-- 
			-- 
			-- argument: thread_id The ID of the thread to which this run belongs. (required)
			-- 
			-- argument: run_id The ID of the run to cancel. (required)
			-- 
			-- 
			-- Result RUN_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/threads/{thread_id}/runs/{run_id}/cancel"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))
			l_path.replace_substring_all ("{"+"run_id"+"}", api_client.url_encode (run_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { RUN_OBJECT } l_response.data ({ RUN_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_assistant (create_assistant_request: CREATE_ASSISTANT_REQUEST): detachable ASSISTANT_OBJECT
			-- Create an assistant with a model and instructions.
			-- 
			-- 
			-- argument: create_assistant_request  (required)
			-- 
			-- 
			-- Result ASSISTANT_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(create_assistant_request)
			l_path := "/assistants"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ASSISTANT_OBJECT } l_response.data ({ ASSISTANT_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_assistant_file (assistant_id: STRING_32; create_assistant_file_request: CREATE_ASSISTANT_FILE_REQUEST): detachable ASSISTANT_FILE_OBJECT
			-- Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants).
			-- 
			-- 
			-- argument: assistant_id The ID of the assistant for which to create a File.  (required)
			-- 
			-- argument: create_assistant_file_request  (required)
			-- 
			-- 
			-- Result ASSISTANT_FILE_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(create_assistant_file_request)
			l_path := "/assistants/{assistant_id}/files"
			l_path.replace_substring_all ("{"+"assistant_id"+"}", api_client.url_encode (assistant_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ASSISTANT_FILE_OBJECT } l_response.data ({ ASSISTANT_FILE_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_message (thread_id: STRING_32; create_message_request: CREATE_MESSAGE_REQUEST): detachable MESSAGE_OBJECT
			-- Create a message.
			-- 
			-- 
			-- argument: thread_id The ID of the [thread](/docs/api-reference/threads) to create a message for. (required)
			-- 
			-- argument: create_message_request  (required)
			-- 
			-- 
			-- Result MESSAGE_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(create_message_request)
			l_path := "/threads/{thread_id}/messages"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { MESSAGE_OBJECT } l_response.data ({ MESSAGE_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_run (thread_id: STRING_32; create_run_request: CREATE_RUN_REQUEST): detachable RUN_OBJECT
			-- Create a run.
			-- 
			-- 
			-- argument: thread_id The ID of the thread to run. (required)
			-- 
			-- argument: create_run_request  (required)
			-- 
			-- 
			-- Result RUN_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(create_run_request)
			l_path := "/threads/{thread_id}/runs"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { RUN_OBJECT } l_response.data ({ RUN_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_thread (create_thread_request: detachable CREATE_THREAD_REQUEST): detachable THREAD_OBJECT
			-- Create a thread.
			-- 
			-- 
			-- argument: create_thread_request  (optional)
			-- 
			-- 
			-- Result THREAD_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(create_thread_request)
			l_path := "/threads"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { THREAD_OBJECT } l_response.data ({ THREAD_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_thread_and_run (create_thread_and_run_request: CREATE_THREAD_AND_RUN_REQUEST): detachable RUN_OBJECT
			-- Create a thread and run it in one request.
			-- 
			-- 
			-- argument: create_thread_and_run_request  (required)
			-- 
			-- 
			-- Result RUN_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(create_thread_and_run_request)
			l_path := "/threads/runs"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { RUN_OBJECT } l_response.data ({ RUN_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	delete_assistant (assistant_id: STRING_32): detachable DELETE_ASSISTANT_RESPONSE
			-- Delete an assistant.
			-- 
			-- 
			-- argument: assistant_id The ID of the assistant to delete. (required)
			-- 
			-- 
			-- Result DELETE_ASSISTANT_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/assistants/{assistant_id}"
			l_path.replace_substring_all ("{"+"assistant_id"+"}", api_client.url_encode (assistant_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Delete", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { DELETE_ASSISTANT_RESPONSE } l_response.data ({ DELETE_ASSISTANT_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	delete_assistant_file (assistant_id: STRING_32; file_id: STRING_32): detachable DELETE_ASSISTANT_FILE_RESPONSE
			-- Delete an assistant file.
			-- 
			-- 
			-- argument: assistant_id The ID of the assistant that the file belongs to. (required)
			-- 
			-- argument: file_id The ID of the file to delete. (required)
			-- 
			-- 
			-- Result DELETE_ASSISTANT_FILE_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/assistants/{assistant_id}/files/{file_id}"
			l_path.replace_substring_all ("{"+"assistant_id"+"}", api_client.url_encode (assistant_id.out))
			l_path.replace_substring_all ("{"+"file_id"+"}", api_client.url_encode (file_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Delete", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { DELETE_ASSISTANT_FILE_RESPONSE } l_response.data ({ DELETE_ASSISTANT_FILE_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	delete_thread (thread_id: STRING_32): detachable DELETE_THREAD_RESPONSE
			-- Delete a thread.
			-- 
			-- 
			-- argument: thread_id The ID of the thread to delete. (required)
			-- 
			-- 
			-- Result DELETE_THREAD_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/threads/{thread_id}"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Delete", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { DELETE_THREAD_RESPONSE } l_response.data ({ DELETE_THREAD_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	list_assistant_files (assistant_id: STRING_32; limit: INTEGER_32; order: STRING_32; after: STRING_32; before: STRING_32): detachable LIST_ASSISTANT_FILES_RESPONSE
			-- Returns a list of assistant files.
			-- 
			-- 
			-- argument: assistant_id The ID of the assistant the file belongs to. (required)
			-- 
			-- argument: limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
			-- 
			-- argument: order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
			-- 
			-- argument: after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional, default to null)
			-- 
			-- argument: before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional, default to null)
			-- 
			-- 
			-- Result LIST_ASSISTANT_FILES_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/assistants/{assistant_id}/files"
			l_path.replace_substring_all ("{"+"assistant_id"+"}", api_client.url_encode (assistant_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "order", order));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "after", after));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "before", before));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST_ASSISTANT_FILES_RESPONSE } l_response.data ({ LIST_ASSISTANT_FILES_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	list_assistants (limit: INTEGER_32; order: STRING_32; after: STRING_32; before: STRING_32): detachable LIST_ASSISTANTS_RESPONSE
			-- Returns a list of assistants.
			-- 
			-- 
			-- argument: limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
			-- 
			-- argument: order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
			-- 
			-- argument: after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional, default to null)
			-- 
			-- argument: before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional, default to null)
			-- 
			-- 
			-- Result LIST_ASSISTANTS_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/assistants"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "order", order));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "after", after));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "before", before));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST_ASSISTANTS_RESPONSE } l_response.data ({ LIST_ASSISTANTS_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	list_message_files (thread_id: STRING_32; message_id: STRING_32; limit: INTEGER_32; order: STRING_32; after: STRING_32; before: STRING_32): detachable LIST_MESSAGE_FILES_RESPONSE
			-- Returns a list of message files.
			-- 
			-- 
			-- argument: thread_id The ID of the thread that the message and files belong to. (required)
			-- 
			-- argument: message_id The ID of the message that the files belongs to. (required)
			-- 
			-- argument: limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
			-- 
			-- argument: order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
			-- 
			-- argument: after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional, default to null)
			-- 
			-- argument: before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional, default to null)
			-- 
			-- 
			-- Result LIST_MESSAGE_FILES_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/threads/{thread_id}/messages/{message_id}/files"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))
			l_path.replace_substring_all ("{"+"message_id"+"}", api_client.url_encode (message_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "order", order));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "after", after));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "before", before));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST_MESSAGE_FILES_RESPONSE } l_response.data ({ LIST_MESSAGE_FILES_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	list_messages (thread_id: STRING_32; limit: INTEGER_32; order: STRING_32; after: STRING_32; before: STRING_32; run_id: STRING_32): detachable LIST_MESSAGES_RESPONSE
			-- Returns a list of messages for a given thread.
			-- 
			-- 
			-- argument: thread_id The ID of the [thread](/docs/api-reference/threads) the messages belong to. (required)
			-- 
			-- argument: limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
			-- 
			-- argument: order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
			-- 
			-- argument: after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional, default to null)
			-- 
			-- argument: before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional, default to null)
			-- 
			-- argument: run_id Filter messages by the run ID that generated them.  (optional, default to null)
			-- 
			-- 
			-- Result LIST_MESSAGES_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/threads/{thread_id}/messages"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "order", order));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "after", after));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "before", before));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "run_id", run_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST_MESSAGES_RESPONSE } l_response.data ({ LIST_MESSAGES_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	list_run_steps (thread_id: STRING_32; run_id: STRING_32; limit: INTEGER_32; order: STRING_32; after: STRING_32; before: STRING_32): detachable LIST_RUN_STEPS_RESPONSE
			-- Returns a list of run steps belonging to a run.
			-- 
			-- 
			-- argument: thread_id The ID of the thread the run and run steps belong to. (required)
			-- 
			-- argument: run_id The ID of the run the run steps belong to. (required)
			-- 
			-- argument: limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
			-- 
			-- argument: order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
			-- 
			-- argument: after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional, default to null)
			-- 
			-- argument: before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional, default to null)
			-- 
			-- 
			-- Result LIST_RUN_STEPS_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/threads/{thread_id}/runs/{run_id}/steps"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))
			l_path.replace_substring_all ("{"+"run_id"+"}", api_client.url_encode (run_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "order", order));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "after", after));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "before", before));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST_RUN_STEPS_RESPONSE } l_response.data ({ LIST_RUN_STEPS_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	list_runs (thread_id: STRING_32; limit: INTEGER_32; order: STRING_32; after: STRING_32; before: STRING_32): detachable LIST_RUNS_RESPONSE
			-- Returns a list of runs belonging to a thread.
			-- 
			-- 
			-- argument: thread_id The ID of the thread the run belongs to. (required)
			-- 
			-- argument: limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
			-- 
			-- argument: order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
			-- 
			-- argument: after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional, default to null)
			-- 
			-- argument: before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional, default to null)
			-- 
			-- 
			-- Result LIST_RUNS_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/threads/{thread_id}/runs"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "order", order));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "after", after));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "before", before));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST_RUNS_RESPONSE } l_response.data ({ LIST_RUNS_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	message (thread_id: STRING_32; message_id: STRING_32): detachable MESSAGE_OBJECT
			-- Retrieve a message.
			-- 
			-- 
			-- argument: thread_id The ID of the [thread](/docs/api-reference/threads) to which this message belongs. (required)
			-- 
			-- argument: message_id The ID of the message to retrieve. (required)
			-- 
			-- 
			-- Result MESSAGE_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/threads/{thread_id}/messages/{message_id}"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))
			l_path.replace_substring_all ("{"+"message_id"+"}", api_client.url_encode (message_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { MESSAGE_OBJECT } l_response.data ({ MESSAGE_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	message_file (thread_id: STRING_32; message_id: STRING_32; file_id: STRING_32): detachable MESSAGE_FILE_OBJECT
			-- Retrieves a message file.
			-- 
			-- 
			-- argument: thread_id The ID of the thread to which the message and File belong. (required)
			-- 
			-- argument: message_id The ID of the message the file belongs to. (required)
			-- 
			-- argument: file_id The ID of the file being retrieved. (required)
			-- 
			-- 
			-- Result MESSAGE_FILE_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/threads/{thread_id}/messages/{message_id}/files/{file_id}"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))
			l_path.replace_substring_all ("{"+"message_id"+"}", api_client.url_encode (message_id.out))
			l_path.replace_substring_all ("{"+"file_id"+"}", api_client.url_encode (file_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { MESSAGE_FILE_OBJECT } l_response.data ({ MESSAGE_FILE_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	modify_assistant (assistant_id: STRING_32; modify_assistant_request: MODIFY_ASSISTANT_REQUEST): detachable ASSISTANT_OBJECT
			-- Modifies an assistant.
			-- 
			-- 
			-- argument: assistant_id The ID of the assistant to modify. (required)
			-- 
			-- argument: modify_assistant_request  (required)
			-- 
			-- 
			-- Result ASSISTANT_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(modify_assistant_request)
			l_path := "/assistants/{assistant_id}"
			l_path.replace_substring_all ("{"+"assistant_id"+"}", api_client.url_encode (assistant_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { ASSISTANT_OBJECT } l_response.data ({ ASSISTANT_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	modify_message (thread_id: STRING_32; message_id: STRING_32; modify_message_request: MODIFY_MESSAGE_REQUEST): detachable MESSAGE_OBJECT
			-- Modifies a message.
			-- 
			-- 
			-- argument: thread_id The ID of the thread to which this message belongs. (required)
			-- 
			-- argument: message_id The ID of the message to modify. (required)
			-- 
			-- argument: modify_message_request  (required)
			-- 
			-- 
			-- Result MESSAGE_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(modify_message_request)
			l_path := "/threads/{thread_id}/messages/{message_id}"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))
			l_path.replace_substring_all ("{"+"message_id"+"}", api_client.url_encode (message_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { MESSAGE_OBJECT } l_response.data ({ MESSAGE_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	modify_run (thread_id: STRING_32; run_id: STRING_32; modify_run_request: MODIFY_RUN_REQUEST): detachable RUN_OBJECT
			-- Modifies a run.
			-- 
			-- 
			-- argument: thread_id The ID of the [thread](/docs/api-reference/threads) that was run. (required)
			-- 
			-- argument: run_id The ID of the run to modify. (required)
			-- 
			-- argument: modify_run_request  (required)
			-- 
			-- 
			-- Result RUN_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(modify_run_request)
			l_path := "/threads/{thread_id}/runs/{run_id}"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))
			l_path.replace_substring_all ("{"+"run_id"+"}", api_client.url_encode (run_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { RUN_OBJECT } l_response.data ({ RUN_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	modify_thread (thread_id: STRING_32; modify_thread_request: MODIFY_THREAD_REQUEST): detachable THREAD_OBJECT
			-- Modifies a thread.
			-- 
			-- 
			-- argument: thread_id The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified. (required)
			-- 
			-- argument: modify_thread_request  (required)
			-- 
			-- 
			-- Result THREAD_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(modify_thread_request)
			l_path := "/threads/{thread_id}"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { THREAD_OBJECT } l_response.data ({ THREAD_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	run (thread_id: STRING_32; run_id: STRING_32): detachable RUN_OBJECT
			-- Retrieves a run.
			-- 
			-- 
			-- argument: thread_id The ID of the [thread](/docs/api-reference/threads) that was run. (required)
			-- 
			-- argument: run_id The ID of the run to retrieve. (required)
			-- 
			-- 
			-- Result RUN_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/threads/{thread_id}/runs/{run_id}"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))
			l_path.replace_substring_all ("{"+"run_id"+"}", api_client.url_encode (run_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { RUN_OBJECT } l_response.data ({ RUN_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	run_step (thread_id: STRING_32; run_id: STRING_32; step_id: STRING_32): detachable RUN_STEP_OBJECT
			-- Retrieves a run step.
			-- 
			-- 
			-- argument: thread_id The ID of the thread to which the run and run step belongs. (required)
			-- 
			-- argument: run_id The ID of the run to which the run step belongs. (required)
			-- 
			-- argument: step_id The ID of the run step to retrieve. (required)
			-- 
			-- 
			-- Result RUN_STEP_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/threads/{thread_id}/runs/{run_id}/steps/{step_id}"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))
			l_path.replace_substring_all ("{"+"run_id"+"}", api_client.url_encode (run_id.out))
			l_path.replace_substring_all ("{"+"step_id"+"}", api_client.url_encode (step_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { RUN_STEP_OBJECT } l_response.data ({ RUN_STEP_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	submit_tool_ouputs_to_run (thread_id: STRING_32; run_id: STRING_32; submit_tool_outputs_run_request: SUBMIT_TOOL_OUTPUTS_RUN_REQUEST): detachable RUN_OBJECT
			-- When a run has the &#x60;status: \&quot;requires_action\&quot;&#x60; and &#x60;required_action.type&#x60; is &#x60;submit_tool_outputs&#x60;, this endpoint can be used to submit the outputs from the tool calls once they&#39;re all completed. All outputs must be submitted in a single request. 
			-- 
			-- 
			-- argument: thread_id The ID of the [thread](/docs/api-reference/threads) to which this run belongs. (required)
			-- 
			-- argument: run_id The ID of the run that requires the tool output submission. (required)
			-- 
			-- argument: submit_tool_outputs_run_request  (required)
			-- 
			-- 
			-- Result RUN_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(submit_tool_outputs_run_request)
			l_path := "/threads/{thread_id}/runs/{run_id}/submit_tool_outputs"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))
			l_path.replace_substring_all ("{"+"run_id"+"}", api_client.url_encode (run_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { RUN_OBJECT } l_response.data ({ RUN_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	thread (thread_id: STRING_32): detachable THREAD_OBJECT
			-- Retrieves a thread.
			-- 
			-- 
			-- argument: thread_id The ID of the thread to retrieve. (required)
			-- 
			-- 
			-- Result THREAD_OBJECT
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/threads/{thread_id}"
			l_path.replace_substring_all ("{"+"thread_id"+"}", api_client.url_encode (thread_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"ApiKeyAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { THREAD_OBJECT } l_response.data ({ THREAD_OBJECT }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end


end
