note
 description:"[
		OpenAI API
 		APIs for sampling from and fine-tuning language models
  		The version of the OpenAPI document: 2.0.0
 	    Contact: blah+oapicf@cliffano.com

  	NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

 		 Do not edit the class manually.
 	]"
	date: "$Date$"
	revision: "$Revision$"
	EIS:"Eiffel openapi generator", "src=https://openapi-generator.tech", "protocol=uri"

class
	OPENAI_API

inherit

    API_I


feature -- API Access


	cancel_fine_tune (fine_tune_id: STRING_32): detachable FINE_TUNE
			-- Immediately cancel a fine-tune job. 
			-- 
			-- 
			-- argument: fine_tune_id The ID of the fine-tune job to cancel  (required)
			-- 
			-- 
			-- Result FINE_TUNE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/fine-tunes/{fine_tune_id}/cancel"
			l_path.replace_substring_all ("{"+"fine_tune_id"+"}", api_client.url_encode (fine_tune_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { FINE_TUNE } l_response.data ({ FINE_TUNE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_chat_completion (create_chat_completion_request: CREATE_CHAT_COMPLETION_REQUEST): detachable CREATE_CHAT_COMPLETION_RESPONSE
			-- Creates a model response for the given chat conversation.
			-- 
			-- 
			-- argument: create_chat_completion_request  (required)
			-- 
			-- 
			-- Result CREATE_CHAT_COMPLETION_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(create_chat_completion_request)
			l_path := "/chat/completions"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { CREATE_CHAT_COMPLETION_RESPONSE } l_response.data ({ CREATE_CHAT_COMPLETION_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_completion (create_completion_request: CREATE_COMPLETION_REQUEST): detachable CREATE_COMPLETION_RESPONSE
			-- Creates a completion for the provided prompt and parameters.
			-- 
			-- 
			-- argument: create_completion_request  (required)
			-- 
			-- 
			-- Result CREATE_COMPLETION_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(create_completion_request)
			l_path := "/completions"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { CREATE_COMPLETION_RESPONSE } l_response.data ({ CREATE_COMPLETION_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_edit (create_edit_request: CREATE_EDIT_REQUEST): detachable CREATE_EDIT_RESPONSE
			-- Creates a new edit for the provided input, instruction, and parameters.
			-- 
			-- 
			-- argument: create_edit_request  (required)
			-- 
			-- 
			-- Result CREATE_EDIT_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(create_edit_request)
			l_path := "/edits"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { CREATE_EDIT_RESPONSE } l_response.data ({ CREATE_EDIT_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_embedding (create_embedding_request: CREATE_EMBEDDING_REQUEST): detachable CREATE_EMBEDDING_RESPONSE
			-- Creates an embedding vector representing the input text.
			-- 
			-- 
			-- argument: create_embedding_request  (required)
			-- 
			-- 
			-- Result CREATE_EMBEDDING_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(create_embedding_request)
			l_path := "/embeddings"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { CREATE_EMBEDDING_RESPONSE } l_response.data ({ CREATE_EMBEDDING_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_file (file: FILE; purpose: STRING_32): detachable OPEN_AI_FILE
			-- Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit. 
			-- 
			-- 
			-- argument: file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).  (required)
			-- 
			-- argument: purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.  (required)
			-- 
			-- 
			-- Result OPEN_AI_FILE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/files"

			if attached file as l_file then
				l_request.add_form(l_file,"file");
			end
			if attached purpose as l_purpose then
				l_request.add_form(l_purpose,"purpose");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"multipart/form-data">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { OPEN_AI_FILE } l_response.data ({ OPEN_AI_FILE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_fine_tune (create_fine_tune_request: CREATE_FINE_TUNE_REQUEST): detachable FINE_TUNE
			-- Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning) 
			-- 
			-- 
			-- argument: create_fine_tune_request  (required)
			-- 
			-- 
			-- Result FINE_TUNE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(create_fine_tune_request)
			l_path := "/fine-tunes"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { FINE_TUNE } l_response.data ({ FINE_TUNE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_image (create_image_request: CREATE_IMAGE_REQUEST): detachable IMAGES_RESPONSE
			-- Creates an image given a prompt.
			-- 
			-- 
			-- argument: create_image_request  (required)
			-- 
			-- 
			-- Result IMAGES_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(create_image_request)
			l_path := "/images/generations"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { IMAGES_RESPONSE } l_response.data ({ IMAGES_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_image_edit (image: FILE; prompt: STRING_32; mask: FILE; n: INTEGER_32; size: STRING_32; response_format: STRING_32; user: STRING_32): detachable IMAGES_RESPONSE
			-- Creates an edited or extended image given an original image and a prompt.
			-- 
			-- 
			-- argument: image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask. (required)
			-- 
			-- argument: prompt A text description of the desired image(s). The maximum length is 1000 characters. (required)
			-- 
			-- argument: mask An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;. (optional, default to null)
			-- 
			-- argument: n The number of images to generate. Must be between 1 and 10. (optional, default to 1)
			-- 
			-- argument: size The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;. (optional, default to 1024x1024)
			-- 
			-- argument: response_format The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;. (optional, default to url)
			-- 
			-- argument: user A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).  (optional, default to null)
			-- 
			-- 
			-- Result IMAGES_RESPONSE
		require
			n_is_less_or_equal_than: n <= 10
     		n_is_greater_or_equal_than: n >= 1
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/images/edits"

			if attached image as l_image then
				l_request.add_form(l_image,"image");
			end
			if attached mask as l_mask then
				l_request.add_form(l_mask,"mask");
			end
			if attached prompt as l_prompt then
				l_request.add_form(l_prompt,"prompt");
			end
			if attached n as l_n then
				l_request.add_form(l_n,"n");
			end
			if attached size as l_size then
				l_request.add_form(l_size,"size");
			end
			if attached response_format as l_response_format then
				l_request.add_form(l_response_format,"response_format");
			end
			if attached user as l_user then
				l_request.add_form(l_user,"user");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"multipart/form-data">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { IMAGES_RESPONSE } l_response.data ({ IMAGES_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_image_variation (image: FILE; n: INTEGER_32; size: STRING_32; response_format: STRING_32; user: STRING_32): detachable IMAGES_RESPONSE
			-- Creates a variation of a given image.
			-- 
			-- 
			-- argument: image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square. (required)
			-- 
			-- argument: n The number of images to generate. Must be between 1 and 10. (optional, default to 1)
			-- 
			-- argument: size The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;. (optional, default to 1024x1024)
			-- 
			-- argument: response_format The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;. (optional, default to url)
			-- 
			-- argument: user A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).  (optional, default to null)
			-- 
			-- 
			-- Result IMAGES_RESPONSE
		require
			n_is_less_or_equal_than: n <= 10
     		n_is_greater_or_equal_than: n >= 1
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/images/variations"

			if attached image as l_image then
				l_request.add_form(l_image,"image");
			end
			if attached n as l_n then
				l_request.add_form(l_n,"n");
			end
			if attached size as l_size then
				l_request.add_form(l_size,"size");
			end
			if attached response_format as l_response_format then
				l_request.add_form(l_response_format,"response_format");
			end
			if attached user as l_user then
				l_request.add_form(l_user,"user");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"multipart/form-data">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { IMAGES_RESPONSE } l_response.data ({ IMAGES_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_moderation (create_moderation_request: CREATE_MODERATION_REQUEST): detachable CREATE_MODERATION_RESPONSE
			-- Classifies if text violates OpenAI&#39;s Content Policy
			-- 
			-- 
			-- argument: create_moderation_request  (required)
			-- 
			-- 
			-- Result CREATE_MODERATION_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			l_request.set_body(create_moderation_request)
			l_path := "/moderations"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { CREATE_MODERATION_RESPONSE } l_response.data ({ CREATE_MODERATION_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_transcription (file: FILE; model: CREATE_TRANSCRIPTION_REQUEST_MODEL; prompt: STRING_32; response_format: STRING_32; temperature: REAL_32; language: STRING_32): detachable CREATE_TRANSCRIPTION_RESPONSE
			-- Transcribes audio into the input language.
			-- 
			-- 
			-- argument: file The audio file object (not file name) to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.  (required)
			-- 
			-- argument: model  (required)
			-- 
			-- argument: prompt An optional text to guide the model&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.  (optional, default to null)
			-- 
			-- argument: response_format The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.  (optional, default to json)
			-- 
			-- argument: temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.  (optional, default to 0)
			-- 
			-- argument: language The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.  (optional, default to null)
			-- 
			-- 
			-- Result CREATE_TRANSCRIPTION_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/audio/transcriptions"

			if attached file as l_file then
				l_request.add_form(l_file,"file");
			end
			if attached model as l_model then
				l_request.add_form(l_model,"model");
			end
			if attached prompt as l_prompt then
				l_request.add_form(l_prompt,"prompt");
			end
			if attached response_format as l_response_format then
				l_request.add_form(l_response_format,"response_format");
			end
			if attached temperature as l_temperature then
				l_request.add_form(l_temperature,"temperature");
			end
			if attached language as l_language then
				l_request.add_form(l_language,"language");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"multipart/form-data">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { CREATE_TRANSCRIPTION_RESPONSE } l_response.data ({ CREATE_TRANSCRIPTION_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	create_translation (file: FILE; model: CREATE_TRANSCRIPTION_REQUEST_MODEL; prompt: STRING_32; response_format: STRING_32; temperature: REAL_32): detachable CREATE_TRANSLATION_RESPONSE
			-- Translates audio into English.
			-- 
			-- 
			-- argument: file The audio file object (not file name) translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.  (required)
			-- 
			-- argument: model  (required)
			-- 
			-- argument: prompt An optional text to guide the model&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.  (optional, default to null)
			-- 
			-- argument: response_format The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.  (optional, default to json)
			-- 
			-- argument: temperature The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.  (optional, default to 0)
			-- 
			-- 
			-- Result CREATE_TRANSLATION_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/audio/translations"

			if attached file as l_file then
				l_request.add_form(l_file,"file");
			end
			if attached model as l_model then
				l_request.add_form(l_model,"model");
			end
			if attached prompt as l_prompt then
				l_request.add_form(l_prompt,"prompt");
			end
			if attached response_format as l_response_format then
				l_request.add_form(l_response_format,"response_format");
			end
			if attached temperature as l_temperature then
				l_request.add_form(l_temperature,"temperature");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"multipart/form-data">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { CREATE_TRANSLATION_RESPONSE } l_response.data ({ CREATE_TRANSLATION_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	delete_file (file_id: STRING_32): detachable DELETE_FILE_RESPONSE
			-- Delete a file.
			-- 
			-- 
			-- argument: file_id The ID of the file to use for this request (required)
			-- 
			-- 
			-- Result DELETE_FILE_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/files/{file_id}"
			l_path.replace_substring_all ("{"+"file_id"+"}", api_client.url_encode (file_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Delete", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { DELETE_FILE_RESPONSE } l_response.data ({ DELETE_FILE_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	delete_model (model: STRING_32): detachable DELETE_MODEL_RESPONSE
			-- Delete a fine-tuned model. You must have the Owner role in your organization.
			-- 
			-- 
			-- argument: model The model to delete (required)
			-- 
			-- 
			-- Result DELETE_MODEL_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/models/{model}"
			l_path.replace_substring_all ("{"+"model"+"}", api_client.url_encode (model.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Delete", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { DELETE_MODEL_RESPONSE } l_response.data ({ DELETE_MODEL_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	download_file (file_id: STRING_32): detachable STRING_32
			-- Returns the contents of the specified file
			-- 
			-- 
			-- argument: file_id The ID of the file to use for this request (required)
			-- 
			-- 
			-- Result STRING_32
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/files/{file_id}/content"
			l_path.replace_substring_all ("{"+"file_id"+"}", api_client.url_encode (file_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_32 } l_response.data ({ STRING_32 }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	list_files : detachable LIST_FILES_RESPONSE
			-- Returns a list of files that belong to the user&#39;s organization.
			-- 
			-- 
			-- 
			-- Result LIST_FILES_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/files"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST_FILES_RESPONSE } l_response.data ({ LIST_FILES_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	list_fine_tune_events (fine_tune_id: STRING_32; stream: BOOLEAN): detachable LIST_FINE_TUNE_EVENTS_RESPONSE
			-- Get fine-grained status updates for a fine-tune job. 
			-- 
			-- 
			-- argument: fine_tune_id The ID of the fine-tune job to get events for.  (required)
			-- 
			-- argument: stream Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.  (optional, default to false)
			-- 
			-- 
			-- Result LIST_FINE_TUNE_EVENTS_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/fine-tunes/{fine_tune_id}/events"
			l_path.replace_substring_all ("{"+"fine_tune_id"+"}", api_client.url_encode (fine_tune_id.out))
			l_request.fill_query_params(api_client.parameter_to_tuple("", "stream", stream));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST_FINE_TUNE_EVENTS_RESPONSE } l_response.data ({ LIST_FINE_TUNE_EVENTS_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	list_fine_tunes : detachable LIST_FINE_TUNES_RESPONSE
			-- List your organization&#39;s fine-tuning jobs 
			-- 
			-- 
			-- 
			-- Result LIST_FINE_TUNES_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/fine-tunes"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST_FINE_TUNES_RESPONSE } l_response.data ({ LIST_FINE_TUNES_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	list_models : detachable LIST_MODELS_RESPONSE
			-- Lists the currently available models, and provides basic information about each one such as the owner and availability.
			-- 
			-- 
			-- 
			-- Result LIST_MODELS_RESPONSE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/models"


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { LIST_MODELS_RESPONSE } l_response.data ({ LIST_MODELS_RESPONSE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	retrieve_file (file_id: STRING_32): detachable OPEN_AI_FILE
			-- Returns information about a specific file.
			-- 
			-- 
			-- argument: file_id The ID of the file to use for this request (required)
			-- 
			-- 
			-- Result OPEN_AI_FILE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/files/{file_id}"
			l_path.replace_substring_all ("{"+"file_id"+"}", api_client.url_encode (file_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { OPEN_AI_FILE } l_response.data ({ OPEN_AI_FILE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	retrieve_fine_tune (fine_tune_id: STRING_32): detachable FINE_TUNE
			-- Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning) 
			-- 
			-- 
			-- argument: fine_tune_id The ID of the fine-tune job  (required)
			-- 
			-- 
			-- Result FINE_TUNE
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/fine-tunes/{fine_tune_id}"
			l_path.replace_substring_all ("{"+"fine_tune_id"+"}", api_client.url_encode (fine_tune_id.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { FINE_TUNE } l_response.data ({ FINE_TUNE }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end

	retrieve_model (model: STRING_32): detachable MODEL
			-- Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
			-- 
			-- 
			-- argument: model The ID of the model to use for this request (required)
			-- 
			-- 
			-- Result MODEL
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/models/{model}"
			l_path.replace_substring_all ("{"+"model"+"}", api_client.url_encode (model.out))


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<>>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { MODEL } l_response.data ({ MODEL }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end


end
