// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * OpenAI API
 *
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * API version: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 */

package openapi

import (
	"net/http"
	"strings"
	"reflect"
)

// UsageAPIController binds http requests to an api service and writes the service results to the http response
type UsageAPIController struct {
	service UsageAPIServicer
	errorHandler ErrorHandler
}

// UsageAPIOption for how the controller is set up.
type UsageAPIOption func(*UsageAPIController)

// WithUsageAPIErrorHandler inject ErrorHandler into controller
func WithUsageAPIErrorHandler(h ErrorHandler) UsageAPIOption {
	return func(c *UsageAPIController) {
		c.errorHandler = h
	}
}

// NewUsageAPIController creates a default api controller
func NewUsageAPIController(s UsageAPIServicer, opts ...UsageAPIOption) *UsageAPIController {
	controller := &UsageAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the UsageAPIController
func (c *UsageAPIController) Routes() Routes {
	return Routes{
		"UsageCosts": Route{
			"UsageCosts",
			strings.ToUpper("Get"),
			"/v1/organization/costs",
			c.UsageCosts,
		},
		"UsageAudioSpeeches": Route{
			"UsageAudioSpeeches",
			strings.ToUpper("Get"),
			"/v1/organization/usage/audio_speeches",
			c.UsageAudioSpeeches,
		},
		"UsageAudioTranscriptions": Route{
			"UsageAudioTranscriptions",
			strings.ToUpper("Get"),
			"/v1/organization/usage/audio_transcriptions",
			c.UsageAudioTranscriptions,
		},
		"UsageCodeInterpreterSessions": Route{
			"UsageCodeInterpreterSessions",
			strings.ToUpper("Get"),
			"/v1/organization/usage/code_interpreter_sessions",
			c.UsageCodeInterpreterSessions,
		},
		"UsageCompletions": Route{
			"UsageCompletions",
			strings.ToUpper("Get"),
			"/v1/organization/usage/completions",
			c.UsageCompletions,
		},
		"UsageEmbeddings": Route{
			"UsageEmbeddings",
			strings.ToUpper("Get"),
			"/v1/organization/usage/embeddings",
			c.UsageEmbeddings,
		},
		"UsageImages": Route{
			"UsageImages",
			strings.ToUpper("Get"),
			"/v1/organization/usage/images",
			c.UsageImages,
		},
		"UsageModerations": Route{
			"UsageModerations",
			strings.ToUpper("Get"),
			"/v1/organization/usage/moderations",
			c.UsageModerations,
		},
		"UsageVectorStores": Route{
			"UsageVectorStores",
			strings.ToUpper("Get"),
			"/v1/organization/usage/vector_stores",
			c.UsageVectorStores,
		},
	}
}

// OrderedRoutes returns all the api routes in a deterministic order for the UsageAPIController
func (c *UsageAPIController) OrderedRoutes() []Route {
	return []Route{
		Route{
			"UsageCosts",
			strings.ToUpper("Get"),
			"/v1/organization/costs",
			c.UsageCosts,
		},
		Route{
			"UsageAudioSpeeches",
			strings.ToUpper("Get"),
			"/v1/organization/usage/audio_speeches",
			c.UsageAudioSpeeches,
		},
		Route{
			"UsageAudioTranscriptions",
			strings.ToUpper("Get"),
			"/v1/organization/usage/audio_transcriptions",
			c.UsageAudioTranscriptions,
		},
		Route{
			"UsageCodeInterpreterSessions",
			strings.ToUpper("Get"),
			"/v1/organization/usage/code_interpreter_sessions",
			c.UsageCodeInterpreterSessions,
		},
		Route{
			"UsageCompletions",
			strings.ToUpper("Get"),
			"/v1/organization/usage/completions",
			c.UsageCompletions,
		},
		Route{
			"UsageEmbeddings",
			strings.ToUpper("Get"),
			"/v1/organization/usage/embeddings",
			c.UsageEmbeddings,
		},
		Route{
			"UsageImages",
			strings.ToUpper("Get"),
			"/v1/organization/usage/images",
			c.UsageImages,
		},
		Route{
			"UsageModerations",
			strings.ToUpper("Get"),
			"/v1/organization/usage/moderations",
			c.UsageModerations,
		},
		Route{
			"UsageVectorStores",
			strings.ToUpper("Get"),
			"/v1/organization/usage/vector_stores",
			c.UsageVectorStores,
		},
	}
}



// UsageCosts - Get costs details for the organization.
func (c *UsageAPIController) UsageCosts(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var startTimeParam int32
	if query.Has("start_time") {
		param, err := parseNumericParameter[int32](
			query.Get("start_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start_time", Err: err}, nil)
			return
		}

		startTimeParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "start_time"}, nil)
		return
	}
	var endTimeParam int32
	if query.Has("end_time") {
		param, err := parseNumericParameter[int32](
			query.Get("end_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "end_time", Err: err}, nil)
			return
		}

		endTimeParam = param
	} else {
	}
	var bucketWidthParam string
	if query.Has("bucket_width") {
		param := query.Get("bucket_width")

		bucketWidthParam = param
	} else {
		param := "1d"
		bucketWidthParam = param
	}
	var projectIdsParam []string
	if query.Has("project_ids") {
		projectIdsParam = strings.Split(query.Get("project_ids"), ",")
	}
	var groupByParam []string
	if query.Has("group_by") {
		groupByParam = strings.Split(query.Get("group_by"), ",")
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
		var param int32 = 7
		limitParam = param
	}
	var pageParam string
	if query.Has("page") {
		param := query.Get("page")

		pageParam = param
	} else {
	}
	result, err := c.service.UsageCosts(r.Context(), startTimeParam, endTimeParam, bucketWidthParam, projectIdsParam, groupByParam, limitParam, pageParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// UsageAudioSpeeches - Get audio speeches usage details for the organization.
func (c *UsageAPIController) UsageAudioSpeeches(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var startTimeParam int32
	if query.Has("start_time") {
		param, err := parseNumericParameter[int32](
			query.Get("start_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start_time", Err: err}, nil)
			return
		}

		startTimeParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "start_time"}, nil)
		return
	}
	var endTimeParam int32
	if query.Has("end_time") {
		param, err := parseNumericParameter[int32](
			query.Get("end_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "end_time", Err: err}, nil)
			return
		}

		endTimeParam = param
	} else {
	}
	var bucketWidthParam string
	if query.Has("bucket_width") {
		param := query.Get("bucket_width")

		bucketWidthParam = param
	} else {
		param := "1d"
		bucketWidthParam = param
	}
	var projectIdsParam []string
	if query.Has("project_ids") {
		projectIdsParam = strings.Split(query.Get("project_ids"), ",")
	}
	var userIdsParam []string
	if query.Has("user_ids") {
		userIdsParam = strings.Split(query.Get("user_ids"), ",")
	}
	var apiKeyIdsParam []string
	if query.Has("api_key_ids") {
		apiKeyIdsParam = strings.Split(query.Get("api_key_ids"), ",")
	}
	var modelsParam []string
	if query.Has("models") {
		modelsParam = strings.Split(query.Get("models"), ",")
	}
	var groupByParam []string
	if query.Has("group_by") {
		groupByParam = strings.Split(query.Get("group_by"), ",")
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var pageParam string
	if query.Has("page") {
		param := query.Get("page")

		pageParam = param
	} else {
	}
	result, err := c.service.UsageAudioSpeeches(r.Context(), startTimeParam, endTimeParam, bucketWidthParam, projectIdsParam, userIdsParam, apiKeyIdsParam, modelsParam, groupByParam, limitParam, pageParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// UsageAudioTranscriptions - Get audio transcriptions usage details for the organization.
func (c *UsageAPIController) UsageAudioTranscriptions(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var startTimeParam int32
	if query.Has("start_time") {
		param, err := parseNumericParameter[int32](
			query.Get("start_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start_time", Err: err}, nil)
			return
		}

		startTimeParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "start_time"}, nil)
		return
	}
	var endTimeParam int32
	if query.Has("end_time") {
		param, err := parseNumericParameter[int32](
			query.Get("end_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "end_time", Err: err}, nil)
			return
		}

		endTimeParam = param
	} else {
	}
	var bucketWidthParam string
	if query.Has("bucket_width") {
		param := query.Get("bucket_width")

		bucketWidthParam = param
	} else {
		param := "1d"
		bucketWidthParam = param
	}
	var projectIdsParam []string
	if query.Has("project_ids") {
		projectIdsParam = strings.Split(query.Get("project_ids"), ",")
	}
	var userIdsParam []string
	if query.Has("user_ids") {
		userIdsParam = strings.Split(query.Get("user_ids"), ",")
	}
	var apiKeyIdsParam []string
	if query.Has("api_key_ids") {
		apiKeyIdsParam = strings.Split(query.Get("api_key_ids"), ",")
	}
	var modelsParam []string
	if query.Has("models") {
		modelsParam = strings.Split(query.Get("models"), ",")
	}
	var groupByParam []string
	if query.Has("group_by") {
		groupByParam = strings.Split(query.Get("group_by"), ",")
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var pageParam string
	if query.Has("page") {
		param := query.Get("page")

		pageParam = param
	} else {
	}
	result, err := c.service.UsageAudioTranscriptions(r.Context(), startTimeParam, endTimeParam, bucketWidthParam, projectIdsParam, userIdsParam, apiKeyIdsParam, modelsParam, groupByParam, limitParam, pageParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// UsageCodeInterpreterSessions - Get code interpreter sessions usage details for the organization.
func (c *UsageAPIController) UsageCodeInterpreterSessions(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var startTimeParam int32
	if query.Has("start_time") {
		param, err := parseNumericParameter[int32](
			query.Get("start_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start_time", Err: err}, nil)
			return
		}

		startTimeParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "start_time"}, nil)
		return
	}
	var endTimeParam int32
	if query.Has("end_time") {
		param, err := parseNumericParameter[int32](
			query.Get("end_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "end_time", Err: err}, nil)
			return
		}

		endTimeParam = param
	} else {
	}
	var bucketWidthParam string
	if query.Has("bucket_width") {
		param := query.Get("bucket_width")

		bucketWidthParam = param
	} else {
		param := "1d"
		bucketWidthParam = param
	}
	var projectIdsParam []string
	if query.Has("project_ids") {
		projectIdsParam = strings.Split(query.Get("project_ids"), ",")
	}
	var groupByParam []string
	if query.Has("group_by") {
		groupByParam = strings.Split(query.Get("group_by"), ",")
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var pageParam string
	if query.Has("page") {
		param := query.Get("page")

		pageParam = param
	} else {
	}
	result, err := c.service.UsageCodeInterpreterSessions(r.Context(), startTimeParam, endTimeParam, bucketWidthParam, projectIdsParam, groupByParam, limitParam, pageParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// UsageCompletions - Get completions usage details for the organization.
func (c *UsageAPIController) UsageCompletions(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var startTimeParam int32
	if query.Has("start_time") {
		param, err := parseNumericParameter[int32](
			query.Get("start_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start_time", Err: err}, nil)
			return
		}

		startTimeParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "start_time"}, nil)
		return
	}
	var endTimeParam int32
	if query.Has("end_time") {
		param, err := parseNumericParameter[int32](
			query.Get("end_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "end_time", Err: err}, nil)
			return
		}

		endTimeParam = param
	} else {
	}
	var bucketWidthParam string
	if query.Has("bucket_width") {
		param := query.Get("bucket_width")

		bucketWidthParam = param
	} else {
		param := "1d"
		bucketWidthParam = param
	}
	var projectIdsParam []string
	if query.Has("project_ids") {
		projectIdsParam = strings.Split(query.Get("project_ids"), ",")
	}
	var userIdsParam []string
	if query.Has("user_ids") {
		userIdsParam = strings.Split(query.Get("user_ids"), ",")
	}
	var apiKeyIdsParam []string
	if query.Has("api_key_ids") {
		apiKeyIdsParam = strings.Split(query.Get("api_key_ids"), ",")
	}
	var modelsParam []string
	if query.Has("models") {
		modelsParam = strings.Split(query.Get("models"), ",")
	}
	var batchParam bool
	if query.Has("batch") {
		param, err := parseBoolParameter(
			query.Get("batch"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "batch", Err: err}, nil)
			return
		}

		batchParam = param
	} else {
	}
	var groupByParam []string
	if query.Has("group_by") {
		groupByParam = strings.Split(query.Get("group_by"), ",")
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var pageParam string
	if query.Has("page") {
		param := query.Get("page")

		pageParam = param
	} else {
	}
	result, err := c.service.UsageCompletions(r.Context(), startTimeParam, endTimeParam, bucketWidthParam, projectIdsParam, userIdsParam, apiKeyIdsParam, modelsParam, batchParam, groupByParam, limitParam, pageParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// UsageEmbeddings - Get embeddings usage details for the organization.
func (c *UsageAPIController) UsageEmbeddings(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var startTimeParam int32
	if query.Has("start_time") {
		param, err := parseNumericParameter[int32](
			query.Get("start_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start_time", Err: err}, nil)
			return
		}

		startTimeParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "start_time"}, nil)
		return
	}
	var endTimeParam int32
	if query.Has("end_time") {
		param, err := parseNumericParameter[int32](
			query.Get("end_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "end_time", Err: err}, nil)
			return
		}

		endTimeParam = param
	} else {
	}
	var bucketWidthParam string
	if query.Has("bucket_width") {
		param := query.Get("bucket_width")

		bucketWidthParam = param
	} else {
		param := "1d"
		bucketWidthParam = param
	}
	var projectIdsParam []string
	if query.Has("project_ids") {
		projectIdsParam = strings.Split(query.Get("project_ids"), ",")
	}
	var userIdsParam []string
	if query.Has("user_ids") {
		userIdsParam = strings.Split(query.Get("user_ids"), ",")
	}
	var apiKeyIdsParam []string
	if query.Has("api_key_ids") {
		apiKeyIdsParam = strings.Split(query.Get("api_key_ids"), ",")
	}
	var modelsParam []string
	if query.Has("models") {
		modelsParam = strings.Split(query.Get("models"), ",")
	}
	var groupByParam []string
	if query.Has("group_by") {
		groupByParam = strings.Split(query.Get("group_by"), ",")
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var pageParam string
	if query.Has("page") {
		param := query.Get("page")

		pageParam = param
	} else {
	}
	result, err := c.service.UsageEmbeddings(r.Context(), startTimeParam, endTimeParam, bucketWidthParam, projectIdsParam, userIdsParam, apiKeyIdsParam, modelsParam, groupByParam, limitParam, pageParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// UsageImages - Get images usage details for the organization.
func (c *UsageAPIController) UsageImages(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var startTimeParam int32
	if query.Has("start_time") {
		param, err := parseNumericParameter[int32](
			query.Get("start_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start_time", Err: err}, nil)
			return
		}

		startTimeParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "start_time"}, nil)
		return
	}
	var endTimeParam int32
	if query.Has("end_time") {
		param, err := parseNumericParameter[int32](
			query.Get("end_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "end_time", Err: err}, nil)
			return
		}

		endTimeParam = param
	} else {
	}
	var bucketWidthParam string
	if query.Has("bucket_width") {
		param := query.Get("bucket_width")

		bucketWidthParam = param
	} else {
		param := "1d"
		bucketWidthParam = param
	}
	var sourcesParam []string
	if query.Has("sources") {
		sourcesParam = strings.Split(query.Get("sources"), ",")
	}
	var sizesParam []string
	if query.Has("sizes") {
		sizesParam = strings.Split(query.Get("sizes"), ",")
	}
	var projectIdsParam []string
	if query.Has("project_ids") {
		projectIdsParam = strings.Split(query.Get("project_ids"), ",")
	}
	var userIdsParam []string
	if query.Has("user_ids") {
		userIdsParam = strings.Split(query.Get("user_ids"), ",")
	}
	var apiKeyIdsParam []string
	if query.Has("api_key_ids") {
		apiKeyIdsParam = strings.Split(query.Get("api_key_ids"), ",")
	}
	var modelsParam []string
	if query.Has("models") {
		modelsParam = strings.Split(query.Get("models"), ",")
	}
	var groupByParam []string
	if query.Has("group_by") {
		groupByParam = strings.Split(query.Get("group_by"), ",")
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var pageParam string
	if query.Has("page") {
		param := query.Get("page")

		pageParam = param
	} else {
	}
	result, err := c.service.UsageImages(r.Context(), startTimeParam, endTimeParam, bucketWidthParam, sourcesParam, sizesParam, projectIdsParam, userIdsParam, apiKeyIdsParam, modelsParam, groupByParam, limitParam, pageParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// UsageModerations - Get moderations usage details for the organization.
func (c *UsageAPIController) UsageModerations(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var startTimeParam int32
	if query.Has("start_time") {
		param, err := parseNumericParameter[int32](
			query.Get("start_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start_time", Err: err}, nil)
			return
		}

		startTimeParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "start_time"}, nil)
		return
	}
	var endTimeParam int32
	if query.Has("end_time") {
		param, err := parseNumericParameter[int32](
			query.Get("end_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "end_time", Err: err}, nil)
			return
		}

		endTimeParam = param
	} else {
	}
	var bucketWidthParam string
	if query.Has("bucket_width") {
		param := query.Get("bucket_width")

		bucketWidthParam = param
	} else {
		param := "1d"
		bucketWidthParam = param
	}
	var projectIdsParam []string
	if query.Has("project_ids") {
		projectIdsParam = strings.Split(query.Get("project_ids"), ",")
	}
	var userIdsParam []string
	if query.Has("user_ids") {
		userIdsParam = strings.Split(query.Get("user_ids"), ",")
	}
	var apiKeyIdsParam []string
	if query.Has("api_key_ids") {
		apiKeyIdsParam = strings.Split(query.Get("api_key_ids"), ",")
	}
	var modelsParam []string
	if query.Has("models") {
		modelsParam = strings.Split(query.Get("models"), ",")
	}
	var groupByParam []string
	if query.Has("group_by") {
		groupByParam = strings.Split(query.Get("group_by"), ",")
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var pageParam string
	if query.Has("page") {
		param := query.Get("page")

		pageParam = param
	} else {
	}
	result, err := c.service.UsageModerations(r.Context(), startTimeParam, endTimeParam, bucketWidthParam, projectIdsParam, userIdsParam, apiKeyIdsParam, modelsParam, groupByParam, limitParam, pageParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// UsageVectorStores - Get vector stores usage details for the organization.
func (c *UsageAPIController) UsageVectorStores(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var startTimeParam int32
	if query.Has("start_time") {
		param, err := parseNumericParameter[int32](
			query.Get("start_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "start_time", Err: err}, nil)
			return
		}

		startTimeParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "start_time"}, nil)
		return
	}
	var endTimeParam int32
	if query.Has("end_time") {
		param, err := parseNumericParameter[int32](
			query.Get("end_time"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "end_time", Err: err}, nil)
			return
		}

		endTimeParam = param
	} else {
	}
	var bucketWidthParam string
	if query.Has("bucket_width") {
		param := query.Get("bucket_width")

		bucketWidthParam = param
	} else {
		param := "1d"
		bucketWidthParam = param
	}
	var projectIdsParam []string
	if query.Has("project_ids") {
		projectIdsParam = strings.Split(query.Get("project_ids"), ",")
	}
	var groupByParam []string
	if query.Has("group_by") {
		groupByParam = strings.Split(query.Get("group_by"), ",")
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var pageParam string
	if query.Has("page") {
		param := query.Get("page")

		pageParam = param
	} else {
	}
	result, err := c.service.UsageVectorStores(r.Context(), startTimeParam, endTimeParam, bucketWidthParam, projectIdsParam, groupByParam, limitParam, pageParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}
