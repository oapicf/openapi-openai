// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * OpenAI API
 *
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * API version: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 */

package openapi

import (
	"encoding/json"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
)

// VectorStoresAPIController binds http requests to an api service and writes the service results to the http response
type VectorStoresAPIController struct {
	service VectorStoresAPIServicer
	errorHandler ErrorHandler
}

// VectorStoresAPIOption for how the controller is set up.
type VectorStoresAPIOption func(*VectorStoresAPIController)

// WithVectorStoresAPIErrorHandler inject ErrorHandler into controller
func WithVectorStoresAPIErrorHandler(h ErrorHandler) VectorStoresAPIOption {
	return func(c *VectorStoresAPIController) {
		c.errorHandler = h
	}
}

// NewVectorStoresAPIController creates a default api controller
func NewVectorStoresAPIController(s VectorStoresAPIServicer, opts ...VectorStoresAPIOption) *VectorStoresAPIController {
	controller := &VectorStoresAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the VectorStoresAPIController
func (c *VectorStoresAPIController) Routes() Routes {
	return Routes{
		"ListVectorStores": Route{
			"ListVectorStores",
			strings.ToUpper("Get"),
			"/v1/vector_stores",
			c.ListVectorStores,
		},
		"CreateVectorStore": Route{
			"CreateVectorStore",
			strings.ToUpper("Post"),
			"/v1/vector_stores",
			c.CreateVectorStore,
		},
		"GetVectorStore": Route{
			"GetVectorStore",
			strings.ToUpper("Get"),
			"/v1/vector_stores/{vector_store_id}",
			c.GetVectorStore,
		},
		"ModifyVectorStore": Route{
			"ModifyVectorStore",
			strings.ToUpper("Post"),
			"/v1/vector_stores/{vector_store_id}",
			c.ModifyVectorStore,
		},
		"DeleteVectorStore": Route{
			"DeleteVectorStore",
			strings.ToUpper("Delete"),
			"/v1/vector_stores/{vector_store_id}",
			c.DeleteVectorStore,
		},
		"CreateVectorStoreFileBatch": Route{
			"CreateVectorStoreFileBatch",
			strings.ToUpper("Post"),
			"/v1/vector_stores/{vector_store_id}/file_batches",
			c.CreateVectorStoreFileBatch,
		},
		"GetVectorStoreFileBatch": Route{
			"GetVectorStoreFileBatch",
			strings.ToUpper("Get"),
			"/v1/vector_stores/{vector_store_id}/file_batches/{batch_id}",
			c.GetVectorStoreFileBatch,
		},
		"CancelVectorStoreFileBatch": Route{
			"CancelVectorStoreFileBatch",
			strings.ToUpper("Post"),
			"/v1/vector_stores/{vector_store_id}/file_batches/{batch_id}/cancel",
			c.CancelVectorStoreFileBatch,
		},
		"ListFilesInVectorStoreBatch": Route{
			"ListFilesInVectorStoreBatch",
			strings.ToUpper("Get"),
			"/v1/vector_stores/{vector_store_id}/file_batches/{batch_id}/files",
			c.ListFilesInVectorStoreBatch,
		},
		"ListVectorStoreFiles": Route{
			"ListVectorStoreFiles",
			strings.ToUpper("Get"),
			"/v1/vector_stores/{vector_store_id}/files",
			c.ListVectorStoreFiles,
		},
		"CreateVectorStoreFile": Route{
			"CreateVectorStoreFile",
			strings.ToUpper("Post"),
			"/v1/vector_stores/{vector_store_id}/files",
			c.CreateVectorStoreFile,
		},
		"GetVectorStoreFile": Route{
			"GetVectorStoreFile",
			strings.ToUpper("Get"),
			"/v1/vector_stores/{vector_store_id}/files/{file_id}",
			c.GetVectorStoreFile,
		},
		"DeleteVectorStoreFile": Route{
			"DeleteVectorStoreFile",
			strings.ToUpper("Delete"),
			"/v1/vector_stores/{vector_store_id}/files/{file_id}",
			c.DeleteVectorStoreFile,
		},
	}
}

// OrderedRoutes returns all the api routes in a deterministic order for the VectorStoresAPIController
func (c *VectorStoresAPIController) OrderedRoutes() []Route {
	return []Route{
		Route{
			"ListVectorStores",
			strings.ToUpper("Get"),
			"/v1/vector_stores",
			c.ListVectorStores,
		},
		Route{
			"CreateVectorStore",
			strings.ToUpper("Post"),
			"/v1/vector_stores",
			c.CreateVectorStore,
		},
		Route{
			"GetVectorStore",
			strings.ToUpper("Get"),
			"/v1/vector_stores/{vector_store_id}",
			c.GetVectorStore,
		},
		Route{
			"ModifyVectorStore",
			strings.ToUpper("Post"),
			"/v1/vector_stores/{vector_store_id}",
			c.ModifyVectorStore,
		},
		Route{
			"DeleteVectorStore",
			strings.ToUpper("Delete"),
			"/v1/vector_stores/{vector_store_id}",
			c.DeleteVectorStore,
		},
		Route{
			"CreateVectorStoreFileBatch",
			strings.ToUpper("Post"),
			"/v1/vector_stores/{vector_store_id}/file_batches",
			c.CreateVectorStoreFileBatch,
		},
		Route{
			"GetVectorStoreFileBatch",
			strings.ToUpper("Get"),
			"/v1/vector_stores/{vector_store_id}/file_batches/{batch_id}",
			c.GetVectorStoreFileBatch,
		},
		Route{
			"CancelVectorStoreFileBatch",
			strings.ToUpper("Post"),
			"/v1/vector_stores/{vector_store_id}/file_batches/{batch_id}/cancel",
			c.CancelVectorStoreFileBatch,
		},
		Route{
			"ListFilesInVectorStoreBatch",
			strings.ToUpper("Get"),
			"/v1/vector_stores/{vector_store_id}/file_batches/{batch_id}/files",
			c.ListFilesInVectorStoreBatch,
		},
		Route{
			"ListVectorStoreFiles",
			strings.ToUpper("Get"),
			"/v1/vector_stores/{vector_store_id}/files",
			c.ListVectorStoreFiles,
		},
		Route{
			"CreateVectorStoreFile",
			strings.ToUpper("Post"),
			"/v1/vector_stores/{vector_store_id}/files",
			c.CreateVectorStoreFile,
		},
		Route{
			"GetVectorStoreFile",
			strings.ToUpper("Get"),
			"/v1/vector_stores/{vector_store_id}/files/{file_id}",
			c.GetVectorStoreFile,
		},
		Route{
			"DeleteVectorStoreFile",
			strings.ToUpper("Delete"),
			"/v1/vector_stores/{vector_store_id}/files/{file_id}",
			c.DeleteVectorStoreFile,
		},
	}
}



// ListVectorStores - Returns a list of vector stores.
func (c *VectorStoresAPIController) ListVectorStores(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
		var param int32 = 20
		limitParam = param
	}
	var orderParam string
	if query.Has("order") {
		param := query.Get("order")

		orderParam = param
	} else {
		param := "desc"
		orderParam = param
	}
	var afterParam string
	if query.Has("after") {
		param := query.Get("after")

		afterParam = param
	} else {
	}
	var beforeParam string
	if query.Has("before") {
		param := query.Get("before")

		beforeParam = param
	} else {
	}
	result, err := c.service.ListVectorStores(r.Context(), limitParam, orderParam, afterParam, beforeParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// CreateVectorStore - Create a vector store.
func (c *VectorStoresAPIController) CreateVectorStore(w http.ResponseWriter, r *http.Request) {
	var createVectorStoreRequestParam CreateVectorStoreRequest
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&createVectorStoreRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertCreateVectorStoreRequestRequired(createVectorStoreRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertCreateVectorStoreRequestConstraints(createVectorStoreRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.CreateVectorStore(r.Context(), createVectorStoreRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetVectorStore - Retrieves a vector store.
func (c *VectorStoresAPIController) GetVectorStore(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	vectorStoreIdParam := params["vector_store_id"]
	if vectorStoreIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"vector_store_id"}, nil)
		return
	}
	result, err := c.service.GetVectorStore(r.Context(), vectorStoreIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// ModifyVectorStore - Modifies a vector store.
func (c *VectorStoresAPIController) ModifyVectorStore(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	vectorStoreIdParam := params["vector_store_id"]
	if vectorStoreIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"vector_store_id"}, nil)
		return
	}
	var updateVectorStoreRequestParam UpdateVectorStoreRequest
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&updateVectorStoreRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertUpdateVectorStoreRequestRequired(updateVectorStoreRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertUpdateVectorStoreRequestConstraints(updateVectorStoreRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.ModifyVectorStore(r.Context(), vectorStoreIdParam, updateVectorStoreRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// DeleteVectorStore - Delete a vector store.
func (c *VectorStoresAPIController) DeleteVectorStore(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	vectorStoreIdParam := params["vector_store_id"]
	if vectorStoreIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"vector_store_id"}, nil)
		return
	}
	result, err := c.service.DeleteVectorStore(r.Context(), vectorStoreIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// CreateVectorStoreFileBatch - Create a vector store file batch.
func (c *VectorStoresAPIController) CreateVectorStoreFileBatch(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	vectorStoreIdParam := params["vector_store_id"]
	if vectorStoreIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"vector_store_id"}, nil)
		return
	}
	var createVectorStoreFileBatchRequestParam CreateVectorStoreFileBatchRequest
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&createVectorStoreFileBatchRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertCreateVectorStoreFileBatchRequestRequired(createVectorStoreFileBatchRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertCreateVectorStoreFileBatchRequestConstraints(createVectorStoreFileBatchRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.CreateVectorStoreFileBatch(r.Context(), vectorStoreIdParam, createVectorStoreFileBatchRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetVectorStoreFileBatch - Retrieves a vector store file batch.
func (c *VectorStoresAPIController) GetVectorStoreFileBatch(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	vectorStoreIdParam := params["vector_store_id"]
	if vectorStoreIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"vector_store_id"}, nil)
		return
	}
	batchIdParam := params["batch_id"]
	if batchIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"batch_id"}, nil)
		return
	}
	result, err := c.service.GetVectorStoreFileBatch(r.Context(), vectorStoreIdParam, batchIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// CancelVectorStoreFileBatch - Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
func (c *VectorStoresAPIController) CancelVectorStoreFileBatch(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	vectorStoreIdParam := params["vector_store_id"]
	if vectorStoreIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"vector_store_id"}, nil)
		return
	}
	batchIdParam := params["batch_id"]
	if batchIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"batch_id"}, nil)
		return
	}
	result, err := c.service.CancelVectorStoreFileBatch(r.Context(), vectorStoreIdParam, batchIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// ListFilesInVectorStoreBatch - Returns a list of vector store files in a batch.
func (c *VectorStoresAPIController) ListFilesInVectorStoreBatch(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	vectorStoreIdParam := params["vector_store_id"]
	if vectorStoreIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"vector_store_id"}, nil)
		return
	}
	batchIdParam := params["batch_id"]
	if batchIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"batch_id"}, nil)
		return
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
		var param int32 = 20
		limitParam = param
	}
	var orderParam string
	if query.Has("order") {
		param := query.Get("order")

		orderParam = param
	} else {
		param := "desc"
		orderParam = param
	}
	var afterParam string
	if query.Has("after") {
		param := query.Get("after")

		afterParam = param
	} else {
	}
	var beforeParam string
	if query.Has("before") {
		param := query.Get("before")

		beforeParam = param
	} else {
	}
	var filterParam string
	if query.Has("filter") {
		param := query.Get("filter")

		filterParam = param
	} else {
	}
	result, err := c.service.ListFilesInVectorStoreBatch(r.Context(), vectorStoreIdParam, batchIdParam, limitParam, orderParam, afterParam, beforeParam, filterParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// ListVectorStoreFiles - Returns a list of vector store files.
func (c *VectorStoresAPIController) ListVectorStoreFiles(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	vectorStoreIdParam := params["vector_store_id"]
	if vectorStoreIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"vector_store_id"}, nil)
		return
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Param: "limit", Err: err}, nil)
			return
		}

		limitParam = param
	} else {
		var param int32 = 20
		limitParam = param
	}
	var orderParam string
	if query.Has("order") {
		param := query.Get("order")

		orderParam = param
	} else {
		param := "desc"
		orderParam = param
	}
	var afterParam string
	if query.Has("after") {
		param := query.Get("after")

		afterParam = param
	} else {
	}
	var beforeParam string
	if query.Has("before") {
		param := query.Get("before")

		beforeParam = param
	} else {
	}
	var filterParam string
	if query.Has("filter") {
		param := query.Get("filter")

		filterParam = param
	} else {
	}
	result, err := c.service.ListVectorStoreFiles(r.Context(), vectorStoreIdParam, limitParam, orderParam, afterParam, beforeParam, filterParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// CreateVectorStoreFile - Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
func (c *VectorStoresAPIController) CreateVectorStoreFile(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	vectorStoreIdParam := params["vector_store_id"]
	if vectorStoreIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"vector_store_id"}, nil)
		return
	}
	var createVectorStoreFileRequestParam CreateVectorStoreFileRequest
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&createVectorStoreFileRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertCreateVectorStoreFileRequestRequired(createVectorStoreFileRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertCreateVectorStoreFileRequestConstraints(createVectorStoreFileRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.CreateVectorStoreFile(r.Context(), vectorStoreIdParam, createVectorStoreFileRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetVectorStoreFile - Retrieves a vector store file.
func (c *VectorStoresAPIController) GetVectorStoreFile(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	vectorStoreIdParam := params["vector_store_id"]
	if vectorStoreIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"vector_store_id"}, nil)
		return
	}
	fileIdParam := params["file_id"]
	if fileIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"file_id"}, nil)
		return
	}
	result, err := c.service.GetVectorStoreFile(r.Context(), vectorStoreIdParam, fileIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}

// DeleteVectorStoreFile - Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
func (c *VectorStoresAPIController) DeleteVectorStoreFile(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	vectorStoreIdParam := params["vector_store_id"]
	if vectorStoreIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"vector_store_id"}, nil)
		return
	}
	fileIdParam := params["file_id"]
	if fileIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"file_id"}, nil)
		return
	}
	result, err := c.service.DeleteVectorStoreFile(r.Context(), vectorStoreIdParam, fileIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	_ = EncodeJSONResponse(result.Body, &result.Code, w)
}
