/*
OpenAI API

The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.

API version: 2.3.0
Contact: blah+oapicf@cliffano.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// UsageAPIService UsageAPI service
type UsageAPIService service

type ApiUsageAudioSpeechesRequest struct {
	ctx context.Context
	ApiService *UsageAPIService
	startTime *int32
	endTime *int32
	bucketWidth *string
	projectIds *[]string
	userIds *[]string
	apiKeyIds *[]string
	models *[]string
	groupBy *[]string
	limit *int32
	page *string
}

// Start time (Unix seconds) of the query time range, inclusive.
func (r ApiUsageAudioSpeechesRequest) StartTime(startTime int32) ApiUsageAudioSpeechesRequest {
	r.startTime = &startTime
	return r
}

// End time (Unix seconds) of the query time range, exclusive.
func (r ApiUsageAudioSpeechesRequest) EndTime(endTime int32) ApiUsageAudioSpeechesRequest {
	r.endTime = &endTime
	return r
}

// Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
func (r ApiUsageAudioSpeechesRequest) BucketWidth(bucketWidth string) ApiUsageAudioSpeechesRequest {
	r.bucketWidth = &bucketWidth
	return r
}

// Return only usage for these projects.
func (r ApiUsageAudioSpeechesRequest) ProjectIds(projectIds []string) ApiUsageAudioSpeechesRequest {
	r.projectIds = &projectIds
	return r
}

// Return only usage for these users.
func (r ApiUsageAudioSpeechesRequest) UserIds(userIds []string) ApiUsageAudioSpeechesRequest {
	r.userIds = &userIds
	return r
}

// Return only usage for these API keys.
func (r ApiUsageAudioSpeechesRequest) ApiKeyIds(apiKeyIds []string) ApiUsageAudioSpeechesRequest {
	r.apiKeyIds = &apiKeyIds
	return r
}

// Return only usage for these models.
func (r ApiUsageAudioSpeechesRequest) Models(models []string) ApiUsageAudioSpeechesRequest {
	r.models = &models
	return r
}

// Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
func (r ApiUsageAudioSpeechesRequest) GroupBy(groupBy []string) ApiUsageAudioSpeechesRequest {
	r.groupBy = &groupBy
	return r
}

// Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
func (r ApiUsageAudioSpeechesRequest) Limit(limit int32) ApiUsageAudioSpeechesRequest {
	r.limit = &limit
	return r
}

// A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
func (r ApiUsageAudioSpeechesRequest) Page(page string) ApiUsageAudioSpeechesRequest {
	r.page = &page
	return r
}

func (r ApiUsageAudioSpeechesRequest) Execute() (*UsageResponse, *http.Response, error) {
	return r.ApiService.UsageAudioSpeechesExecute(r)
}

/*
UsageAudioSpeeches Get audio speeches usage details for the organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsageAudioSpeechesRequest
*/
func (a *UsageAPIService) UsageAudioSpeeches(ctx context.Context) ApiUsageAudioSpeechesRequest {
	return ApiUsageAudioSpeechesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsageResponse
func (a *UsageAPIService) UsageAudioSpeechesExecute(r ApiUsageAudioSpeechesRequest) (*UsageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.UsageAudioSpeeches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organization/usage/audio_speeches"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "form", "")
	}
	if r.bucketWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", r.bucketWidth, "form", "")
	} else {
        var defaultValue string = "1d"
        parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", defaultValue, "form", "")
        r.bucketWidth = &defaultValue
	}
	if r.projectIds != nil {
		t := *r.projectIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", t, "form", "multi")
		}
	}
	if r.userIds != nil {
		t := *r.userIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_ids", t, "form", "multi")
		}
	}
	if r.apiKeyIds != nil {
		t := *r.apiKeyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "api_key_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "api_key_ids", t, "form", "multi")
		}
	}
	if r.models != nil {
		t := *r.models
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "models", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "models", t, "form", "multi")
		}
	}
	if r.groupBy != nil {
		t := *r.groupBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsageAudioTranscriptionsRequest struct {
	ctx context.Context
	ApiService *UsageAPIService
	startTime *int32
	endTime *int32
	bucketWidth *string
	projectIds *[]string
	userIds *[]string
	apiKeyIds *[]string
	models *[]string
	groupBy *[]string
	limit *int32
	page *string
}

// Start time (Unix seconds) of the query time range, inclusive.
func (r ApiUsageAudioTranscriptionsRequest) StartTime(startTime int32) ApiUsageAudioTranscriptionsRequest {
	r.startTime = &startTime
	return r
}

// End time (Unix seconds) of the query time range, exclusive.
func (r ApiUsageAudioTranscriptionsRequest) EndTime(endTime int32) ApiUsageAudioTranscriptionsRequest {
	r.endTime = &endTime
	return r
}

// Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
func (r ApiUsageAudioTranscriptionsRequest) BucketWidth(bucketWidth string) ApiUsageAudioTranscriptionsRequest {
	r.bucketWidth = &bucketWidth
	return r
}

// Return only usage for these projects.
func (r ApiUsageAudioTranscriptionsRequest) ProjectIds(projectIds []string) ApiUsageAudioTranscriptionsRequest {
	r.projectIds = &projectIds
	return r
}

// Return only usage for these users.
func (r ApiUsageAudioTranscriptionsRequest) UserIds(userIds []string) ApiUsageAudioTranscriptionsRequest {
	r.userIds = &userIds
	return r
}

// Return only usage for these API keys.
func (r ApiUsageAudioTranscriptionsRequest) ApiKeyIds(apiKeyIds []string) ApiUsageAudioTranscriptionsRequest {
	r.apiKeyIds = &apiKeyIds
	return r
}

// Return only usage for these models.
func (r ApiUsageAudioTranscriptionsRequest) Models(models []string) ApiUsageAudioTranscriptionsRequest {
	r.models = &models
	return r
}

// Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
func (r ApiUsageAudioTranscriptionsRequest) GroupBy(groupBy []string) ApiUsageAudioTranscriptionsRequest {
	r.groupBy = &groupBy
	return r
}

// Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
func (r ApiUsageAudioTranscriptionsRequest) Limit(limit int32) ApiUsageAudioTranscriptionsRequest {
	r.limit = &limit
	return r
}

// A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
func (r ApiUsageAudioTranscriptionsRequest) Page(page string) ApiUsageAudioTranscriptionsRequest {
	r.page = &page
	return r
}

func (r ApiUsageAudioTranscriptionsRequest) Execute() (*UsageResponse, *http.Response, error) {
	return r.ApiService.UsageAudioTranscriptionsExecute(r)
}

/*
UsageAudioTranscriptions Get audio transcriptions usage details for the organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsageAudioTranscriptionsRequest
*/
func (a *UsageAPIService) UsageAudioTranscriptions(ctx context.Context) ApiUsageAudioTranscriptionsRequest {
	return ApiUsageAudioTranscriptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsageResponse
func (a *UsageAPIService) UsageAudioTranscriptionsExecute(r ApiUsageAudioTranscriptionsRequest) (*UsageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.UsageAudioTranscriptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organization/usage/audio_transcriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "form", "")
	}
	if r.bucketWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", r.bucketWidth, "form", "")
	} else {
        var defaultValue string = "1d"
        parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", defaultValue, "form", "")
        r.bucketWidth = &defaultValue
	}
	if r.projectIds != nil {
		t := *r.projectIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", t, "form", "multi")
		}
	}
	if r.userIds != nil {
		t := *r.userIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_ids", t, "form", "multi")
		}
	}
	if r.apiKeyIds != nil {
		t := *r.apiKeyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "api_key_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "api_key_ids", t, "form", "multi")
		}
	}
	if r.models != nil {
		t := *r.models
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "models", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "models", t, "form", "multi")
		}
	}
	if r.groupBy != nil {
		t := *r.groupBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsageCodeInterpreterSessionsRequest struct {
	ctx context.Context
	ApiService *UsageAPIService
	startTime *int32
	endTime *int32
	bucketWidth *string
	projectIds *[]string
	groupBy *[]string
	limit *int32
	page *string
}

// Start time (Unix seconds) of the query time range, inclusive.
func (r ApiUsageCodeInterpreterSessionsRequest) StartTime(startTime int32) ApiUsageCodeInterpreterSessionsRequest {
	r.startTime = &startTime
	return r
}

// End time (Unix seconds) of the query time range, exclusive.
func (r ApiUsageCodeInterpreterSessionsRequest) EndTime(endTime int32) ApiUsageCodeInterpreterSessionsRequest {
	r.endTime = &endTime
	return r
}

// Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
func (r ApiUsageCodeInterpreterSessionsRequest) BucketWidth(bucketWidth string) ApiUsageCodeInterpreterSessionsRequest {
	r.bucketWidth = &bucketWidth
	return r
}

// Return only usage for these projects.
func (r ApiUsageCodeInterpreterSessionsRequest) ProjectIds(projectIds []string) ApiUsageCodeInterpreterSessionsRequest {
	r.projectIds = &projectIds
	return r
}

// Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;.
func (r ApiUsageCodeInterpreterSessionsRequest) GroupBy(groupBy []string) ApiUsageCodeInterpreterSessionsRequest {
	r.groupBy = &groupBy
	return r
}

// Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
func (r ApiUsageCodeInterpreterSessionsRequest) Limit(limit int32) ApiUsageCodeInterpreterSessionsRequest {
	r.limit = &limit
	return r
}

// A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
func (r ApiUsageCodeInterpreterSessionsRequest) Page(page string) ApiUsageCodeInterpreterSessionsRequest {
	r.page = &page
	return r
}

func (r ApiUsageCodeInterpreterSessionsRequest) Execute() (*UsageResponse, *http.Response, error) {
	return r.ApiService.UsageCodeInterpreterSessionsExecute(r)
}

/*
UsageCodeInterpreterSessions Get code interpreter sessions usage details for the organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsageCodeInterpreterSessionsRequest
*/
func (a *UsageAPIService) UsageCodeInterpreterSessions(ctx context.Context) ApiUsageCodeInterpreterSessionsRequest {
	return ApiUsageCodeInterpreterSessionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsageResponse
func (a *UsageAPIService) UsageCodeInterpreterSessionsExecute(r ApiUsageCodeInterpreterSessionsRequest) (*UsageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.UsageCodeInterpreterSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organization/usage/code_interpreter_sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "form", "")
	}
	if r.bucketWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", r.bucketWidth, "form", "")
	} else {
        var defaultValue string = "1d"
        parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", defaultValue, "form", "")
        r.bucketWidth = &defaultValue
	}
	if r.projectIds != nil {
		t := *r.projectIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", t, "form", "multi")
		}
	}
	if r.groupBy != nil {
		t := *r.groupBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsageCompletionsRequest struct {
	ctx context.Context
	ApiService *UsageAPIService
	startTime *int32
	endTime *int32
	bucketWidth *string
	projectIds *[]string
	userIds *[]string
	apiKeyIds *[]string
	models *[]string
	batch *bool
	groupBy *[]string
	limit *int32
	page *string
}

// Start time (Unix seconds) of the query time range, inclusive.
func (r ApiUsageCompletionsRequest) StartTime(startTime int32) ApiUsageCompletionsRequest {
	r.startTime = &startTime
	return r
}

// End time (Unix seconds) of the query time range, exclusive.
func (r ApiUsageCompletionsRequest) EndTime(endTime int32) ApiUsageCompletionsRequest {
	r.endTime = &endTime
	return r
}

// Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
func (r ApiUsageCompletionsRequest) BucketWidth(bucketWidth string) ApiUsageCompletionsRequest {
	r.bucketWidth = &bucketWidth
	return r
}

// Return only usage for these projects.
func (r ApiUsageCompletionsRequest) ProjectIds(projectIds []string) ApiUsageCompletionsRequest {
	r.projectIds = &projectIds
	return r
}

// Return only usage for these users.
func (r ApiUsageCompletionsRequest) UserIds(userIds []string) ApiUsageCompletionsRequest {
	r.userIds = &userIds
	return r
}

// Return only usage for these API keys.
func (r ApiUsageCompletionsRequest) ApiKeyIds(apiKeyIds []string) ApiUsageCompletionsRequest {
	r.apiKeyIds = &apiKeyIds
	return r
}

// Return only usage for these models.
func (r ApiUsageCompletionsRequest) Models(models []string) ApiUsageCompletionsRequest {
	r.models = &models
	return r
}

// If &#x60;true&#x60;, return batch jobs only. If &#x60;false&#x60;, return non-batch jobs only. By default, return both. 
func (r ApiUsageCompletionsRequest) Batch(batch bool) ApiUsageCompletionsRequest {
	r.batch = &batch
	return r
}

// Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;batch&#x60; or any combination of them.
func (r ApiUsageCompletionsRequest) GroupBy(groupBy []string) ApiUsageCompletionsRequest {
	r.groupBy = &groupBy
	return r
}

// Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
func (r ApiUsageCompletionsRequest) Limit(limit int32) ApiUsageCompletionsRequest {
	r.limit = &limit
	return r
}

// A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
func (r ApiUsageCompletionsRequest) Page(page string) ApiUsageCompletionsRequest {
	r.page = &page
	return r
}

func (r ApiUsageCompletionsRequest) Execute() (*UsageResponse, *http.Response, error) {
	return r.ApiService.UsageCompletionsExecute(r)
}

/*
UsageCompletions Get completions usage details for the organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsageCompletionsRequest
*/
func (a *UsageAPIService) UsageCompletions(ctx context.Context) ApiUsageCompletionsRequest {
	return ApiUsageCompletionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsageResponse
func (a *UsageAPIService) UsageCompletionsExecute(r ApiUsageCompletionsRequest) (*UsageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.UsageCompletions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organization/usage/completions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "form", "")
	}
	if r.bucketWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", r.bucketWidth, "form", "")
	} else {
        var defaultValue string = "1d"
        parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", defaultValue, "form", "")
        r.bucketWidth = &defaultValue
	}
	if r.projectIds != nil {
		t := *r.projectIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", t, "form", "multi")
		}
	}
	if r.userIds != nil {
		t := *r.userIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_ids", t, "form", "multi")
		}
	}
	if r.apiKeyIds != nil {
		t := *r.apiKeyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "api_key_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "api_key_ids", t, "form", "multi")
		}
	}
	if r.models != nil {
		t := *r.models
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "models", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "models", t, "form", "multi")
		}
	}
	if r.batch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batch", r.batch, "form", "")
	}
	if r.groupBy != nil {
		t := *r.groupBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsageCostsRequest struct {
	ctx context.Context
	ApiService *UsageAPIService
	startTime *int32
	endTime *int32
	bucketWidth *string
	projectIds *[]string
	groupBy *[]string
	limit *int32
	page *string
}

// Start time (Unix seconds) of the query time range, inclusive.
func (r ApiUsageCostsRequest) StartTime(startTime int32) ApiUsageCostsRequest {
	r.startTime = &startTime
	return r
}

// End time (Unix seconds) of the query time range, exclusive.
func (r ApiUsageCostsRequest) EndTime(endTime int32) ApiUsageCostsRequest {
	r.endTime = &endTime
	return r
}

// Width of each time bucket in response. Currently only &#x60;1d&#x60; is supported, default to &#x60;1d&#x60;.
func (r ApiUsageCostsRequest) BucketWidth(bucketWidth string) ApiUsageCostsRequest {
	r.bucketWidth = &bucketWidth
	return r
}

// Return only costs for these projects.
func (r ApiUsageCostsRequest) ProjectIds(projectIds []string) ApiUsageCostsRequest {
	r.projectIds = &projectIds
	return r
}

// Group the costs by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;line_item&#x60; and any combination of them.
func (r ApiUsageCostsRequest) GroupBy(groupBy []string) ApiUsageCostsRequest {
	r.groupBy = &groupBy
	return r
}

// A limit on the number of buckets to be returned. Limit can range between 1 and 180, and the default is 7. 
func (r ApiUsageCostsRequest) Limit(limit int32) ApiUsageCostsRequest {
	r.limit = &limit
	return r
}

// A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
func (r ApiUsageCostsRequest) Page(page string) ApiUsageCostsRequest {
	r.page = &page
	return r
}

func (r ApiUsageCostsRequest) Execute() (*UsageResponse, *http.Response, error) {
	return r.ApiService.UsageCostsExecute(r)
}

/*
UsageCosts Get costs details for the organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsageCostsRequest
*/
func (a *UsageAPIService) UsageCosts(ctx context.Context) ApiUsageCostsRequest {
	return ApiUsageCostsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsageResponse
func (a *UsageAPIService) UsageCostsExecute(r ApiUsageCostsRequest) (*UsageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.UsageCosts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organization/costs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "form", "")
	}
	if r.bucketWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", r.bucketWidth, "form", "")
	} else {
        var defaultValue string = "1d"
        parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", defaultValue, "form", "")
        r.bucketWidth = &defaultValue
	}
	if r.projectIds != nil {
		t := *r.projectIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", t, "form", "multi")
		}
	}
	if r.groupBy != nil {
		t := *r.groupBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
        var defaultValue int32 = 7
        parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
        r.limit = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsageEmbeddingsRequest struct {
	ctx context.Context
	ApiService *UsageAPIService
	startTime *int32
	endTime *int32
	bucketWidth *string
	projectIds *[]string
	userIds *[]string
	apiKeyIds *[]string
	models *[]string
	groupBy *[]string
	limit *int32
	page *string
}

// Start time (Unix seconds) of the query time range, inclusive.
func (r ApiUsageEmbeddingsRequest) StartTime(startTime int32) ApiUsageEmbeddingsRequest {
	r.startTime = &startTime
	return r
}

// End time (Unix seconds) of the query time range, exclusive.
func (r ApiUsageEmbeddingsRequest) EndTime(endTime int32) ApiUsageEmbeddingsRequest {
	r.endTime = &endTime
	return r
}

// Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
func (r ApiUsageEmbeddingsRequest) BucketWidth(bucketWidth string) ApiUsageEmbeddingsRequest {
	r.bucketWidth = &bucketWidth
	return r
}

// Return only usage for these projects.
func (r ApiUsageEmbeddingsRequest) ProjectIds(projectIds []string) ApiUsageEmbeddingsRequest {
	r.projectIds = &projectIds
	return r
}

// Return only usage for these users.
func (r ApiUsageEmbeddingsRequest) UserIds(userIds []string) ApiUsageEmbeddingsRequest {
	r.userIds = &userIds
	return r
}

// Return only usage for these API keys.
func (r ApiUsageEmbeddingsRequest) ApiKeyIds(apiKeyIds []string) ApiUsageEmbeddingsRequest {
	r.apiKeyIds = &apiKeyIds
	return r
}

// Return only usage for these models.
func (r ApiUsageEmbeddingsRequest) Models(models []string) ApiUsageEmbeddingsRequest {
	r.models = &models
	return r
}

// Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
func (r ApiUsageEmbeddingsRequest) GroupBy(groupBy []string) ApiUsageEmbeddingsRequest {
	r.groupBy = &groupBy
	return r
}

// Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
func (r ApiUsageEmbeddingsRequest) Limit(limit int32) ApiUsageEmbeddingsRequest {
	r.limit = &limit
	return r
}

// A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
func (r ApiUsageEmbeddingsRequest) Page(page string) ApiUsageEmbeddingsRequest {
	r.page = &page
	return r
}

func (r ApiUsageEmbeddingsRequest) Execute() (*UsageResponse, *http.Response, error) {
	return r.ApiService.UsageEmbeddingsExecute(r)
}

/*
UsageEmbeddings Get embeddings usage details for the organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsageEmbeddingsRequest
*/
func (a *UsageAPIService) UsageEmbeddings(ctx context.Context) ApiUsageEmbeddingsRequest {
	return ApiUsageEmbeddingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsageResponse
func (a *UsageAPIService) UsageEmbeddingsExecute(r ApiUsageEmbeddingsRequest) (*UsageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.UsageEmbeddings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organization/usage/embeddings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "form", "")
	}
	if r.bucketWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", r.bucketWidth, "form", "")
	} else {
        var defaultValue string = "1d"
        parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", defaultValue, "form", "")
        r.bucketWidth = &defaultValue
	}
	if r.projectIds != nil {
		t := *r.projectIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", t, "form", "multi")
		}
	}
	if r.userIds != nil {
		t := *r.userIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_ids", t, "form", "multi")
		}
	}
	if r.apiKeyIds != nil {
		t := *r.apiKeyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "api_key_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "api_key_ids", t, "form", "multi")
		}
	}
	if r.models != nil {
		t := *r.models
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "models", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "models", t, "form", "multi")
		}
	}
	if r.groupBy != nil {
		t := *r.groupBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsageImagesRequest struct {
	ctx context.Context
	ApiService *UsageAPIService
	startTime *int32
	endTime *int32
	bucketWidth *string
	sources *[]string
	sizes *[]string
	projectIds *[]string
	userIds *[]string
	apiKeyIds *[]string
	models *[]string
	groupBy *[]string
	limit *int32
	page *string
}

// Start time (Unix seconds) of the query time range, inclusive.
func (r ApiUsageImagesRequest) StartTime(startTime int32) ApiUsageImagesRequest {
	r.startTime = &startTime
	return r
}

// End time (Unix seconds) of the query time range, exclusive.
func (r ApiUsageImagesRequest) EndTime(endTime int32) ApiUsageImagesRequest {
	r.endTime = &endTime
	return r
}

// Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
func (r ApiUsageImagesRequest) BucketWidth(bucketWidth string) ApiUsageImagesRequest {
	r.bucketWidth = &bucketWidth
	return r
}

// Return only usages for these sources. Possible values are &#x60;image.generation&#x60;, &#x60;image.edit&#x60;, &#x60;image.variation&#x60; or any combination of them.
func (r ApiUsageImagesRequest) Sources(sources []string) ApiUsageImagesRequest {
	r.sources = &sources
	return r
}

// Return only usages for these image sizes. Possible values are &#x60;256x256&#x60;, &#x60;512x512&#x60;, &#x60;1024x1024&#x60;, &#x60;1792x1792&#x60;, &#x60;1024x1792&#x60; or any combination of them.
func (r ApiUsageImagesRequest) Sizes(sizes []string) ApiUsageImagesRequest {
	r.sizes = &sizes
	return r
}

// Return only usage for these projects.
func (r ApiUsageImagesRequest) ProjectIds(projectIds []string) ApiUsageImagesRequest {
	r.projectIds = &projectIds
	return r
}

// Return only usage for these users.
func (r ApiUsageImagesRequest) UserIds(userIds []string) ApiUsageImagesRequest {
	r.userIds = &userIds
	return r
}

// Return only usage for these API keys.
func (r ApiUsageImagesRequest) ApiKeyIds(apiKeyIds []string) ApiUsageImagesRequest {
	r.apiKeyIds = &apiKeyIds
	return r
}

// Return only usage for these models.
func (r ApiUsageImagesRequest) Models(models []string) ApiUsageImagesRequest {
	r.models = &models
	return r
}

// Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;size&#x60;, &#x60;source&#x60; or any combination of them.
func (r ApiUsageImagesRequest) GroupBy(groupBy []string) ApiUsageImagesRequest {
	r.groupBy = &groupBy
	return r
}

// Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
func (r ApiUsageImagesRequest) Limit(limit int32) ApiUsageImagesRequest {
	r.limit = &limit
	return r
}

// A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
func (r ApiUsageImagesRequest) Page(page string) ApiUsageImagesRequest {
	r.page = &page
	return r
}

func (r ApiUsageImagesRequest) Execute() (*UsageResponse, *http.Response, error) {
	return r.ApiService.UsageImagesExecute(r)
}

/*
UsageImages Get images usage details for the organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsageImagesRequest
*/
func (a *UsageAPIService) UsageImages(ctx context.Context) ApiUsageImagesRequest {
	return ApiUsageImagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsageResponse
func (a *UsageAPIService) UsageImagesExecute(r ApiUsageImagesRequest) (*UsageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.UsageImages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organization/usage/images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "form", "")
	}
	if r.bucketWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", r.bucketWidth, "form", "")
	} else {
        var defaultValue string = "1d"
        parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", defaultValue, "form", "")
        r.bucketWidth = &defaultValue
	}
	if r.sources != nil {
		t := *r.sources
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sources", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sources", t, "form", "multi")
		}
	}
	if r.sizes != nil {
		t := *r.sizes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sizes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sizes", t, "form", "multi")
		}
	}
	if r.projectIds != nil {
		t := *r.projectIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", t, "form", "multi")
		}
	}
	if r.userIds != nil {
		t := *r.userIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_ids", t, "form", "multi")
		}
	}
	if r.apiKeyIds != nil {
		t := *r.apiKeyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "api_key_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "api_key_ids", t, "form", "multi")
		}
	}
	if r.models != nil {
		t := *r.models
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "models", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "models", t, "form", "multi")
		}
	}
	if r.groupBy != nil {
		t := *r.groupBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsageModerationsRequest struct {
	ctx context.Context
	ApiService *UsageAPIService
	startTime *int32
	endTime *int32
	bucketWidth *string
	projectIds *[]string
	userIds *[]string
	apiKeyIds *[]string
	models *[]string
	groupBy *[]string
	limit *int32
	page *string
}

// Start time (Unix seconds) of the query time range, inclusive.
func (r ApiUsageModerationsRequest) StartTime(startTime int32) ApiUsageModerationsRequest {
	r.startTime = &startTime
	return r
}

// End time (Unix seconds) of the query time range, exclusive.
func (r ApiUsageModerationsRequest) EndTime(endTime int32) ApiUsageModerationsRequest {
	r.endTime = &endTime
	return r
}

// Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
func (r ApiUsageModerationsRequest) BucketWidth(bucketWidth string) ApiUsageModerationsRequest {
	r.bucketWidth = &bucketWidth
	return r
}

// Return only usage for these projects.
func (r ApiUsageModerationsRequest) ProjectIds(projectIds []string) ApiUsageModerationsRequest {
	r.projectIds = &projectIds
	return r
}

// Return only usage for these users.
func (r ApiUsageModerationsRequest) UserIds(userIds []string) ApiUsageModerationsRequest {
	r.userIds = &userIds
	return r
}

// Return only usage for these API keys.
func (r ApiUsageModerationsRequest) ApiKeyIds(apiKeyIds []string) ApiUsageModerationsRequest {
	r.apiKeyIds = &apiKeyIds
	return r
}

// Return only usage for these models.
func (r ApiUsageModerationsRequest) Models(models []string) ApiUsageModerationsRequest {
	r.models = &models
	return r
}

// Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
func (r ApiUsageModerationsRequest) GroupBy(groupBy []string) ApiUsageModerationsRequest {
	r.groupBy = &groupBy
	return r
}

// Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
func (r ApiUsageModerationsRequest) Limit(limit int32) ApiUsageModerationsRequest {
	r.limit = &limit
	return r
}

// A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
func (r ApiUsageModerationsRequest) Page(page string) ApiUsageModerationsRequest {
	r.page = &page
	return r
}

func (r ApiUsageModerationsRequest) Execute() (*UsageResponse, *http.Response, error) {
	return r.ApiService.UsageModerationsExecute(r)
}

/*
UsageModerations Get moderations usage details for the organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsageModerationsRequest
*/
func (a *UsageAPIService) UsageModerations(ctx context.Context) ApiUsageModerationsRequest {
	return ApiUsageModerationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsageResponse
func (a *UsageAPIService) UsageModerationsExecute(r ApiUsageModerationsRequest) (*UsageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.UsageModerations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organization/usage/moderations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "form", "")
	}
	if r.bucketWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", r.bucketWidth, "form", "")
	} else {
        var defaultValue string = "1d"
        parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", defaultValue, "form", "")
        r.bucketWidth = &defaultValue
	}
	if r.projectIds != nil {
		t := *r.projectIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", t, "form", "multi")
		}
	}
	if r.userIds != nil {
		t := *r.userIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_ids", t, "form", "multi")
		}
	}
	if r.apiKeyIds != nil {
		t := *r.apiKeyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "api_key_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "api_key_ids", t, "form", "multi")
		}
	}
	if r.models != nil {
		t := *r.models
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "models", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "models", t, "form", "multi")
		}
	}
	if r.groupBy != nil {
		t := *r.groupBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUsageVectorStoresRequest struct {
	ctx context.Context
	ApiService *UsageAPIService
	startTime *int32
	endTime *int32
	bucketWidth *string
	projectIds *[]string
	groupBy *[]string
	limit *int32
	page *string
}

// Start time (Unix seconds) of the query time range, inclusive.
func (r ApiUsageVectorStoresRequest) StartTime(startTime int32) ApiUsageVectorStoresRequest {
	r.startTime = &startTime
	return r
}

// End time (Unix seconds) of the query time range, exclusive.
func (r ApiUsageVectorStoresRequest) EndTime(endTime int32) ApiUsageVectorStoresRequest {
	r.endTime = &endTime
	return r
}

// Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
func (r ApiUsageVectorStoresRequest) BucketWidth(bucketWidth string) ApiUsageVectorStoresRequest {
	r.bucketWidth = &bucketWidth
	return r
}

// Return only usage for these projects.
func (r ApiUsageVectorStoresRequest) ProjectIds(projectIds []string) ApiUsageVectorStoresRequest {
	r.projectIds = &projectIds
	return r
}

// Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;.
func (r ApiUsageVectorStoresRequest) GroupBy(groupBy []string) ApiUsageVectorStoresRequest {
	r.groupBy = &groupBy
	return r
}

// Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
func (r ApiUsageVectorStoresRequest) Limit(limit int32) ApiUsageVectorStoresRequest {
	r.limit = &limit
	return r
}

// A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
func (r ApiUsageVectorStoresRequest) Page(page string) ApiUsageVectorStoresRequest {
	r.page = &page
	return r
}

func (r ApiUsageVectorStoresRequest) Execute() (*UsageResponse, *http.Response, error) {
	return r.ApiService.UsageVectorStoresExecute(r)
}

/*
UsageVectorStores Get vector stores usage details for the organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUsageVectorStoresRequest
*/
func (a *UsageAPIService) UsageVectorStores(ctx context.Context) ApiUsageVectorStoresRequest {
	return ApiUsageVectorStoresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsageResponse
func (a *UsageAPIService) UsageVectorStoresExecute(r ApiUsageVectorStoresRequest) (*UsageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.UsageVectorStores")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organization/usage/vector_stores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "form", "")
	}
	if r.bucketWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", r.bucketWidth, "form", "")
	} else {
        var defaultValue string = "1d"
        parameterAddToHeaderOrQuery(localVarQueryParams, "bucket_width", defaultValue, "form", "")
        r.bucketWidth = &defaultValue
	}
	if r.projectIds != nil {
		t := *r.projectIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "project_ids", t, "form", "multi")
		}
	}
	if r.groupBy != nil {
		t := *r.groupBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_by", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
