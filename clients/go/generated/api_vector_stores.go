/*
OpenAI API

The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.

API version: 2.3.0
Contact: blah+oapicf@cliffano.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// VectorStoresAPIService VectorStoresAPI service
type VectorStoresAPIService service

type ApiCancelVectorStoreFileBatchRequest struct {
	ctx context.Context
	ApiService *VectorStoresAPIService
	vectorStoreId string
	batchId string
}

func (r ApiCancelVectorStoreFileBatchRequest) Execute() (*VectorStoreFileBatchObject, *http.Response, error) {
	return r.ApiService.CancelVectorStoreFileBatchExecute(r)
}

/*
CancelVectorStoreFileBatch Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vectorStoreId The ID of the vector store that the file batch belongs to.
 @param batchId The ID of the file batch to cancel.
 @return ApiCancelVectorStoreFileBatchRequest
*/
func (a *VectorStoresAPIService) CancelVectorStoreFileBatch(ctx context.Context, vectorStoreId string, batchId string) ApiCancelVectorStoreFileBatchRequest {
	return ApiCancelVectorStoreFileBatchRequest{
		ApiService: a,
		ctx: ctx,
		vectorStoreId: vectorStoreId,
		batchId: batchId,
	}
}

// Execute executes the request
//  @return VectorStoreFileBatchObject
func (a *VectorStoresAPIService) CancelVectorStoreFileBatchExecute(r ApiCancelVectorStoreFileBatchRequest) (*VectorStoreFileBatchObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VectorStoreFileBatchObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VectorStoresAPIService.CancelVectorStoreFileBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vector_stores/{vector_store_id}/file_batches/{batch_id}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"vector_store_id"+"}", url.PathEscape(parameterValueToString(r.vectorStoreId, "vectorStoreId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"batch_id"+"}", url.PathEscape(parameterValueToString(r.batchId, "batchId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVectorStoreRequest struct {
	ctx context.Context
	ApiService *VectorStoresAPIService
	createVectorStoreRequest *CreateVectorStoreRequest
}

func (r ApiCreateVectorStoreRequest) CreateVectorStoreRequest(createVectorStoreRequest CreateVectorStoreRequest) ApiCreateVectorStoreRequest {
	r.createVectorStoreRequest = &createVectorStoreRequest
	return r
}

func (r ApiCreateVectorStoreRequest) Execute() (*VectorStoreObject, *http.Response, error) {
	return r.ApiService.CreateVectorStoreExecute(r)
}

/*
CreateVectorStore Create a vector store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVectorStoreRequest
*/
func (a *VectorStoresAPIService) CreateVectorStore(ctx context.Context) ApiCreateVectorStoreRequest {
	return ApiCreateVectorStoreRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VectorStoreObject
func (a *VectorStoresAPIService) CreateVectorStoreExecute(r ApiCreateVectorStoreRequest) (*VectorStoreObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VectorStoreObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VectorStoresAPIService.CreateVectorStore")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vector_stores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVectorStoreRequest == nil {
		return localVarReturnValue, nil, reportError("createVectorStoreRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVectorStoreRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVectorStoreFileRequest struct {
	ctx context.Context
	ApiService *VectorStoresAPIService
	vectorStoreId string
	createVectorStoreFileRequest *CreateVectorStoreFileRequest
}

func (r ApiCreateVectorStoreFileRequest) CreateVectorStoreFileRequest(createVectorStoreFileRequest CreateVectorStoreFileRequest) ApiCreateVectorStoreFileRequest {
	r.createVectorStoreFileRequest = &createVectorStoreFileRequest
	return r
}

func (r ApiCreateVectorStoreFileRequest) Execute() (*VectorStoreFileObject, *http.Response, error) {
	return r.ApiService.CreateVectorStoreFileExecute(r)
}

/*
CreateVectorStoreFile Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vectorStoreId The ID of the vector store for which to create a File. 
 @return ApiCreateVectorStoreFileRequest
*/
func (a *VectorStoresAPIService) CreateVectorStoreFile(ctx context.Context, vectorStoreId string) ApiCreateVectorStoreFileRequest {
	return ApiCreateVectorStoreFileRequest{
		ApiService: a,
		ctx: ctx,
		vectorStoreId: vectorStoreId,
	}
}

// Execute executes the request
//  @return VectorStoreFileObject
func (a *VectorStoresAPIService) CreateVectorStoreFileExecute(r ApiCreateVectorStoreFileRequest) (*VectorStoreFileObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VectorStoreFileObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VectorStoresAPIService.CreateVectorStoreFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vector_stores/{vector_store_id}/files"
	localVarPath = strings.Replace(localVarPath, "{"+"vector_store_id"+"}", url.PathEscape(parameterValueToString(r.vectorStoreId, "vectorStoreId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVectorStoreFileRequest == nil {
		return localVarReturnValue, nil, reportError("createVectorStoreFileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVectorStoreFileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVectorStoreFileBatchRequest struct {
	ctx context.Context
	ApiService *VectorStoresAPIService
	vectorStoreId string
	createVectorStoreFileBatchRequest *CreateVectorStoreFileBatchRequest
}

func (r ApiCreateVectorStoreFileBatchRequest) CreateVectorStoreFileBatchRequest(createVectorStoreFileBatchRequest CreateVectorStoreFileBatchRequest) ApiCreateVectorStoreFileBatchRequest {
	r.createVectorStoreFileBatchRequest = &createVectorStoreFileBatchRequest
	return r
}

func (r ApiCreateVectorStoreFileBatchRequest) Execute() (*VectorStoreFileBatchObject, *http.Response, error) {
	return r.ApiService.CreateVectorStoreFileBatchExecute(r)
}

/*
CreateVectorStoreFileBatch Create a vector store file batch.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vectorStoreId The ID of the vector store for which to create a File Batch. 
 @return ApiCreateVectorStoreFileBatchRequest
*/
func (a *VectorStoresAPIService) CreateVectorStoreFileBatch(ctx context.Context, vectorStoreId string) ApiCreateVectorStoreFileBatchRequest {
	return ApiCreateVectorStoreFileBatchRequest{
		ApiService: a,
		ctx: ctx,
		vectorStoreId: vectorStoreId,
	}
}

// Execute executes the request
//  @return VectorStoreFileBatchObject
func (a *VectorStoresAPIService) CreateVectorStoreFileBatchExecute(r ApiCreateVectorStoreFileBatchRequest) (*VectorStoreFileBatchObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VectorStoreFileBatchObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VectorStoresAPIService.CreateVectorStoreFileBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vector_stores/{vector_store_id}/file_batches"
	localVarPath = strings.Replace(localVarPath, "{"+"vector_store_id"+"}", url.PathEscape(parameterValueToString(r.vectorStoreId, "vectorStoreId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createVectorStoreFileBatchRequest == nil {
		return localVarReturnValue, nil, reportError("createVectorStoreFileBatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createVectorStoreFileBatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVectorStoreRequest struct {
	ctx context.Context
	ApiService *VectorStoresAPIService
	vectorStoreId string
}

func (r ApiDeleteVectorStoreRequest) Execute() (*DeleteVectorStoreResponse, *http.Response, error) {
	return r.ApiService.DeleteVectorStoreExecute(r)
}

/*
DeleteVectorStore Delete a vector store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vectorStoreId The ID of the vector store to delete.
 @return ApiDeleteVectorStoreRequest
*/
func (a *VectorStoresAPIService) DeleteVectorStore(ctx context.Context, vectorStoreId string) ApiDeleteVectorStoreRequest {
	return ApiDeleteVectorStoreRequest{
		ApiService: a,
		ctx: ctx,
		vectorStoreId: vectorStoreId,
	}
}

// Execute executes the request
//  @return DeleteVectorStoreResponse
func (a *VectorStoresAPIService) DeleteVectorStoreExecute(r ApiDeleteVectorStoreRequest) (*DeleteVectorStoreResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteVectorStoreResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VectorStoresAPIService.DeleteVectorStore")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vector_stores/{vector_store_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vector_store_id"+"}", url.PathEscape(parameterValueToString(r.vectorStoreId, "vectorStoreId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVectorStoreFileRequest struct {
	ctx context.Context
	ApiService *VectorStoresAPIService
	vectorStoreId string
	fileId string
}

func (r ApiDeleteVectorStoreFileRequest) Execute() (*DeleteVectorStoreFileResponse, *http.Response, error) {
	return r.ApiService.DeleteVectorStoreFileExecute(r)
}

/*
DeleteVectorStoreFile Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vectorStoreId The ID of the vector store that the file belongs to.
 @param fileId The ID of the file to delete.
 @return ApiDeleteVectorStoreFileRequest
*/
func (a *VectorStoresAPIService) DeleteVectorStoreFile(ctx context.Context, vectorStoreId string, fileId string) ApiDeleteVectorStoreFileRequest {
	return ApiDeleteVectorStoreFileRequest{
		ApiService: a,
		ctx: ctx,
		vectorStoreId: vectorStoreId,
		fileId: fileId,
	}
}

// Execute executes the request
//  @return DeleteVectorStoreFileResponse
func (a *VectorStoresAPIService) DeleteVectorStoreFileExecute(r ApiDeleteVectorStoreFileRequest) (*DeleteVectorStoreFileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteVectorStoreFileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VectorStoresAPIService.DeleteVectorStoreFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vector_stores/{vector_store_id}/files/{file_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vector_store_id"+"}", url.PathEscape(parameterValueToString(r.vectorStoreId, "vectorStoreId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"file_id"+"}", url.PathEscape(parameterValueToString(r.fileId, "fileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVectorStoreRequest struct {
	ctx context.Context
	ApiService *VectorStoresAPIService
	vectorStoreId string
}

func (r ApiGetVectorStoreRequest) Execute() (*VectorStoreObject, *http.Response, error) {
	return r.ApiService.GetVectorStoreExecute(r)
}

/*
GetVectorStore Retrieves a vector store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vectorStoreId The ID of the vector store to retrieve.
 @return ApiGetVectorStoreRequest
*/
func (a *VectorStoresAPIService) GetVectorStore(ctx context.Context, vectorStoreId string) ApiGetVectorStoreRequest {
	return ApiGetVectorStoreRequest{
		ApiService: a,
		ctx: ctx,
		vectorStoreId: vectorStoreId,
	}
}

// Execute executes the request
//  @return VectorStoreObject
func (a *VectorStoresAPIService) GetVectorStoreExecute(r ApiGetVectorStoreRequest) (*VectorStoreObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VectorStoreObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VectorStoresAPIService.GetVectorStore")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vector_stores/{vector_store_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vector_store_id"+"}", url.PathEscape(parameterValueToString(r.vectorStoreId, "vectorStoreId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVectorStoreFileRequest struct {
	ctx context.Context
	ApiService *VectorStoresAPIService
	vectorStoreId string
	fileId string
}

func (r ApiGetVectorStoreFileRequest) Execute() (*VectorStoreFileObject, *http.Response, error) {
	return r.ApiService.GetVectorStoreFileExecute(r)
}

/*
GetVectorStoreFile Retrieves a vector store file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vectorStoreId The ID of the vector store that the file belongs to.
 @param fileId The ID of the file being retrieved.
 @return ApiGetVectorStoreFileRequest
*/
func (a *VectorStoresAPIService) GetVectorStoreFile(ctx context.Context, vectorStoreId string, fileId string) ApiGetVectorStoreFileRequest {
	return ApiGetVectorStoreFileRequest{
		ApiService: a,
		ctx: ctx,
		vectorStoreId: vectorStoreId,
		fileId: fileId,
	}
}

// Execute executes the request
//  @return VectorStoreFileObject
func (a *VectorStoresAPIService) GetVectorStoreFileExecute(r ApiGetVectorStoreFileRequest) (*VectorStoreFileObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VectorStoreFileObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VectorStoresAPIService.GetVectorStoreFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vector_stores/{vector_store_id}/files/{file_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vector_store_id"+"}", url.PathEscape(parameterValueToString(r.vectorStoreId, "vectorStoreId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"file_id"+"}", url.PathEscape(parameterValueToString(r.fileId, "fileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVectorStoreFileBatchRequest struct {
	ctx context.Context
	ApiService *VectorStoresAPIService
	vectorStoreId string
	batchId string
}

func (r ApiGetVectorStoreFileBatchRequest) Execute() (*VectorStoreFileBatchObject, *http.Response, error) {
	return r.ApiService.GetVectorStoreFileBatchExecute(r)
}

/*
GetVectorStoreFileBatch Retrieves a vector store file batch.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vectorStoreId The ID of the vector store that the file batch belongs to.
 @param batchId The ID of the file batch being retrieved.
 @return ApiGetVectorStoreFileBatchRequest
*/
func (a *VectorStoresAPIService) GetVectorStoreFileBatch(ctx context.Context, vectorStoreId string, batchId string) ApiGetVectorStoreFileBatchRequest {
	return ApiGetVectorStoreFileBatchRequest{
		ApiService: a,
		ctx: ctx,
		vectorStoreId: vectorStoreId,
		batchId: batchId,
	}
}

// Execute executes the request
//  @return VectorStoreFileBatchObject
func (a *VectorStoresAPIService) GetVectorStoreFileBatchExecute(r ApiGetVectorStoreFileBatchRequest) (*VectorStoreFileBatchObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VectorStoreFileBatchObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VectorStoresAPIService.GetVectorStoreFileBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vector_stores/{vector_store_id}/file_batches/{batch_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vector_store_id"+"}", url.PathEscape(parameterValueToString(r.vectorStoreId, "vectorStoreId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"batch_id"+"}", url.PathEscape(parameterValueToString(r.batchId, "batchId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFilesInVectorStoreBatchRequest struct {
	ctx context.Context
	ApiService *VectorStoresAPIService
	vectorStoreId string
	batchId string
	limit *int32
	order *string
	after *string
	before *string
	filter *string
}

// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
func (r ApiListFilesInVectorStoreBatchRequest) Limit(limit int32) ApiListFilesInVectorStoreBatchRequest {
	r.limit = &limit
	return r
}

// Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
func (r ApiListFilesInVectorStoreBatchRequest) Order(order string) ApiListFilesInVectorStoreBatchRequest {
	r.order = &order
	return r
}

// A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
func (r ApiListFilesInVectorStoreBatchRequest) After(after string) ApiListFilesInVectorStoreBatchRequest {
	r.after = &after
	return r
}

// A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
func (r ApiListFilesInVectorStoreBatchRequest) Before(before string) ApiListFilesInVectorStoreBatchRequest {
	r.before = &before
	return r
}

// Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
func (r ApiListFilesInVectorStoreBatchRequest) Filter(filter string) ApiListFilesInVectorStoreBatchRequest {
	r.filter = &filter
	return r
}

func (r ApiListFilesInVectorStoreBatchRequest) Execute() (*ListVectorStoreFilesResponse, *http.Response, error) {
	return r.ApiService.ListFilesInVectorStoreBatchExecute(r)
}

/*
ListFilesInVectorStoreBatch Returns a list of vector store files in a batch.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vectorStoreId The ID of the vector store that the files belong to.
 @param batchId The ID of the file batch that the files belong to.
 @return ApiListFilesInVectorStoreBatchRequest
*/
func (a *VectorStoresAPIService) ListFilesInVectorStoreBatch(ctx context.Context, vectorStoreId string, batchId string) ApiListFilesInVectorStoreBatchRequest {
	return ApiListFilesInVectorStoreBatchRequest{
		ApiService: a,
		ctx: ctx,
		vectorStoreId: vectorStoreId,
		batchId: batchId,
	}
}

// Execute executes the request
//  @return ListVectorStoreFilesResponse
func (a *VectorStoresAPIService) ListFilesInVectorStoreBatchExecute(r ApiListFilesInVectorStoreBatchRequest) (*ListVectorStoreFilesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListVectorStoreFilesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VectorStoresAPIService.ListFilesInVectorStoreBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vector_stores/{vector_store_id}/file_batches/{batch_id}/files"
	localVarPath = strings.Replace(localVarPath, "{"+"vector_store_id"+"}", url.PathEscape(parameterValueToString(r.vectorStoreId, "vectorStoreId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"batch_id"+"}", url.PathEscape(parameterValueToString(r.batchId, "batchId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
        var defaultValue int32 = 20
        parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
        r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVectorStoreFilesRequest struct {
	ctx context.Context
	ApiService *VectorStoresAPIService
	vectorStoreId string
	limit *int32
	order *string
	after *string
	before *string
	filter *string
}

// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
func (r ApiListVectorStoreFilesRequest) Limit(limit int32) ApiListVectorStoreFilesRequest {
	r.limit = &limit
	return r
}

// Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
func (r ApiListVectorStoreFilesRequest) Order(order string) ApiListVectorStoreFilesRequest {
	r.order = &order
	return r
}

// A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
func (r ApiListVectorStoreFilesRequest) After(after string) ApiListVectorStoreFilesRequest {
	r.after = &after
	return r
}

// A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
func (r ApiListVectorStoreFilesRequest) Before(before string) ApiListVectorStoreFilesRequest {
	r.before = &before
	return r
}

// Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
func (r ApiListVectorStoreFilesRequest) Filter(filter string) ApiListVectorStoreFilesRequest {
	r.filter = &filter
	return r
}

func (r ApiListVectorStoreFilesRequest) Execute() (*ListVectorStoreFilesResponse, *http.Response, error) {
	return r.ApiService.ListVectorStoreFilesExecute(r)
}

/*
ListVectorStoreFiles Returns a list of vector store files.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vectorStoreId The ID of the vector store that the files belong to.
 @return ApiListVectorStoreFilesRequest
*/
func (a *VectorStoresAPIService) ListVectorStoreFiles(ctx context.Context, vectorStoreId string) ApiListVectorStoreFilesRequest {
	return ApiListVectorStoreFilesRequest{
		ApiService: a,
		ctx: ctx,
		vectorStoreId: vectorStoreId,
	}
}

// Execute executes the request
//  @return ListVectorStoreFilesResponse
func (a *VectorStoresAPIService) ListVectorStoreFilesExecute(r ApiListVectorStoreFilesRequest) (*ListVectorStoreFilesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListVectorStoreFilesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VectorStoresAPIService.ListVectorStoreFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vector_stores/{vector_store_id}/files"
	localVarPath = strings.Replace(localVarPath, "{"+"vector_store_id"+"}", url.PathEscape(parameterValueToString(r.vectorStoreId, "vectorStoreId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
        var defaultValue int32 = 20
        parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
        r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVectorStoresRequest struct {
	ctx context.Context
	ApiService *VectorStoresAPIService
	limit *int32
	order *string
	after *string
	before *string
}

// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
func (r ApiListVectorStoresRequest) Limit(limit int32) ApiListVectorStoresRequest {
	r.limit = &limit
	return r
}

// Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
func (r ApiListVectorStoresRequest) Order(order string) ApiListVectorStoresRequest {
	r.order = &order
	return r
}

// A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
func (r ApiListVectorStoresRequest) After(after string) ApiListVectorStoresRequest {
	r.after = &after
	return r
}

// A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
func (r ApiListVectorStoresRequest) Before(before string) ApiListVectorStoresRequest {
	r.before = &before
	return r
}

func (r ApiListVectorStoresRequest) Execute() (*ListVectorStoresResponse, *http.Response, error) {
	return r.ApiService.ListVectorStoresExecute(r)
}

/*
ListVectorStores Returns a list of vector stores.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVectorStoresRequest
*/
func (a *VectorStoresAPIService) ListVectorStores(ctx context.Context) ApiListVectorStoresRequest {
	return ApiListVectorStoresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListVectorStoresResponse
func (a *VectorStoresAPIService) ListVectorStoresExecute(r ApiListVectorStoresRequest) (*ListVectorStoresResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListVectorStoresResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VectorStoresAPIService.ListVectorStores")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vector_stores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
        var defaultValue int32 = 20
        parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
        r.limit = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	} else {
        var defaultValue string = "desc"
        parameterAddToHeaderOrQuery(localVarQueryParams, "order", defaultValue, "form", "")
        r.order = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiModifyVectorStoreRequest struct {
	ctx context.Context
	ApiService *VectorStoresAPIService
	vectorStoreId string
	updateVectorStoreRequest *UpdateVectorStoreRequest
}

func (r ApiModifyVectorStoreRequest) UpdateVectorStoreRequest(updateVectorStoreRequest UpdateVectorStoreRequest) ApiModifyVectorStoreRequest {
	r.updateVectorStoreRequest = &updateVectorStoreRequest
	return r
}

func (r ApiModifyVectorStoreRequest) Execute() (*VectorStoreObject, *http.Response, error) {
	return r.ApiService.ModifyVectorStoreExecute(r)
}

/*
ModifyVectorStore Modifies a vector store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vectorStoreId The ID of the vector store to modify.
 @return ApiModifyVectorStoreRequest
*/
func (a *VectorStoresAPIService) ModifyVectorStore(ctx context.Context, vectorStoreId string) ApiModifyVectorStoreRequest {
	return ApiModifyVectorStoreRequest{
		ApiService: a,
		ctx: ctx,
		vectorStoreId: vectorStoreId,
	}
}

// Execute executes the request
//  @return VectorStoreObject
func (a *VectorStoresAPIService) ModifyVectorStoreExecute(r ApiModifyVectorStoreRequest) (*VectorStoreObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VectorStoreObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VectorStoresAPIService.ModifyVectorStore")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vector_stores/{vector_store_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vector_store_id"+"}", url.PathEscape(parameterValueToString(r.vectorStoreId, "vectorStoreId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateVectorStoreRequest == nil {
		return localVarReturnValue, nil, reportError("updateVectorStoreRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateVectorStoreRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
