// @flow
/* eslint-disable no-use-before-define */
/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://api.openai.com/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type AdminApiKey = {
    /**
     * 
     * @type {string}
     * @memberof AdminApiKey
     */
    _object?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminApiKey
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminApiKey
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminApiKey
     */
    redacted_value?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminApiKey
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof AdminApiKey
     */
    created_at?: number;
    /**
     * 
     * @type {AdminApiKeyOwner}
     * @memberof AdminApiKey
     */
    owner?: AdminApiKeyOwner;
}

/**
 * 
 * @export
 */
export type AdminApiKeyOwner = {
    /**
     * 
     * @type {string}
     * @memberof AdminApiKeyOwner
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminApiKeyOwner
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminApiKeyOwner
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof AdminApiKeyOwner
     */
    created_at?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminApiKeyOwner
     */
    role?: string;
}

/**
 * 
 * @export
 */
export type AdminApiKeysCreateRequest = {
    /**
     * 
     * @type {string}
     * @memberof AdminApiKeysCreateRequest
     */
    name: string;
}

/**
 * 
 * @export
 */
export type AdminApiKeysDelete200Response = {
    /**
     * 
     * @type {string}
     * @memberof AdminApiKeysDelete200Response
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminApiKeysDelete200Response
     */
    _object?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AdminApiKeysDelete200Response
     */
    deleted?: boolean;
}

/**
 * 
 * @export
 */
export type ApiKeyList = {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyList
     */
    _object?: string;
    /**
     * 
     * @type {Array<AdminApiKey>}
     * @memberof ApiKeyList
     */
    data?: Array<AdminApiKey>;
    /**
     * 
     * @type {boolean}
     * @memberof ApiKeyList
     */
    has_more?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyList
     */
    first_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyList
     */
    last_id?: string;
}


            export type ArrayOfContentPartsInnerTypeEnum = 'image_file' | 'image_url' | 'text';
/**
 * 
 * @export
 */
export type ArrayOfContentPartsInner = {
    /**
     * Always `image_file`.
     * @type {string}
     * @memberof ArrayOfContentPartsInner
     */
    type: ArrayOfContentPartsInnerTypeEnum;
    /**
     * 
     * @type {MessageContentImageFileObjectImageFile}
     * @memberof ArrayOfContentPartsInner
     */
    image_file: MessageContentImageFileObjectImageFile;
    /**
     * 
     * @type {MessageContentImageUrlObjectImageUrl}
     * @memberof ArrayOfContentPartsInner
     */
    image_url: MessageContentImageUrlObjectImageUrl;
    /**
     * Text content to be sent to the model
     * @type {string}
     * @memberof ArrayOfContentPartsInner
     */
    text: string;
}


            export type AssistantObjectObjectEnum = 'assistant';
/**
 * Represents an `assistant` that can call the model and use tools.
 * @export
 */
export type AssistantObject = {
    /**
     * The identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof AssistantObject
     */
    id: string;
    /**
     * The object type, which is always `assistant`.
     * @type {string}
     * @memberof AssistantObject
     */
    _object: AssistantObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the assistant was created.
     * @type {number}
     * @memberof AssistantObject
     */
    created_at: number;
    /**
     * The name of the assistant. The maximum length is 256 characters. 
     * @type {string}
     * @memberof AssistantObject
     */
    name: string;
    /**
     * The description of the assistant. The maximum length is 512 characters. 
     * @type {string}
     * @memberof AssistantObject
     */
    description: string;
    /**
     * ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them. 
     * @type {string}
     * @memberof AssistantObject
     */
    model: string;
    /**
     * The system instructions that the assistant uses. The maximum length is 256,000 characters. 
     * @type {string}
     * @memberof AssistantObject
     */
    instructions: string;
    /**
     * A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`. 
     * @type {Array<AssistantObjectToolsInner>}
     * @memberof AssistantObject
     */
    tools: Array<AssistantObjectToolsInner>;
    /**
     * 
     * @type {AssistantObjectToolResources}
     * @memberof AssistantObject
     */
    tool_resources?: AssistantObjectToolResources;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof AssistantObject
     */
    metadata: Object;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
     * @type {number}
     * @memberof AssistantObject
     */
    temperature?: number;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
     * @type {number}
     * @memberof AssistantObject
     */
    top_p?: number;
    /**
     * 
     * @type {AssistantsApiResponseFormatOption}
     * @memberof AssistantObject
     */
    response_format?: AssistantsApiResponseFormatOption;
}

/**
 * A set of resources that are used by the assistant\'s tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
 * @export
 */
export type AssistantObjectToolResources = {
    /**
     * 
     * @type {AssistantObjectToolResourcesCodeInterpreter}
     * @memberof AssistantObjectToolResources
     */
    code_interpreter?: AssistantObjectToolResourcesCodeInterpreter;
    /**
     * 
     * @type {AssistantObjectToolResourcesFileSearch}
     * @memberof AssistantObjectToolResources
     */
    file_search?: AssistantObjectToolResourcesFileSearch;
}

/**
 * 
 * @export
 */
export type AssistantObjectToolResourcesCodeInterpreter = {
    /**
     * A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter`` tool. There can be a maximum of 20 files associated with the tool. 
     * @type {Array<string>}
     * @memberof AssistantObjectToolResourcesCodeInterpreter
     */
    file_ids?: Array<string>;
}

/**
 * 
 * @export
 */
export type AssistantObjectToolResourcesFileSearch = {
    /**
     * The ID of the [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant. 
     * @type {Array<string>}
     * @memberof AssistantObjectToolResourcesFileSearch
     */
    vector_store_ids?: Array<string>;
}


            export type AssistantObjectToolsInnerTypeEnum = 'code_interpreter' | 'file_search' | 'function';
/**
 * 
 * @export
 */
export type AssistantObjectToolsInner = {
    /**
     * The type of tool being defined: `code_interpreter`
     * @type {string}
     * @memberof AssistantObjectToolsInner
     */
    type: AssistantObjectToolsInnerTypeEnum;
    /**
     * 
     * @type {AssistantToolsFileSearchFileSearch}
     * @memberof AssistantObjectToolsInner
     */
    file_search?: AssistantToolsFileSearchFileSearch;
    /**
     * 
     * @type {FunctionObject}
     * @memberof AssistantObjectToolsInner
     */
    _function: FunctionObject;
}


            export type AssistantStreamEventEventEnum = 'done';

            export type AssistantStreamEventDataEnum = '[DONE]';
/**
 * Represents an event emitted when streaming a Run.  Each event in a server-sent events stream has an `event` and `data` property:  ``` event: thread.created data: {\"id\": \"thread_123\", \"object\": \"thread\", ...} ```  We emit events whenever a new object is created, transitions to a new state, or is being streamed in parts (deltas). For example, we emit `thread.run.created` when a new run is created, `thread.run.completed` when a run completes, and so on. When an Assistant chooses to create a message during a run, we emit a `thread.message.created event`, a `thread.message.in_progress` event, many `thread.message.delta` events, and finally a `thread.message.completed` event.  We may add additional events over time, so we recommend handling unknown events gracefully in your code. See the [Assistants API quickstart](/docs/assistants/overview) to learn how to integrate the Assistants API with streaming. 
 * @export
 */
export type AssistantStreamEvent = {
    /**
     * Whether to enable input audio transcription.
     * @type {boolean}
     * @memberof AssistantStreamEvent
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AssistantStreamEvent
     */
    event: AssistantStreamEventEventEnum;
    /**
     * 
     * @type {string}
     * @memberof AssistantStreamEvent
     */
    data: AssistantStreamEventDataEnum;
}


            export type AssistantToolsCodeTypeEnum = 'code_interpreter';
/**
 * 
 * @export
 */
export type AssistantToolsCode = {
    /**
     * The type of tool being defined: `code_interpreter`
     * @type {string}
     * @memberof AssistantToolsCode
     */
    type: AssistantToolsCodeTypeEnum;
}


            export type AssistantToolsFileSearchTypeEnum = 'file_search';
/**
 * 
 * @export
 */
export type AssistantToolsFileSearch = {
    /**
     * The type of tool being defined: `file_search`
     * @type {string}
     * @memberof AssistantToolsFileSearch
     */
    type: AssistantToolsFileSearchTypeEnum;
    /**
     * 
     * @type {AssistantToolsFileSearchFileSearch}
     * @memberof AssistantToolsFileSearch
     */
    file_search?: AssistantToolsFileSearchFileSearch;
}

/**
 * Overrides for the file search tool.
 * @export
 */
export type AssistantToolsFileSearchFileSearch = {
    /**
     * The maximum number of results the file search tool should output. The default is 20 for `gpt-4*` models and 5 for `gpt-3.5-turbo`. This number should be between 1 and 50 inclusive.  Note that the file search tool may output fewer than `max_num_results` results. See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
     * @type {number}
     * @memberof AssistantToolsFileSearchFileSearch
     */
    max_num_results?: number;
    /**
     * 
     * @type {FileSearchRankingOptions}
     * @memberof AssistantToolsFileSearchFileSearch
     */
    ranking_options?: FileSearchRankingOptions;
}


            export type AssistantToolsFileSearchTypeOnlyTypeEnum = 'file_search';
/**
 * 
 * @export
 */
export type AssistantToolsFileSearchTypeOnly = {
    /**
     * The type of tool being defined: `file_search`
     * @type {string}
     * @memberof AssistantToolsFileSearchTypeOnly
     */
    type: AssistantToolsFileSearchTypeOnlyTypeEnum;
}


            export type AssistantToolsFunctionTypeEnum = 'function';
/**
 * 
 * @export
 */
export type AssistantToolsFunction = {
    /**
     * The type of tool being defined: `function`
     * @type {string}
     * @memberof AssistantToolsFunction
     */
    type: AssistantToolsFunctionTypeEnum;
    /**
     * 
     * @type {FunctionObject}
     * @memberof AssistantToolsFunction
     */
    _function: FunctionObject;
}


            export type AssistantsApiResponseFormatOptionTypeEnum = 'text' | 'json_object' | 'json_schema';
/**
 * Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.  Setting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).  Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the message the model generates is valid JSON.  **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \"stuck\" request. Also note that the message content may be partially cut off if `finish_reason=\"length\"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length. 
 * @export
 */
export type AssistantsApiResponseFormatOption = {
    /**
     * The type of response format being defined: `text`
     * @type {string}
     * @memberof AssistantsApiResponseFormatOption
     */
    type: AssistantsApiResponseFormatOptionTypeEnum;
    /**
     * 
     * @type {ResponseFormatJsonSchemaJsonSchema}
     * @memberof AssistantsApiResponseFormatOption
     */
    json_schema: ResponseFormatJsonSchemaJsonSchema;
}


            export type AssistantsApiToolChoiceOptionTypeEnum = 'function' | 'code_interpreter' | 'file_search';
/**
 * Controls which (if any) tool is called by the model. `none` means the model will not call any tools and instead generates a message. `auto` is the default value and means the model can pick between generating a message or calling one or more tools. `required` means the model must call one or more tools before responding to the user. Specifying a particular tool like `{\"type\": \"file_search\"}` or `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool. 
 * @export
 */
export type AssistantsApiToolChoiceOption = {
    /**
     * The type of the tool. If type is `function`, the function name must be set
     * @type {string}
     * @memberof AssistantsApiToolChoiceOption
     */
    type: AssistantsApiToolChoiceOptionTypeEnum;
    /**
     * 
     * @type {AssistantsNamedToolChoiceFunction}
     * @memberof AssistantsApiToolChoiceOption
     */
    _function?: AssistantsNamedToolChoiceFunction;
}


            export type AssistantsNamedToolChoiceTypeEnum = 'function' | 'code_interpreter' | 'file_search';
/**
 * Specifies a tool the model should use. Use to force the model to call a specific tool.
 * @export
 */
export type AssistantsNamedToolChoice = {
    /**
     * The type of the tool. If type is `function`, the function name must be set
     * @type {string}
     * @memberof AssistantsNamedToolChoice
     */
    type: AssistantsNamedToolChoiceTypeEnum;
    /**
     * 
     * @type {AssistantsNamedToolChoiceFunction}
     * @memberof AssistantsNamedToolChoice
     */
    _function?: AssistantsNamedToolChoiceFunction;
}

/**
 * 
 * @export
 */
export type AssistantsNamedToolChoiceFunction = {
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof AssistantsNamedToolChoiceFunction
     */
    name: string;
}

/**
 * The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`. 
 * @export
 * @enum {string}
 */
export type AudioResponseFormat = 'json' | 'text' | 'srt' | 'verbose_json' | 'vtt';

/**
 * A log of a user action or configuration change within this organization.
 * @export
 */
export type AuditLog = {
    /**
     * The ID of this log.
     * @type {string}
     * @memberof AuditLog
     */
    id: string;
    /**
     * 
     * @type {AuditLogEventType}
     * @memberof AuditLog
     */
    type: AuditLogEventType;
    /**
     * The Unix timestamp (in seconds) of the event.
     * @type {number}
     * @memberof AuditLog
     */
    effective_at: number;
    /**
     * 
     * @type {AuditLogProject}
     * @memberof AuditLog
     */
    project?: AuditLogProject;
    /**
     * 
     * @type {AuditLogActor}
     * @memberof AuditLog
     */
    actor: AuditLogActor;
    /**
     * 
     * @type {AuditLogApiKeyCreated}
     * @memberof AuditLog
     */
    api_key_created?: AuditLogApiKeyCreated;
    /**
     * 
     * @type {AuditLogApiKeyUpdated}
     * @memberof AuditLog
     */
    api_key_updated?: AuditLogApiKeyUpdated;
    /**
     * 
     * @type {AuditLogApiKeyDeleted}
     * @memberof AuditLog
     */
    api_key_deleted?: AuditLogApiKeyDeleted;
    /**
     * 
     * @type {AuditLogInviteSent}
     * @memberof AuditLog
     */
    invite_sent?: AuditLogInviteSent;
    /**
     * 
     * @type {AuditLogInviteAccepted}
     * @memberof AuditLog
     */
    invite_accepted?: AuditLogInviteAccepted;
    /**
     * 
     * @type {AuditLogInviteAccepted}
     * @memberof AuditLog
     */
    invite_deleted?: AuditLogInviteAccepted;
    /**
     * 
     * @type {AuditLogLoginFailed}
     * @memberof AuditLog
     */
    login_failed?: AuditLogLoginFailed;
    /**
     * 
     * @type {AuditLogLoginFailed}
     * @memberof AuditLog
     */
    logout_failed?: AuditLogLoginFailed;
    /**
     * 
     * @type {AuditLogOrganizationUpdated}
     * @memberof AuditLog
     */
    organization_updated?: AuditLogOrganizationUpdated;
    /**
     * 
     * @type {AuditLogProjectCreated}
     * @memberof AuditLog
     */
    project_created?: AuditLogProjectCreated;
    /**
     * 
     * @type {AuditLogProjectUpdated}
     * @memberof AuditLog
     */
    project_updated?: AuditLogProjectUpdated;
    /**
     * 
     * @type {AuditLogProjectArchived}
     * @memberof AuditLog
     */
    project_archived?: AuditLogProjectArchived;
    /**
     * 
     * @type {AuditLogRateLimitUpdated}
     * @memberof AuditLog
     */
    rate_limit_updated?: AuditLogRateLimitUpdated;
    /**
     * 
     * @type {AuditLogRateLimitDeleted}
     * @memberof AuditLog
     */
    rate_limit_deleted?: AuditLogRateLimitDeleted;
    /**
     * 
     * @type {AuditLogServiceAccountCreated}
     * @memberof AuditLog
     */
    service_account_created?: AuditLogServiceAccountCreated;
    /**
     * 
     * @type {AuditLogServiceAccountUpdated}
     * @memberof AuditLog
     */
    service_account_updated?: AuditLogServiceAccountUpdated;
    /**
     * 
     * @type {AuditLogServiceAccountDeleted}
     * @memberof AuditLog
     */
    service_account_deleted?: AuditLogServiceAccountDeleted;
    /**
     * 
     * @type {AuditLogUserAdded}
     * @memberof AuditLog
     */
    user_added?: AuditLogUserAdded;
    /**
     * 
     * @type {AuditLogUserUpdated}
     * @memberof AuditLog
     */
    user_updated?: AuditLogUserUpdated;
    /**
     * 
     * @type {AuditLogUserDeleted}
     * @memberof AuditLog
     */
    user_deleted?: AuditLogUserDeleted;
}


            export type AuditLogActorTypeEnum = 'session' | 'api_key';
/**
 * The actor who performed the audit logged action.
 * @export
 */
export type AuditLogActor = {
    /**
     * The type of actor. Is either `session` or `api_key`.
     * @type {string}
     * @memberof AuditLogActor
     */
    type?: AuditLogActorTypeEnum;
    /**
     * 
     * @type {AuditLogActorSession}
     * @memberof AuditLogActor
     */
    session?: AuditLogActorSession;
    /**
     * 
     * @type {AuditLogActorApiKey}
     * @memberof AuditLogActor
     */
    api_key?: AuditLogActorApiKey;
}


            export type AuditLogActorApiKeyTypeEnum = 'user' | 'service_account';
/**
 * The API Key used to perform the audit logged action.
 * @export
 */
export type AuditLogActorApiKey = {
    /**
     * The tracking id of the API key.
     * @type {string}
     * @memberof AuditLogActorApiKey
     */
    id?: string;
    /**
     * The type of API key. Can be either `user` or `service_account`.
     * @type {string}
     * @memberof AuditLogActorApiKey
     */
    type?: AuditLogActorApiKeyTypeEnum;
    /**
     * 
     * @type {AuditLogActorUser}
     * @memberof AuditLogActorApiKey
     */
    user?: AuditLogActorUser;
    /**
     * 
     * @type {AuditLogActorServiceAccount}
     * @memberof AuditLogActorApiKey
     */
    service_account?: AuditLogActorServiceAccount;
}

/**
 * The service account that performed the audit logged action.
 * @export
 */
export type AuditLogActorServiceAccount = {
    /**
     * The service account id.
     * @type {string}
     * @memberof AuditLogActorServiceAccount
     */
    id?: string;
}

/**
 * The session in which the audit logged action was performed.
 * @export
 */
export type AuditLogActorSession = {
    /**
     * 
     * @type {AuditLogActorUser}
     * @memberof AuditLogActorSession
     */
    user?: AuditLogActorUser;
    /**
     * The IP address from which the action was performed.
     * @type {string}
     * @memberof AuditLogActorSession
     */
    ip_address?: string;
}

/**
 * The user who performed the audit logged action.
 * @export
 */
export type AuditLogActorUser = {
    /**
     * The user id.
     * @type {string}
     * @memberof AuditLogActorUser
     */
    id?: string;
    /**
     * The user email.
     * @type {string}
     * @memberof AuditLogActorUser
     */
    email?: string;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogApiKeyCreated = {
    /**
     * The tracking ID of the API key.
     * @type {string}
     * @memberof AuditLogApiKeyCreated
     */
    id?: string;
    /**
     * 
     * @type {AuditLogApiKeyCreatedData}
     * @memberof AuditLogApiKeyCreated
     */
    data?: AuditLogApiKeyCreatedData;
}

/**
 * The payload used to create the API key.
 * @export
 */
export type AuditLogApiKeyCreatedData = {
    /**
     * A list of scopes allowed for the API key, e.g. `[\"api.model.request\"]`
     * @type {Array<string>}
     * @memberof AuditLogApiKeyCreatedData
     */
    scopes?: Array<string>;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogApiKeyDeleted = {
    /**
     * The tracking ID of the API key.
     * @type {string}
     * @memberof AuditLogApiKeyDeleted
     */
    id?: string;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogApiKeyUpdated = {
    /**
     * The tracking ID of the API key.
     * @type {string}
     * @memberof AuditLogApiKeyUpdated
     */
    id?: string;
    /**
     * 
     * @type {AuditLogApiKeyUpdatedChangesRequested}
     * @memberof AuditLogApiKeyUpdated
     */
    changes_requested?: AuditLogApiKeyUpdatedChangesRequested;
}

/**
 * The payload used to update the API key.
 * @export
 */
export type AuditLogApiKeyUpdatedChangesRequested = {
    /**
     * A list of scopes allowed for the API key, e.g. `[\"api.model.request\"]`
     * @type {Array<string>}
     * @memberof AuditLogApiKeyUpdatedChangesRequested
     */
    scopes?: Array<string>;
}

/**
 * The event type.
 * @export
 * @enum {string}
 */
export type AuditLogEventType = 'api_key.created' | 'api_key.updated' | 'api_key.deleted' | 'invite.sent' | 'invite.accepted' | 'invite.deleted' | 'login.succeeded' | 'login.failed' | 'logout.succeeded' | 'logout.failed' | 'organization.updated' | 'project.created' | 'project.updated' | 'project.archived' | 'service_account.created' | 'service_account.updated' | 'service_account.deleted' | 'rate_limit.updated' | 'rate_limit.deleted' | 'user.added' | 'user.updated' | 'user.deleted';

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogInviteAccepted = {
    /**
     * The ID of the invite.
     * @type {string}
     * @memberof AuditLogInviteAccepted
     */
    id?: string;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogInviteSent = {
    /**
     * The ID of the invite.
     * @type {string}
     * @memberof AuditLogInviteSent
     */
    id?: string;
    /**
     * 
     * @type {AuditLogInviteSentData}
     * @memberof AuditLogInviteSent
     */
    data?: AuditLogInviteSentData;
}

/**
 * The payload used to create the invite.
 * @export
 */
export type AuditLogInviteSentData = {
    /**
     * The email invited to the organization.
     * @type {string}
     * @memberof AuditLogInviteSentData
     */
    email?: string;
    /**
     * The role the email was invited to be. Is either `owner` or `member`.
     * @type {string}
     * @memberof AuditLogInviteSentData
     */
    role?: string;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogLoginFailed = {
    /**
     * The error code of the failure.
     * @type {string}
     * @memberof AuditLogLoginFailed
     */
    error_code?: string;
    /**
     * The error message of the failure.
     * @type {string}
     * @memberof AuditLogLoginFailed
     */
    error_message?: string;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogOrganizationUpdated = {
    /**
     * The organization ID.
     * @type {string}
     * @memberof AuditLogOrganizationUpdated
     */
    id?: string;
    /**
     * 
     * @type {AuditLogOrganizationUpdatedChangesRequested}
     * @memberof AuditLogOrganizationUpdated
     */
    changes_requested?: AuditLogOrganizationUpdatedChangesRequested;
}

/**
 * The payload used to update the organization settings.
 * @export
 */
export type AuditLogOrganizationUpdatedChangesRequested = {
    /**
     * The organization title.
     * @type {string}
     * @memberof AuditLogOrganizationUpdatedChangesRequested
     */
    title?: string;
    /**
     * The organization description.
     * @type {string}
     * @memberof AuditLogOrganizationUpdatedChangesRequested
     */
    description?: string;
    /**
     * The organization name.
     * @type {string}
     * @memberof AuditLogOrganizationUpdatedChangesRequested
     */
    name?: string;
    /**
     * 
     * @type {AuditLogOrganizationUpdatedChangesRequestedSettings}
     * @memberof AuditLogOrganizationUpdatedChangesRequested
     */
    settings?: AuditLogOrganizationUpdatedChangesRequestedSettings;
}

/**
 * 
 * @export
 */
export type AuditLogOrganizationUpdatedChangesRequestedSettings = {
    /**
     * Visibility of the threads page which shows messages created with the Assistants API and Playground. One of `ANY_ROLE`, `OWNERS`, or `NONE`.
     * @type {string}
     * @memberof AuditLogOrganizationUpdatedChangesRequestedSettings
     */
    threads_ui_visibility?: string;
    /**
     * Visibility of the usage dashboard which shows activity and costs for your organization. One of `ANY_ROLE` or `OWNERS`.
     * @type {string}
     * @memberof AuditLogOrganizationUpdatedChangesRequestedSettings
     */
    usage_dashboard_visibility?: string;
}

/**
 * The project that the action was scoped to. Absent for actions not scoped to projects.
 * @export
 */
export type AuditLogProject = {
    /**
     * The project ID.
     * @type {string}
     * @memberof AuditLogProject
     */
    id?: string;
    /**
     * The project title.
     * @type {string}
     * @memberof AuditLogProject
     */
    name?: string;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogProjectArchived = {
    /**
     * The project ID.
     * @type {string}
     * @memberof AuditLogProjectArchived
     */
    id?: string;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogProjectCreated = {
    /**
     * The project ID.
     * @type {string}
     * @memberof AuditLogProjectCreated
     */
    id?: string;
    /**
     * 
     * @type {AuditLogProjectCreatedData}
     * @memberof AuditLogProjectCreated
     */
    data?: AuditLogProjectCreatedData;
}

/**
 * The payload used to create the project.
 * @export
 */
export type AuditLogProjectCreatedData = {
    /**
     * The project name.
     * @type {string}
     * @memberof AuditLogProjectCreatedData
     */
    name?: string;
    /**
     * The title of the project as seen on the dashboard.
     * @type {string}
     * @memberof AuditLogProjectCreatedData
     */
    title?: string;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogProjectUpdated = {
    /**
     * The project ID.
     * @type {string}
     * @memberof AuditLogProjectUpdated
     */
    id?: string;
    /**
     * 
     * @type {AuditLogProjectUpdatedChangesRequested}
     * @memberof AuditLogProjectUpdated
     */
    changes_requested?: AuditLogProjectUpdatedChangesRequested;
}

/**
 * The payload used to update the project.
 * @export
 */
export type AuditLogProjectUpdatedChangesRequested = {
    /**
     * The title of the project as seen on the dashboard.
     * @type {string}
     * @memberof AuditLogProjectUpdatedChangesRequested
     */
    title?: string;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogRateLimitDeleted = {
    /**
     * The rate limit ID
     * @type {string}
     * @memberof AuditLogRateLimitDeleted
     */
    id?: string;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogRateLimitUpdated = {
    /**
     * The rate limit ID
     * @type {string}
     * @memberof AuditLogRateLimitUpdated
     */
    id?: string;
    /**
     * 
     * @type {AuditLogRateLimitUpdatedChangesRequested}
     * @memberof AuditLogRateLimitUpdated
     */
    changes_requested?: AuditLogRateLimitUpdatedChangesRequested;
}

/**
 * The payload used to update the rate limits.
 * @export
 */
export type AuditLogRateLimitUpdatedChangesRequested = {
    /**
     * The maximum requests per minute.
     * @type {number}
     * @memberof AuditLogRateLimitUpdatedChangesRequested
     */
    max_requests_per_1_minute?: number;
    /**
     * The maximum tokens per minute.
     * @type {number}
     * @memberof AuditLogRateLimitUpdatedChangesRequested
     */
    max_tokens_per_1_minute?: number;
    /**
     * The maximum images per minute. Only relevant for certain models.
     * @type {number}
     * @memberof AuditLogRateLimitUpdatedChangesRequested
     */
    max_images_per_1_minute?: number;
    /**
     * The maximum audio megabytes per minute. Only relevant for certain models.
     * @type {number}
     * @memberof AuditLogRateLimitUpdatedChangesRequested
     */
    max_audio_megabytes_per_1_minute?: number;
    /**
     * The maximum requests per day. Only relevant for certain models.
     * @type {number}
     * @memberof AuditLogRateLimitUpdatedChangesRequested
     */
    max_requests_per_1_day?: number;
    /**
     * The maximum batch input tokens per day. Only relevant for certain models.
     * @type {number}
     * @memberof AuditLogRateLimitUpdatedChangesRequested
     */
    batch_1_day_max_input_tokens?: number;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogServiceAccountCreated = {
    /**
     * The service account ID.
     * @type {string}
     * @memberof AuditLogServiceAccountCreated
     */
    id?: string;
    /**
     * 
     * @type {AuditLogServiceAccountCreatedData}
     * @memberof AuditLogServiceAccountCreated
     */
    data?: AuditLogServiceAccountCreatedData;
}

/**
 * The payload used to create the service account.
 * @export
 */
export type AuditLogServiceAccountCreatedData = {
    /**
     * The role of the service account. Is either `owner` or `member`.
     * @type {string}
     * @memberof AuditLogServiceAccountCreatedData
     */
    role?: string;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogServiceAccountDeleted = {
    /**
     * The service account ID.
     * @type {string}
     * @memberof AuditLogServiceAccountDeleted
     */
    id?: string;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogServiceAccountUpdated = {
    /**
     * The service account ID.
     * @type {string}
     * @memberof AuditLogServiceAccountUpdated
     */
    id?: string;
    /**
     * 
     * @type {AuditLogServiceAccountUpdatedChangesRequested}
     * @memberof AuditLogServiceAccountUpdated
     */
    changes_requested?: AuditLogServiceAccountUpdatedChangesRequested;
}

/**
 * The payload used to updated the service account.
 * @export
 */
export type AuditLogServiceAccountUpdatedChangesRequested = {
    /**
     * The role of the service account. Is either `owner` or `member`.
     * @type {string}
     * @memberof AuditLogServiceAccountUpdatedChangesRequested
     */
    role?: string;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogUserAdded = {
    /**
     * The user ID.
     * @type {string}
     * @memberof AuditLogUserAdded
     */
    id?: string;
    /**
     * 
     * @type {AuditLogUserAddedData}
     * @memberof AuditLogUserAdded
     */
    data?: AuditLogUserAddedData;
}

/**
 * The payload used to add the user to the project.
 * @export
 */
export type AuditLogUserAddedData = {
    /**
     * The role of the user. Is either `owner` or `member`.
     * @type {string}
     * @memberof AuditLogUserAddedData
     */
    role?: string;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogUserDeleted = {
    /**
     * The user ID.
     * @type {string}
     * @memberof AuditLogUserDeleted
     */
    id?: string;
}

/**
 * The details for events with this `type`.
 * @export
 */
export type AuditLogUserUpdated = {
    /**
     * The project ID.
     * @type {string}
     * @memberof AuditLogUserUpdated
     */
    id?: string;
    /**
     * 
     * @type {AuditLogUserUpdatedChangesRequested}
     * @memberof AuditLogUserUpdated
     */
    changes_requested?: AuditLogUserUpdatedChangesRequested;
}

/**
 * The payload used to update the user.
 * @export
 */
export type AuditLogUserUpdatedChangesRequested = {
    /**
     * The role of the user. Is either `owner` or `member`.
     * @type {string}
     * @memberof AuditLogUserUpdatedChangesRequested
     */
    role?: string;
}


            export type AutoChunkingStrategyTypeEnum = 'auto';
/**
 * The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`.
 * @export
 */
export type AutoChunkingStrategy = {
    /**
     * Always `auto`.
     * @type {string}
     * @memberof AutoChunkingStrategy
     */
    type: AutoChunkingStrategyTypeEnum;
}


            export type AutoChunkingStrategyRequestParamTypeEnum = 'auto';
/**
 * The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`.
 * @export
 */
export type AutoChunkingStrategyRequestParam = {
    /**
     * Always `auto`.
     * @type {string}
     * @memberof AutoChunkingStrategyRequestParam
     */
    type: AutoChunkingStrategyRequestParamTypeEnum;
}


            export type BatchObjectEnum = 'batch';

            export type BatchStatusEnum = 'validating' | 'failed' | 'in_progress' | 'finalizing' | 'completed' | 'expired' | 'cancelling' | 'cancelled';
/**
 * 
 * @export
 */
export type Batch = {
    /**
     * 
     * @type {string}
     * @memberof Batch
     */
    id: string;
    /**
     * The object type, which is always `batch`.
     * @type {string}
     * @memberof Batch
     */
    _object: BatchObjectEnum;
    /**
     * The OpenAI API endpoint used by the batch.
     * @type {string}
     * @memberof Batch
     */
    endpoint: string;
    /**
     * 
     * @type {BatchErrors}
     * @memberof Batch
     */
    errors?: BatchErrors;
    /**
     * The ID of the input file for the batch.
     * @type {string}
     * @memberof Batch
     */
    input_file_id: string;
    /**
     * The time frame within which the batch should be processed.
     * @type {string}
     * @memberof Batch
     */
    completion_window: string;
    /**
     * The current status of the batch.
     * @type {string}
     * @memberof Batch
     */
    status: BatchStatusEnum;
    /**
     * The ID of the file containing the outputs of successfully executed requests.
     * @type {string}
     * @memberof Batch
     */
    output_file_id?: string;
    /**
     * The ID of the file containing the outputs of requests with errors.
     * @type {string}
     * @memberof Batch
     */
    error_file_id?: string;
    /**
     * The Unix timestamp (in seconds) for when the batch was created.
     * @type {number}
     * @memberof Batch
     */
    created_at: number;
    /**
     * The Unix timestamp (in seconds) for when the batch started processing.
     * @type {number}
     * @memberof Batch
     */
    in_progress_at?: number;
    /**
     * The Unix timestamp (in seconds) for when the batch will expire.
     * @type {number}
     * @memberof Batch
     */
    expires_at?: number;
    /**
     * The Unix timestamp (in seconds) for when the batch started finalizing.
     * @type {number}
     * @memberof Batch
     */
    finalizing_at?: number;
    /**
     * The Unix timestamp (in seconds) for when the batch was completed.
     * @type {number}
     * @memberof Batch
     */
    completed_at?: number;
    /**
     * The Unix timestamp (in seconds) for when the batch failed.
     * @type {number}
     * @memberof Batch
     */
    failed_at?: number;
    /**
     * The Unix timestamp (in seconds) for when the batch expired.
     * @type {number}
     * @memberof Batch
     */
    expired_at?: number;
    /**
     * The Unix timestamp (in seconds) for when the batch started cancelling.
     * @type {number}
     * @memberof Batch
     */
    cancelling_at?: number;
    /**
     * The Unix timestamp (in seconds) for when the batch was cancelled.
     * @type {number}
     * @memberof Batch
     */
    cancelled_at?: number;
    /**
     * 
     * @type {BatchRequestCounts}
     * @memberof Batch
     */
    request_counts?: BatchRequestCounts;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof Batch
     */
    metadata?: Object;
}

/**
 * 
 * @export
 */
export type BatchErrors = {
    /**
     * The object type, which is always `list`.
     * @type {string}
     * @memberof BatchErrors
     */
    _object?: string;
    /**
     * 
     * @type {Array<BatchErrorsDataInner>}
     * @memberof BatchErrors
     */
    data?: Array<BatchErrorsDataInner>;
}

/**
 * 
 * @export
 */
export type BatchErrorsDataInner = {
    /**
     * An error code identifying the error type.
     * @type {string}
     * @memberof BatchErrorsDataInner
     */
    code?: string;
    /**
     * A human-readable message providing more details about the error.
     * @type {string}
     * @memberof BatchErrorsDataInner
     */
    message?: string;
    /**
     * The name of the parameter that caused the error, if applicable.
     * @type {string}
     * @memberof BatchErrorsDataInner
     */
    param?: string;
    /**
     * The line number of the input file where the error occurred, if applicable.
     * @type {number}
     * @memberof BatchErrorsDataInner
     */
    line?: number;
}

/**
 * The request counts for different statuses within the batch.
 * @export
 */
export type BatchRequestCounts = {
    /**
     * Total number of requests in the batch.
     * @type {number}
     * @memberof BatchRequestCounts
     */
    total: number;
    /**
     * Number of requests that have been completed successfully.
     * @type {number}
     * @memberof BatchRequestCounts
     */
    completed: number;
    /**
     * Number of requests that have failed.
     * @type {number}
     * @memberof BatchRequestCounts
     */
    failed: number;
}


            export type BatchRequestInputMethodEnum = 'POST';
/**
 * The per-line object of the batch input file
 * @export
 */
export type BatchRequestInput = {
    /**
     * A developer-provided per-request id that will be used to match outputs to inputs. Must be unique for each request in a batch.
     * @type {string}
     * @memberof BatchRequestInput
     */
    custom_id?: string;
    /**
     * The HTTP method to be used for the request. Currently only `POST` is supported.
     * @type {string}
     * @memberof BatchRequestInput
     */
    method?: BatchRequestInputMethodEnum;
    /**
     * The OpenAI API relative URL to be used for the request. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported.
     * @type {string}
     * @memberof BatchRequestInput
     */
    url?: string;
}

/**
 * The per-line object of the batch output and error files
 * @export
 */
export type BatchRequestOutput = {
    /**
     * 
     * @type {string}
     * @memberof BatchRequestOutput
     */
    id?: string;
    /**
     * A developer-provided per-request id that will be used to match outputs to inputs.
     * @type {string}
     * @memberof BatchRequestOutput
     */
    custom_id?: string;
    /**
     * 
     * @type {BatchRequestOutputResponse}
     * @memberof BatchRequestOutput
     */
    response?: BatchRequestOutputResponse;
    /**
     * 
     * @type {BatchRequestOutputError}
     * @memberof BatchRequestOutput
     */
    error?: BatchRequestOutputError;
}

/**
 * For requests that failed with a non-HTTP error, this will contain more information on the cause of the failure.
 * @export
 */
export type BatchRequestOutputError = {
    /**
     * A machine-readable error code.
     * @type {string}
     * @memberof BatchRequestOutputError
     */
    code?: string;
    /**
     * A human-readable error message.
     * @type {string}
     * @memberof BatchRequestOutputError
     */
    message?: string;
}

/**
 * 
 * @export
 */
export type BatchRequestOutputResponse = {
    /**
     * The HTTP status code of the response
     * @type {number}
     * @memberof BatchRequestOutputResponse
     */
    status_code?: number;
    /**
     * An unique identifier for the OpenAI API request. Please include this request ID when contacting support.
     * @type {string}
     * @memberof BatchRequestOutputResponse
     */
    request_id?: string;
    /**
     * The JSON body of the response
     * @type {Object}
     * @memberof BatchRequestOutputResponse
     */
    body?: Object;
}

/**
 * Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function. 
 * @export
 */
export type ChatCompletionFunctionCallOption = {
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionFunctionCallOption
     */
    name: string;
}

/**
 * 
 * @export
 */
export type ChatCompletionFunctions = {
    /**
     * A description of what the function does, used by the model to choose when and how to call the function.
     * @type {string}
     * @memberof ChatCompletionFunctions
     */
    description?: string;
    /**
     * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     * @type {string}
     * @memberof ChatCompletionFunctions
     */
    name: string;
    /**
     * The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.   Omitting `parameters` defines a function with an empty parameter list.
     * @type {{ [key: string]: AnyType; }}
     * @memberof ChatCompletionFunctions
     */
    parameters?: { [key: string]: AnyType; };
}


            export type ChatCompletionMessageToolCallTypeEnum = 'function';
/**
 * 
 * @export
 */
export type ChatCompletionMessageToolCall = {
    /**
     * The ID of the tool call.
     * @type {string}
     * @memberof ChatCompletionMessageToolCall
     */
    id: string;
    /**
     * The type of the tool. Currently, only `function` is supported.
     * @type {string}
     * @memberof ChatCompletionMessageToolCall
     */
    type: ChatCompletionMessageToolCallTypeEnum;
    /**
     * 
     * @type {ChatCompletionMessageToolCallFunction}
     * @memberof ChatCompletionMessageToolCall
     */
    _function: ChatCompletionMessageToolCallFunction;
}


            export type ChatCompletionMessageToolCallChunkTypeEnum = 'function';
/**
 * 
 * @export
 */
export type ChatCompletionMessageToolCallChunk = {
    /**
     * 
     * @type {number}
     * @memberof ChatCompletionMessageToolCallChunk
     */
    index: number;
    /**
     * The ID of the tool call.
     * @type {string}
     * @memberof ChatCompletionMessageToolCallChunk
     */
    id?: string;
    /**
     * The type of the tool. Currently, only `function` is supported.
     * @type {string}
     * @memberof ChatCompletionMessageToolCallChunk
     */
    type?: ChatCompletionMessageToolCallChunkTypeEnum;
    /**
     * 
     * @type {ChatCompletionMessageToolCallChunkFunction}
     * @memberof ChatCompletionMessageToolCallChunk
     */
    _function?: ChatCompletionMessageToolCallChunkFunction;
}

/**
 * 
 * @export
 */
export type ChatCompletionMessageToolCallChunkFunction = {
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionMessageToolCallChunkFunction
     */
    name?: string;
    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     * @type {string}
     * @memberof ChatCompletionMessageToolCallChunkFunction
     */
    _arguments?: string;
}

/**
 * The function that the model called.
 * @export
 */
export type ChatCompletionMessageToolCallFunction = {
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionMessageToolCallFunction
     */
    name: string;
    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     * @type {string}
     * @memberof ChatCompletionMessageToolCallFunction
     */
    _arguments: string;
}


            export type ChatCompletionNamedToolChoiceTypeEnum = 'function';
/**
 * Specifies a tool the model should use. Use to force the model to call a specific function.
 * @export
 */
export type ChatCompletionNamedToolChoice = {
    /**
     * The type of the tool. Currently, only `function` is supported.
     * @type {string}
     * @memberof ChatCompletionNamedToolChoice
     */
    type: ChatCompletionNamedToolChoiceTypeEnum;
    /**
     * 
     * @type {AssistantsNamedToolChoiceFunction}
     * @memberof ChatCompletionNamedToolChoice
     */
    _function: AssistantsNamedToolChoiceFunction;
}


            export type ChatCompletionRequestAssistantMessageRoleEnum = 'assistant';
/**
 * Messages sent by the model in response to user messages. 
 * @export
 */
export type ChatCompletionRequestAssistantMessage = {
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageContent}
     * @memberof ChatCompletionRequestAssistantMessage
     */
    content?: ChatCompletionRequestAssistantMessageContent;
    /**
     * The refusal message by the assistant.
     * @type {string}
     * @memberof ChatCompletionRequestAssistantMessage
     */
    refusal?: string;
    /**
     * The role of the messages author, in this case `assistant`.
     * @type {string}
     * @memberof ChatCompletionRequestAssistantMessage
     */
    role: ChatCompletionRequestAssistantMessageRoleEnum;
    /**
     * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     * @type {string}
     * @memberof ChatCompletionRequestAssistantMessage
     */
    name?: string;
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageAudio}
     * @memberof ChatCompletionRequestAssistantMessage
     */
    audio?: ChatCompletionRequestAssistantMessageAudio;
    /**
     * The tool calls generated by the model, such as function calls.
     * @type {Array<ChatCompletionMessageToolCall>}
     * @memberof ChatCompletionRequestAssistantMessage
     */
    tool_calls?: Array<ChatCompletionMessageToolCall>;
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageFunctionCall}
     * @memberof ChatCompletionRequestAssistantMessage
     */
    function_call?: ChatCompletionRequestAssistantMessageFunctionCall;
}

/**
 * Data about a previous audio response from the model.  [Learn more](/docs/guides/audio). 
 * @export
 */
export type ChatCompletionRequestAssistantMessageAudio = {
    /**
     * Unique identifier for a previous audio response from the model. 
     * @type {string}
     * @memberof ChatCompletionRequestAssistantMessageAudio
     */
    id: string;
}

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified. 
 * @export
 */
export type ChatCompletionRequestAssistantMessageContent = {
}


            export type ChatCompletionRequestAssistantMessageContentPartTypeEnum = 'text' | 'refusal';
/**
 * 
 * @export
 */
export type ChatCompletionRequestAssistantMessageContentPart = {
    /**
     * The type of the content part.
     * @type {string}
     * @memberof ChatCompletionRequestAssistantMessageContentPart
     */
    type: ChatCompletionRequestAssistantMessageContentPartTypeEnum;
    /**
     * The text content.
     * @type {string}
     * @memberof ChatCompletionRequestAssistantMessageContentPart
     */
    text: string;
    /**
     * The refusal message generated by the model.
     * @type {string}
     * @memberof ChatCompletionRequestAssistantMessageContentPart
     */
    refusal: string;
}

/**
 * Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
 * @export
 */
export type ChatCompletionRequestAssistantMessageFunctionCall = {
    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     * @type {string}
     * @memberof ChatCompletionRequestAssistantMessageFunctionCall
     */
    _arguments: string;
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionRequestAssistantMessageFunctionCall
     */
    name: string;
}


            export type ChatCompletionRequestDeveloperMessageRoleEnum = 'developer';
/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user. With o1 models and newer, `developer` messages replace the previous `system` messages. 
 * @export
 */
export type ChatCompletionRequestDeveloperMessage = {
    /**
     * 
     * @type {ChatCompletionRequestDeveloperMessageContent}
     * @memberof ChatCompletionRequestDeveloperMessage
     */
    content: ChatCompletionRequestDeveloperMessageContent;
    /**
     * The role of the messages author, in this case `developer`.
     * @type {string}
     * @memberof ChatCompletionRequestDeveloperMessage
     */
    role: ChatCompletionRequestDeveloperMessageRoleEnum;
    /**
     * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     * @type {string}
     * @memberof ChatCompletionRequestDeveloperMessage
     */
    name?: string;
}

/**
 * The contents of the developer message.
 * @export
 */
export type ChatCompletionRequestDeveloperMessageContent = {
}


            export type ChatCompletionRequestFunctionMessageRoleEnum = 'function';
/**
 * 
 * @export
 */
export type ChatCompletionRequestFunctionMessage = {
    /**
     * The role of the messages author, in this case `function`.
     * @type {string}
     * @memberof ChatCompletionRequestFunctionMessage
     */
    role: ChatCompletionRequestFunctionMessageRoleEnum;
    /**
     * The contents of the function message.
     * @type {string}
     * @memberof ChatCompletionRequestFunctionMessage
     */
    content: string;
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionRequestFunctionMessage
     */
    name: string;
}


            export type ChatCompletionRequestMessageRoleEnum = 'function';
/**
 * 
 * @export
 */
export type ChatCompletionRequestMessage = {
    /**
     * The contents of the function message.
     * @type {string}
     * @memberof ChatCompletionRequestMessage
     */
    content: string;
    /**
     * The role of the messages author, in this case `function`.
     * @type {string}
     * @memberof ChatCompletionRequestMessage
     */
    role: ChatCompletionRequestMessageRoleEnum;
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionRequestMessage
     */
    name: string;
    /**
     * The refusal message by the assistant.
     * @type {string}
     * @memberof ChatCompletionRequestMessage
     */
    refusal?: string;
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageAudio}
     * @memberof ChatCompletionRequestMessage
     */
    audio?: ChatCompletionRequestAssistantMessageAudio;
    /**
     * The tool calls generated by the model, such as function calls.
     * @type {Array<ChatCompletionMessageToolCall>}
     * @memberof ChatCompletionRequestMessage
     */
    tool_calls?: Array<ChatCompletionMessageToolCall>;
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageFunctionCall}
     * @memberof ChatCompletionRequestMessage
     */
    function_call?: ChatCompletionRequestAssistantMessageFunctionCall;
    /**
     * Tool call that this message is responding to.
     * @type {string}
     * @memberof ChatCompletionRequestMessage
     */
    tool_call_id: string;
}


            export type ChatCompletionRequestMessageContentPartAudioTypeEnum = 'input_audio';
/**
 * Learn about [audio inputs](/docs/guides/audio). 
 * @export
 */
export type ChatCompletionRequestMessageContentPartAudio = {
    /**
     * The type of the content part. Always `input_audio`.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartAudio
     */
    type: ChatCompletionRequestMessageContentPartAudioTypeEnum;
    /**
     * 
     * @type {ChatCompletionRequestMessageContentPartAudioInputAudio}
     * @memberof ChatCompletionRequestMessageContentPartAudio
     */
    input_audio: ChatCompletionRequestMessageContentPartAudioInputAudio;
}


            export type ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum = 'wav' | 'mp3';
/**
 * 
 * @export
 */
export type ChatCompletionRequestMessageContentPartAudioInputAudio = {
    /**
     * Base64 encoded audio data.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartAudioInputAudio
     */
    data: string;
    /**
     * The format of the encoded audio data. Currently supports \"wav\" and \"mp3\". 
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartAudioInputAudio
     */
    format: ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum;
}


            export type ChatCompletionRequestMessageContentPartImageTypeEnum = 'image_url';
/**
 * Learn about [image inputs](/docs/guides/vision). 
 * @export
 */
export type ChatCompletionRequestMessageContentPartImage = {
    /**
     * The type of the content part.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartImage
     */
    type: ChatCompletionRequestMessageContentPartImageTypeEnum;
    /**
     * 
     * @type {ChatCompletionRequestMessageContentPartImageImageUrl}
     * @memberof ChatCompletionRequestMessageContentPartImage
     */
    image_url: ChatCompletionRequestMessageContentPartImageImageUrl;
}


            export type ChatCompletionRequestMessageContentPartImageImageUrlDetailEnum = 'auto' | 'low' | 'high';
/**
 * 
 * @export
 */
export type ChatCompletionRequestMessageContentPartImageImageUrl = {
    /**
     * Either a URL of the image or the base64 encoded image data.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartImageImageUrl
     */
    url: string;
    /**
     * Specifies the detail level of the image. Learn more in the [Vision guide](/docs/guides/vision#low-or-high-fidelity-image-understanding).
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartImageImageUrl
     */
    detail?: ChatCompletionRequestMessageContentPartImageImageUrlDetailEnum;
}


            export type ChatCompletionRequestMessageContentPartRefusalTypeEnum = 'refusal';
/**
 * 
 * @export
 */
export type ChatCompletionRequestMessageContentPartRefusal = {
    /**
     * The type of the content part.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartRefusal
     */
    type: ChatCompletionRequestMessageContentPartRefusalTypeEnum;
    /**
     * The refusal message generated by the model.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartRefusal
     */
    refusal: string;
}


            export type ChatCompletionRequestMessageContentPartTextTypeEnum = 'text';
/**
 * Learn about [text inputs](/docs/guides/text-generation). 
 * @export
 */
export type ChatCompletionRequestMessageContentPartText = {
    /**
     * The type of the content part.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartText
     */
    type: ChatCompletionRequestMessageContentPartTextTypeEnum;
    /**
     * The text content.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartText
     */
    text: string;
}


            export type ChatCompletionRequestSystemMessageRoleEnum = 'system';
/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user. With o1 models and newer, use `developer` messages for this purpose instead. 
 * @export
 */
export type ChatCompletionRequestSystemMessage = {
    /**
     * 
     * @type {ChatCompletionRequestSystemMessageContent}
     * @memberof ChatCompletionRequestSystemMessage
     */
    content: ChatCompletionRequestSystemMessageContent;
    /**
     * The role of the messages author, in this case `system`.
     * @type {string}
     * @memberof ChatCompletionRequestSystemMessage
     */
    role: ChatCompletionRequestSystemMessageRoleEnum;
    /**
     * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     * @type {string}
     * @memberof ChatCompletionRequestSystemMessage
     */
    name?: string;
}

/**
 * The contents of the system message.
 * @export
 */
export type ChatCompletionRequestSystemMessageContent = {
}


            export type ChatCompletionRequestToolMessageRoleEnum = 'tool';
/**
 * 
 * @export
 */
export type ChatCompletionRequestToolMessage = {
    /**
     * The role of the messages author, in this case `tool`.
     * @type {string}
     * @memberof ChatCompletionRequestToolMessage
     */
    role: ChatCompletionRequestToolMessageRoleEnum;
    /**
     * 
     * @type {ChatCompletionRequestToolMessageContent}
     * @memberof ChatCompletionRequestToolMessage
     */
    content: ChatCompletionRequestToolMessageContent;
    /**
     * Tool call that this message is responding to.
     * @type {string}
     * @memberof ChatCompletionRequestToolMessage
     */
    tool_call_id: string;
}

/**
 * The contents of the tool message.
 * @export
 */
export type ChatCompletionRequestToolMessageContent = {
}


            export type ChatCompletionRequestUserMessageRoleEnum = 'user';
/**
 * Messages sent by an end user, containing prompts or additional context information. 
 * @export
 */
export type ChatCompletionRequestUserMessage = {
    /**
     * 
     * @type {ChatCompletionRequestUserMessageContent}
     * @memberof ChatCompletionRequestUserMessage
     */
    content: ChatCompletionRequestUserMessageContent;
    /**
     * The role of the messages author, in this case `user`.
     * @type {string}
     * @memberof ChatCompletionRequestUserMessage
     */
    role: ChatCompletionRequestUserMessageRoleEnum;
    /**
     * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     * @type {string}
     * @memberof ChatCompletionRequestUserMessage
     */
    name?: string;
}

/**
 * The contents of the user message. 
 * @export
 */
export type ChatCompletionRequestUserMessageContent = {
}


            export type ChatCompletionRequestUserMessageContentPartTypeEnum = 'text' | 'image_url' | 'input_audio';
/**
 * 
 * @export
 */
export type ChatCompletionRequestUserMessageContentPart = {
    /**
     * The type of the content part.
     * @type {string}
     * @memberof ChatCompletionRequestUserMessageContentPart
     */
    type: ChatCompletionRequestUserMessageContentPartTypeEnum;
    /**
     * The text content.
     * @type {string}
     * @memberof ChatCompletionRequestUserMessageContentPart
     */
    text: string;
    /**
     * 
     * @type {ChatCompletionRequestMessageContentPartImageImageUrl}
     * @memberof ChatCompletionRequestUserMessageContentPart
     */
    image_url: ChatCompletionRequestMessageContentPartImageImageUrl;
    /**
     * 
     * @type {ChatCompletionRequestMessageContentPartAudioInputAudio}
     * @memberof ChatCompletionRequestUserMessageContentPart
     */
    input_audio: ChatCompletionRequestMessageContentPartAudioInputAudio;
}


            export type ChatCompletionResponseMessageRoleEnum = 'assistant';
/**
 * A chat completion message generated by the model.
 * @export
 */
export type ChatCompletionResponseMessage = {
    /**
     * The contents of the message.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    content: string;
    /**
     * The refusal message generated by the model.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    refusal: string;
    /**
     * The tool calls generated by the model, such as function calls.
     * @type {Array<ChatCompletionMessageToolCall>}
     * @memberof ChatCompletionResponseMessage
     */
    tool_calls?: Array<ChatCompletionMessageToolCall>;
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    role: ChatCompletionResponseMessageRoleEnum;
    /**
     * 
     * @type {ChatCompletionResponseMessageFunctionCall}
     * @memberof ChatCompletionResponseMessage
     */
    function_call?: ChatCompletionResponseMessageFunctionCall;
    /**
     * 
     * @type {ChatCompletionResponseMessageAudio}
     * @memberof ChatCompletionResponseMessage
     */
    audio?: ChatCompletionResponseMessageAudio;
}

/**
 * If the audio output modality is requested, this object contains data about the audio response from the model. [Learn more](/docs/guides/audio). 
 * @export
 */
export type ChatCompletionResponseMessageAudio = {
    /**
     * Unique identifier for this audio response.
     * @type {string}
     * @memberof ChatCompletionResponseMessageAudio
     */
    id: string;
    /**
     * The Unix timestamp (in seconds) for when this audio response will no longer be accessible on the server for use in multi-turn conversations. 
     * @type {number}
     * @memberof ChatCompletionResponseMessageAudio
     */
    expires_at: number;
    /**
     * Base64 encoded audio bytes generated by the model, in the format specified in the request. 
     * @type {string}
     * @memberof ChatCompletionResponseMessageAudio
     */
    data: string;
    /**
     * Transcript of the audio generated by the model.
     * @type {string}
     * @memberof ChatCompletionResponseMessageAudio
     */
    transcript: string;
}

/**
 * Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
 * @export
 */
export type ChatCompletionResponseMessageFunctionCall = {
    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     * @type {string}
     * @memberof ChatCompletionResponseMessageFunctionCall
     */
    _arguments: string;
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionResponseMessageFunctionCall
     */
    name: string;
}

/**
 * The role of the author of a message
 * @export
 * @enum {string}
 */
export type ChatCompletionRole = 'system' | 'user' | 'assistant' | 'tool' | 'function';

/**
 * Options for streaming response. Only set this when you set `stream: true`. 
 * @export
 */
export type ChatCompletionStreamOptions = {
    /**
     * If set, an additional chunk will be streamed before the `data: [DONE]` message. The `usage` field on this chunk shows the token usage statistics for the entire request, and the `choices` field will always be an empty array. All other chunks will also include a `usage` field, but with a null value. 
     * @type {boolean}
     * @memberof ChatCompletionStreamOptions
     */
    include_usage?: boolean;
}


            export type ChatCompletionStreamResponseDeltaRoleEnum = 'system' | 'user' | 'assistant' | 'tool';
/**
 * A chat completion delta generated by streamed model responses.
 * @export
 */
export type ChatCompletionStreamResponseDelta = {
    /**
     * The contents of the chunk message.
     * @type {string}
     * @memberof ChatCompletionStreamResponseDelta
     */
    content?: string;
    /**
     * 
     * @type {ChatCompletionStreamResponseDeltaFunctionCall}
     * @memberof ChatCompletionStreamResponseDelta
     */
    function_call?: ChatCompletionStreamResponseDeltaFunctionCall;
    /**
     * 
     * @type {Array<ChatCompletionMessageToolCallChunk>}
     * @memberof ChatCompletionStreamResponseDelta
     */
    tool_calls?: Array<ChatCompletionMessageToolCallChunk>;
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ChatCompletionStreamResponseDelta
     */
    role?: ChatCompletionStreamResponseDeltaRoleEnum;
    /**
     * The refusal message generated by the model.
     * @type {string}
     * @memberof ChatCompletionStreamResponseDelta
     */
    refusal?: string;
}

/**
 * Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
 * @export
 */
export type ChatCompletionStreamResponseDeltaFunctionCall = {
    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     * @type {string}
     * @memberof ChatCompletionStreamResponseDeltaFunctionCall
     */
    _arguments?: string;
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionStreamResponseDeltaFunctionCall
     */
    name?: string;
}

/**
 * 
 * @export
 */
export type ChatCompletionTokenLogprob = {
    /**
     * The token.
     * @type {string}
     * @memberof ChatCompletionTokenLogprob
     */
    token: string;
    /**
     * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
     * @type {number}
     * @memberof ChatCompletionTokenLogprob
     */
    logprob: number;
    /**
     * A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
     * @type {Array<number>}
     * @memberof ChatCompletionTokenLogprob
     */
    bytes: Array<number>;
    /**
     * List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
     * @type {Array<ChatCompletionTokenLogprobTopLogprobsInner>}
     * @memberof ChatCompletionTokenLogprob
     */
    top_logprobs: Array<ChatCompletionTokenLogprobTopLogprobsInner>;
}

/**
 * 
 * @export
 */
export type ChatCompletionTokenLogprobTopLogprobsInner = {
    /**
     * The token.
     * @type {string}
     * @memberof ChatCompletionTokenLogprobTopLogprobsInner
     */
    token: string;
    /**
     * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
     * @type {number}
     * @memberof ChatCompletionTokenLogprobTopLogprobsInner
     */
    logprob: number;
    /**
     * A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
     * @type {Array<number>}
     * @memberof ChatCompletionTokenLogprobTopLogprobsInner
     */
    bytes: Array<number>;
}


            export type ChatCompletionToolTypeEnum = 'function';
/**
 * 
 * @export
 */
export type ChatCompletionTool = {
    /**
     * The type of the tool. Currently, only `function` is supported.
     * @type {string}
     * @memberof ChatCompletionTool
     */
    type: ChatCompletionToolTypeEnum;
    /**
     * 
     * @type {FunctionObject}
     * @memberof ChatCompletionTool
     */
    _function: FunctionObject;
}


            export type ChatCompletionToolChoiceOptionTypeEnum = 'function';
/**
 * Controls which (if any) tool is called by the model. `none` means the model will not call any tool and instead generates a message. `auto` means the model can pick between generating a message or calling one or more tools. `required` means the model must call one or more tools. Specifying a particular tool via `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool.  `none` is the default when no tools are present. `auto` is the default if tools are present. 
 * @export
 */
export type ChatCompletionToolChoiceOption = {
    /**
     * The type of the tool. Currently, only `function` is supported.
     * @type {string}
     * @memberof ChatCompletionToolChoiceOption
     */
    type: ChatCompletionToolChoiceOptionTypeEnum;
    /**
     * 
     * @type {AssistantsNamedToolChoiceFunction}
     * @memberof ChatCompletionToolChoiceOption
     */
    _function: AssistantsNamedToolChoiceFunction;
}


            export type ChunkingStrategyRequestParamTypeEnum = 'auto' | 'static';
/**
 * The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
 * @export
 */
export type ChunkingStrategyRequestParam = {
    /**
     * Always `auto`.
     * @type {string}
     * @memberof ChunkingStrategyRequestParam
     */
    type: ChunkingStrategyRequestParamTypeEnum;
    /**
     * 
     * @type {StaticChunkingStrategy}
     * @memberof ChunkingStrategyRequestParam
     */
    _static: StaticChunkingStrategy;
}

/**
 * 
 * @export
 */
export type CompleteUploadRequest = {
    /**
     * The ordered list of Part IDs. 
     * @type {Array<string>}
     * @memberof CompleteUploadRequest
     */
    part_ids: Array<string>;
    /**
     * The optional md5 checksum for the file contents to verify if the bytes uploaded matches what you expect. 
     * @type {string}
     * @memberof CompleteUploadRequest
     */
    md5?: string;
}

/**
 * Usage statistics for the completion request.
 * @export
 */
export type CompletionUsage = {
    /**
     * Number of tokens in the generated completion.
     * @type {number}
     * @memberof CompletionUsage
     */
    completion_tokens: number;
    /**
     * Number of tokens in the prompt.
     * @type {number}
     * @memberof CompletionUsage
     */
    prompt_tokens: number;
    /**
     * Total number of tokens used in the request (prompt + completion).
     * @type {number}
     * @memberof CompletionUsage
     */
    total_tokens: number;
    /**
     * 
     * @type {CompletionUsageCompletionTokensDetails}
     * @memberof CompletionUsage
     */
    completion_tokens_details?: CompletionUsageCompletionTokensDetails;
    /**
     * 
     * @type {CompletionUsagePromptTokensDetails}
     * @memberof CompletionUsage
     */
    prompt_tokens_details?: CompletionUsagePromptTokensDetails;
}

/**
 * Breakdown of tokens used in a completion.
 * @export
 */
export type CompletionUsageCompletionTokensDetails = {
    /**
     * When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion. 
     * @type {number}
     * @memberof CompletionUsageCompletionTokensDetails
     */
    accepted_prediction_tokens?: number;
    /**
     * Audio input tokens generated by the model.
     * @type {number}
     * @memberof CompletionUsageCompletionTokensDetails
     */
    audio_tokens?: number;
    /**
     * Tokens generated by the model for reasoning.
     * @type {number}
     * @memberof CompletionUsageCompletionTokensDetails
     */
    reasoning_tokens?: number;
    /**
     * When using Predicted Outputs, the number of tokens in the prediction that did not appear in the completion. However, like reasoning tokens, these tokens are still counted in the total completion tokens for purposes of billing, output, and context window limits. 
     * @type {number}
     * @memberof CompletionUsageCompletionTokensDetails
     */
    rejected_prediction_tokens?: number;
}

/**
 * Breakdown of tokens used in the prompt.
 * @export
 */
export type CompletionUsagePromptTokensDetails = {
    /**
     * Audio input tokens present in the prompt.
     * @type {number}
     * @memberof CompletionUsagePromptTokensDetails
     */
    audio_tokens?: number;
    /**
     * Cached tokens present in the prompt.
     * @type {number}
     * @memberof CompletionUsagePromptTokensDetails
     */
    cached_tokens?: number;
}


            export type CostsResultObjectEnum = 'organization.costs.result';
/**
 * The aggregated costs details of the specific time bucket.
 * @export
 */
export type CostsResult = {
    /**
     * 
     * @type {string}
     * @memberof CostsResult
     */
    _object: CostsResultObjectEnum;
    /**
     * 
     * @type {CostsResultAmount}
     * @memberof CostsResult
     */
    amount?: CostsResultAmount;
    /**
     * When `group_by=line_item`, this field provides the line item of the grouped costs result.
     * @type {string}
     * @memberof CostsResult
     */
    line_item?: string;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped costs result.
     * @type {string}
     * @memberof CostsResult
     */
    project_id?: string;
}

/**
 * The monetary value in its associated currency.
 * @export
 */
export type CostsResultAmount = {
    /**
     * The numeric value of the cost.
     * @type {number}
     * @memberof CostsResultAmount
     */
    value?: number;
    /**
     * Lowercase ISO-4217 currency e.g. \"usd\"
     * @type {string}
     * @memberof CostsResultAmount
     */
    currency?: string;
}

/**
 * 
 * @export
 */
export type CreateAssistantRequest = {
    /**
     * 
     * @type {CreateAssistantRequestModel}
     * @memberof CreateAssistantRequest
     */
    model: CreateAssistantRequestModel;
    /**
     * The name of the assistant. The maximum length is 256 characters. 
     * @type {string}
     * @memberof CreateAssistantRequest
     */
    name?: string;
    /**
     * The description of the assistant. The maximum length is 512 characters. 
     * @type {string}
     * @memberof CreateAssistantRequest
     */
    description?: string;
    /**
     * The system instructions that the assistant uses. The maximum length is 256,000 characters. 
     * @type {string}
     * @memberof CreateAssistantRequest
     */
    instructions?: string;
    /**
     * A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`. 
     * @type {Array<AssistantObjectToolsInner>}
     * @memberof CreateAssistantRequest
     */
    tools?: Array<AssistantObjectToolsInner>;
    /**
     * 
     * @type {CreateAssistantRequestToolResources}
     * @memberof CreateAssistantRequest
     */
    tool_resources?: CreateAssistantRequestToolResources;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof CreateAssistantRequest
     */
    metadata?: Object;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
     * @type {number}
     * @memberof CreateAssistantRequest
     */
    temperature?: number;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
     * @type {number}
     * @memberof CreateAssistantRequest
     */
    top_p?: number;
    /**
     * 
     * @type {AssistantsApiResponseFormatOption}
     * @memberof CreateAssistantRequest
     */
    response_format?: AssistantsApiResponseFormatOption;
}

/**
 * ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them. 
 * @export
 */
export type CreateAssistantRequestModel = {
}

/**
 * A set of resources that are used by the assistant\'s tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
 * @export
 */
export type CreateAssistantRequestToolResources = {
    /**
     * 
     * @type {CreateAssistantRequestToolResourcesCodeInterpreter}
     * @memberof CreateAssistantRequestToolResources
     */
    code_interpreter?: CreateAssistantRequestToolResourcesCodeInterpreter;
    /**
     * 
     * @type {CreateAssistantRequestToolResourcesFileSearch}
     * @memberof CreateAssistantRequestToolResources
     */
    file_search?: CreateAssistantRequestToolResourcesFileSearch;
}

/**
 * 
 * @export
 */
export type CreateAssistantRequestToolResourcesCodeInterpreter = {
    /**
     * A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool. 
     * @type {Array<string>}
     * @memberof CreateAssistantRequestToolResourcesCodeInterpreter
     */
    file_ids?: Array<string>;
}

/**
 * 
 * @export
 */
export type CreateAssistantRequestToolResourcesFileSearch = {
    /**
     * The [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant. 
     * @type {Array<string>}
     * @memberof CreateAssistantRequestToolResourcesFileSearch
     */
    vector_store_ids?: Array<string>;
    /**
     * A helper to create a [vector store](/docs/api-reference/vector-stores/object) with file_ids and attach it to this assistant. There can be a maximum of 1 vector store attached to the assistant. 
     * @type {Array<CreateAssistantRequestToolResourcesFileSearchVectorStoresInner>}
     * @memberof CreateAssistantRequestToolResourcesFileSearch
     */
    vector_stores?: Array<CreateAssistantRequestToolResourcesFileSearchVectorStoresInner>;
}

/**
 * 
 * @export
 */
export type CreateAssistantRequestToolResourcesFileSearchVectorStoresInner = {
    /**
     * A list of [file](/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store. 
     * @type {Array<string>}
     * @memberof CreateAssistantRequestToolResourcesFileSearchVectorStoresInner
     */
    file_ids?: Array<string>;
    /**
     * 
     * @type {CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy}
     * @memberof CreateAssistantRequestToolResourcesFileSearchVectorStoresInner
     */
    chunking_strategy?: CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy;
    /**
     * Set of 16 key-value pairs that can be attached to a vector store. This can be useful for storing additional information about the vector store in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof CreateAssistantRequestToolResourcesFileSearchVectorStoresInner
     */
    metadata?: Object;
}


            export type CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategyTypeEnum = 'auto' | 'static';
/**
 * The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
 * @export
 */
export type CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy = {
    /**
     * Always `auto`.
     * @type {string}
     * @memberof CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy
     */
    type: CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategyTypeEnum;
    /**
     * 
     * @type {StaticChunkingStrategyStatic}
     * @memberof CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy
     */
    _static: StaticChunkingStrategyStatic;
}


            export type CreateBatchRequestEndpointEnum = '/v1/chat/completions' | '/v1/embeddings' | '/v1/completions';

            export type CreateBatchRequestCompletionWindowEnum = '24h';
/**
 * 
 * @export
 */
export type CreateBatchRequest = {
    /**
     * The ID of an uploaded file that contains requests for the new batch.  See [upload file](/docs/api-reference/files/create) for how to upload a file.  Your input file must be formatted as a [JSONL file](/docs/api-reference/batch/request-input), and must be uploaded with the purpose `batch`. The file can contain up to 50,000 requests, and can be up to 200 MB in size. 
     * @type {string}
     * @memberof CreateBatchRequest
     */
    input_file_id: string;
    /**
     * The endpoint to be used for all requests in the batch. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.
     * @type {string}
     * @memberof CreateBatchRequest
     */
    endpoint: CreateBatchRequestEndpointEnum;
    /**
     * The time frame within which the batch should be processed. Currently only `24h` is supported.
     * @type {string}
     * @memberof CreateBatchRequest
     */
    completion_window: CreateBatchRequestCompletionWindowEnum;
    /**
     * Optional custom metadata for the batch.
     * @type {{ [key: string]: string; }}
     * @memberof CreateBatchRequest
     */
    metadata?: { [key: string]: string; };
}


            export type CreateChatCompletionFunctionResponseObjectEnum = 'chat.completion';
/**
 * Represents a chat completion response returned by model, based on the provided input.
 * @export
 */
export type CreateChatCompletionFunctionResponse = {
    /**
     * A unique identifier for the chat completion.
     * @type {string}
     * @memberof CreateChatCompletionFunctionResponse
     */
    id: string;
    /**
     * A list of chat completion choices. Can be more than one if `n` is greater than 1.
     * @type {Array<CreateChatCompletionFunctionResponseChoicesInner>}
     * @memberof CreateChatCompletionFunctionResponse
     */
    choices: Array<CreateChatCompletionFunctionResponseChoicesInner>;
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created.
     * @type {number}
     * @memberof CreateChatCompletionFunctionResponse
     */
    created: number;
    /**
     * The model used for the chat completion.
     * @type {string}
     * @memberof CreateChatCompletionFunctionResponse
     */
    model: string;
    /**
     * This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
     * @type {string}
     * @memberof CreateChatCompletionFunctionResponse
     */
    system_fingerprint?: string;
    /**
     * The object type, which is always `chat.completion`.
     * @type {string}
     * @memberof CreateChatCompletionFunctionResponse
     */
    _object: CreateChatCompletionFunctionResponseObjectEnum;
    /**
     * 
     * @type {CompletionUsage}
     * @memberof CreateChatCompletionFunctionResponse
     */
    usage?: CompletionUsage;
}


            export type CreateChatCompletionFunctionResponseChoicesInnerFinishReasonEnum = 'stop' | 'length' | 'function_call' | 'content_filter';
/**
 * 
 * @export
 */
export type CreateChatCompletionFunctionResponseChoicesInner = {
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, or `function_call` if the model called a function. 
     * @type {string}
     * @memberof CreateChatCompletionFunctionResponseChoicesInner
     */
    finish_reason: CreateChatCompletionFunctionResponseChoicesInnerFinishReasonEnum;
    /**
     * The index of the choice in the list of choices.
     * @type {number}
     * @memberof CreateChatCompletionFunctionResponseChoicesInner
     */
    index: number;
    /**
     * 
     * @type {ChatCompletionResponseMessage}
     * @memberof CreateChatCompletionFunctionResponseChoicesInner
     */
    message: ChatCompletionResponseMessage;
}


            export type CreateChatCompletionRequestReasoningEffortEnum = 'low' | 'medium' | 'high';

            export type CreateChatCompletionRequestModalitiesEnum = 'text' | 'audio';

            export type CreateChatCompletionRequestServiceTierEnum = 'auto' | 'default';
/**
 * 
 * @export
 */
export type CreateChatCompletionRequest = {
    /**
     * A list of messages comprising the conversation so far. Depending on the [model](/docs/models) you use, different message types (modalities) are supported, like [text](/docs/guides/text-generation), [images](/docs/guides/vision), and [audio](/docs/guides/audio). 
     * @type {Array<ChatCompletionRequestMessage>}
     * @memberof CreateChatCompletionRequest
     */
    messages: Array<ChatCompletionRequestMessage>;
    /**
     * 
     * @type {CreateChatCompletionRequestModel}
     * @memberof CreateChatCompletionRequest
     */
    model: CreateChatCompletionRequestModel;
    /**
     * Whether or not to store the output of this chat completion request for  use in our [model distillation](/docs/guides/distillation) or [evals](/docs/guides/evals) products. 
     * @type {boolean}
     * @memberof CreateChatCompletionRequest
     */
    store?: boolean;
    /**
     * **o1 models only**   Constrains effort on reasoning for  [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `low`, `medium`, and `high`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response. 
     * @type {string}
     * @memberof CreateChatCompletionRequest
     */
    reasoning_effort?: CreateChatCompletionRequestReasoningEffortEnum;
    /**
     * Developer-defined tags and values used for filtering completions in the [dashboard](https://platform.openai.com/chat-completions). 
     * @type {{ [key: string]: string; }}
     * @memberof CreateChatCompletionRequest
     */
    metadata?: { [key: string]: string; };
    /**
     * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model\'s likelihood to repeat the same line verbatim. 
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    frequency_penalty?: number;
    /**
     * Modify the likelihood of specified tokens appearing in the completion.  Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token. 
     * @type {{ [key: string]: number; }}
     * @memberof CreateChatCompletionRequest
     */
    logit_bias?: { [key: string]: number; };
    /**
     * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the `content` of `message`. 
     * @type {boolean}
     * @memberof CreateChatCompletionRequest
     */
    logprobs?: boolean;
    /**
     * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. `logprobs` must be set to `true` if this parameter is used. 
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    top_logprobs?: number;
    /**
     * The maximum number of [tokens](/tokenizer) that can be generated in the chat completion. This value can be used to control [costs](https://openai.com/api/pricing/) for text generated via API.  This value is now deprecated in favor of `max_completion_tokens`, and is not compatible with [o1 series models](/docs/guides/reasoning). 
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    max_tokens?: number;
    /**
     * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and [reasoning tokens](/docs/guides/reasoning). 
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    max_completion_tokens?: number;
    /**
     * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    n?: number;
    /**
     * Output types that you would like the model to generate for this request. Most models are capable of generating text, which is the default:  `[\"text\"]`  The `gpt-4o-audio-preview` model can also be used to [generate audio](/docs/guides/audio). To request that this model generate both text and audio responses, you can use:  `[\"text\", \"audio\"]` 
     * @type {Array<string>}
     * @memberof CreateChatCompletionRequest
     */
    modalities?: Array<CreateChatCompletionRequestModalitiesEnum>;
    /**
     * 
     * @type {PredictionContent}
     * @memberof CreateChatCompletionRequest
     */
    prediction?: PredictionContent;
    /**
     * 
     * @type {CreateChatCompletionRequestAudio}
     * @memberof CreateChatCompletionRequest
     */
    audio?: CreateChatCompletionRequestAudio;
    /**
     * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model\'s likelihood to talk about new topics. 
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    presence_penalty?: number;
    /**
     * 
     * @type {CreateChatCompletionRequestResponseFormat}
     * @memberof CreateChatCompletionRequest
     */
    response_format?: CreateChatCompletionRequestResponseFormat;
    /**
     * This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result. Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend. 
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    seed?: number;
    /**
     * Specifies the latency tier to use for processing the request. This parameter is relevant for customers subscribed to the scale tier service:    - If set to \'auto\', and the Project is Scale tier enabled, the system will utilize scale tier credits until they are exhausted.   - If set to \'auto\', and the Project is not Scale tier enabled, the request will be processed using the default service tier with a lower uptime SLA and no latency guarentee.   - If set to \'default\', the request will be processed using the default service tier with a lower uptime SLA and no latency guarentee.   - When not set, the default behavior is \'auto\'.    When this parameter is set, the response body will include the `service_tier` utilized. 
     * @type {string}
     * @memberof CreateChatCompletionRequest
     */
    service_tier?: CreateChatCompletionRequestServiceTierEnum;
    /**
     * 
     * @type {CreateChatCompletionRequestStop}
     * @memberof CreateChatCompletionRequest
     */
    stop?: CreateChatCompletionRequestStop;
    /**
     * If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions). 
     * @type {boolean}
     * @memberof CreateChatCompletionRequest
     */
    stream?: boolean;
    /**
     * 
     * @type {ChatCompletionStreamOptions}
     * @memberof CreateChatCompletionRequest
     */
    stream_options?: ChatCompletionStreamOptions;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. We generally recommend altering this or `top_p` but not both. 
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    temperature?: number;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or `temperature` but not both. 
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    top_p?: number;
    /**
     * A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported. 
     * @type {Array<ChatCompletionTool>}
     * @memberof CreateChatCompletionRequest
     */
    tools?: Array<ChatCompletionTool>;
    /**
     * 
     * @type {ChatCompletionToolChoiceOption}
     * @memberof CreateChatCompletionRequest
     */
    tool_choice?: ChatCompletionToolChoiceOption;
    /**
     * Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
     * @type {boolean}
     * @memberof CreateChatCompletionRequest
     */
    parallel_tool_calls?: boolean;
    /**
     * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
     * @type {string}
     * @memberof CreateChatCompletionRequest
     */
    user?: string;
    /**
     * 
     * @type {CreateChatCompletionRequestFunctionCall}
     * @memberof CreateChatCompletionRequest
     */
    function_call?: CreateChatCompletionRequestFunctionCall;
    /**
     * Deprecated in favor of `tools`.  A list of functions the model may generate JSON inputs for. 
     * @type {Array<ChatCompletionFunctions>}
     * @memberof CreateChatCompletionRequest
     */
    functions?: Array<ChatCompletionFunctions>;
}


            export type CreateChatCompletionRequestAudioVoiceEnum = 'alloy' | 'ash' | 'ballad' | 'coral' | 'echo' | 'sage' | 'shimmer' | 'verse';

            export type CreateChatCompletionRequestAudioFormatEnum = 'wav' | 'mp3' | 'flac' | 'opus' | 'pcm16';
/**
 * Parameters for audio output. Required when audio output is requested with `modalities: [\"audio\"]`. [Learn more](/docs/guides/audio). 
 * @export
 */
export type CreateChatCompletionRequestAudio = {
    /**
     * The voice the model uses to respond. Supported voices are `ash`, `ballad`, `coral`, `sage`, and `verse` (also supported but not recommended are `alloy`, `echo`, and `shimmer`; these voices are less expressive). 
     * @type {string}
     * @memberof CreateChatCompletionRequestAudio
     */
    voice: CreateChatCompletionRequestAudioVoiceEnum;
    /**
     * Specifies the output audio format. Must be one of `wav`, `mp3`, `flac`, `opus`, or `pcm16`. 
     * @type {string}
     * @memberof CreateChatCompletionRequestAudio
     */
    format: CreateChatCompletionRequestAudioFormatEnum;
}

/**
 * Deprecated in favor of `tool_choice`.  Controls which (if any) function is called by the model.  `none` means the model will not call a function and instead generates a message.  `auto` means the model can pick between generating a message or calling a function.  Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function.  `none` is the default when no functions are present. `auto` is the default if functions are present. 
 * @export
 */
export type CreateChatCompletionRequestFunctionCall = {
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof CreateChatCompletionRequestFunctionCall
     */
    name: string;
}

/**
 * ID of the model to use. See the [model endpoint compatibility](/docs/models#model-endpoint-compatibility) table for details on which models work with the Chat API.
 * @export
 */
export type CreateChatCompletionRequestModel = {
}


            export type CreateChatCompletionRequestResponseFormatTypeEnum = 'text' | 'json_object' | 'json_schema';
/**
 * An object specifying the format that the model must output.  Setting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).  Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the message the model generates is valid JSON.  **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \"stuck\" request. Also note that the message content may be partially cut off if `finish_reason=\"length\"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length. 
 * @export
 */
export type CreateChatCompletionRequestResponseFormat = {
    /**
     * The type of response format being defined: `text`
     * @type {string}
     * @memberof CreateChatCompletionRequestResponseFormat
     */
    type: CreateChatCompletionRequestResponseFormatTypeEnum;
    /**
     * 
     * @type {ResponseFormatJsonSchemaJsonSchema}
     * @memberof CreateChatCompletionRequestResponseFormat
     */
    json_schema: ResponseFormatJsonSchemaJsonSchema;
}

/**
 * Up to 4 sequences where the API will stop generating further tokens. 
 * @export
 */
export type CreateChatCompletionRequestStop = {
}


            export type CreateChatCompletionResponseServiceTierEnum = 'scale' | 'default';

            export type CreateChatCompletionResponseObjectEnum = 'chat.completion';
/**
 * Represents a chat completion response returned by model, based on the provided input.
 * @export
 */
export type CreateChatCompletionResponse = {
    /**
     * A unique identifier for the chat completion.
     * @type {string}
     * @memberof CreateChatCompletionResponse
     */
    id: string;
    /**
     * A list of chat completion choices. Can be more than one if `n` is greater than 1.
     * @type {Array<CreateChatCompletionResponseChoicesInner>}
     * @memberof CreateChatCompletionResponse
     */
    choices: Array<CreateChatCompletionResponseChoicesInner>;
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created.
     * @type {number}
     * @memberof CreateChatCompletionResponse
     */
    created: number;
    /**
     * The model used for the chat completion.
     * @type {string}
     * @memberof CreateChatCompletionResponse
     */
    model: string;
    /**
     * The service tier used for processing the request. This field is only included if the `service_tier` parameter is specified in the request.
     * @type {string}
     * @memberof CreateChatCompletionResponse
     */
    service_tier?: CreateChatCompletionResponseServiceTierEnum;
    /**
     * This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
     * @type {string}
     * @memberof CreateChatCompletionResponse
     */
    system_fingerprint?: string;
    /**
     * The object type, which is always `chat.completion`.
     * @type {string}
     * @memberof CreateChatCompletionResponse
     */
    _object: CreateChatCompletionResponseObjectEnum;
    /**
     * 
     * @type {CompletionUsage}
     * @memberof CreateChatCompletionResponse
     */
    usage?: CompletionUsage;
}


            export type CreateChatCompletionResponseChoicesInnerFinishReasonEnum = 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
/**
 * 
 * @export
 */
export type CreateChatCompletionResponseChoicesInner = {
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
     * @type {string}
     * @memberof CreateChatCompletionResponseChoicesInner
     */
    finish_reason: CreateChatCompletionResponseChoicesInnerFinishReasonEnum;
    /**
     * The index of the choice in the list of choices.
     * @type {number}
     * @memberof CreateChatCompletionResponseChoicesInner
     */
    index: number;
    /**
     * 
     * @type {ChatCompletionResponseMessage}
     * @memberof CreateChatCompletionResponseChoicesInner
     */
    message: ChatCompletionResponseMessage;
    /**
     * 
     * @type {CreateChatCompletionResponseChoicesInnerLogprobs}
     * @memberof CreateChatCompletionResponseChoicesInner
     */
    logprobs: CreateChatCompletionResponseChoicesInnerLogprobs;
}

/**
 * Log probability information for the choice.
 * @export
 */
export type CreateChatCompletionResponseChoicesInnerLogprobs = {
    /**
     * A list of message content tokens with log probability information.
     * @type {Array<ChatCompletionTokenLogprob>}
     * @memberof CreateChatCompletionResponseChoicesInnerLogprobs
     */
    content: Array<ChatCompletionTokenLogprob>;
    /**
     * A list of message refusal tokens with log probability information.
     * @type {Array<ChatCompletionTokenLogprob>}
     * @memberof CreateChatCompletionResponseChoicesInnerLogprobs
     */
    refusal: Array<ChatCompletionTokenLogprob>;
}


            export type CreateChatCompletionStreamResponseServiceTierEnum = 'scale' | 'default';

            export type CreateChatCompletionStreamResponseObjectEnum = 'chat.completion.chunk';
/**
 * Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
 * @export
 */
export type CreateChatCompletionStreamResponse = {
    /**
     * A unique identifier for the chat completion. Each chunk has the same ID.
     * @type {string}
     * @memberof CreateChatCompletionStreamResponse
     */
    id: string;
    /**
     * A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the last chunk if you set `stream_options: {\"include_usage\": true}`. 
     * @type {Array<CreateChatCompletionStreamResponseChoicesInner>}
     * @memberof CreateChatCompletionStreamResponse
     */
    choices: Array<CreateChatCompletionStreamResponseChoicesInner>;
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
     * @type {number}
     * @memberof CreateChatCompletionStreamResponse
     */
    created: number;
    /**
     * The model to generate the completion.
     * @type {string}
     * @memberof CreateChatCompletionStreamResponse
     */
    model: string;
    /**
     * The service tier used for processing the request. This field is only included if the `service_tier` parameter is specified in the request.
     * @type {string}
     * @memberof CreateChatCompletionStreamResponse
     */
    service_tier?: CreateChatCompletionStreamResponseServiceTierEnum;
    /**
     * This fingerprint represents the backend configuration that the model runs with. Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
     * @type {string}
     * @memberof CreateChatCompletionStreamResponse
     */
    system_fingerprint?: string;
    /**
     * The object type, which is always `chat.completion.chunk`.
     * @type {string}
     * @memberof CreateChatCompletionStreamResponse
     */
    _object: CreateChatCompletionStreamResponseObjectEnum;
    /**
     * 
     * @type {CreateChatCompletionStreamResponseUsage}
     * @memberof CreateChatCompletionStreamResponse
     */
    usage?: CreateChatCompletionStreamResponseUsage;
}


            export type CreateChatCompletionStreamResponseChoicesInnerFinishReasonEnum = 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
/**
 * 
 * @export
 */
export type CreateChatCompletionStreamResponseChoicesInner = {
    /**
     * 
     * @type {ChatCompletionStreamResponseDelta}
     * @memberof CreateChatCompletionStreamResponseChoicesInner
     */
    delta: ChatCompletionStreamResponseDelta;
    /**
     * 
     * @type {CreateChatCompletionResponseChoicesInnerLogprobs}
     * @memberof CreateChatCompletionStreamResponseChoicesInner
     */
    logprobs?: CreateChatCompletionResponseChoicesInnerLogprobs;
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
     * @type {string}
     * @memberof CreateChatCompletionStreamResponseChoicesInner
     */
    finish_reason: CreateChatCompletionStreamResponseChoicesInnerFinishReasonEnum;
    /**
     * The index of the choice in the list of choices.
     * @type {number}
     * @memberof CreateChatCompletionStreamResponseChoicesInner
     */
    index: number;
}

/**
 * An optional field that will only be present when you set `stream_options: {\"include_usage\": true}` in your request. When present, it contains a null value except for the last chunk which contains the token usage statistics for the entire request. 
 * @export
 */
export type CreateChatCompletionStreamResponseUsage = {
    /**
     * Number of tokens in the generated completion.
     * @type {number}
     * @memberof CreateChatCompletionStreamResponseUsage
     */
    completion_tokens: number;
    /**
     * Number of tokens in the prompt.
     * @type {number}
     * @memberof CreateChatCompletionStreamResponseUsage
     */
    prompt_tokens: number;
    /**
     * Total number of tokens used in the request (prompt + completion).
     * @type {number}
     * @memberof CreateChatCompletionStreamResponseUsage
     */
    total_tokens: number;
}

/**
 * 
 * @export
 */
export type CreateCompletionRequest = {
    /**
     * 
     * @type {CreateCompletionRequestModel}
     * @memberof CreateCompletionRequest
     */
    model: CreateCompletionRequestModel;
    /**
     * 
     * @type {CreateCompletionRequestPrompt}
     * @memberof CreateCompletionRequest
     */
    prompt: CreateCompletionRequestPrompt;
    /**
     * Generates `best_of` completions server-side and returns the \"best\" (the one with the highest log probability per token). Results cannot be streamed.  When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return  `best_of` must be greater than `n`.  **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`. 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    best_of?: number;
    /**
     * Echo back the prompt in addition to the completion 
     * @type {boolean}
     * @memberof CreateCompletionRequest
     */
    echo?: boolean;
    /**
     * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model\'s likelihood to repeat the same line verbatim.  [See more information about frequency and presence penalties.](/docs/guides/text-generation) 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    frequency_penalty?: number;
    /**
     * Modify the likelihood of specified tokens appearing in the completion.  Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.  As an example, you can pass `{\"50256\": -100}` to prevent the <|endoftext|> token from being generated. 
     * @type {{ [key: string]: number; }}
     * @memberof CreateCompletionRequest
     */
    logit_bias?: { [key: string]: number; };
    /**
     * Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.  The maximum value for `logprobs` is 5. 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    logprobs?: number;
    /**
     * The maximum number of [tokens](/tokenizer) that can be generated in the completion.  The token count of your prompt plus `max_tokens` cannot exceed the model\'s context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    max_tokens?: number;
    /**
     * How many completions to generate for each prompt.  **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`. 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    n?: number;
    /**
     * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model\'s likelihood to talk about new topics.  [See more information about frequency and presence penalties.](/docs/guides/text-generation) 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    presence_penalty?: number;
    /**
     * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.  Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend. 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    seed?: number;
    /**
     * 
     * @type {CreateCompletionRequestStop}
     * @memberof CreateCompletionRequest
     */
    stop?: CreateCompletionRequestStop;
    /**
     * Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions). 
     * @type {boolean}
     * @memberof CreateCompletionRequest
     */
    stream?: boolean;
    /**
     * 
     * @type {ChatCompletionStreamOptions}
     * @memberof CreateCompletionRequest
     */
    stream_options?: ChatCompletionStreamOptions;
    /**
     * The suffix that comes after a completion of inserted text.  This parameter is only supported for `gpt-3.5-turbo-instruct`. 
     * @type {string}
     * @memberof CreateCompletionRequest
     */
    suffix?: string;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or `top_p` but not both. 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    temperature?: number;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or `temperature` but not both. 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    top_p?: number;
    /**
     * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
     * @type {string}
     * @memberof CreateCompletionRequest
     */
    user?: string;
}

/**
 * ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them. 
 * @export
 */
export type CreateCompletionRequestModel = {
}

/**
 * The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.  Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document. 
 * @export
 */
export type CreateCompletionRequestPrompt = {
}

/**
 * Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence. 
 * @export
 */
export type CreateCompletionRequestStop = {
}


            export type CreateCompletionResponseObjectEnum = 'text_completion';
/**
 * Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape (unlike the chat endpoint). 
 * @export
 */
export type CreateCompletionResponse = {
    /**
     * A unique identifier for the completion.
     * @type {string}
     * @memberof CreateCompletionResponse
     */
    id: string;
    /**
     * The list of completion choices the model generated for the input prompt.
     * @type {Array<CreateCompletionResponseChoicesInner>}
     * @memberof CreateCompletionResponse
     */
    choices: Array<CreateCompletionResponseChoicesInner>;
    /**
     * The Unix timestamp (in seconds) of when the completion was created.
     * @type {number}
     * @memberof CreateCompletionResponse
     */
    created: number;
    /**
     * The model used for completion.
     * @type {string}
     * @memberof CreateCompletionResponse
     */
    model: string;
    /**
     * This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
     * @type {string}
     * @memberof CreateCompletionResponse
     */
    system_fingerprint?: string;
    /**
     * The object type, which is always \"text_completion\"
     * @type {string}
     * @memberof CreateCompletionResponse
     */
    _object: CreateCompletionResponseObjectEnum;
    /**
     * 
     * @type {CompletionUsage}
     * @memberof CreateCompletionResponse
     */
    usage?: CompletionUsage;
}


            export type CreateCompletionResponseChoicesInnerFinishReasonEnum = 'stop' | 'length' | 'content_filter';
/**
 * 
 * @export
 */
export type CreateCompletionResponseChoicesInner = {
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, or `content_filter` if content was omitted due to a flag from our content filters. 
     * @type {string}
     * @memberof CreateCompletionResponseChoicesInner
     */
    finish_reason: CreateCompletionResponseChoicesInnerFinishReasonEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateCompletionResponseChoicesInner
     */
    index: number;
    /**
     * 
     * @type {CreateCompletionResponseChoicesInnerLogprobs}
     * @memberof CreateCompletionResponseChoicesInner
     */
    logprobs: CreateCompletionResponseChoicesInnerLogprobs;
    /**
     * 
     * @type {string}
     * @memberof CreateCompletionResponseChoicesInner
     */
    text: string;
}

/**
 * 
 * @export
 */
export type CreateCompletionResponseChoicesInnerLogprobs = {
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateCompletionResponseChoicesInnerLogprobs
     */
    text_offset?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateCompletionResponseChoicesInnerLogprobs
     */
    token_logprobs?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCompletionResponseChoicesInnerLogprobs
     */
    tokens?: Array<string>;
    /**
     * 
     * @type {Array<{ [key: string]: number; }>}
     * @memberof CreateCompletionResponseChoicesInnerLogprobs
     */
    top_logprobs?: Array<{ [key: string]: number; }>;
}


            export type CreateEmbeddingRequestEncodingFormatEnum = 'float' | 'base64';
/**
 * 
 * @export
 */
export type CreateEmbeddingRequest = {
    /**
     * 
     * @type {CreateEmbeddingRequestInput}
     * @memberof CreateEmbeddingRequest
     */
    input: CreateEmbeddingRequestInput;
    /**
     * 
     * @type {CreateEmbeddingRequestModel}
     * @memberof CreateEmbeddingRequest
     */
    model: CreateEmbeddingRequestModel;
    /**
     * The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
     * @type {string}
     * @memberof CreateEmbeddingRequest
     */
    encoding_format?: CreateEmbeddingRequestEncodingFormatEnum;
    /**
     * The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models. 
     * @type {number}
     * @memberof CreateEmbeddingRequest
     */
    dimensions?: number;
    /**
     * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
     * @type {string}
     * @memberof CreateEmbeddingRequest
     */
    user?: string;
}

/**
 * Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. 
 * @export
 */
export type CreateEmbeddingRequestInput = {
}

/**
 * ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them. 
 * @export
 */
export type CreateEmbeddingRequestModel = {
}


            export type CreateEmbeddingResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type CreateEmbeddingResponse = {
    /**
     * The list of embeddings generated by the model.
     * @type {Array<Embedding>}
     * @memberof CreateEmbeddingResponse
     */
    data: Array<Embedding>;
    /**
     * The name of the model used to generate the embedding.
     * @type {string}
     * @memberof CreateEmbeddingResponse
     */
    model: string;
    /**
     * The object type, which is always \"list\".
     * @type {string}
     * @memberof CreateEmbeddingResponse
     */
    _object: CreateEmbeddingResponseObjectEnum;
    /**
     * 
     * @type {CreateEmbeddingResponseUsage}
     * @memberof CreateEmbeddingResponse
     */
    usage: CreateEmbeddingResponseUsage;
}

/**
 * The usage information for the request.
 * @export
 */
export type CreateEmbeddingResponseUsage = {
    /**
     * The number of tokens used by the prompt.
     * @type {number}
     * @memberof CreateEmbeddingResponseUsage
     */
    prompt_tokens: number;
    /**
     * The total number of tokens used by the request.
     * @type {number}
     * @memberof CreateEmbeddingResponseUsage
     */
    total_tokens: number;
}

/**
 * 
 * @export
 */
export type CreateFineTuningJobRequest = {
    /**
     * 
     * @type {CreateFineTuningJobRequestModel}
     * @memberof CreateFineTuningJobRequest
     */
    model: CreateFineTuningJobRequestModel;
    /**
     * The ID of an uploaded file that contains training data.  See [upload file](/docs/api-reference/files/create) for how to upload a file.  Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.  The contents of the file should differ depending on if the model uses the [chat](/docs/api-reference/fine-tuning/chat-input), [completions](/docs/api-reference/fine-tuning/completions-input) format, or if the fine-tuning method uses the [preference](/docs/api-reference/fine-tuning/preference-input) format.  See the [fine-tuning guide](/docs/guides/fine-tuning) for more details. 
     * @type {string}
     * @memberof CreateFineTuningJobRequest
     */
    training_file: string;
    /**
     * 
     * @type {CreateFineTuningJobRequestHyperparameters}
     * @memberof CreateFineTuningJobRequest
     */
    hyperparameters?: CreateFineTuningJobRequestHyperparameters;
    /**
     * A string of up to 64 characters that will be added to your fine-tuned model name.  For example, a `suffix` of \"custom-model-name\" would produce a model name like `ft:gpt-4o-mini:openai:custom-model-name:7p4lURel`. 
     * @type {string}
     * @memberof CreateFineTuningJobRequest
     */
    suffix?: string;
    /**
     * The ID of an uploaded file that contains validation data.  If you provide this file, the data is used to generate validation metrics periodically during fine-tuning. These metrics can be viewed in the fine-tuning results file. The same data should not be present in both train and validation files.  Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.  See the [fine-tuning guide](/docs/guides/fine-tuning) for more details. 
     * @type {string}
     * @memberof CreateFineTuningJobRequest
     */
    validation_file?: string;
    /**
     * A list of integrations to enable for your fine-tuning job.
     * @type {Array<CreateFineTuningJobRequestIntegrationsInner>}
     * @memberof CreateFineTuningJobRequest
     */
    integrations?: Array<CreateFineTuningJobRequestIntegrationsInner>;
    /**
     * The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases. If a seed is not specified, one will be generated for you. 
     * @type {number}
     * @memberof CreateFineTuningJobRequest
     */
    seed?: number;
    /**
     * 
     * @type {FineTuneMethod}
     * @memberof CreateFineTuningJobRequest
     */
    method?: FineTuneMethod;
}

/**
 * The hyperparameters used for the fine-tuning job. This value is now deprecated in favor of `method`, and should be passed in under the `method` parameter. 
 * @export
 */
export type CreateFineTuningJobRequestHyperparameters = {
    /**
     * 
     * @type {CreateFineTuningJobRequestHyperparametersBatchSize}
     * @memberof CreateFineTuningJobRequestHyperparameters
     */
    batch_size?: CreateFineTuningJobRequestHyperparametersBatchSize;
    /**
     * 
     * @type {CreateFineTuningJobRequestHyperparametersLearningRateMultiplier}
     * @memberof CreateFineTuningJobRequestHyperparameters
     */
    learning_rate_multiplier?: CreateFineTuningJobRequestHyperparametersLearningRateMultiplier;
    /**
     * 
     * @type {CreateFineTuningJobRequestHyperparametersNEpochs}
     * @memberof CreateFineTuningJobRequestHyperparameters
     */
    n_epochs?: CreateFineTuningJobRequestHyperparametersNEpochs;
}

/**
 * Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance. 
 * @export
 */
export type CreateFineTuningJobRequestHyperparametersBatchSize = {
}

/**
 * Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting. 
 * @export
 */
export type CreateFineTuningJobRequestHyperparametersLearningRateMultiplier = {
}

/**
 * The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset. 
 * @export
 */
export type CreateFineTuningJobRequestHyperparametersNEpochs = {
}


            export type CreateFineTuningJobRequestIntegrationsInnerTypeEnum = 'wandb';
/**
 * 
 * @export
 */
export type CreateFineTuningJobRequestIntegrationsInner = {
    /**
     * 
     * @type {string}
     * @memberof CreateFineTuningJobRequestIntegrationsInner
     */
    type: CreateFineTuningJobRequestIntegrationsInnerTypeEnum;
    /**
     * 
     * @type {CreateFineTuningJobRequestIntegrationsInnerWandb}
     * @memberof CreateFineTuningJobRequestIntegrationsInner
     */
    wandb: CreateFineTuningJobRequestIntegrationsInnerWandb;
}

/**
 * The settings for your integration with Weights and Biases. This payload specifies the project that metrics will be sent to. Optionally, you can set an explicit display name for your run, add tags to your run, and set a default entity (team, username, etc) to be associated with your run. 
 * @export
 */
export type CreateFineTuningJobRequestIntegrationsInnerWandb = {
    /**
     * The name of the project that the new run will be created under. 
     * @type {string}
     * @memberof CreateFineTuningJobRequestIntegrationsInnerWandb
     */
    project: string;
    /**
     * A display name to set for the run. If not set, we will use the Job ID as the name. 
     * @type {string}
     * @memberof CreateFineTuningJobRequestIntegrationsInnerWandb
     */
    name?: string;
    /**
     * The entity to use for the run. This allows you to set the team or username of the WandB user that you would like associated with the run. If not set, the default entity for the registered WandB API key is used. 
     * @type {string}
     * @memberof CreateFineTuningJobRequestIntegrationsInnerWandb
     */
    entity?: string;
    /**
     * A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some default tags are generated by OpenAI: \"openai/finetune\", \"openai/{base-model}\", \"openai/{ftjob-abcdef}\". 
     * @type {Array<string>}
     * @memberof CreateFineTuningJobRequestIntegrationsInnerWandb
     */
    tags?: Array<string>;
}

/**
 * The name of the model to fine-tune. You can select one of the [supported models](/docs/guides/fine-tuning#which-models-can-be-fine-tuned). 
 * @export
 */
export type CreateFineTuningJobRequestModel = {
}

/**
 * The model to use for image generation. Only `dall-e-2` is supported at this time.
 * @export
 */
export type CreateImageEditRequestModel = {
}


            export type CreateImageRequestQualityEnum = 'standard' | 'hd';

            export type CreateImageRequestResponseFormatEnum = 'url' | 'b64_json';

            export type CreateImageRequestSizeEnum = '256x256' | '512x512' | '1024x1024' | '1792x1024' | '1024x1792';

            export type CreateImageRequestStyleEnum = 'vivid' | 'natural';
/**
 * 
 * @export
 */
export type CreateImageRequest = {
    /**
     * A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
     * @type {string}
     * @memberof CreateImageRequest
     */
    prompt: string;
    /**
     * 
     * @type {CreateImageRequestModel}
     * @memberof CreateImageRequest
     */
    model?: CreateImageRequestModel;
    /**
     * The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
     * @type {number}
     * @memberof CreateImageRequest
     */
    n?: number;
    /**
     * The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
     * @type {string}
     * @memberof CreateImageRequest
     */
    quality?: CreateImageRequestQualityEnum;
    /**
     * The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
     * @type {string}
     * @memberof CreateImageRequest
     */
    response_format?: CreateImageRequestResponseFormatEnum;
    /**
     * The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
     * @type {string}
     * @memberof CreateImageRequest
     */
    size?: CreateImageRequestSizeEnum;
    /**
     * The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
     * @type {string}
     * @memberof CreateImageRequest
     */
    style?: CreateImageRequestStyleEnum;
    /**
     * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
     * @type {string}
     * @memberof CreateImageRequest
     */
    user?: string;
}

/**
 * The model to use for image generation.
 * @export
 */
export type CreateImageRequestModel = {
}


            export type CreateMessageRequestRoleEnum = 'user' | 'assistant';
/**
 * 
 * @export
 */
export type CreateMessageRequest = {
    /**
     * The role of the entity that is creating the message. Allowed values include: - `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages. - `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation. 
     * @type {string}
     * @memberof CreateMessageRequest
     */
    role: CreateMessageRequestRoleEnum;
    /**
     * 
     * @type {CreateMessageRequestContent}
     * @memberof CreateMessageRequest
     */
    content: CreateMessageRequestContent;
    /**
     * A list of files attached to the message, and the tools they should be added to.
     * @type {Array<CreateMessageRequestAttachmentsInner>}
     * @memberof CreateMessageRequest
     */
    attachments?: Array<CreateMessageRequestAttachmentsInner>;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof CreateMessageRequest
     */
    metadata?: Object;
}

/**
 * 
 * @export
 */
export type CreateMessageRequestAttachmentsInner = {
    /**
     * The ID of the file to attach to the message.
     * @type {string}
     * @memberof CreateMessageRequestAttachmentsInner
     */
    file_id?: string;
    /**
     * The tools to add this file to.
     * @type {Array<CreateMessageRequestAttachmentsInnerToolsInner>}
     * @memberof CreateMessageRequestAttachmentsInner
     */
    tools?: Array<CreateMessageRequestAttachmentsInnerToolsInner>;
}


            export type CreateMessageRequestAttachmentsInnerToolsInnerTypeEnum = 'code_interpreter' | 'file_search';
/**
 * 
 * @export
 */
export type CreateMessageRequestAttachmentsInnerToolsInner = {
    /**
     * The type of tool being defined: `code_interpreter`
     * @type {string}
     * @memberof CreateMessageRequestAttachmentsInnerToolsInner
     */
    type: CreateMessageRequestAttachmentsInnerToolsInnerTypeEnum;
}

/**
 * 
 * @export
 */
export type CreateMessageRequestContent = {
}

/**
 * 
 * @export
 */
export type CreateModerationRequest = {
    /**
     * 
     * @type {CreateModerationRequestInput}
     * @memberof CreateModerationRequest
     */
    input: CreateModerationRequestInput;
    /**
     * 
     * @type {CreateModerationRequestModel}
     * @memberof CreateModerationRequest
     */
    model?: CreateModerationRequestModel;
}

/**
 * Input (or inputs) to classify. Can be a single string, an array of strings, or an array of multi-modal input objects similar to other models. 
 * @export
 */
export type CreateModerationRequestInput = {
}


            export type CreateModerationRequestInputOneOfInnerTypeEnum = 'image_url' | 'text';
/**
 * 
 * @export
 */
export type CreateModerationRequestInputOneOfInner = {
    /**
     * Always `image_url`.
     * @type {string}
     * @memberof CreateModerationRequestInputOneOfInner
     */
    type: CreateModerationRequestInputOneOfInnerTypeEnum;
    /**
     * 
     * @type {CreateModerationRequestInputOneOfInnerOneOfImageUrl}
     * @memberof CreateModerationRequestInputOneOfInner
     */
    image_url: CreateModerationRequestInputOneOfInnerOneOfImageUrl;
    /**
     * A string of text to classify.
     * @type {string}
     * @memberof CreateModerationRequestInputOneOfInner
     */
    text: string;
}


            export type CreateModerationRequestInputOneOfInnerOneOfTypeEnum = 'image_url';
/**
 * An object describing an image to classify.
 * @export
 */
export type CreateModerationRequestInputOneOfInnerOneOf = {
    /**
     * Always `image_url`.
     * @type {string}
     * @memberof CreateModerationRequestInputOneOfInnerOneOf
     */
    type: CreateModerationRequestInputOneOfInnerOneOfTypeEnum;
    /**
     * 
     * @type {CreateModerationRequestInputOneOfInnerOneOfImageUrl}
     * @memberof CreateModerationRequestInputOneOfInnerOneOf
     */
    image_url: CreateModerationRequestInputOneOfInnerOneOfImageUrl;
}


            export type CreateModerationRequestInputOneOfInnerOneOf1TypeEnum = 'text';
/**
 * An object describing text to classify.
 * @export
 */
export type CreateModerationRequestInputOneOfInnerOneOf1 = {
    /**
     * Always `text`.
     * @type {string}
     * @memberof CreateModerationRequestInputOneOfInnerOneOf1
     */
    type: CreateModerationRequestInputOneOfInnerOneOf1TypeEnum;
    /**
     * A string of text to classify.
     * @type {string}
     * @memberof CreateModerationRequestInputOneOfInnerOneOf1
     */
    text: string;
}

/**
 * Contains either an image URL or a data URL for a base64 encoded image.
 * @export
 */
export type CreateModerationRequestInputOneOfInnerOneOfImageUrl = {
    /**
     * Either a URL of the image or the base64 encoded image data.
     * @type {string}
     * @memberof CreateModerationRequestInputOneOfInnerOneOfImageUrl
     */
    url: string;
}

/**
 * The content moderation model you would like to use. Learn more in [the moderation guide](/docs/guides/moderation), and learn about available models [here](/docs/models#moderation). 
 * @export
 */
export type CreateModerationRequestModel = {
}

/**
 * Represents if a given text input is potentially harmful.
 * @export
 */
export type CreateModerationResponse = {
    /**
     * The unique identifier for the moderation request.
     * @type {string}
     * @memberof CreateModerationResponse
     */
    id: string;
    /**
     * The model used to generate the moderation results.
     * @type {string}
     * @memberof CreateModerationResponse
     */
    model: string;
    /**
     * A list of moderation objects.
     * @type {Array<CreateModerationResponseResultsInner>}
     * @memberof CreateModerationResponse
     */
    results: Array<CreateModerationResponseResultsInner>;
}

/**
 * 
 * @export
 */
export type CreateModerationResponseResultsInner = {
    /**
     * Whether any of the below categories are flagged.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInner
     */
    flagged: boolean;
    /**
     * 
     * @type {CreateModerationResponseResultsInnerCategories}
     * @memberof CreateModerationResponseResultsInner
     */
    categories: CreateModerationResponseResultsInnerCategories;
    /**
     * 
     * @type {CreateModerationResponseResultsInnerCategoryScores}
     * @memberof CreateModerationResponseResultsInner
     */
    category_scores: CreateModerationResponseResultsInnerCategoryScores;
    /**
     * 
     * @type {CreateModerationResponseResultsInnerCategoryAppliedInputTypes}
     * @memberof CreateModerationResponseResultsInner
     */
    category_applied_input_types: CreateModerationResponseResultsInnerCategoryAppliedInputTypes;
}

/**
 * A list of the categories, and whether they are flagged or not.
 * @export
 */
export type CreateModerationResponseResultsInnerCategories = {
    /**
     * Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    hate: boolean;
    /**
     * Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    hate_threatening: boolean;
    /**
     * Content that expresses, incites, or promotes harassing language towards any target.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    harassment: boolean;
    /**
     * Harassment content that also includes violence or serious harm towards any target.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    harassment_threatening: boolean;
    /**
     * Content that includes instructions or advice that facilitate the planning or execution of wrongdoing, or that gives advice or instruction on how to commit illicit acts. For example, \"how to shoplift\" would fit this category.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    illicit: boolean;
    /**
     * Content that includes instructions or advice that facilitate the planning or execution of wrongdoing that also includes violence, or that gives advice or instruction on the procurement of any weapon.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    illicit_violent: boolean;
    /**
     * Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    self_harm: boolean;
    /**
     * Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    self_harm_intent: boolean;
    /**
     * Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    self_harm_instructions: boolean;
    /**
     * Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    sexual: boolean;
    /**
     * Sexual content that includes an individual who is under 18 years old.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    sexual_minors: boolean;
    /**
     * Content that depicts death, violence, or physical injury.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    violence: boolean;
    /**
     * Content that depicts death, violence, or physical injury in graphic detail.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    violence_graphic: boolean;
}


            export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesHateEnum = 'text';

            export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesHateThreateningEnum = 'text';

            export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesHarassmentEnum = 'text';

            export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesHarassmentThreateningEnum = 'text';

            export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesIllicitEnum = 'text';

            export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesIllicitViolentEnum = 'text';

            export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmEnum = 'text' | 'image';

            export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmIntentEnum = 'text' | 'image';

            export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmInstructionsEnum = 'text' | 'image';

            export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesSexualEnum = 'text' | 'image';

            export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesSexualMinorsEnum = 'text';

            export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesViolenceEnum = 'text' | 'image';

            export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesViolenceGraphicEnum = 'text' | 'image';
/**
 * A list of the categories along with the input type(s) that the score applies to.
 * @export
 */
export type CreateModerationResponseResultsInnerCategoryAppliedInputTypes = {
    /**
     * The applied input type(s) for the category \'hate\'.
     * @type {Array<string>}
     * @memberof CreateModerationResponseResultsInnerCategoryAppliedInputTypes
     */
    hate: Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesHateEnum>;
    /**
     * The applied input type(s) for the category \'hate/threatening\'.
     * @type {Array<string>}
     * @memberof CreateModerationResponseResultsInnerCategoryAppliedInputTypes
     */
    hate_threatening: Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesHateThreateningEnum>;
    /**
     * The applied input type(s) for the category \'harassment\'.
     * @type {Array<string>}
     * @memberof CreateModerationResponseResultsInnerCategoryAppliedInputTypes
     */
    harassment: Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesHarassmentEnum>;
    /**
     * The applied input type(s) for the category \'harassment/threatening\'.
     * @type {Array<string>}
     * @memberof CreateModerationResponseResultsInnerCategoryAppliedInputTypes
     */
    harassment_threatening: Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesHarassmentThreateningEnum>;
    /**
     * The applied input type(s) for the category \'illicit\'.
     * @type {Array<string>}
     * @memberof CreateModerationResponseResultsInnerCategoryAppliedInputTypes
     */
    illicit: Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesIllicitEnum>;
    /**
     * The applied input type(s) for the category \'illicit/violent\'.
     * @type {Array<string>}
     * @memberof CreateModerationResponseResultsInnerCategoryAppliedInputTypes
     */
    illicit_violent: Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesIllicitViolentEnum>;
    /**
     * The applied input type(s) for the category \'self-harm\'.
     * @type {Array<string>}
     * @memberof CreateModerationResponseResultsInnerCategoryAppliedInputTypes
     */
    self_harm: Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmEnum>;
    /**
     * The applied input type(s) for the category \'self-harm/intent\'.
     * @type {Array<string>}
     * @memberof CreateModerationResponseResultsInnerCategoryAppliedInputTypes
     */
    self_harm_intent: Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmIntentEnum>;
    /**
     * The applied input type(s) for the category \'self-harm/instructions\'.
     * @type {Array<string>}
     * @memberof CreateModerationResponseResultsInnerCategoryAppliedInputTypes
     */
    self_harm_instructions: Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmInstructionsEnum>;
    /**
     * The applied input type(s) for the category \'sexual\'.
     * @type {Array<string>}
     * @memberof CreateModerationResponseResultsInnerCategoryAppliedInputTypes
     */
    sexual: Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesSexualEnum>;
    /**
     * The applied input type(s) for the category \'sexual/minors\'.
     * @type {Array<string>}
     * @memberof CreateModerationResponseResultsInnerCategoryAppliedInputTypes
     */
    sexual_minors: Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesSexualMinorsEnum>;
    /**
     * The applied input type(s) for the category \'violence\'.
     * @type {Array<string>}
     * @memberof CreateModerationResponseResultsInnerCategoryAppliedInputTypes
     */
    violence: Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesViolenceEnum>;
    /**
     * The applied input type(s) for the category \'violence/graphic\'.
     * @type {Array<string>}
     * @memberof CreateModerationResponseResultsInnerCategoryAppliedInputTypes
     */
    violence_graphic: Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesViolenceGraphicEnum>;
}

/**
 * A list of the categories along with their scores as predicted by model.
 * @export
 */
export type CreateModerationResponseResultsInnerCategoryScores = {
    /**
     * The score for the category \'hate\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    hate: number;
    /**
     * The score for the category \'hate/threatening\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    hate_threatening: number;
    /**
     * The score for the category \'harassment\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    harassment: number;
    /**
     * The score for the category \'harassment/threatening\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    harassment_threatening: number;
    /**
     * The score for the category \'illicit\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    illicit: number;
    /**
     * The score for the category \'illicit/violent\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    illicit_violent: number;
    /**
     * The score for the category \'self-harm\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    self_harm: number;
    /**
     * The score for the category \'self-harm/intent\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    self_harm_intent: number;
    /**
     * The score for the category \'self-harm/instructions\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    self_harm_instructions: number;
    /**
     * The score for the category \'sexual\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    sexual: number;
    /**
     * The score for the category \'sexual/minors\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    sexual_minors: number;
    /**
     * The score for the category \'violence\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    violence: number;
    /**
     * The score for the category \'violence/graphic\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    violence_graphic: number;
}

/**
 * 
 * @export
 */
export type CreateRunRequest = {
    /**
     * The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
     * @type {string}
     * @memberof CreateRunRequest
     */
    assistant_id: string;
    /**
     * 
     * @type {CreateRunRequestModel}
     * @memberof CreateRunRequest
     */
    model?: CreateRunRequestModel;
    /**
     * Overrides the [instructions](/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis.
     * @type {string}
     * @memberof CreateRunRequest
     */
    instructions?: string;
    /**
     * Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.
     * @type {string}
     * @memberof CreateRunRequest
     */
    additional_instructions?: string;
    /**
     * Adds additional messages to the thread before creating the run.
     * @type {Array<CreateMessageRequest>}
     * @memberof CreateRunRequest
     */
    additional_messages?: Array<CreateMessageRequest>;
    /**
     * Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
     * @type {Array<AssistantObjectToolsInner>}
     * @memberof CreateRunRequest
     */
    tools?: Array<AssistantObjectToolsInner>;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof CreateRunRequest
     */
    metadata?: Object;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
     * @type {number}
     * @memberof CreateRunRequest
     */
    temperature?: number;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
     * @type {number}
     * @memberof CreateRunRequest
     */
    top_p?: number;
    /**
     * If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message. 
     * @type {boolean}
     * @memberof CreateRunRequest
     */
    stream?: boolean;
    /**
     * The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info. 
     * @type {number}
     * @memberof CreateRunRequest
     */
    max_prompt_tokens?: number;
    /**
     * The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info. 
     * @type {number}
     * @memberof CreateRunRequest
     */
    max_completion_tokens?: number;
    /**
     * 
     * @type {TruncationObject}
     * @memberof CreateRunRequest
     */
    truncation_strategy?: TruncationObject;
    /**
     * 
     * @type {AssistantsApiToolChoiceOption}
     * @memberof CreateRunRequest
     */
    tool_choice?: AssistantsApiToolChoiceOption;
    /**
     * Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
     * @type {boolean}
     * @memberof CreateRunRequest
     */
    parallel_tool_calls?: boolean;
    /**
     * 
     * @type {AssistantsApiResponseFormatOption}
     * @memberof CreateRunRequest
     */
    response_format?: AssistantsApiResponseFormatOption;
}

/**
 * The ID of the [Model](/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
 * @export
 */
export type CreateRunRequestModel = {
}


            export type CreateSpeechRequestVoiceEnum = 'alloy' | 'echo' | 'fable' | 'onyx' | 'nova' | 'shimmer';

            export type CreateSpeechRequestResponseFormatEnum = 'mp3' | 'opus' | 'aac' | 'flac' | 'wav' | 'pcm';
/**
 * 
 * @export
 */
export type CreateSpeechRequest = {
    /**
     * 
     * @type {CreateSpeechRequestModel}
     * @memberof CreateSpeechRequest
     */
    model: CreateSpeechRequestModel;
    /**
     * The text to generate audio for. The maximum length is 4096 characters.
     * @type {string}
     * @memberof CreateSpeechRequest
     */
    input: string;
    /**
     * The voice to use when generating the audio. Supported voices are `alloy`, `echo`, `fable`, `onyx`, `nova`, and `shimmer`. Previews of the voices are available in the [Text to speech guide](/docs/guides/text-to-speech#voice-options).
     * @type {string}
     * @memberof CreateSpeechRequest
     */
    voice: CreateSpeechRequestVoiceEnum;
    /**
     * The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`.
     * @type {string}
     * @memberof CreateSpeechRequest
     */
    response_format?: CreateSpeechRequestResponseFormatEnum;
    /**
     * The speed of the generated audio. Select a value from `0.25` to `4.0`. `1.0` is the default.
     * @type {number}
     * @memberof CreateSpeechRequest
     */
    speed?: number;
}

/**
 * One of the available [TTS models](/docs/models#tts): `tts-1` or `tts-1-hd` 
 * @export
 */
export type CreateSpeechRequestModel = {
}

/**
 * 
 * @export
 */
export type CreateThreadAndRunRequest = {
    /**
     * The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
     * @type {string}
     * @memberof CreateThreadAndRunRequest
     */
    assistant_id: string;
    /**
     * 
     * @type {CreateThreadRequest}
     * @memberof CreateThreadAndRunRequest
     */
    thread?: CreateThreadRequest;
    /**
     * 
     * @type {CreateRunRequestModel}
     * @memberof CreateThreadAndRunRequest
     */
    model?: CreateRunRequestModel;
    /**
     * Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.
     * @type {string}
     * @memberof CreateThreadAndRunRequest
     */
    instructions?: string;
    /**
     * Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
     * @type {Array<CreateThreadAndRunRequestToolsInner>}
     * @memberof CreateThreadAndRunRequest
     */
    tools?: Array<CreateThreadAndRunRequestToolsInner>;
    /**
     * 
     * @type {CreateThreadAndRunRequestToolResources}
     * @memberof CreateThreadAndRunRequest
     */
    tool_resources?: CreateThreadAndRunRequestToolResources;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof CreateThreadAndRunRequest
     */
    metadata?: Object;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
     * @type {number}
     * @memberof CreateThreadAndRunRequest
     */
    temperature?: number;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
     * @type {number}
     * @memberof CreateThreadAndRunRequest
     */
    top_p?: number;
    /**
     * If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message. 
     * @type {boolean}
     * @memberof CreateThreadAndRunRequest
     */
    stream?: boolean;
    /**
     * The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info. 
     * @type {number}
     * @memberof CreateThreadAndRunRequest
     */
    max_prompt_tokens?: number;
    /**
     * The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info. 
     * @type {number}
     * @memberof CreateThreadAndRunRequest
     */
    max_completion_tokens?: number;
    /**
     * 
     * @type {TruncationObject}
     * @memberof CreateThreadAndRunRequest
     */
    truncation_strategy?: TruncationObject;
    /**
     * 
     * @type {AssistantsApiToolChoiceOption}
     * @memberof CreateThreadAndRunRequest
     */
    tool_choice?: AssistantsApiToolChoiceOption;
    /**
     * Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
     * @type {boolean}
     * @memberof CreateThreadAndRunRequest
     */
    parallel_tool_calls?: boolean;
    /**
     * 
     * @type {AssistantsApiResponseFormatOption}
     * @memberof CreateThreadAndRunRequest
     */
    response_format?: AssistantsApiResponseFormatOption;
}

/**
 * A set of resources that are used by the assistant\'s tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
 * @export
 */
export type CreateThreadAndRunRequestToolResources = {
    /**
     * 
     * @type {CreateAssistantRequestToolResourcesCodeInterpreter}
     * @memberof CreateThreadAndRunRequestToolResources
     */
    code_interpreter?: CreateAssistantRequestToolResourcesCodeInterpreter;
    /**
     * 
     * @type {AssistantObjectToolResourcesFileSearch}
     * @memberof CreateThreadAndRunRequestToolResources
     */
    file_search?: AssistantObjectToolResourcesFileSearch;
}


            export type CreateThreadAndRunRequestToolsInnerTypeEnum = 'code_interpreter' | 'file_search' | 'function';
/**
 * 
 * @export
 */
export type CreateThreadAndRunRequestToolsInner = {
    /**
     * The type of tool being defined: `code_interpreter`
     * @type {string}
     * @memberof CreateThreadAndRunRequestToolsInner
     */
    type: CreateThreadAndRunRequestToolsInnerTypeEnum;
    /**
     * 
     * @type {AssistantToolsFileSearchFileSearch}
     * @memberof CreateThreadAndRunRequestToolsInner
     */
    file_search?: AssistantToolsFileSearchFileSearch;
    /**
     * 
     * @type {FunctionObject}
     * @memberof CreateThreadAndRunRequestToolsInner
     */
    _function: FunctionObject;
}

/**
 * 
 * @export
 */
export type CreateThreadRequest = {
    /**
     * A list of [messages](/docs/api-reference/messages) to start the thread with.
     * @type {Array<CreateMessageRequest>}
     * @memberof CreateThreadRequest
     */
    messages?: Array<CreateMessageRequest>;
    /**
     * 
     * @type {CreateThreadRequestToolResources}
     * @memberof CreateThreadRequest
     */
    tool_resources?: CreateThreadRequestToolResources;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof CreateThreadRequest
     */
    metadata?: Object;
}

/**
 * A set of resources that are made available to the assistant\'s tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
 * @export
 */
export type CreateThreadRequestToolResources = {
    /**
     * 
     * @type {CreateAssistantRequestToolResourcesCodeInterpreter}
     * @memberof CreateThreadRequestToolResources
     */
    code_interpreter?: CreateAssistantRequestToolResourcesCodeInterpreter;
    /**
     * 
     * @type {CreateThreadRequestToolResourcesFileSearch}
     * @memberof CreateThreadRequestToolResources
     */
    file_search?: CreateThreadRequestToolResourcesFileSearch;
}

/**
 * 
 * @export
 */
export type CreateThreadRequestToolResourcesFileSearch = {
    /**
     * The [vector store](/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread. 
     * @type {Array<string>}
     * @memberof CreateThreadRequestToolResourcesFileSearch
     */
    vector_store_ids?: Array<string>;
    /**
     * A helper to create a [vector store](/docs/api-reference/vector-stores/object) with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the thread. 
     * @type {Array<CreateThreadRequestToolResourcesFileSearchVectorStoresInner>}
     * @memberof CreateThreadRequestToolResourcesFileSearch
     */
    vector_stores?: Array<CreateThreadRequestToolResourcesFileSearchVectorStoresInner>;
}

/**
 * 
 * @export
 */
export type CreateThreadRequestToolResourcesFileSearchVectorStoresInner = {
    /**
     * A list of [file](/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store. 
     * @type {Array<string>}
     * @memberof CreateThreadRequestToolResourcesFileSearchVectorStoresInner
     */
    file_ids?: Array<string>;
    /**
     * 
     * @type {CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy}
     * @memberof CreateThreadRequestToolResourcesFileSearchVectorStoresInner
     */
    chunking_strategy?: CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy;
    /**
     * Set of 16 key-value pairs that can be attached to a vector store. This can be useful for storing additional information about the vector store in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof CreateThreadRequestToolResourcesFileSearchVectorStoresInner
     */
    metadata?: Object;
}

/**
 * 
 * @export
 */
export type CreateTranscription200Response = {
    /**
     * The transcribed text.
     * @type {string}
     * @memberof CreateTranscription200Response
     */
    text: string;
    /**
     * The language of the input audio.
     * @type {string}
     * @memberof CreateTranscription200Response
     */
    language: string;
    /**
     * The duration of the input audio.
     * @type {string}
     * @memberof CreateTranscription200Response
     */
    duration: string;
    /**
     * Extracted words and their corresponding timestamps.
     * @type {Array<TranscriptionWord>}
     * @memberof CreateTranscription200Response
     */
    words?: Array<TranscriptionWord>;
    /**
     * Segments of the transcribed text and their corresponding details.
     * @type {Array<TranscriptionSegment>}
     * @memberof CreateTranscription200Response
     */
    segments?: Array<TranscriptionSegment>;
}

/**
 * ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available. 
 * @export
 */
export type CreateTranscriptionRequestModel = {
}

/**
 * Represents a transcription response returned by model, based on the provided input.
 * @export
 */
export type CreateTranscriptionResponseJson = {
    /**
     * The transcribed text.
     * @type {string}
     * @memberof CreateTranscriptionResponseJson
     */
    text: string;
}

/**
 * Represents a verbose json transcription response returned by model, based on the provided input.
 * @export
 */
export type CreateTranscriptionResponseVerboseJson = {
    /**
     * The language of the input audio.
     * @type {string}
     * @memberof CreateTranscriptionResponseVerboseJson
     */
    language: string;
    /**
     * The duration of the input audio.
     * @type {string}
     * @memberof CreateTranscriptionResponseVerboseJson
     */
    duration: string;
    /**
     * The transcribed text.
     * @type {string}
     * @memberof CreateTranscriptionResponseVerboseJson
     */
    text: string;
    /**
     * Extracted words and their corresponding timestamps.
     * @type {Array<TranscriptionWord>}
     * @memberof CreateTranscriptionResponseVerboseJson
     */
    words?: Array<TranscriptionWord>;
    /**
     * Segments of the transcribed text and their corresponding details.
     * @type {Array<TranscriptionSegment>}
     * @memberof CreateTranscriptionResponseVerboseJson
     */
    segments?: Array<TranscriptionSegment>;
}

/**
 * 
 * @export
 */
export type CreateTranslation200Response = {
    /**
     * The translated text.
     * @type {string}
     * @memberof CreateTranslation200Response
     */
    text: string;
    /**
     * The language of the output translation (always `english`).
     * @type {string}
     * @memberof CreateTranslation200Response
     */
    language: string;
    /**
     * The duration of the input audio.
     * @type {string}
     * @memberof CreateTranslation200Response
     */
    duration: string;
    /**
     * Segments of the translated text and their corresponding details.
     * @type {Array<TranscriptionSegment>}
     * @memberof CreateTranslation200Response
     */
    segments?: Array<TranscriptionSegment>;
}

/**
 * 
 * @export
 */
export type CreateTranslationResponseJson = {
    /**
     * 
     * @type {string}
     * @memberof CreateTranslationResponseJson
     */
    text: string;
}

/**
 * 
 * @export
 */
export type CreateTranslationResponseVerboseJson = {
    /**
     * The language of the output translation (always `english`).
     * @type {string}
     * @memberof CreateTranslationResponseVerboseJson
     */
    language: string;
    /**
     * The duration of the input audio.
     * @type {string}
     * @memberof CreateTranslationResponseVerboseJson
     */
    duration: string;
    /**
     * The translated text.
     * @type {string}
     * @memberof CreateTranslationResponseVerboseJson
     */
    text: string;
    /**
     * Segments of the translated text and their corresponding details.
     * @type {Array<TranscriptionSegment>}
     * @memberof CreateTranslationResponseVerboseJson
     */
    segments?: Array<TranscriptionSegment>;
}


            export type CreateUploadRequestPurposeEnum = 'assistants' | 'batch' | 'fine-tune' | 'vision';
/**
 * 
 * @export
 */
export type CreateUploadRequest = {
    /**
     * The name of the file to upload. 
     * @type {string}
     * @memberof CreateUploadRequest
     */
    filename: string;
    /**
     * The intended purpose of the uploaded file.  See the [documentation on File purposes](/docs/api-reference/files/create#files-create-purpose). 
     * @type {string}
     * @memberof CreateUploadRequest
     */
    purpose: CreateUploadRequestPurposeEnum;
    /**
     * The number of bytes in the file you are uploading. 
     * @type {number}
     * @memberof CreateUploadRequest
     */
    bytes: number;
    /**
     * The MIME type of the file.  This must fall within the supported MIME types for your file purpose. See the supported MIME types for assistants and vision. 
     * @type {string}
     * @memberof CreateUploadRequest
     */
    mime_type: string;
}

/**
 * 
 * @export
 */
export type CreateVectorStoreFileBatchRequest = {
    /**
     * A list of [File](/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
     * @type {Array<string>}
     * @memberof CreateVectorStoreFileBatchRequest
     */
    file_ids: Array<string>;
    /**
     * 
     * @type {ChunkingStrategyRequestParam}
     * @memberof CreateVectorStoreFileBatchRequest
     */
    chunking_strategy?: ChunkingStrategyRequestParam;
}

/**
 * 
 * @export
 */
export type CreateVectorStoreFileRequest = {
    /**
     * A [File](/docs/api-reference/files) ID that the vector store should use. Useful for tools like `file_search` that can access files.
     * @type {string}
     * @memberof CreateVectorStoreFileRequest
     */
    file_id: string;
    /**
     * 
     * @type {ChunkingStrategyRequestParam}
     * @memberof CreateVectorStoreFileRequest
     */
    chunking_strategy?: ChunkingStrategyRequestParam;
}

/**
 * 
 * @export
 */
export type CreateVectorStoreRequest = {
    /**
     * A list of [File](/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
     * @type {Array<string>}
     * @memberof CreateVectorStoreRequest
     */
    file_ids?: Array<string>;
    /**
     * The name of the vector store.
     * @type {string}
     * @memberof CreateVectorStoreRequest
     */
    name?: string;
    /**
     * 
     * @type {VectorStoreExpirationAfter}
     * @memberof CreateVectorStoreRequest
     */
    expires_after?: VectorStoreExpirationAfter;
    /**
     * 
     * @type {CreateVectorStoreRequestChunkingStrategy}
     * @memberof CreateVectorStoreRequest
     */
    chunking_strategy?: CreateVectorStoreRequestChunkingStrategy;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof CreateVectorStoreRequest
     */
    metadata?: Object;
}


            export type CreateVectorStoreRequestChunkingStrategyTypeEnum = 'auto' | 'static';
/**
 * The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy. Only applicable if `file_ids` is non-empty.
 * @export
 */
export type CreateVectorStoreRequestChunkingStrategy = {
    /**
     * Always `auto`.
     * @type {string}
     * @memberof CreateVectorStoreRequestChunkingStrategy
     */
    type: CreateVectorStoreRequestChunkingStrategyTypeEnum;
    /**
     * 
     * @type {StaticChunkingStrategy}
     * @memberof CreateVectorStoreRequestChunkingStrategy
     */
    _static: StaticChunkingStrategy;
}

/**
 * 
 * @export
 */
export type DefaultProjectErrorResponse = {
    /**
     * 
     * @type {number}
     * @memberof DefaultProjectErrorResponse
     */
    code: number;
    /**
     * 
     * @type {string}
     * @memberof DefaultProjectErrorResponse
     */
    message: string;
}


            export type DeleteAssistantResponseObjectEnum = 'assistant.deleted';
/**
 * 
 * @export
 */
export type DeleteAssistantResponse = {
    /**
     * 
     * @type {string}
     * @memberof DeleteAssistantResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteAssistantResponse
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeleteAssistantResponse
     */
    _object: DeleteAssistantResponseObjectEnum;
}


            export type DeleteFileResponseObjectEnum = 'file';
/**
 * 
 * @export
 */
export type DeleteFileResponse = {
    /**
     * 
     * @type {string}
     * @memberof DeleteFileResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DeleteFileResponse
     */
    _object: DeleteFileResponseObjectEnum;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteFileResponse
     */
    deleted: boolean;
}


            export type DeleteMessageResponseObjectEnum = 'thread.message.deleted';
/**
 * 
 * @export
 */
export type DeleteMessageResponse = {
    /**
     * 
     * @type {string}
     * @memberof DeleteMessageResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteMessageResponse
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeleteMessageResponse
     */
    _object: DeleteMessageResponseObjectEnum;
}

/**
 * 
 * @export
 */
export type DeleteModelResponse = {
    /**
     * 
     * @type {string}
     * @memberof DeleteModelResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteModelResponse
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeleteModelResponse
     */
    _object: string;
}


            export type DeleteThreadResponseObjectEnum = 'thread.deleted';
/**
 * 
 * @export
 */
export type DeleteThreadResponse = {
    /**
     * 
     * @type {string}
     * @memberof DeleteThreadResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteThreadResponse
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeleteThreadResponse
     */
    _object: DeleteThreadResponseObjectEnum;
}


            export type DeleteVectorStoreFileResponseObjectEnum = 'vector_store.file.deleted';
/**
 * 
 * @export
 */
export type DeleteVectorStoreFileResponse = {
    /**
     * 
     * @type {string}
     * @memberof DeleteVectorStoreFileResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteVectorStoreFileResponse
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeleteVectorStoreFileResponse
     */
    _object: DeleteVectorStoreFileResponseObjectEnum;
}


            export type DeleteVectorStoreResponseObjectEnum = 'vector_store.deleted';
/**
 * 
 * @export
 */
export type DeleteVectorStoreResponse = {
    /**
     * 
     * @type {string}
     * @memberof DeleteVectorStoreResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteVectorStoreResponse
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeleteVectorStoreResponse
     */
    _object: DeleteVectorStoreResponseObjectEnum;
}


            export type DoneEventEventEnum = 'done';

            export type DoneEventDataEnum = '[DONE]';
/**
 * Occurs when a stream ends.
 * @export
 */
export type DoneEvent = {
    /**
     * 
     * @type {string}
     * @memberof DoneEvent
     */
    event: DoneEventEventEnum;
    /**
     * 
     * @type {string}
     * @memberof DoneEvent
     */
    data: DoneEventDataEnum;
}


            export type EmbeddingObjectEnum = 'embedding';
/**
 * Represents an embedding vector returned by embedding endpoint. 
 * @export
 */
export type Embedding = {
    /**
     * The index of the embedding in the list of embeddings.
     * @type {number}
     * @memberof Embedding
     */
    index: number;
    /**
     * The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](/docs/guides/embeddings). 
     * @type {Array<number>}
     * @memberof Embedding
     */
    embedding: Array<number>;
    /**
     * The object type, which is always \"embedding\".
     * @type {string}
     * @memberof Embedding
     */
    _object: EmbeddingObjectEnum;
}

/**
 * 
 * @export
 */
export type Error = {
    /**
     * 
     * @type {string}
     * @memberof Error
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof Error
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof Error
     */
    param: string;
    /**
     * 
     * @type {string}
     * @memberof Error
     */
    type: string;
}


            export type ErrorEventEventEnum = 'error';
/**
 * Occurs when an [error](/docs/guides/error-codes#api-errors) occurs. This can happen due to an internal server error or a timeout.
 * @export
 */
export type ErrorEvent = {
    /**
     * 
     * @type {string}
     * @memberof ErrorEvent
     */
    event: ErrorEventEventEnum;
    /**
     * 
     * @type {Error}
     * @memberof ErrorEvent
     */
    data: Error;
}

/**
 * 
 * @export
 */
export type ErrorResponse = {
    /**
     * 
     * @type {Error}
     * @memberof ErrorResponse
     */
    error: Error;
}


            export type FileSearchRankingOptionsRankerEnum = 'auto' | 'default_2024_08_21';
/**
 * The ranking options for the file search. If not specified, the file search tool will use the `auto` ranker and a score_threshold of 0.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
 * @export
 */
export type FileSearchRankingOptions = {
    /**
     * The ranker to use for the file search. If not specified will use the `auto` ranker.
     * @type {string}
     * @memberof FileSearchRankingOptions
     */
    ranker?: FileSearchRankingOptionsRankerEnum;
    /**
     * The score threshold for the file search. All values must be a floating point number between 0 and 1.
     * @type {number}
     * @memberof FileSearchRankingOptions
     */
    score_threshold: number;
}


            export type FineTuneChatCompletionRequestAssistantMessageRoleEnum = 'assistant';

            export type FineTuneChatCompletionRequestAssistantMessageWeightEnum = 0 | 1;
/**
 * 
 * @export
 */
export type FineTuneChatCompletionRequestAssistantMessage = {
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageContent}
     * @memberof FineTuneChatCompletionRequestAssistantMessage
     */
    content?: ChatCompletionRequestAssistantMessageContent;
    /**
     * The refusal message by the assistant.
     * @type {string}
     * @memberof FineTuneChatCompletionRequestAssistantMessage
     */
    refusal?: string;
    /**
     * The role of the messages author, in this case `assistant`.
     * @type {string}
     * @memberof FineTuneChatCompletionRequestAssistantMessage
     */
    role: FineTuneChatCompletionRequestAssistantMessageRoleEnum;
    /**
     * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     * @type {string}
     * @memberof FineTuneChatCompletionRequestAssistantMessage
     */
    name?: string;
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageAudio}
     * @memberof FineTuneChatCompletionRequestAssistantMessage
     */
    audio?: ChatCompletionRequestAssistantMessageAudio;
    /**
     * The tool calls generated by the model, such as function calls.
     * @type {Array<ChatCompletionMessageToolCall>}
     * @memberof FineTuneChatCompletionRequestAssistantMessage
     */
    tool_calls?: Array<ChatCompletionMessageToolCall>;
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageFunctionCall}
     * @memberof FineTuneChatCompletionRequestAssistantMessage
     */
    function_call?: ChatCompletionRequestAssistantMessageFunctionCall;
    /**
     * Controls whether the assistant message is trained against (0 or 1)
     * @type {number}
     * @memberof FineTuneChatCompletionRequestAssistantMessage
     */
    weight?: FineTuneChatCompletionRequestAssistantMessageWeightEnum;
}

/**
 * The per-line training example of a fine-tuning input file for chat models using the supervised method.
 * @export
 */
export type FineTuneChatRequestInput = {
    /**
     * 
     * @type {Array<FineTuneChatRequestInputMessagesInner>}
     * @memberof FineTuneChatRequestInput
     */
    messages?: Array<FineTuneChatRequestInputMessagesInner>;
    /**
     * A list of tools the model may generate JSON inputs for.
     * @type {Array<ChatCompletionTool>}
     * @memberof FineTuneChatRequestInput
     */
    tools?: Array<ChatCompletionTool>;
    /**
     * Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
     * @type {boolean}
     * @memberof FineTuneChatRequestInput
     */
    parallel_tool_calls?: boolean;
    /**
     * A list of functions the model may generate JSON inputs for.
     * @type {Array<ChatCompletionFunctions>}
     * @memberof FineTuneChatRequestInput
     */
    functions?: Array<ChatCompletionFunctions>;
}


            export type FineTuneChatRequestInputMessagesInnerRoleEnum = 'function';

            export type FineTuneChatRequestInputMessagesInnerWeightEnum = 0 | 1;
/**
 * 
 * @export
 */
export type FineTuneChatRequestInputMessagesInner = {
    /**
     * The contents of the function message.
     * @type {string}
     * @memberof FineTuneChatRequestInputMessagesInner
     */
    content: string;
    /**
     * The role of the messages author, in this case `function`.
     * @type {string}
     * @memberof FineTuneChatRequestInputMessagesInner
     */
    role: FineTuneChatRequestInputMessagesInnerRoleEnum;
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof FineTuneChatRequestInputMessagesInner
     */
    name: string;
    /**
     * Controls whether the assistant message is trained against (0 or 1)
     * @type {number}
     * @memberof FineTuneChatRequestInputMessagesInner
     */
    weight?: FineTuneChatRequestInputMessagesInnerWeightEnum;
    /**
     * The refusal message by the assistant.
     * @type {string}
     * @memberof FineTuneChatRequestInputMessagesInner
     */
    refusal?: string;
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageAudio}
     * @memberof FineTuneChatRequestInputMessagesInner
     */
    audio?: ChatCompletionRequestAssistantMessageAudio;
    /**
     * The tool calls generated by the model, such as function calls.
     * @type {Array<ChatCompletionMessageToolCall>}
     * @memberof FineTuneChatRequestInputMessagesInner
     */
    tool_calls?: Array<ChatCompletionMessageToolCall>;
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageFunctionCall}
     * @memberof FineTuneChatRequestInputMessagesInner
     */
    function_call?: ChatCompletionRequestAssistantMessageFunctionCall;
    /**
     * Tool call that this message is responding to.
     * @type {string}
     * @memberof FineTuneChatRequestInputMessagesInner
     */
    tool_call_id: string;
}

/**
 * The per-line training example of a fine-tuning input file for completions models
 * @export
 */
export type FineTuneCompletionRequestInput = {
    /**
     * The input prompt for this training example.
     * @type {string}
     * @memberof FineTuneCompletionRequestInput
     */
    prompt?: string;
    /**
     * The desired completion for this training example.
     * @type {string}
     * @memberof FineTuneCompletionRequestInput
     */
    completion?: string;
}

/**
 * Configuration for the DPO fine-tuning method.
 * @export
 */
export type FineTuneDPOMethod = {
    /**
     * 
     * @type {FineTuneDPOMethodHyperparameters}
     * @memberof FineTuneDPOMethod
     */
    hyperparameters?: FineTuneDPOMethodHyperparameters;
}

/**
 * The hyperparameters used for the fine-tuning job.
 * @export
 */
export type FineTuneDPOMethodHyperparameters = {
    /**
     * 
     * @type {FineTuneDPOMethodHyperparametersBeta}
     * @memberof FineTuneDPOMethodHyperparameters
     */
    beta?: FineTuneDPOMethodHyperparametersBeta;
    /**
     * 
     * @type {FineTuneDPOMethodHyperparametersBatchSize}
     * @memberof FineTuneDPOMethodHyperparameters
     */
    batch_size?: FineTuneDPOMethodHyperparametersBatchSize;
    /**
     * 
     * @type {FineTuneDPOMethodHyperparametersLearningRateMultiplier}
     * @memberof FineTuneDPOMethodHyperparameters
     */
    learning_rate_multiplier?: FineTuneDPOMethodHyperparametersLearningRateMultiplier;
    /**
     * 
     * @type {FineTuneDPOMethodHyperparametersNEpochs}
     * @memberof FineTuneDPOMethodHyperparameters
     */
    n_epochs?: FineTuneDPOMethodHyperparametersNEpochs;
}

/**
 * Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance. 
 * @export
 */
export type FineTuneDPOMethodHyperparametersBatchSize = {
}

/**
 * The beta value for the DPO method. A higher beta value will increase the weight of the penalty between the policy and reference model. 
 * @export
 */
export type FineTuneDPOMethodHyperparametersBeta = {
}

/**
 * Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting. 
 * @export
 */
export type FineTuneDPOMethodHyperparametersLearningRateMultiplier = {
}

/**
 * The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset. 
 * @export
 */
export type FineTuneDPOMethodHyperparametersNEpochs = {
}


            export type FineTuneMethodTypeEnum = 'supervised' | 'dpo';
/**
 * The method used for fine-tuning.
 * @export
 */
export type FineTuneMethod = {
    /**
     * The type of method. Is either `supervised` or `dpo`.
     * @type {string}
     * @memberof FineTuneMethod
     */
    type?: FineTuneMethodTypeEnum;
    /**
     * 
     * @type {FineTuneSupervisedMethod}
     * @memberof FineTuneMethod
     */
    supervised?: FineTuneSupervisedMethod;
    /**
     * 
     * @type {FineTuneDPOMethod}
     * @memberof FineTuneMethod
     */
    dpo?: FineTuneDPOMethod;
}

/**
 * The per-line training example of a fine-tuning input file for chat models using the dpo method.
 * @export
 */
export type FineTunePreferenceRequestInput = {
    /**
     * 
     * @type {FineTunePreferenceRequestInputInput}
     * @memberof FineTunePreferenceRequestInput
     */
    input?: FineTunePreferenceRequestInputInput;
    /**
     * The preferred completion message for the output.
     * @type {Array<FineTunePreferenceRequestInputPreferredCompletionInner>}
     * @memberof FineTunePreferenceRequestInput
     */
    preferred_completion?: Array<FineTunePreferenceRequestInputPreferredCompletionInner>;
    /**
     * The non-preferred completion message for the output.
     * @type {Array<FineTunePreferenceRequestInputPreferredCompletionInner>}
     * @memberof FineTunePreferenceRequestInput
     */
    non_preferred_completion?: Array<FineTunePreferenceRequestInputPreferredCompletionInner>;
}

/**
 * 
 * @export
 */
export type FineTunePreferenceRequestInputInput = {
    /**
     * 
     * @type {Array<FineTuneChatRequestInputMessagesInner>}
     * @memberof FineTunePreferenceRequestInputInput
     */
    messages?: Array<FineTuneChatRequestInputMessagesInner>;
    /**
     * A list of tools the model may generate JSON inputs for.
     * @type {Array<ChatCompletionTool>}
     * @memberof FineTunePreferenceRequestInputInput
     */
    tools?: Array<ChatCompletionTool>;
    /**
     * Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
     * @type {boolean}
     * @memberof FineTunePreferenceRequestInputInput
     */
    parallel_tool_calls?: boolean;
}


            export type FineTunePreferenceRequestInputPreferredCompletionInnerRoleEnum = 'assistant';
/**
 * 
 * @export
 */
export type FineTunePreferenceRequestInputPreferredCompletionInner = {
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageContent}
     * @memberof FineTunePreferenceRequestInputPreferredCompletionInner
     */
    content?: ChatCompletionRequestAssistantMessageContent;
    /**
     * The refusal message by the assistant.
     * @type {string}
     * @memberof FineTunePreferenceRequestInputPreferredCompletionInner
     */
    refusal?: string;
    /**
     * The role of the messages author, in this case `assistant`.
     * @type {string}
     * @memberof FineTunePreferenceRequestInputPreferredCompletionInner
     */
    role: FineTunePreferenceRequestInputPreferredCompletionInnerRoleEnum;
    /**
     * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     * @type {string}
     * @memberof FineTunePreferenceRequestInputPreferredCompletionInner
     */
    name?: string;
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageAudio}
     * @memberof FineTunePreferenceRequestInputPreferredCompletionInner
     */
    audio?: ChatCompletionRequestAssistantMessageAudio;
    /**
     * The tool calls generated by the model, such as function calls.
     * @type {Array<ChatCompletionMessageToolCall>}
     * @memberof FineTunePreferenceRequestInputPreferredCompletionInner
     */
    tool_calls?: Array<ChatCompletionMessageToolCall>;
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageFunctionCall}
     * @memberof FineTunePreferenceRequestInputPreferredCompletionInner
     */
    function_call?: ChatCompletionRequestAssistantMessageFunctionCall;
}

/**
 * Configuration for the supervised fine-tuning method.
 * @export
 */
export type FineTuneSupervisedMethod = {
    /**
     * 
     * @type {FineTuneSupervisedMethodHyperparameters}
     * @memberof FineTuneSupervisedMethod
     */
    hyperparameters?: FineTuneSupervisedMethodHyperparameters;
}

/**
 * The hyperparameters used for the fine-tuning job.
 * @export
 */
export type FineTuneSupervisedMethodHyperparameters = {
    /**
     * 
     * @type {FineTuneDPOMethodHyperparametersBatchSize}
     * @memberof FineTuneSupervisedMethodHyperparameters
     */
    batch_size?: FineTuneDPOMethodHyperparametersBatchSize;
    /**
     * 
     * @type {FineTuneDPOMethodHyperparametersLearningRateMultiplier}
     * @memberof FineTuneSupervisedMethodHyperparameters
     */
    learning_rate_multiplier?: FineTuneDPOMethodHyperparametersLearningRateMultiplier;
    /**
     * 
     * @type {FineTuneDPOMethodHyperparametersNEpochs}
     * @memberof FineTuneSupervisedMethodHyperparameters
     */
    n_epochs?: FineTuneDPOMethodHyperparametersNEpochs;
}


            export type FineTuningIntegrationTypeEnum = 'wandb';
/**
 * 
 * @export
 */
export type FineTuningIntegration = {
    /**
     * The type of the integration being enabled for the fine-tuning job
     * @type {string}
     * @memberof FineTuningIntegration
     */
    type: FineTuningIntegrationTypeEnum;
    /**
     * 
     * @type {CreateFineTuningJobRequestIntegrationsInnerWandb}
     * @memberof FineTuningIntegration
     */
    wandb: CreateFineTuningJobRequestIntegrationsInnerWandb;
}


            export type FineTuningJobObjectEnum = 'fine_tuning.job';

            export type FineTuningJobStatusEnum = 'validating_files' | 'queued' | 'running' | 'succeeded' | 'failed' | 'cancelled';
/**
 * The `fine_tuning.job` object represents a fine-tuning job that has been created through the API. 
 * @export
 */
export type FineTuningJob = {
    /**
     * The object identifier, which can be referenced in the API endpoints.
     * @type {string}
     * @memberof FineTuningJob
     */
    id: string;
    /**
     * The Unix timestamp (in seconds) for when the fine-tuning job was created.
     * @type {number}
     * @memberof FineTuningJob
     */
    created_at: number;
    /**
     * 
     * @type {FineTuningJobError}
     * @memberof FineTuningJob
     */
    error: FineTuningJobError;
    /**
     * The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
     * @type {string}
     * @memberof FineTuningJob
     */
    fine_tuned_model: string;
    /**
     * The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
     * @type {number}
     * @memberof FineTuningJob
     */
    finished_at: number;
    /**
     * 
     * @type {FineTuningJobHyperparameters}
     * @memberof FineTuningJob
     */
    hyperparameters: FineTuningJobHyperparameters;
    /**
     * The base model that is being fine-tuned.
     * @type {string}
     * @memberof FineTuningJob
     */
    model: string;
    /**
     * The object type, which is always \"fine_tuning.job\".
     * @type {string}
     * @memberof FineTuningJob
     */
    _object: FineTuningJobObjectEnum;
    /**
     * The organization that owns the fine-tuning job.
     * @type {string}
     * @memberof FineTuningJob
     */
    organization_id: string;
    /**
     * The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](/docs/api-reference/files/retrieve-contents).
     * @type {Array<string>}
     * @memberof FineTuningJob
     */
    result_files: Array<string>;
    /**
     * The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
     * @type {string}
     * @memberof FineTuningJob
     */
    status: FineTuningJobStatusEnum;
    /**
     * The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
     * @type {number}
     * @memberof FineTuningJob
     */
    trained_tokens: number;
    /**
     * The file ID used for training. You can retrieve the training data with the [Files API](/docs/api-reference/files/retrieve-contents).
     * @type {string}
     * @memberof FineTuningJob
     */
    training_file: string;
    /**
     * The file ID used for validation. You can retrieve the validation results with the [Files API](/docs/api-reference/files/retrieve-contents).
     * @type {string}
     * @memberof FineTuningJob
     */
    validation_file: string;
    /**
     * A list of integrations to enable for this fine-tuning job.
     * @type {Array<FineTuningJobIntegrationsInner>}
     * @memberof FineTuningJob
     */
    integrations?: Array<FineTuningJobIntegrationsInner>;
    /**
     * The seed used for the fine-tuning job.
     * @type {number}
     * @memberof FineTuningJob
     */
    seed: number;
    /**
     * The Unix timestamp (in seconds) for when the fine-tuning job is estimated to finish. The value will be null if the fine-tuning job is not running.
     * @type {number}
     * @memberof FineTuningJob
     */
    estimated_finish?: number;
    /**
     * 
     * @type {FineTuneMethod}
     * @memberof FineTuningJob
     */
    method?: FineTuneMethod;
}


            export type FineTuningJobCheckpointObjectEnum = 'fine_tuning.job.checkpoint';
/**
 * The `fine_tuning.job.checkpoint` object represents a model checkpoint for a fine-tuning job that is ready to use. 
 * @export
 */
export type FineTuningJobCheckpoint = {
    /**
     * The checkpoint identifier, which can be referenced in the API endpoints.
     * @type {string}
     * @memberof FineTuningJobCheckpoint
     */
    id: string;
    /**
     * The Unix timestamp (in seconds) for when the checkpoint was created.
     * @type {number}
     * @memberof FineTuningJobCheckpoint
     */
    created_at: number;
    /**
     * The name of the fine-tuned checkpoint model that is created.
     * @type {string}
     * @memberof FineTuningJobCheckpoint
     */
    fine_tuned_model_checkpoint: string;
    /**
     * The step number that the checkpoint was created at.
     * @type {number}
     * @memberof FineTuningJobCheckpoint
     */
    step_number: number;
    /**
     * 
     * @type {FineTuningJobCheckpointMetrics}
     * @memberof FineTuningJobCheckpoint
     */
    metrics: FineTuningJobCheckpointMetrics;
    /**
     * The name of the fine-tuning job that this checkpoint was created from.
     * @type {string}
     * @memberof FineTuningJobCheckpoint
     */
    fine_tuning_job_id: string;
    /**
     * The object type, which is always \"fine_tuning.job.checkpoint\".
     * @type {string}
     * @memberof FineTuningJobCheckpoint
     */
    _object: FineTuningJobCheckpointObjectEnum;
}

/**
 * Metrics at the step number during the fine-tuning job.
 * @export
 */
export type FineTuningJobCheckpointMetrics = {
    /**
     * 
     * @type {number}
     * @memberof FineTuningJobCheckpointMetrics
     */
    step?: number;
    /**
     * 
     * @type {number}
     * @memberof FineTuningJobCheckpointMetrics
     */
    train_loss?: number;
    /**
     * 
     * @type {number}
     * @memberof FineTuningJobCheckpointMetrics
     */
    train_mean_token_accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof FineTuningJobCheckpointMetrics
     */
    valid_loss?: number;
    /**
     * 
     * @type {number}
     * @memberof FineTuningJobCheckpointMetrics
     */
    valid_mean_token_accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof FineTuningJobCheckpointMetrics
     */
    full_valid_loss?: number;
    /**
     * 
     * @type {number}
     * @memberof FineTuningJobCheckpointMetrics
     */
    full_valid_mean_token_accuracy?: number;
}

/**
 * For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
 * @export
 */
export type FineTuningJobError = {
    /**
     * A machine-readable error code.
     * @type {string}
     * @memberof FineTuningJobError
     */
    code: string;
    /**
     * A human-readable error message.
     * @type {string}
     * @memberof FineTuningJobError
     */
    message: string;
    /**
     * The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
     * @type {string}
     * @memberof FineTuningJobError
     */
    param: string;
}


            export type FineTuningJobEventObjectEnum = 'fine_tuning.job.event';

            export type FineTuningJobEventLevelEnum = 'info' | 'warn' | 'error';

            export type FineTuningJobEventTypeEnum = 'message' | 'metrics';
/**
 * Fine-tuning job event object
 * @export
 */
export type FineTuningJobEvent = {
    /**
     * The object type, which is always \"fine_tuning.job.event\".
     * @type {string}
     * @memberof FineTuningJobEvent
     */
    _object: FineTuningJobEventObjectEnum;
    /**
     * The object identifier.
     * @type {string}
     * @memberof FineTuningJobEvent
     */
    id: string;
    /**
     * The Unix timestamp (in seconds) for when the fine-tuning job was created.
     * @type {number}
     * @memberof FineTuningJobEvent
     */
    created_at: number;
    /**
     * The log level of the event.
     * @type {string}
     * @memberof FineTuningJobEvent
     */
    level: FineTuningJobEventLevelEnum;
    /**
     * The message of the event.
     * @type {string}
     * @memberof FineTuningJobEvent
     */
    message: string;
    /**
     * The type of event.
     * @type {string}
     * @memberof FineTuningJobEvent
     */
    type?: FineTuningJobEventTypeEnum;
    /**
     * The data associated with the event.
     * @type {Object}
     * @memberof FineTuningJobEvent
     */
    data?: Object;
}

/**
 * The hyperparameters used for the fine-tuning job. This value will only be returned when running `supervised` jobs.
 * @export
 */
export type FineTuningJobHyperparameters = {
    /**
     * 
     * @type {CreateFineTuningJobRequestHyperparametersBatchSize}
     * @memberof FineTuningJobHyperparameters
     */
    batch_size?: CreateFineTuningJobRequestHyperparametersBatchSize;
    /**
     * 
     * @type {CreateFineTuningJobRequestHyperparametersLearningRateMultiplier}
     * @memberof FineTuningJobHyperparameters
     */
    learning_rate_multiplier?: CreateFineTuningJobRequestHyperparametersLearningRateMultiplier;
    /**
     * 
     * @type {CreateFineTuningJobRequestHyperparametersNEpochs}
     * @memberof FineTuningJobHyperparameters
     */
    n_epochs?: CreateFineTuningJobRequestHyperparametersNEpochs;
}


            export type FineTuningJobIntegrationsInnerTypeEnum = 'wandb';
/**
 * 
 * @export
 */
export type FineTuningJobIntegrationsInner = {
    /**
     * The type of the integration being enabled for the fine-tuning job
     * @type {string}
     * @memberof FineTuningJobIntegrationsInner
     */
    type: FineTuningJobIntegrationsInnerTypeEnum;
    /**
     * 
     * @type {CreateFineTuningJobRequestIntegrationsInnerWandb}
     * @memberof FineTuningJobIntegrationsInner
     */
    wandb: CreateFineTuningJobRequestIntegrationsInnerWandb;
}

/**
 * 
 * @export
 */
export type FunctionObject = {
    /**
     * A description of what the function does, used by the model to choose when and how to call the function.
     * @type {string}
     * @memberof FunctionObject
     */
    description?: string;
    /**
     * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     * @type {string}
     * @memberof FunctionObject
     */
    name: string;
    /**
     * The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.   Omitting `parameters` defines a function with an empty parameter list.
     * @type {{ [key: string]: AnyType; }}
     * @memberof FunctionObject
     */
    parameters?: { [key: string]: AnyType; };
    /**
     * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Learn more about Structured Outputs in the [function calling guide](docs/guides/function-calling).
     * @type {boolean}
     * @memberof FunctionObject
     */
    strict?: boolean;
}

/**
 * Represents the url or the content of an image generated by the OpenAI API.
 * @export
 */
export type Image = {
    /**
     * The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
     * @type {string}
     * @memberof Image
     */
    b64_json?: string;
    /**
     * The URL of the generated image, if `response_format` is `url` (default).
     * @type {string}
     * @memberof Image
     */
    url?: string;
    /**
     * The prompt that was used to generate the image, if there was any revision to the prompt.
     * @type {string}
     * @memberof Image
     */
    revised_prompt?: string;
}

/**
 * 
 * @export
 */
export type ImagesResponse = {
    /**
     * 
     * @type {number}
     * @memberof ImagesResponse
     */
    created: number;
    /**
     * 
     * @type {Array<Image>}
     * @memberof ImagesResponse
     */
    data: Array<Image>;
}


            export type InviteObjectEnum = 'organization.invite';

            export type InviteRoleEnum = 'owner' | 'reader';

            export type InviteStatusEnum = 'accepted' | 'expired' | 'pending';
/**
 * Represents an individual `invite` to the organization.
 * @export
 */
export type Invite = {
    /**
     * The object type, which is always `organization.invite`
     * @type {string}
     * @memberof Invite
     */
    _object: InviteObjectEnum;
    /**
     * The identifier, which can be referenced in API endpoints
     * @type {string}
     * @memberof Invite
     */
    id: string;
    /**
     * The email address of the individual to whom the invite was sent
     * @type {string}
     * @memberof Invite
     */
    email: string;
    /**
     * `owner` or `reader`
     * @type {string}
     * @memberof Invite
     */
    role: InviteRoleEnum;
    /**
     * `accepted`,`expired`, or `pending`
     * @type {string}
     * @memberof Invite
     */
    status: InviteStatusEnum;
    /**
     * The Unix timestamp (in seconds) of when the invite was sent.
     * @type {number}
     * @memberof Invite
     */
    invited_at: number;
    /**
     * The Unix timestamp (in seconds) of when the invite expires.
     * @type {number}
     * @memberof Invite
     */
    expires_at: number;
    /**
     * The Unix timestamp (in seconds) of when the invite was accepted.
     * @type {number}
     * @memberof Invite
     */
    accepted_at?: number;
    /**
     * The projects that were granted membership upon acceptance of the invite.
     * @type {Array<InviteProjectsInner>}
     * @memberof Invite
     */
    projects?: Array<InviteProjectsInner>;
}


            export type InviteDeleteResponseObjectEnum = 'organization.invite.deleted';
/**
 * 
 * @export
 */
export type InviteDeleteResponse = {
    /**
     * The object type, which is always `organization.invite.deleted`
     * @type {string}
     * @memberof InviteDeleteResponse
     */
    _object: InviteDeleteResponseObjectEnum;
    /**
     * 
     * @type {string}
     * @memberof InviteDeleteResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof InviteDeleteResponse
     */
    deleted: boolean;
}


            export type InviteListResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type InviteListResponse = {
    /**
     * The object type, which is always `list`
     * @type {string}
     * @memberof InviteListResponse
     */
    _object: InviteListResponseObjectEnum;
    /**
     * 
     * @type {Array<Invite>}
     * @memberof InviteListResponse
     */
    data: Array<Invite>;
    /**
     * The first `invite_id` in the retrieved `list`
     * @type {string}
     * @memberof InviteListResponse
     */
    first_id?: string;
    /**
     * The last `invite_id` in the retrieved `list`
     * @type {string}
     * @memberof InviteListResponse
     */
    last_id?: string;
    /**
     * The `has_more` property is used for pagination to indicate there are additional results.
     * @type {boolean}
     * @memberof InviteListResponse
     */
    has_more?: boolean;
}


            export type InviteProjectsInnerRoleEnum = 'member' | 'owner';
/**
 * 
 * @export
 */
export type InviteProjectsInner = {
    /**
     * Project\'s public ID
     * @type {string}
     * @memberof InviteProjectsInner
     */
    id?: string;
    /**
     * Project membership role
     * @type {string}
     * @memberof InviteProjectsInner
     */
    role?: InviteProjectsInnerRoleEnum;
}


            export type InviteRequestRoleEnum = 'reader' | 'owner';
/**
 * 
 * @export
 */
export type InviteRequest = {
    /**
     * Send an email to this address
     * @type {string}
     * @memberof InviteRequest
     */
    email: string;
    /**
     * `owner` or `reader`
     * @type {string}
     * @memberof InviteRequest
     */
    role: InviteRequestRoleEnum;
    /**
     * An array of projects to which membership is granted at the same time the org invite is accepted. If omitted, the user will be invited to the default project for compatibility with legacy behavior.
     * @type {Array<InviteRequestProjectsInner>}
     * @memberof InviteRequest
     */
    projects?: Array<InviteRequestProjectsInner>;
}


            export type InviteRequestProjectsInnerRoleEnum = 'member' | 'owner';
/**
 * 
 * @export
 */
export type InviteRequestProjectsInner = {
    /**
     * Project\'s public ID
     * @type {string}
     * @memberof InviteRequestProjectsInner
     */
    id: string;
    /**
     * Project membership role
     * @type {string}
     * @memberof InviteRequestProjectsInner
     */
    role: InviteRequestProjectsInnerRoleEnum;
}

/**
 * 
 * @export
 */
export type ListAssistantsResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListAssistantsResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<AssistantObject>}
     * @memberof ListAssistantsResponse
     */
    data: Array<AssistantObject>;
    /**
     * 
     * @type {string}
     * @memberof ListAssistantsResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListAssistantsResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListAssistantsResponse
     */
    has_more: boolean;
}

/**
 * 
 * @export
 */
export type ListAuditLogsEffectiveAtParameter = {
    /**
     * Return only events whose `effective_at` (Unix seconds) is greater than this value.
     * @type {number}
     * @memberof ListAuditLogsEffectiveAtParameter
     */
    gt?: number;
    /**
     * Return only events whose `effective_at` (Unix seconds) is greater than or equal to this value.
     * @type {number}
     * @memberof ListAuditLogsEffectiveAtParameter
     */
    gte?: number;
    /**
     * Return only events whose `effective_at` (Unix seconds) is less than this value.
     * @type {number}
     * @memberof ListAuditLogsEffectiveAtParameter
     */
    lt?: number;
    /**
     * Return only events whose `effective_at` (Unix seconds) is less than or equal to this value.
     * @type {number}
     * @memberof ListAuditLogsEffectiveAtParameter
     */
    lte?: number;
}


            export type ListAuditLogsResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type ListAuditLogsResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListAuditLogsResponse
     */
    _object: ListAuditLogsResponseObjectEnum;
    /**
     * 
     * @type {Array<AuditLog>}
     * @memberof ListAuditLogsResponse
     */
    data: Array<AuditLog>;
    /**
     * 
     * @type {string}
     * @memberof ListAuditLogsResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListAuditLogsResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListAuditLogsResponse
     */
    has_more: boolean;
}


            export type ListBatchesResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type ListBatchesResponse = {
    /**
     * 
     * @type {Array<Batch>}
     * @memberof ListBatchesResponse
     */
    data: Array<Batch>;
    /**
     * 
     * @type {string}
     * @memberof ListBatchesResponse
     */
    first_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ListBatchesResponse
     */
    last_id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListBatchesResponse
     */
    has_more: boolean;
    /**
     * 
     * @type {string}
     * @memberof ListBatchesResponse
     */
    _object: ListBatchesResponseObjectEnum;
}

/**
 * 
 * @export
 */
export type ListFilesResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListFilesResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<OpenAIFile>}
     * @memberof ListFilesResponse
     */
    data: Array<OpenAIFile>;
    /**
     * 
     * @type {string}
     * @memberof ListFilesResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListFilesResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListFilesResponse
     */
    has_more: boolean;
}


            export type ListFineTuningJobCheckpointsResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type ListFineTuningJobCheckpointsResponse = {
    /**
     * 
     * @type {Array<FineTuningJobCheckpoint>}
     * @memberof ListFineTuningJobCheckpointsResponse
     */
    data: Array<FineTuningJobCheckpoint>;
    /**
     * 
     * @type {string}
     * @memberof ListFineTuningJobCheckpointsResponse
     */
    _object: ListFineTuningJobCheckpointsResponseObjectEnum;
    /**
     * 
     * @type {string}
     * @memberof ListFineTuningJobCheckpointsResponse
     */
    first_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ListFineTuningJobCheckpointsResponse
     */
    last_id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListFineTuningJobCheckpointsResponse
     */
    has_more: boolean;
}


            export type ListFineTuningJobEventsResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type ListFineTuningJobEventsResponse = {
    /**
     * 
     * @type {Array<FineTuningJobEvent>}
     * @memberof ListFineTuningJobEventsResponse
     */
    data: Array<FineTuningJobEvent>;
    /**
     * 
     * @type {string}
     * @memberof ListFineTuningJobEventsResponse
     */
    _object: ListFineTuningJobEventsResponseObjectEnum;
}

/**
 * 
 * @export
 */
export type ListMessagesResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListMessagesResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<MessageObject>}
     * @memberof ListMessagesResponse
     */
    data: Array<MessageObject>;
    /**
     * 
     * @type {string}
     * @memberof ListMessagesResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListMessagesResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListMessagesResponse
     */
    has_more: boolean;
}


            export type ListModelsResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type ListModelsResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListModelsResponse
     */
    _object: ListModelsResponseObjectEnum;
    /**
     * 
     * @type {Array<Model>}
     * @memberof ListModelsResponse
     */
    data: Array<Model>;
}


            export type ListPaginatedFineTuningJobsResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type ListPaginatedFineTuningJobsResponse = {
    /**
     * 
     * @type {Array<FineTuningJob>}
     * @memberof ListPaginatedFineTuningJobsResponse
     */
    data: Array<FineTuningJob>;
    /**
     * 
     * @type {boolean}
     * @memberof ListPaginatedFineTuningJobsResponse
     */
    has_more: boolean;
    /**
     * 
     * @type {string}
     * @memberof ListPaginatedFineTuningJobsResponse
     */
    _object: ListPaginatedFineTuningJobsResponseObjectEnum;
}

/**
 * 
 * @export
 */
export type ListRunStepsResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListRunStepsResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<RunStepObject>}
     * @memberof ListRunStepsResponse
     */
    data: Array<RunStepObject>;
    /**
     * 
     * @type {string}
     * @memberof ListRunStepsResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListRunStepsResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListRunStepsResponse
     */
    has_more: boolean;
}

/**
 * 
 * @export
 */
export type ListRunsResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListRunsResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<RunObject>}
     * @memberof ListRunsResponse
     */
    data: Array<RunObject>;
    /**
     * 
     * @type {string}
     * @memberof ListRunsResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListRunsResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListRunsResponse
     */
    has_more: boolean;
}

/**
 * 
 * @export
 */
export type ListThreadsResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListThreadsResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<ThreadObject>}
     * @memberof ListThreadsResponse
     */
    data: Array<ThreadObject>;
    /**
     * 
     * @type {string}
     * @memberof ListThreadsResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListThreadsResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListThreadsResponse
     */
    has_more: boolean;
}

/**
 * 
 * @export
 */
export type ListVectorStoreFilesResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListVectorStoreFilesResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<VectorStoreFileObject>}
     * @memberof ListVectorStoreFilesResponse
     */
    data: Array<VectorStoreFileObject>;
    /**
     * 
     * @type {string}
     * @memberof ListVectorStoreFilesResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListVectorStoreFilesResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListVectorStoreFilesResponse
     */
    has_more: boolean;
}

/**
 * 
 * @export
 */
export type ListVectorStoresResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListVectorStoresResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<VectorStoreObject>}
     * @memberof ListVectorStoresResponse
     */
    data: Array<VectorStoreObject>;
    /**
     * 
     * @type {string}
     * @memberof ListVectorStoresResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListVectorStoresResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListVectorStoresResponse
     */
    has_more: boolean;
}


            export type MessageContentImageFileObjectTypeEnum = 'image_file';
/**
 * References an image [File](/docs/api-reference/files) in the content of a message.
 * @export
 */
export type MessageContentImageFileObject = {
    /**
     * Always `image_file`.
     * @type {string}
     * @memberof MessageContentImageFileObject
     */
    type: MessageContentImageFileObjectTypeEnum;
    /**
     * 
     * @type {MessageContentImageFileObjectImageFile}
     * @memberof MessageContentImageFileObject
     */
    image_file: MessageContentImageFileObjectImageFile;
}


            export type MessageContentImageFileObjectImageFileDetailEnum = 'auto' | 'low' | 'high';
/**
 * 
 * @export
 */
export type MessageContentImageFileObjectImageFile = {
    /**
     * The [File](/docs/api-reference/files) ID of the image in the message content. Set `purpose=\"vision\"` when uploading the File if you need to later display the file content.
     * @type {string}
     * @memberof MessageContentImageFileObjectImageFile
     */
    file_id: string;
    /**
     * Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
     * @type {string}
     * @memberof MessageContentImageFileObjectImageFile
     */
    detail?: MessageContentImageFileObjectImageFileDetailEnum;
}


            export type MessageContentImageUrlObjectTypeEnum = 'image_url';
/**
 * References an image URL in the content of a message.
 * @export
 */
export type MessageContentImageUrlObject = {
    /**
     * The type of the content part.
     * @type {string}
     * @memberof MessageContentImageUrlObject
     */
    type: MessageContentImageUrlObjectTypeEnum;
    /**
     * 
     * @type {MessageContentImageUrlObjectImageUrl}
     * @memberof MessageContentImageUrlObject
     */
    image_url: MessageContentImageUrlObjectImageUrl;
}


            export type MessageContentImageUrlObjectImageUrlDetailEnum = 'auto' | 'low' | 'high';
/**
 * 
 * @export
 */
export type MessageContentImageUrlObjectImageUrl = {
    /**
     * The external URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp.
     * @type {string}
     * @memberof MessageContentImageUrlObjectImageUrl
     */
    url: string;
    /**
     * Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`. Default value is `auto`
     * @type {string}
     * @memberof MessageContentImageUrlObjectImageUrl
     */
    detail?: MessageContentImageUrlObjectImageUrlDetailEnum;
}


            export type MessageContentRefusalObjectTypeEnum = 'refusal';
/**
 * The refusal content generated by the assistant.
 * @export
 */
export type MessageContentRefusalObject = {
    /**
     * Always `refusal`.
     * @type {string}
     * @memberof MessageContentRefusalObject
     */
    type: MessageContentRefusalObjectTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof MessageContentRefusalObject
     */
    refusal: string;
}


            export type MessageContentTextAnnotationsFileCitationObjectTypeEnum = 'file_citation';
/**
 * A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"file_search\" tool to search files.
 * @export
 */
export type MessageContentTextAnnotationsFileCitationObject = {
    /**
     * Always `file_citation`.
     * @type {string}
     * @memberof MessageContentTextAnnotationsFileCitationObject
     */
    type: MessageContentTextAnnotationsFileCitationObjectTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     * @type {string}
     * @memberof MessageContentTextAnnotationsFileCitationObject
     */
    text: string;
    /**
     * 
     * @type {MessageContentTextAnnotationsFileCitationObjectFileCitation}
     * @memberof MessageContentTextAnnotationsFileCitationObject
     */
    file_citation: MessageContentTextAnnotationsFileCitationObjectFileCitation;
    /**
     * 
     * @type {number}
     * @memberof MessageContentTextAnnotationsFileCitationObject
     */
    start_index: number;
    /**
     * 
     * @type {number}
     * @memberof MessageContentTextAnnotationsFileCitationObject
     */
    end_index: number;
}

/**
 * 
 * @export
 */
export type MessageContentTextAnnotationsFileCitationObjectFileCitation = {
    /**
     * The ID of the specific File the citation is from.
     * @type {string}
     * @memberof MessageContentTextAnnotationsFileCitationObjectFileCitation
     */
    file_id: string;
}


            export type MessageContentTextAnnotationsFilePathObjectTypeEnum = 'file_path';
/**
 * A URL for the file that\'s generated when the assistant used the `code_interpreter` tool to generate a file.
 * @export
 */
export type MessageContentTextAnnotationsFilePathObject = {
    /**
     * Always `file_path`.
     * @type {string}
     * @memberof MessageContentTextAnnotationsFilePathObject
     */
    type: MessageContentTextAnnotationsFilePathObjectTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     * @type {string}
     * @memberof MessageContentTextAnnotationsFilePathObject
     */
    text: string;
    /**
     * 
     * @type {MessageContentTextAnnotationsFilePathObjectFilePath}
     * @memberof MessageContentTextAnnotationsFilePathObject
     */
    file_path: MessageContentTextAnnotationsFilePathObjectFilePath;
    /**
     * 
     * @type {number}
     * @memberof MessageContentTextAnnotationsFilePathObject
     */
    start_index: number;
    /**
     * 
     * @type {number}
     * @memberof MessageContentTextAnnotationsFilePathObject
     */
    end_index: number;
}

/**
 * 
 * @export
 */
export type MessageContentTextAnnotationsFilePathObjectFilePath = {
    /**
     * The ID of the file that was generated.
     * @type {string}
     * @memberof MessageContentTextAnnotationsFilePathObjectFilePath
     */
    file_id: string;
}


            export type MessageContentTextObjectTypeEnum = 'text';
/**
 * The text content that is part of a message.
 * @export
 */
export type MessageContentTextObject = {
    /**
     * Always `text`.
     * @type {string}
     * @memberof MessageContentTextObject
     */
    type: MessageContentTextObjectTypeEnum;
    /**
     * 
     * @type {MessageContentTextObjectText}
     * @memberof MessageContentTextObject
     */
    text: MessageContentTextObjectText;
}

/**
 * 
 * @export
 */
export type MessageContentTextObjectText = {
    /**
     * The data that makes up the text.
     * @type {string}
     * @memberof MessageContentTextObjectText
     */
    value: string;
    /**
     * 
     * @type {Array<MessageContentTextObjectTextAnnotationsInner>}
     * @memberof MessageContentTextObjectText
     */
    annotations: Array<MessageContentTextObjectTextAnnotationsInner>;
}


            export type MessageContentTextObjectTextAnnotationsInnerTypeEnum = 'file_citation' | 'file_path';
/**
 * 
 * @export
 */
export type MessageContentTextObjectTextAnnotationsInner = {
    /**
     * Always `file_citation`.
     * @type {string}
     * @memberof MessageContentTextObjectTextAnnotationsInner
     */
    type: MessageContentTextObjectTextAnnotationsInnerTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     * @type {string}
     * @memberof MessageContentTextObjectTextAnnotationsInner
     */
    text: string;
    /**
     * 
     * @type {MessageContentTextAnnotationsFileCitationObjectFileCitation}
     * @memberof MessageContentTextObjectTextAnnotationsInner
     */
    file_citation: MessageContentTextAnnotationsFileCitationObjectFileCitation;
    /**
     * 
     * @type {number}
     * @memberof MessageContentTextObjectTextAnnotationsInner
     */
    start_index: number;
    /**
     * 
     * @type {number}
     * @memberof MessageContentTextObjectTextAnnotationsInner
     */
    end_index: number;
    /**
     * 
     * @type {MessageContentTextAnnotationsFilePathObjectFilePath}
     * @memberof MessageContentTextObjectTextAnnotationsInner
     */
    file_path: MessageContentTextAnnotationsFilePathObjectFilePath;
}


            export type MessageDeltaContentImageFileObjectTypeEnum = 'image_file';
/**
 * References an image [File](/docs/api-reference/files) in the content of a message.
 * @export
 */
export type MessageDeltaContentImageFileObject = {
    /**
     * The index of the content part in the message.
     * @type {number}
     * @memberof MessageDeltaContentImageFileObject
     */
    index: number;
    /**
     * Always `image_file`.
     * @type {string}
     * @memberof MessageDeltaContentImageFileObject
     */
    type: MessageDeltaContentImageFileObjectTypeEnum;
    /**
     * 
     * @type {MessageDeltaContentImageFileObjectImageFile}
     * @memberof MessageDeltaContentImageFileObject
     */
    image_file?: MessageDeltaContentImageFileObjectImageFile;
}


            export type MessageDeltaContentImageFileObjectImageFileDetailEnum = 'auto' | 'low' | 'high';
/**
 * 
 * @export
 */
export type MessageDeltaContentImageFileObjectImageFile = {
    /**
     * The [File](/docs/api-reference/files) ID of the image in the message content. Set `purpose=\"vision\"` when uploading the File if you need to later display the file content.
     * @type {string}
     * @memberof MessageDeltaContentImageFileObjectImageFile
     */
    file_id?: string;
    /**
     * Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
     * @type {string}
     * @memberof MessageDeltaContentImageFileObjectImageFile
     */
    detail?: MessageDeltaContentImageFileObjectImageFileDetailEnum;
}


            export type MessageDeltaContentImageUrlObjectTypeEnum = 'image_url';
/**
 * References an image URL in the content of a message.
 * @export
 */
export type MessageDeltaContentImageUrlObject = {
    /**
     * The index of the content part in the message.
     * @type {number}
     * @memberof MessageDeltaContentImageUrlObject
     */
    index: number;
    /**
     * Always `image_url`.
     * @type {string}
     * @memberof MessageDeltaContentImageUrlObject
     */
    type: MessageDeltaContentImageUrlObjectTypeEnum;
    /**
     * 
     * @type {MessageDeltaContentImageUrlObjectImageUrl}
     * @memberof MessageDeltaContentImageUrlObject
     */
    image_url?: MessageDeltaContentImageUrlObjectImageUrl;
}


            export type MessageDeltaContentImageUrlObjectImageUrlDetailEnum = 'auto' | 'low' | 'high';
/**
 * 
 * @export
 */
export type MessageDeltaContentImageUrlObjectImageUrl = {
    /**
     * The URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp.
     * @type {string}
     * @memberof MessageDeltaContentImageUrlObjectImageUrl
     */
    url?: string;
    /**
     * Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`.
     * @type {string}
     * @memberof MessageDeltaContentImageUrlObjectImageUrl
     */
    detail?: MessageDeltaContentImageUrlObjectImageUrlDetailEnum;
}


            export type MessageDeltaContentRefusalObjectTypeEnum = 'refusal';
/**
 * The refusal content that is part of a message.
 * @export
 */
export type MessageDeltaContentRefusalObject = {
    /**
     * The index of the refusal part in the message.
     * @type {number}
     * @memberof MessageDeltaContentRefusalObject
     */
    index: number;
    /**
     * Always `refusal`.
     * @type {string}
     * @memberof MessageDeltaContentRefusalObject
     */
    type: MessageDeltaContentRefusalObjectTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof MessageDeltaContentRefusalObject
     */
    refusal?: string;
}


            export type MessageDeltaContentTextAnnotationsFileCitationObjectTypeEnum = 'file_citation';
/**
 * A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"file_search\" tool to search files.
 * @export
 */
export type MessageDeltaContentTextAnnotationsFileCitationObject = {
    /**
     * The index of the annotation in the text content part.
     * @type {number}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObject
     */
    index: number;
    /**
     * Always `file_citation`.
     * @type {string}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObject
     */
    type: MessageDeltaContentTextAnnotationsFileCitationObjectTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     * @type {string}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObject
     */
    text?: string;
    /**
     * 
     * @type {MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObject
     */
    file_citation?: MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation;
    /**
     * 
     * @type {number}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObject
     */
    start_index?: number;
    /**
     * 
     * @type {number}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObject
     */
    end_index?: number;
}

/**
 * 
 * @export
 */
export type MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation = {
    /**
     * The ID of the specific File the citation is from.
     * @type {string}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation
     */
    file_id?: string;
    /**
     * The specific quote in the file.
     * @type {string}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation
     */
    quote?: string;
}


            export type MessageDeltaContentTextAnnotationsFilePathObjectTypeEnum = 'file_path';
/**
 * A URL for the file that\'s generated when the assistant used the `code_interpreter` tool to generate a file.
 * @export
 */
export type MessageDeltaContentTextAnnotationsFilePathObject = {
    /**
     * The index of the annotation in the text content part.
     * @type {number}
     * @memberof MessageDeltaContentTextAnnotationsFilePathObject
     */
    index: number;
    /**
     * Always `file_path`.
     * @type {string}
     * @memberof MessageDeltaContentTextAnnotationsFilePathObject
     */
    type: MessageDeltaContentTextAnnotationsFilePathObjectTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     * @type {string}
     * @memberof MessageDeltaContentTextAnnotationsFilePathObject
     */
    text?: string;
    /**
     * 
     * @type {MessageDeltaContentTextAnnotationsFilePathObjectFilePath}
     * @memberof MessageDeltaContentTextAnnotationsFilePathObject
     */
    file_path?: MessageDeltaContentTextAnnotationsFilePathObjectFilePath;
    /**
     * 
     * @type {number}
     * @memberof MessageDeltaContentTextAnnotationsFilePathObject
     */
    start_index?: number;
    /**
     * 
     * @type {number}
     * @memberof MessageDeltaContentTextAnnotationsFilePathObject
     */
    end_index?: number;
}

/**
 * 
 * @export
 */
export type MessageDeltaContentTextAnnotationsFilePathObjectFilePath = {
    /**
     * The ID of the file that was generated.
     * @type {string}
     * @memberof MessageDeltaContentTextAnnotationsFilePathObjectFilePath
     */
    file_id?: string;
}


            export type MessageDeltaContentTextObjectTypeEnum = 'text';
/**
 * The text content that is part of a message.
 * @export
 */
export type MessageDeltaContentTextObject = {
    /**
     * The index of the content part in the message.
     * @type {number}
     * @memberof MessageDeltaContentTextObject
     */
    index: number;
    /**
     * Always `text`.
     * @type {string}
     * @memberof MessageDeltaContentTextObject
     */
    type: MessageDeltaContentTextObjectTypeEnum;
    /**
     * 
     * @type {MessageDeltaContentTextObjectText}
     * @memberof MessageDeltaContentTextObject
     */
    text?: MessageDeltaContentTextObjectText;
}

/**
 * 
 * @export
 */
export type MessageDeltaContentTextObjectText = {
    /**
     * The data that makes up the text.
     * @type {string}
     * @memberof MessageDeltaContentTextObjectText
     */
    value?: string;
    /**
     * 
     * @type {Array<MessageDeltaContentTextObjectTextAnnotationsInner>}
     * @memberof MessageDeltaContentTextObjectText
     */
    annotations?: Array<MessageDeltaContentTextObjectTextAnnotationsInner>;
}


            export type MessageDeltaContentTextObjectTextAnnotationsInnerTypeEnum = 'file_citation' | 'file_path';
/**
 * 
 * @export
 */
export type MessageDeltaContentTextObjectTextAnnotationsInner = {
    /**
     * The index of the annotation in the text content part.
     * @type {number}
     * @memberof MessageDeltaContentTextObjectTextAnnotationsInner
     */
    index: number;
    /**
     * Always `file_citation`.
     * @type {string}
     * @memberof MessageDeltaContentTextObjectTextAnnotationsInner
     */
    type: MessageDeltaContentTextObjectTextAnnotationsInnerTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     * @type {string}
     * @memberof MessageDeltaContentTextObjectTextAnnotationsInner
     */
    text?: string;
    /**
     * 
     * @type {MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation}
     * @memberof MessageDeltaContentTextObjectTextAnnotationsInner
     */
    file_citation?: MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation;
    /**
     * 
     * @type {number}
     * @memberof MessageDeltaContentTextObjectTextAnnotationsInner
     */
    start_index?: number;
    /**
     * 
     * @type {number}
     * @memberof MessageDeltaContentTextObjectTextAnnotationsInner
     */
    end_index?: number;
    /**
     * 
     * @type {MessageDeltaContentTextAnnotationsFilePathObjectFilePath}
     * @memberof MessageDeltaContentTextObjectTextAnnotationsInner
     */
    file_path?: MessageDeltaContentTextAnnotationsFilePathObjectFilePath;
}


            export type MessageDeltaObjectObjectEnum = 'thread.message.delta';
/**
 * Represents a message delta i.e. any changed fields on a message during streaming. 
 * @export
 */
export type MessageDeltaObject = {
    /**
     * The identifier of the message, which can be referenced in API endpoints.
     * @type {string}
     * @memberof MessageDeltaObject
     */
    id: string;
    /**
     * The object type, which is always `thread.message.delta`.
     * @type {string}
     * @memberof MessageDeltaObject
     */
    _object: MessageDeltaObjectObjectEnum;
    /**
     * 
     * @type {MessageDeltaObjectDelta}
     * @memberof MessageDeltaObject
     */
    delta: MessageDeltaObjectDelta;
}


            export type MessageDeltaObjectDeltaRoleEnum = 'user' | 'assistant';
/**
 * The delta containing the fields that have changed on the Message.
 * @export
 */
export type MessageDeltaObjectDelta = {
    /**
     * The entity that produced the message. One of `user` or `assistant`.
     * @type {string}
     * @memberof MessageDeltaObjectDelta
     */
    role?: MessageDeltaObjectDeltaRoleEnum;
    /**
     * The content of the message in array of text and/or images.
     * @type {Array<MessageDeltaObjectDeltaContentInner>}
     * @memberof MessageDeltaObjectDelta
     */
    content?: Array<MessageDeltaObjectDeltaContentInner>;
}


            export type MessageDeltaObjectDeltaContentInnerTypeEnum = 'image_file' | 'text' | 'refusal' | 'image_url';
/**
 * 
 * @export
 */
export type MessageDeltaObjectDeltaContentInner = {
    /**
     * The index of the content part in the message.
     * @type {number}
     * @memberof MessageDeltaObjectDeltaContentInner
     */
    index: number;
    /**
     * Always `image_file`.
     * @type {string}
     * @memberof MessageDeltaObjectDeltaContentInner
     */
    type: MessageDeltaObjectDeltaContentInnerTypeEnum;
    /**
     * 
     * @type {MessageDeltaContentImageFileObjectImageFile}
     * @memberof MessageDeltaObjectDeltaContentInner
     */
    image_file?: MessageDeltaContentImageFileObjectImageFile;
    /**
     * 
     * @type {MessageDeltaContentTextObjectText}
     * @memberof MessageDeltaObjectDeltaContentInner
     */
    text?: MessageDeltaContentTextObjectText;
    /**
     * 
     * @type {string}
     * @memberof MessageDeltaObjectDeltaContentInner
     */
    refusal?: string;
    /**
     * 
     * @type {MessageDeltaContentImageUrlObjectImageUrl}
     * @memberof MessageDeltaObjectDeltaContentInner
     */
    image_url?: MessageDeltaContentImageUrlObjectImageUrl;
}


            export type MessageObjectObjectEnum = 'thread.message';

            export type MessageObjectStatusEnum = 'in_progress' | 'incomplete' | 'completed';

            export type MessageObjectRoleEnum = 'user' | 'assistant';
/**
 * Represents a message within a [thread](/docs/api-reference/threads).
 * @export
 */
export type MessageObject = {
    /**
     * The identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof MessageObject
     */
    id: string;
    /**
     * The object type, which is always `thread.message`.
     * @type {string}
     * @memberof MessageObject
     */
    _object: MessageObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the message was created.
     * @type {number}
     * @memberof MessageObject
     */
    created_at: number;
    /**
     * The [thread](/docs/api-reference/threads) ID that this message belongs to.
     * @type {string}
     * @memberof MessageObject
     */
    thread_id: string;
    /**
     * The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
     * @type {string}
     * @memberof MessageObject
     */
    status: MessageObjectStatusEnum;
    /**
     * 
     * @type {MessageObjectIncompleteDetails}
     * @memberof MessageObject
     */
    incomplete_details: MessageObjectIncompleteDetails;
    /**
     * The Unix timestamp (in seconds) for when the message was completed.
     * @type {number}
     * @memberof MessageObject
     */
    completed_at: number;
    /**
     * The Unix timestamp (in seconds) for when the message was marked as incomplete.
     * @type {number}
     * @memberof MessageObject
     */
    incomplete_at: number;
    /**
     * The entity that produced the message. One of `user` or `assistant`.
     * @type {string}
     * @memberof MessageObject
     */
    role: MessageObjectRoleEnum;
    /**
     * The content of the message in array of text and/or images.
     * @type {Array<MessageObjectContentInner>}
     * @memberof MessageObject
     */
    content: Array<MessageObjectContentInner>;
    /**
     * If applicable, the ID of the [assistant](/docs/api-reference/assistants) that authored this message.
     * @type {string}
     * @memberof MessageObject
     */
    assistant_id: string;
    /**
     * The ID of the [run](/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints.
     * @type {string}
     * @memberof MessageObject
     */
    run_id: string;
    /**
     * A list of files attached to the message, and the tools they were added to.
     * @type {Array<CreateMessageRequestAttachmentsInner>}
     * @memberof MessageObject
     */
    attachments: Array<CreateMessageRequestAttachmentsInner>;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof MessageObject
     */
    metadata: Object;
}


            export type MessageObjectContentInnerTypeEnum = 'image_file' | 'image_url' | 'text' | 'refusal';
/**
 * 
 * @export
 */
export type MessageObjectContentInner = {
    /**
     * Always `image_file`.
     * @type {string}
     * @memberof MessageObjectContentInner
     */
    type: MessageObjectContentInnerTypeEnum;
    /**
     * 
     * @type {MessageContentImageFileObjectImageFile}
     * @memberof MessageObjectContentInner
     */
    image_file: MessageContentImageFileObjectImageFile;
    /**
     * 
     * @type {MessageContentImageUrlObjectImageUrl}
     * @memberof MessageObjectContentInner
     */
    image_url: MessageContentImageUrlObjectImageUrl;
    /**
     * 
     * @type {MessageContentTextObjectText}
     * @memberof MessageObjectContentInner
     */
    text: MessageContentTextObjectText;
    /**
     * 
     * @type {string}
     * @memberof MessageObjectContentInner
     */
    refusal: string;
}


            export type MessageObjectIncompleteDetailsReasonEnum = 'content_filter' | 'max_tokens' | 'run_cancelled' | 'run_expired' | 'run_failed';
/**
 * On an incomplete message, details about why the message is incomplete.
 * @export
 */
export type MessageObjectIncompleteDetails = {
    /**
     * The reason the message is incomplete.
     * @type {string}
     * @memberof MessageObjectIncompleteDetails
     */
    reason: MessageObjectIncompleteDetailsReasonEnum;
}


            export type MessageRequestContentTextObjectTypeEnum = 'text';
/**
 * The text content that is part of a message.
 * @export
 */
export type MessageRequestContentTextObject = {
    /**
     * Always `text`.
     * @type {string}
     * @memberof MessageRequestContentTextObject
     */
    type: MessageRequestContentTextObjectTypeEnum;
    /**
     * Text content to be sent to the model
     * @type {string}
     * @memberof MessageRequestContentTextObject
     */
    text: string;
}


            export type MessageStreamEventEventEnum = 'thread.message.incomplete';
/**
 * 
 * @export
 */
export type MessageStreamEvent = {
    /**
     * 
     * @type {string}
     * @memberof MessageStreamEvent
     */
    event: MessageStreamEventEventEnum;
    /**
     * 
     * @type {MessageObject}
     * @memberof MessageStreamEvent
     */
    data: MessageObject;
}


            export type MessageStreamEventOneOfEventEnum = 'thread.message.created';
/**
 * Occurs when a [message](/docs/api-reference/messages/object) is created.
 * @export
 */
export type MessageStreamEventOneOf = {
    /**
     * 
     * @type {string}
     * @memberof MessageStreamEventOneOf
     */
    event: MessageStreamEventOneOfEventEnum;
    /**
     * 
     * @type {MessageObject}
     * @memberof MessageStreamEventOneOf
     */
    data: MessageObject;
}


            export type MessageStreamEventOneOf1EventEnum = 'thread.message.in_progress';
/**
 * Occurs when a [message](/docs/api-reference/messages/object) moves to an `in_progress` state.
 * @export
 */
export type MessageStreamEventOneOf1 = {
    /**
     * 
     * @type {string}
     * @memberof MessageStreamEventOneOf1
     */
    event: MessageStreamEventOneOf1EventEnum;
    /**
     * 
     * @type {MessageObject}
     * @memberof MessageStreamEventOneOf1
     */
    data: MessageObject;
}


            export type MessageStreamEventOneOf2EventEnum = 'thread.message.delta';
/**
 * Occurs when parts of a [Message](/docs/api-reference/messages/object) are being streamed.
 * @export
 */
export type MessageStreamEventOneOf2 = {
    /**
     * 
     * @type {string}
     * @memberof MessageStreamEventOneOf2
     */
    event: MessageStreamEventOneOf2EventEnum;
    /**
     * 
     * @type {MessageDeltaObject}
     * @memberof MessageStreamEventOneOf2
     */
    data: MessageDeltaObject;
}


            export type MessageStreamEventOneOf3EventEnum = 'thread.message.completed';
/**
 * Occurs when a [message](/docs/api-reference/messages/object) is completed.
 * @export
 */
export type MessageStreamEventOneOf3 = {
    /**
     * 
     * @type {string}
     * @memberof MessageStreamEventOneOf3
     */
    event: MessageStreamEventOneOf3EventEnum;
    /**
     * 
     * @type {MessageObject}
     * @memberof MessageStreamEventOneOf3
     */
    data: MessageObject;
}


            export type MessageStreamEventOneOf4EventEnum = 'thread.message.incomplete';
/**
 * Occurs when a [message](/docs/api-reference/messages/object) ends before it is completed.
 * @export
 */
export type MessageStreamEventOneOf4 = {
    /**
     * 
     * @type {string}
     * @memberof MessageStreamEventOneOf4
     */
    event: MessageStreamEventOneOf4EventEnum;
    /**
     * 
     * @type {MessageObject}
     * @memberof MessageStreamEventOneOf4
     */
    data: MessageObject;
}


            export type ModelObjectEnum = 'model';
/**
 * Describes an OpenAI model offering that can be used with the API.
 * @export
 */
export type Model = {
    /**
     * The model identifier, which can be referenced in the API endpoints.
     * @type {string}
     * @memberof Model
     */
    id: string;
    /**
     * The Unix timestamp (in seconds) when the model was created.
     * @type {number}
     * @memberof Model
     */
    created: number;
    /**
     * The object type, which is always \"model\".
     * @type {string}
     * @memberof Model
     */
    _object: ModelObjectEnum;
    /**
     * The organization that owns the model.
     * @type {string}
     * @memberof Model
     */
    owned_by: string;
}

/**
 * 
 * @export
 */
export type ModifyAssistantRequest = {
    /**
     * 
     * @type {string}
     * @memberof ModifyAssistantRequest
     */
    model?: string;
    /**
     * The name of the assistant. The maximum length is 256 characters. 
     * @type {string}
     * @memberof ModifyAssistantRequest
     */
    name?: string;
    /**
     * The description of the assistant. The maximum length is 512 characters. 
     * @type {string}
     * @memberof ModifyAssistantRequest
     */
    description?: string;
    /**
     * The system instructions that the assistant uses. The maximum length is 256,000 characters. 
     * @type {string}
     * @memberof ModifyAssistantRequest
     */
    instructions?: string;
    /**
     * A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`. 
     * @type {Array<AssistantObjectToolsInner>}
     * @memberof ModifyAssistantRequest
     */
    tools?: Array<AssistantObjectToolsInner>;
    /**
     * 
     * @type {ModifyAssistantRequestToolResources}
     * @memberof ModifyAssistantRequest
     */
    tool_resources?: ModifyAssistantRequestToolResources;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof ModifyAssistantRequest
     */
    metadata?: Object;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
     * @type {number}
     * @memberof ModifyAssistantRequest
     */
    temperature?: number;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
     * @type {number}
     * @memberof ModifyAssistantRequest
     */
    top_p?: number;
    /**
     * 
     * @type {AssistantsApiResponseFormatOption}
     * @memberof ModifyAssistantRequest
     */
    response_format?: AssistantsApiResponseFormatOption;
}

/**
 * A set of resources that are used by the assistant\'s tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
 * @export
 */
export type ModifyAssistantRequestToolResources = {
    /**
     * 
     * @type {ModifyAssistantRequestToolResourcesCodeInterpreter}
     * @memberof ModifyAssistantRequestToolResources
     */
    code_interpreter?: ModifyAssistantRequestToolResourcesCodeInterpreter;
    /**
     * 
     * @type {ModifyAssistantRequestToolResourcesFileSearch}
     * @memberof ModifyAssistantRequestToolResources
     */
    file_search?: ModifyAssistantRequestToolResourcesFileSearch;
}

/**
 * 
 * @export
 */
export type ModifyAssistantRequestToolResourcesCodeInterpreter = {
    /**
     * Overrides the list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool. 
     * @type {Array<string>}
     * @memberof ModifyAssistantRequestToolResourcesCodeInterpreter
     */
    file_ids?: Array<string>;
}

/**
 * 
 * @export
 */
export type ModifyAssistantRequestToolResourcesFileSearch = {
    /**
     * Overrides the [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant. 
     * @type {Array<string>}
     * @memberof ModifyAssistantRequestToolResourcesFileSearch
     */
    vector_store_ids?: Array<string>;
}

/**
 * 
 * @export
 */
export type ModifyMessageRequest = {
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof ModifyMessageRequest
     */
    metadata?: Object;
}

/**
 * 
 * @export
 */
export type ModifyRunRequest = {
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof ModifyRunRequest
     */
    metadata?: Object;
}

/**
 * 
 * @export
 */
export type ModifyThreadRequest = {
    /**
     * 
     * @type {ModifyThreadRequestToolResources}
     * @memberof ModifyThreadRequest
     */
    tool_resources?: ModifyThreadRequestToolResources;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof ModifyThreadRequest
     */
    metadata?: Object;
}

/**
 * A set of resources that are made available to the assistant\'s tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
 * @export
 */
export type ModifyThreadRequestToolResources = {
    /**
     * 
     * @type {CreateAssistantRequestToolResourcesCodeInterpreter}
     * @memberof ModifyThreadRequestToolResources
     */
    code_interpreter?: CreateAssistantRequestToolResourcesCodeInterpreter;
    /**
     * 
     * @type {ModifyThreadRequestToolResourcesFileSearch}
     * @memberof ModifyThreadRequestToolResources
     */
    file_search?: ModifyThreadRequestToolResourcesFileSearch;
}

/**
 * 
 * @export
 */
export type ModifyThreadRequestToolResourcesFileSearch = {
    /**
     * The [vector store](/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread. 
     * @type {Array<string>}
     * @memberof ModifyThreadRequestToolResourcesFileSearch
     */
    vector_store_ids?: Array<string>;
}


            export type OpenAIFileObjectEnum = 'file';

            export type OpenAIFilePurposeEnum = 'assistants' | 'assistants_output' | 'batch' | 'batch_output' | 'fine-tune' | 'fine-tune-results' | 'vision';

            export type OpenAIFileStatusEnum = 'uploaded' | 'processed' | 'error';
/**
 * The `File` object represents a document that has been uploaded to OpenAI.
 * @export
 */
export type OpenAIFile = {
    /**
     * The file identifier, which can be referenced in the API endpoints.
     * @type {string}
     * @memberof OpenAIFile
     */
    id: string;
    /**
     * The size of the file, in bytes.
     * @type {number}
     * @memberof OpenAIFile
     */
    bytes: number;
    /**
     * The Unix timestamp (in seconds) for when the file was created.
     * @type {number}
     * @memberof OpenAIFile
     */
    created_at: number;
    /**
     * The name of the file.
     * @type {string}
     * @memberof OpenAIFile
     */
    filename: string;
    /**
     * The object type, which is always `file`.
     * @type {string}
     * @memberof OpenAIFile
     */
    _object: OpenAIFileObjectEnum;
    /**
     * The intended purpose of the file. Supported values are `assistants`, `assistants_output`, `batch`, `batch_output`, `fine-tune`, `fine-tune-results` and `vision`.
     * @type {string}
     * @memberof OpenAIFile
     */
    purpose: OpenAIFilePurposeEnum;
    /**
     * Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`.
     * @type {string}
     * @memberof OpenAIFile
     */
    status: OpenAIFileStatusEnum;
    /**
     * Deprecated. For details on why a fine-tuning training file failed validation, see the `error` field on `fine_tuning.job`.
     * @type {string}
     * @memberof OpenAIFile
     */
    status_details?: string;
}


            export type OtherChunkingStrategyResponseParamTypeEnum = 'other';
/**
 * This is returned when the chunking strategy is unknown. Typically, this is because the file was indexed before the `chunking_strategy` concept was introduced in the API.
 * @export
 */
export type OtherChunkingStrategyResponseParam = {
    /**
     * Always `other`.
     * @type {string}
     * @memberof OtherChunkingStrategyResponseParam
     */
    type: OtherChunkingStrategyResponseParamTypeEnum;
}


            export type PredictionContentTypeEnum = 'content';
/**
 * Static predicted output content, such as the content of a text file that is being regenerated. 
 * @export
 */
export type PredictionContent = {
    /**
     * The type of the predicted content you want to provide. This type is currently always `content`. 
     * @type {string}
     * @memberof PredictionContent
     */
    type: PredictionContentTypeEnum;
    /**
     * 
     * @type {PredictionContentContent}
     * @memberof PredictionContent
     */
    content: PredictionContentContent;
}

/**
 * The content that should be matched when generating a model response. If generated tokens would match this content, the entire model response can be returned much more quickly. 
 * @export
 */
export type PredictionContentContent = {
}


            export type ProjectObjectEnum = 'organization.project';

            export type ProjectStatusEnum = 'active' | 'archived';
/**
 * Represents an individual project.
 * @export
 */
export type Project = {
    /**
     * The identifier, which can be referenced in API endpoints
     * @type {string}
     * @memberof Project
     */
    id: string;
    /**
     * The object type, which is always `organization.project`
     * @type {string}
     * @memberof Project
     */
    _object: ProjectObjectEnum;
    /**
     * The name of the project. This appears in reporting.
     * @type {string}
     * @memberof Project
     */
    name: string;
    /**
     * The Unix timestamp (in seconds) of when the project was created.
     * @type {number}
     * @memberof Project
     */
    created_at: number;
    /**
     * The Unix timestamp (in seconds) of when the project was archived or `null`.
     * @type {number}
     * @memberof Project
     */
    archived_at?: number;
    /**
     * `active` or `archived`
     * @type {string}
     * @memberof Project
     */
    status: ProjectStatusEnum;
}


            export type ProjectApiKeyObjectEnum = 'organization.project.api_key';
/**
 * Represents an individual API key in a project.
 * @export
 */
export type ProjectApiKey = {
    /**
     * The object type, which is always `organization.project.api_key`
     * @type {string}
     * @memberof ProjectApiKey
     */
    _object: ProjectApiKeyObjectEnum;
    /**
     * The redacted value of the API key
     * @type {string}
     * @memberof ProjectApiKey
     */
    redacted_value: string;
    /**
     * The name of the API key
     * @type {string}
     * @memberof ProjectApiKey
     */
    name: string;
    /**
     * The Unix timestamp (in seconds) of when the API key was created
     * @type {number}
     * @memberof ProjectApiKey
     */
    created_at: number;
    /**
     * The identifier, which can be referenced in API endpoints
     * @type {string}
     * @memberof ProjectApiKey
     */
    id: string;
    /**
     * 
     * @type {ProjectApiKeyOwner}
     * @memberof ProjectApiKey
     */
    owner: ProjectApiKeyOwner;
}


            export type ProjectApiKeyDeleteResponseObjectEnum = 'organization.project.api_key.deleted';
/**
 * 
 * @export
 */
export type ProjectApiKeyDeleteResponse = {
    /**
     * 
     * @type {string}
     * @memberof ProjectApiKeyDeleteResponse
     */
    _object: ProjectApiKeyDeleteResponseObjectEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectApiKeyDeleteResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectApiKeyDeleteResponse
     */
    deleted: boolean;
}


            export type ProjectApiKeyListResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type ProjectApiKeyListResponse = {
    /**
     * 
     * @type {string}
     * @memberof ProjectApiKeyListResponse
     */
    _object: ProjectApiKeyListResponseObjectEnum;
    /**
     * 
     * @type {Array<ProjectApiKey>}
     * @memberof ProjectApiKeyListResponse
     */
    data: Array<ProjectApiKey>;
    /**
     * 
     * @type {string}
     * @memberof ProjectApiKeyListResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectApiKeyListResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectApiKeyListResponse
     */
    has_more: boolean;
}


            export type ProjectApiKeyOwnerTypeEnum = 'user' | 'service_account';
/**
 * 
 * @export
 */
export type ProjectApiKeyOwner = {
    /**
     * `user` or `service_account`
     * @type {string}
     * @memberof ProjectApiKeyOwner
     */
    type?: ProjectApiKeyOwnerTypeEnum;
    /**
     * 
     * @type {ProjectUser}
     * @memberof ProjectApiKeyOwner
     */
    user?: ProjectUser;
    /**
     * 
     * @type {ProjectServiceAccount}
     * @memberof ProjectApiKeyOwner
     */
    service_account?: ProjectServiceAccount;
}

/**
 * 
 * @export
 */
export type ProjectCreateRequest = {
    /**
     * The friendly name of the project, this name appears in reports.
     * @type {string}
     * @memberof ProjectCreateRequest
     */
    name: string;
}


            export type ProjectListResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type ProjectListResponse = {
    /**
     * 
     * @type {string}
     * @memberof ProjectListResponse
     */
    _object: ProjectListResponseObjectEnum;
    /**
     * 
     * @type {Array<Project>}
     * @memberof ProjectListResponse
     */
    data: Array<Project>;
    /**
     * 
     * @type {string}
     * @memberof ProjectListResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectListResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectListResponse
     */
    has_more: boolean;
}


            export type ProjectRateLimitObjectEnum = 'project.rate_limit';
/**
 * Represents a project rate limit config.
 * @export
 */
export type ProjectRateLimit = {
    /**
     * The object type, which is always `project.rate_limit`
     * @type {string}
     * @memberof ProjectRateLimit
     */
    _object: ProjectRateLimitObjectEnum;
    /**
     * The identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof ProjectRateLimit
     */
    id: string;
    /**
     * The model this rate limit applies to.
     * @type {string}
     * @memberof ProjectRateLimit
     */
    model: string;
    /**
     * The maximum requests per minute.
     * @type {number}
     * @memberof ProjectRateLimit
     */
    max_requests_per_1_minute: number;
    /**
     * The maximum tokens per minute.
     * @type {number}
     * @memberof ProjectRateLimit
     */
    max_tokens_per_1_minute: number;
    /**
     * The maximum images per minute. Only present for relevant models.
     * @type {number}
     * @memberof ProjectRateLimit
     */
    max_images_per_1_minute?: number;
    /**
     * The maximum audio megabytes per minute. Only present for relevant models.
     * @type {number}
     * @memberof ProjectRateLimit
     */
    max_audio_megabytes_per_1_minute?: number;
    /**
     * The maximum requests per day. Only present for relevant models.
     * @type {number}
     * @memberof ProjectRateLimit
     */
    max_requests_per_1_day?: number;
    /**
     * The maximum batch input tokens per day. Only present for relevant models.
     * @type {number}
     * @memberof ProjectRateLimit
     */
    batch_1_day_max_input_tokens?: number;
}


            export type ProjectRateLimitListResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type ProjectRateLimitListResponse = {
    /**
     * 
     * @type {string}
     * @memberof ProjectRateLimitListResponse
     */
    _object: ProjectRateLimitListResponseObjectEnum;
    /**
     * 
     * @type {Array<ProjectRateLimit>}
     * @memberof ProjectRateLimitListResponse
     */
    data: Array<ProjectRateLimit>;
    /**
     * 
     * @type {string}
     * @memberof ProjectRateLimitListResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectRateLimitListResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectRateLimitListResponse
     */
    has_more: boolean;
}

/**
 * 
 * @export
 */
export type ProjectRateLimitUpdateRequest = {
    /**
     * The maximum requests per minute.
     * @type {number}
     * @memberof ProjectRateLimitUpdateRequest
     */
    max_requests_per_1_minute?: number;
    /**
     * The maximum tokens per minute.
     * @type {number}
     * @memberof ProjectRateLimitUpdateRequest
     */
    max_tokens_per_1_minute?: number;
    /**
     * The maximum images per minute. Only relevant for certain models.
     * @type {number}
     * @memberof ProjectRateLimitUpdateRequest
     */
    max_images_per_1_minute?: number;
    /**
     * The maximum audio megabytes per minute. Only relevant for certain models.
     * @type {number}
     * @memberof ProjectRateLimitUpdateRequest
     */
    max_audio_megabytes_per_1_minute?: number;
    /**
     * The maximum requests per day. Only relevant for certain models.
     * @type {number}
     * @memberof ProjectRateLimitUpdateRequest
     */
    max_requests_per_1_day?: number;
    /**
     * The maximum batch input tokens per day. Only relevant for certain models.
     * @type {number}
     * @memberof ProjectRateLimitUpdateRequest
     */
    batch_1_day_max_input_tokens?: number;
}


            export type ProjectServiceAccountObjectEnum = 'organization.project.service_account';

            export type ProjectServiceAccountRoleEnum = 'owner' | 'member';
/**
 * Represents an individual service account in a project.
 * @export
 */
export type ProjectServiceAccount = {
    /**
     * The object type, which is always `organization.project.service_account`
     * @type {string}
     * @memberof ProjectServiceAccount
     */
    _object: ProjectServiceAccountObjectEnum;
    /**
     * The identifier, which can be referenced in API endpoints
     * @type {string}
     * @memberof ProjectServiceAccount
     */
    id: string;
    /**
     * The name of the service account
     * @type {string}
     * @memberof ProjectServiceAccount
     */
    name: string;
    /**
     * `owner` or `member`
     * @type {string}
     * @memberof ProjectServiceAccount
     */
    role: ProjectServiceAccountRoleEnum;
    /**
     * The Unix timestamp (in seconds) of when the service account was created
     * @type {number}
     * @memberof ProjectServiceAccount
     */
    created_at: number;
}


            export type ProjectServiceAccountApiKeyObjectEnum = 'organization.project.service_account.api_key';
/**
 * 
 * @export
 */
export type ProjectServiceAccountApiKey = {
    /**
     * The object type, which is always `organization.project.service_account.api_key`
     * @type {string}
     * @memberof ProjectServiceAccountApiKey
     */
    _object: ProjectServiceAccountApiKeyObjectEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectServiceAccountApiKey
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectServiceAccountApiKey
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectServiceAccountApiKey
     */
    created_at: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectServiceAccountApiKey
     */
    id: string;
}

/**
 * 
 * @export
 */
export type ProjectServiceAccountCreateRequest = {
    /**
     * The name of the service account being created.
     * @type {string}
     * @memberof ProjectServiceAccountCreateRequest
     */
    name: string;
}


            export type ProjectServiceAccountCreateResponseObjectEnum = 'organization.project.service_account';

            export type ProjectServiceAccountCreateResponseRoleEnum = 'member';
/**
 * 
 * @export
 */
export type ProjectServiceAccountCreateResponse = {
    /**
     * 
     * @type {string}
     * @memberof ProjectServiceAccountCreateResponse
     */
    _object: ProjectServiceAccountCreateResponseObjectEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectServiceAccountCreateResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectServiceAccountCreateResponse
     */
    name: string;
    /**
     * Service accounts can only have one role of type `member`
     * @type {string}
     * @memberof ProjectServiceAccountCreateResponse
     */
    role: ProjectServiceAccountCreateResponseRoleEnum;
    /**
     * 
     * @type {number}
     * @memberof ProjectServiceAccountCreateResponse
     */
    created_at: number;
    /**
     * 
     * @type {ProjectServiceAccountApiKey}
     * @memberof ProjectServiceAccountCreateResponse
     */
    api_key: ProjectServiceAccountApiKey;
}


            export type ProjectServiceAccountDeleteResponseObjectEnum = 'organization.project.service_account.deleted';
/**
 * 
 * @export
 */
export type ProjectServiceAccountDeleteResponse = {
    /**
     * 
     * @type {string}
     * @memberof ProjectServiceAccountDeleteResponse
     */
    _object: ProjectServiceAccountDeleteResponseObjectEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectServiceAccountDeleteResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectServiceAccountDeleteResponse
     */
    deleted: boolean;
}


            export type ProjectServiceAccountListResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type ProjectServiceAccountListResponse = {
    /**
     * 
     * @type {string}
     * @memberof ProjectServiceAccountListResponse
     */
    _object: ProjectServiceAccountListResponseObjectEnum;
    /**
     * 
     * @type {Array<ProjectServiceAccount>}
     * @memberof ProjectServiceAccountListResponse
     */
    data: Array<ProjectServiceAccount>;
    /**
     * 
     * @type {string}
     * @memberof ProjectServiceAccountListResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectServiceAccountListResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectServiceAccountListResponse
     */
    has_more: boolean;
}

/**
 * 
 * @export
 */
export type ProjectUpdateRequest = {
    /**
     * The updated name of the project, this name appears in reports.
     * @type {string}
     * @memberof ProjectUpdateRequest
     */
    name: string;
}


            export type ProjectUserObjectEnum = 'organization.project.user';

            export type ProjectUserRoleEnum = 'owner' | 'member';
/**
 * Represents an individual user in a project.
 * @export
 */
export type ProjectUser = {
    /**
     * The object type, which is always `organization.project.user`
     * @type {string}
     * @memberof ProjectUser
     */
    _object: ProjectUserObjectEnum;
    /**
     * The identifier, which can be referenced in API endpoints
     * @type {string}
     * @memberof ProjectUser
     */
    id: string;
    /**
     * The name of the user
     * @type {string}
     * @memberof ProjectUser
     */
    name: string;
    /**
     * The email address of the user
     * @type {string}
     * @memberof ProjectUser
     */
    email: string;
    /**
     * `owner` or `member`
     * @type {string}
     * @memberof ProjectUser
     */
    role: ProjectUserRoleEnum;
    /**
     * The Unix timestamp (in seconds) of when the project was added.
     * @type {number}
     * @memberof ProjectUser
     */
    added_at: number;
}


            export type ProjectUserCreateRequestRoleEnum = 'owner' | 'member';
/**
 * 
 * @export
 */
export type ProjectUserCreateRequest = {
    /**
     * The ID of the user.
     * @type {string}
     * @memberof ProjectUserCreateRequest
     */
    user_id: string;
    /**
     * `owner` or `member`
     * @type {string}
     * @memberof ProjectUserCreateRequest
     */
    role: ProjectUserCreateRequestRoleEnum;
}


            export type ProjectUserDeleteResponseObjectEnum = 'organization.project.user.deleted';
/**
 * 
 * @export
 */
export type ProjectUserDeleteResponse = {
    /**
     * 
     * @type {string}
     * @memberof ProjectUserDeleteResponse
     */
    _object: ProjectUserDeleteResponseObjectEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectUserDeleteResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectUserDeleteResponse
     */
    deleted: boolean;
}

/**
 * 
 * @export
 */
export type ProjectUserListResponse = {
    /**
     * 
     * @type {string}
     * @memberof ProjectUserListResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<ProjectUser>}
     * @memberof ProjectUserListResponse
     */
    data: Array<ProjectUser>;
    /**
     * 
     * @type {string}
     * @memberof ProjectUserListResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectUserListResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectUserListResponse
     */
    has_more: boolean;
}


            export type ProjectUserUpdateRequestRoleEnum = 'owner' | 'member';
/**
 * 
 * @export
 */
export type ProjectUserUpdateRequest = {
    /**
     * `owner` or `member`
     * @type {string}
     * @memberof ProjectUserUpdateRequest
     */
    role: ProjectUserUpdateRequestRoleEnum;
}


            export type RealtimeClientEventConversationItemCreateTypeEnum = 'conversation.item.create';
/**
 * Add a new Item to the Conversation\'s context, including messages, function  calls, and function call responses. This event can be used both to populate a  \"history\" of the conversation and to add new items mid-stream, but has the  current limitation that it cannot populate assistant audio messages.  If successful, the server will respond with a `conversation.item.created`  event, otherwise an `error` event will be sent. 
 * @export
 */
export type RealtimeClientEventConversationItemCreate = {
    /**
     * Optional client-generated ID used to identify this event.
     * @type {string}
     * @memberof RealtimeClientEventConversationItemCreate
     */
    event_id?: string;
    /**
     * The event type, must be `conversation.item.create`.
     * @type {string}
     * @memberof RealtimeClientEventConversationItemCreate
     */
    type: RealtimeClientEventConversationItemCreateTypeEnum;
    /**
     * The ID of the preceding item after which the new item will be inserted.  If not set, the new item will be appended to the end of the conversation.  If set, it allows an item to be inserted mid-conversation. If the ID  cannot be found, an error will be returned and the item will not be added. 
     * @type {string}
     * @memberof RealtimeClientEventConversationItemCreate
     */
    previous_item_id?: string;
    /**
     * 
     * @type {RealtimeConversationItem}
     * @memberof RealtimeClientEventConversationItemCreate
     */
    item: RealtimeConversationItem;
}


            export type RealtimeClientEventConversationItemDeleteTypeEnum = 'conversation.item.delete';
/**
 * Send this event when you want to remove any item from the conversation  history. The server will respond with a `conversation.item.deleted` event,  unless the item does not exist in the conversation history, in which case the  server will respond with an error. 
 * @export
 */
export type RealtimeClientEventConversationItemDelete = {
    /**
     * Optional client-generated ID used to identify this event.
     * @type {string}
     * @memberof RealtimeClientEventConversationItemDelete
     */
    event_id?: string;
    /**
     * The event type, must be `conversation.item.delete`.
     * @type {string}
     * @memberof RealtimeClientEventConversationItemDelete
     */
    type: RealtimeClientEventConversationItemDeleteTypeEnum;
    /**
     * The ID of the item to delete.
     * @type {string}
     * @memberof RealtimeClientEventConversationItemDelete
     */
    item_id: string;
}


            export type RealtimeClientEventConversationItemTruncateTypeEnum = 'conversation.item.truncate';
/**
 * Send this event to truncate a previous assistant messages audio. The server  will produce audio faster than realtime, so this event is useful when the user  interrupts to truncate audio that has already been sent to the client but not  yet played. This will synchronize the server\'s understanding of the audio with  the client\'s playback.  Truncating audio will delete the server-side text transcript to ensure there  is not text in the context that hasn\'t been heard by the user.  If successful, the server will respond with a `conversation.item.truncated`  event.  
 * @export
 */
export type RealtimeClientEventConversationItemTruncate = {
    /**
     * Optional client-generated ID used to identify this event.
     * @type {string}
     * @memberof RealtimeClientEventConversationItemTruncate
     */
    event_id?: string;
    /**
     * The event type, must be `conversation.item.truncate`.
     * @type {string}
     * @memberof RealtimeClientEventConversationItemTruncate
     */
    type: RealtimeClientEventConversationItemTruncateTypeEnum;
    /**
     * The ID of the assistant message item to truncate. Only assistant message  items can be truncated. 
     * @type {string}
     * @memberof RealtimeClientEventConversationItemTruncate
     */
    item_id: string;
    /**
     * The index of the content part to truncate. Set this to 0.
     * @type {number}
     * @memberof RealtimeClientEventConversationItemTruncate
     */
    content_index: number;
    /**
     * Inclusive duration up to which audio is truncated, in milliseconds. If  the audio_end_ms is greater than the actual audio duration, the server  will respond with an error. 
     * @type {number}
     * @memberof RealtimeClientEventConversationItemTruncate
     */
    audio_end_ms: number;
}


            export type RealtimeClientEventInputAudioBufferAppendTypeEnum = 'input_audio_buffer.append';
/**
 * Send this event to append audio bytes to the input audio buffer. The audio  buffer is temporary storage you can write to and later commit. In Server VAD  mode, the audio buffer is used to detect speech and the server will decide  when to commit. When Server VAD is disabled, you must commit the audio buffer manually.  The client may choose how much audio to place in each event up to a maximum  of 15 MiB, for example streaming smaller chunks from the client may allow the  VAD to be more responsive. Unlike made other client events, the server will  not send a confirmation response to this event. 
 * @export
 */
export type RealtimeClientEventInputAudioBufferAppend = {
    /**
     * Optional client-generated ID used to identify this event.
     * @type {string}
     * @memberof RealtimeClientEventInputAudioBufferAppend
     */
    event_id?: string;
    /**
     * The event type, must be `input_audio_buffer.append`.
     * @type {string}
     * @memberof RealtimeClientEventInputAudioBufferAppend
     */
    type: RealtimeClientEventInputAudioBufferAppendTypeEnum;
    /**
     * Base64-encoded audio bytes. This must be in the format specified by the  `input_audio_format` field in the session configuration. 
     * @type {string}
     * @memberof RealtimeClientEventInputAudioBufferAppend
     */
    audio: string;
}


            export type RealtimeClientEventInputAudioBufferClearTypeEnum = 'input_audio_buffer.clear';
/**
 * Send this event to clear the audio bytes in the buffer. The server will  respond with an `input_audio_buffer.cleared` event. 
 * @export
 */
export type RealtimeClientEventInputAudioBufferClear = {
    /**
     * Optional client-generated ID used to identify this event.
     * @type {string}
     * @memberof RealtimeClientEventInputAudioBufferClear
     */
    event_id?: string;
    /**
     * The event type, must be `input_audio_buffer.clear`.
     * @type {string}
     * @memberof RealtimeClientEventInputAudioBufferClear
     */
    type: RealtimeClientEventInputAudioBufferClearTypeEnum;
}


            export type RealtimeClientEventInputAudioBufferCommitTypeEnum = 'input_audio_buffer.commit';
/**
 * Send this event to commit the user input audio buffer, which will create a  new user message item in the conversation. This event will produce an error  if the input audio buffer is empty. When in Server VAD mode, the client does  not need to send this event, the server will commit the audio buffer  automatically.  Committing the input audio buffer will trigger input audio transcription  (if enabled in session configuration), but it will not create a response  from the model. The server will respond with an `input_audio_buffer.committed`  event. 
 * @export
 */
export type RealtimeClientEventInputAudioBufferCommit = {
    /**
     * Optional client-generated ID used to identify this event.
     * @type {string}
     * @memberof RealtimeClientEventInputAudioBufferCommit
     */
    event_id?: string;
    /**
     * The event type, must be `input_audio_buffer.commit`.
     * @type {string}
     * @memberof RealtimeClientEventInputAudioBufferCommit
     */
    type: RealtimeClientEventInputAudioBufferCommitTypeEnum;
}


            export type RealtimeClientEventResponseCancelTypeEnum = 'response.cancel';
/**
 * Send this event to cancel an in-progress response. The server will respond  with a `response.cancelled` event or an error if there is no response to  cancel. 
 * @export
 */
export type RealtimeClientEventResponseCancel = {
    /**
     * Optional client-generated ID used to identify this event.
     * @type {string}
     * @memberof RealtimeClientEventResponseCancel
     */
    event_id?: string;
    /**
     * The event type, must be `response.cancel`.
     * @type {string}
     * @memberof RealtimeClientEventResponseCancel
     */
    type: RealtimeClientEventResponseCancelTypeEnum;
    /**
     * A specific response ID to cancel - if not provided, will cancel an  in-progress response in the default conversation. 
     * @type {string}
     * @memberof RealtimeClientEventResponseCancel
     */
    response_id?: string;
}


            export type RealtimeClientEventResponseCreateTypeEnum = 'response.create';
/**
 * This event instructs the server to create a Response, which means triggering  model inference. When in Server VAD mode, the server will create Responses  automatically.  A Response will include at least one Item, and may have two, in which case  the second will be a function call. These Items will be appended to the  conversation history.  The server will respond with a `response.created` event, events for Items  and content created, and finally a `response.done` event to indicate the  Response is complete.  The `response.create` event includes inference configuration like  `instructions`, and `temperature`. These fields will override the Session\'s  configuration for this Response only. 
 * @export
 */
export type RealtimeClientEventResponseCreate = {
    /**
     * Optional client-generated ID used to identify this event.
     * @type {string}
     * @memberof RealtimeClientEventResponseCreate
     */
    event_id?: string;
    /**
     * The event type, must be `response.create`.
     * @type {string}
     * @memberof RealtimeClientEventResponseCreate
     */
    type: RealtimeClientEventResponseCreateTypeEnum;
    /**
     * 
     * @type {RealtimeResponseCreateParams}
     * @memberof RealtimeClientEventResponseCreate
     */
    response?: RealtimeResponseCreateParams;
}


            export type RealtimeClientEventSessionUpdateTypeEnum = 'session.update';
/**
 * Send this event to update the sessions default configuration. The client may  send this event at any time to update the session configuration, and any  field may be updated at any time, except for \"voice\". The server will respond  with a `session.updated` event that shows the full effective configuration.  Only fields that are present are updated, thus the correct way to clear a  field like \"instructions\" is to pass an empty string. 
 * @export
 */
export type RealtimeClientEventSessionUpdate = {
    /**
     * Optional client-generated ID used to identify this event.
     * @type {string}
     * @memberof RealtimeClientEventSessionUpdate
     */
    event_id?: string;
    /**
     * The event type, must be `session.update`.
     * @type {string}
     * @memberof RealtimeClientEventSessionUpdate
     */
    type: RealtimeClientEventSessionUpdateTypeEnum;
    /**
     * 
     * @type {RealtimeSessionCreateRequest}
     * @memberof RealtimeClientEventSessionUpdate
     */
    session: RealtimeSessionCreateRequest;
}


            export type RealtimeConversationItemTypeEnum = 'message' | 'function_call' | 'function_call_output';

            export type RealtimeConversationItemObjectEnum = 'realtime.item';

            export type RealtimeConversationItemStatusEnum = 'completed' | 'incomplete';

            export type RealtimeConversationItemRoleEnum = 'user' | 'assistant' | 'system';
/**
 * The item to add to the conversation.
 * @export
 */
export type RealtimeConversationItem = {
    /**
     * The unique ID of the item, this can be generated by the client to help  manage server-side context, but is not required because the server will  generate one if not provided. 
     * @type {string}
     * @memberof RealtimeConversationItem
     */
    id?: string;
    /**
     * The type of the item (`message`, `function_call`, `function_call_output`). 
     * @type {string}
     * @memberof RealtimeConversationItem
     */
    type?: RealtimeConversationItemTypeEnum;
    /**
     * Identifier for the API object being returned - always `realtime.item`. 
     * @type {string}
     * @memberof RealtimeConversationItem
     */
    _object?: RealtimeConversationItemObjectEnum;
    /**
     * The status of the item (`completed`, `incomplete`). These have no effect  on the conversation, but are accepted for consistency with the  `conversation.item.created` event. 
     * @type {string}
     * @memberof RealtimeConversationItem
     */
    status?: RealtimeConversationItemStatusEnum;
    /**
     * The role of the message sender (`user`, `assistant`, `system`), only  applicable for `message` items. 
     * @type {string}
     * @memberof RealtimeConversationItem
     */
    role?: RealtimeConversationItemRoleEnum;
    /**
     * The content of the message, applicable for `message` items.  - Message items of role `system` support only `input_text` content - Message items of role `user` support `input_text` and `input_audio`    content - Message items of role `assistant` support `text` content. 
     * @type {Array<RealtimeConversationItemContentInner>}
     * @memberof RealtimeConversationItem
     */
    content?: Array<RealtimeConversationItemContentInner>;
    /**
     * The ID of the function call (for `function_call` and  `function_call_output` items). If passed on a `function_call_output`  item, the server will check that a `function_call` item with the same  ID exists in the conversation history. 
     * @type {string}
     * @memberof RealtimeConversationItem
     */
    call_id?: string;
    /**
     * The name of the function being called (for `function_call` items). 
     * @type {string}
     * @memberof RealtimeConversationItem
     */
    name?: string;
    /**
     * The arguments of the function call (for `function_call` items). 
     * @type {string}
     * @memberof RealtimeConversationItem
     */
    _arguments?: string;
    /**
     * The output of the function call (for `function_call_output` items). 
     * @type {string}
     * @memberof RealtimeConversationItem
     */
    output?: string;
}


            export type RealtimeConversationItemContentInnerTypeEnum = 'input_audio' | 'input_text' | 'item_reference' | 'text';
/**
 * 
 * @export
 */
export type RealtimeConversationItemContentInner = {
    /**
     * The content type (`input_text`, `input_audio`, `item_reference`, `text`). 
     * @type {string}
     * @memberof RealtimeConversationItemContentInner
     */
    type?: RealtimeConversationItemContentInnerTypeEnum;
    /**
     * The text content, used for `input_text` and `text` content types. 
     * @type {string}
     * @memberof RealtimeConversationItemContentInner
     */
    text?: string;
    /**
     * ID of a previous conversation item to reference (for `item_reference` content types in `response.create` events). These can reference both client and server created items. 
     * @type {string}
     * @memberof RealtimeConversationItemContentInner
     */
    id?: string;
    /**
     * Base64-encoded audio bytes, used for `input_audio` content type. 
     * @type {string}
     * @memberof RealtimeConversationItemContentInner
     */
    audio?: string;
    /**
     * The transcript of the audio, used for `input_audio` content type. 
     * @type {string}
     * @memberof RealtimeConversationItemContentInner
     */
    transcript?: string;
}


            export type RealtimeResponseObjectEnum = 'realtime.response';

            export type RealtimeResponseStatusEnum = 'completed' | 'cancelled' | 'failed' | 'incomplete';
/**
 * The response resource.
 * @export
 */
export type RealtimeResponse = {
    /**
     * The unique ID of the response.
     * @type {string}
     * @memberof RealtimeResponse
     */
    id?: string;
    /**
     * The object type, must be `realtime.response`.
     * @type {string}
     * @memberof RealtimeResponse
     */
    _object?: RealtimeResponseObjectEnum;
    /**
     * The final status of the response (`completed`, `cancelled`, `failed`, or  `incomplete`). 
     * @type {string}
     * @memberof RealtimeResponse
     */
    status?: RealtimeResponseStatusEnum;
    /**
     * 
     * @type {RealtimeResponseStatusDetails}
     * @memberof RealtimeResponse
     */
    status_details?: RealtimeResponseStatusDetails;
    /**
     * The list of output items generated by the response.
     * @type {Array<RealtimeConversationItem>}
     * @memberof RealtimeResponse
     */
    output?: Array<RealtimeConversationItem>;
    /**
     * Developer-provided string key-value pairs associated with this response. 
     * @type {Object}
     * @memberof RealtimeResponse
     */
    metadata?: Object;
    /**
     * 
     * @type {RealtimeResponseUsage}
     * @memberof RealtimeResponse
     */
    usage?: RealtimeResponseUsage;
}


            export type RealtimeResponseCreateParamsModalitiesEnum = 'text' | 'audio';

            export type RealtimeResponseCreateParamsVoiceEnum = 'alloy' | 'ash' | 'ballad' | 'coral' | 'echo' | 'sage' | 'shimmer' | 'verse';

            export type RealtimeResponseCreateParamsOutputAudioFormatEnum = 'pcm16' | 'g711_ulaw' | 'g711_alaw';
/**
 * Create a new Realtime response with these parameters
 * @export
 */
export type RealtimeResponseCreateParams = {
    /**
     * The set of modalities the model can respond with. To disable audio, set this to [\"text\"]. 
     * @type {Array<string>}
     * @memberof RealtimeResponseCreateParams
     */
    modalities?: Array<RealtimeResponseCreateParamsModalitiesEnum>;
    /**
     * The default system instructions (i.e. system message) prepended to model  calls. This field allows the client to guide the model on desired  responses. The model can be instructed on response content and format,  (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good  responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion  into your voice\", \"laugh frequently\"). The instructions are not guaranteed  to be followed by the model, but they provide guidance to the model on the  desired behavior.  Note that the server sets default instructions which will be used if this  field is not set and are visible in the `session.created` event at the  start of the session. 
     * @type {string}
     * @memberof RealtimeResponseCreateParams
     */
    instructions?: string;
    /**
     * The voice the model uses to respond. Voice cannot be changed during the  session once the model has responded with audio at least once. Current  voice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`,  `shimmer` and `verse`. 
     * @type {string}
     * @memberof RealtimeResponseCreateParams
     */
    voice?: RealtimeResponseCreateParamsVoiceEnum;
    /**
     * The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
     * @type {string}
     * @memberof RealtimeResponseCreateParams
     */
    output_audio_format?: RealtimeResponseCreateParamsOutputAudioFormatEnum;
    /**
     * Tools (functions) available to the model.
     * @type {Array<RealtimeResponseCreateParamsToolsInner>}
     * @memberof RealtimeResponseCreateParams
     */
    tools?: Array<RealtimeResponseCreateParamsToolsInner>;
    /**
     * How the model chooses tools. Options are `auto`, `none`, `required`, or  specify a function, like `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}`. 
     * @type {string}
     * @memberof RealtimeResponseCreateParams
     */
    tool_choice?: string;
    /**
     * Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8. 
     * @type {number}
     * @memberof RealtimeResponseCreateParams
     */
    temperature?: number;
    /**
     * 
     * @type {RealtimeResponseCreateParamsMaxResponseOutputTokens}
     * @memberof RealtimeResponseCreateParams
     */
    max_response_output_tokens?: RealtimeResponseCreateParamsMaxResponseOutputTokens;
    /**
     * 
     * @type {RealtimeResponseCreateParamsConversation}
     * @memberof RealtimeResponseCreateParams
     */
    conversation?: RealtimeResponseCreateParamsConversation;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof RealtimeResponseCreateParams
     */
    metadata?: Object;
    /**
     * Input items to include in the prompt for the model. Creates a new context for this response, without including the default conversation. Can include references to items from the default conversation. 
     * @type {Array<RealtimeConversationItem>}
     * @memberof RealtimeResponseCreateParams
     */
    input?: Array<RealtimeConversationItem>;
}

/**
 * Controls which conversation the response is added to. Currently supports `auto` and `none`, with `auto` as the default value. The `auto` value means that the contents of the response will be added to the default conversation. Set this to `none` to create an out-of-band response which  will not add items to default conversation. 
 * @export
 */
export type RealtimeResponseCreateParamsConversation = {
}

/**
 * Maximum number of output tokens for a single assistant response, inclusive of tool calls. Provide an integer between 1 and 4096 to limit output tokens, or `inf` for the maximum available tokens for a given model. Defaults to `inf`. 
 * @export
 */
export type RealtimeResponseCreateParamsMaxResponseOutputTokens = {
}


            export type RealtimeResponseCreateParamsToolsInnerTypeEnum = 'function';
/**
 * 
 * @export
 */
export type RealtimeResponseCreateParamsToolsInner = {
    /**
     * The type of the tool, i.e. `function`.
     * @type {string}
     * @memberof RealtimeResponseCreateParamsToolsInner
     */
    type?: RealtimeResponseCreateParamsToolsInnerTypeEnum;
    /**
     * The name of the function.
     * @type {string}
     * @memberof RealtimeResponseCreateParamsToolsInner
     */
    name?: string;
    /**
     * The description of the function, including guidance on when and how  to call it, and guidance about what to tell the user when calling  (if anything). 
     * @type {string}
     * @memberof RealtimeResponseCreateParamsToolsInner
     */
    description?: string;
    /**
     * Parameters of the function in JSON Schema.
     * @type {Object}
     * @memberof RealtimeResponseCreateParamsToolsInner
     */
    parameters?: Object;
}


            export type RealtimeResponseStatusDetailsTypeEnum = 'completed' | 'cancelled' | 'failed' | 'incomplete';

            export type RealtimeResponseStatusDetailsReasonEnum = 'turn_detected' | 'client_cancelled' | 'max_output_tokens' | 'content_filter';
/**
 * Additional details about the status.
 * @export
 */
export type RealtimeResponseStatusDetails = {
    /**
     * The type of error that caused the response to fail, corresponding  with the `status` field (`completed`, `cancelled`, `incomplete`,  `failed`). 
     * @type {string}
     * @memberof RealtimeResponseStatusDetails
     */
    type?: RealtimeResponseStatusDetailsTypeEnum;
    /**
     * The reason the Response did not complete. For a `cancelled` Response,  one of `turn_detected` (the server VAD detected a new start of speech)  or `client_cancelled` (the client sent a cancel event). For an  `incomplete` Response, one of `max_output_tokens` or `content_filter`  (the server-side safety filter activated and cut off the response). 
     * @type {string}
     * @memberof RealtimeResponseStatusDetails
     */
    reason?: RealtimeResponseStatusDetailsReasonEnum;
    /**
     * 
     * @type {RealtimeResponseStatusDetailsError}
     * @memberof RealtimeResponseStatusDetails
     */
    error?: RealtimeResponseStatusDetailsError;
}

/**
 * A description of the error that caused the response to fail,  populated when the `status` is `failed`. 
 * @export
 */
export type RealtimeResponseStatusDetailsError = {
    /**
     * The type of error.
     * @type {string}
     * @memberof RealtimeResponseStatusDetailsError
     */
    type?: string;
    /**
     * Error code, if any.
     * @type {string}
     * @memberof RealtimeResponseStatusDetailsError
     */
    code?: string;
}

/**
 * Usage statistics for the Response, this will correspond to billing. A  Realtime API session will maintain a conversation context and append new  Items to the Conversation, thus output from previous turns (text and  audio tokens) will become the input for later turns. 
 * @export
 */
export type RealtimeResponseUsage = {
    /**
     * The total number of tokens in the Response including input and output  text and audio tokens. 
     * @type {number}
     * @memberof RealtimeResponseUsage
     */
    total_tokens?: number;
    /**
     * The number of input tokens used in the Response, including text and  audio tokens. 
     * @type {number}
     * @memberof RealtimeResponseUsage
     */
    input_tokens?: number;
    /**
     * The number of output tokens sent in the Response, including text and  audio tokens. 
     * @type {number}
     * @memberof RealtimeResponseUsage
     */
    output_tokens?: number;
    /**
     * 
     * @type {RealtimeResponseUsageInputTokenDetails}
     * @memberof RealtimeResponseUsage
     */
    input_token_details?: RealtimeResponseUsageInputTokenDetails;
    /**
     * 
     * @type {RealtimeResponseUsageOutputTokenDetails}
     * @memberof RealtimeResponseUsage
     */
    output_token_details?: RealtimeResponseUsageOutputTokenDetails;
}

/**
 * Details about the input tokens used in the Response.
 * @export
 */
export type RealtimeResponseUsageInputTokenDetails = {
    /**
     * The number of cached tokens used in the Response.
     * @type {number}
     * @memberof RealtimeResponseUsageInputTokenDetails
     */
    cached_tokens?: number;
    /**
     * The number of text tokens used in the Response.
     * @type {number}
     * @memberof RealtimeResponseUsageInputTokenDetails
     */
    text_tokens?: number;
    /**
     * The number of audio tokens used in the Response.
     * @type {number}
     * @memberof RealtimeResponseUsageInputTokenDetails
     */
    audio_tokens?: number;
}

/**
 * Details about the output tokens used in the Response.
 * @export
 */
export type RealtimeResponseUsageOutputTokenDetails = {
    /**
     * The number of text tokens used in the Response.
     * @type {number}
     * @memberof RealtimeResponseUsageOutputTokenDetails
     */
    text_tokens?: number;
    /**
     * The number of audio tokens used in the Response.
     * @type {number}
     * @memberof RealtimeResponseUsageOutputTokenDetails
     */
    audio_tokens?: number;
}


            export type RealtimeServerEventConversationCreatedTypeEnum = 'conversation.created';
/**
 * Returned when a conversation is created. Emitted right after session creation. 
 * @export
 */
export type RealtimeServerEventConversationCreated = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventConversationCreated
     */
    event_id: string;
    /**
     * The event type, must be `conversation.created`.
     * @type {string}
     * @memberof RealtimeServerEventConversationCreated
     */
    type: RealtimeServerEventConversationCreatedTypeEnum;
    /**
     * 
     * @type {RealtimeServerEventConversationCreatedConversation}
     * @memberof RealtimeServerEventConversationCreated
     */
    conversation: RealtimeServerEventConversationCreatedConversation;
}

/**
 * The conversation resource.
 * @export
 */
export type RealtimeServerEventConversationCreatedConversation = {
    /**
     * The unique ID of the conversation.
     * @type {string}
     * @memberof RealtimeServerEventConversationCreatedConversation
     */
    id?: string;
    /**
     * The object type, must be `realtime.conversation`.
     * @type {string}
     * @memberof RealtimeServerEventConversationCreatedConversation
     */
    _object?: string;
}


            export type RealtimeServerEventConversationItemCreatedTypeEnum = 'conversation.item.created';
/**
 * Returned when a conversation item is created. There are several scenarios that  produce this event:   - The server is generating a Response, which if successful will produce      either one or two Items, which will be of type `message`      (role `assistant`) or type `function_call`.   - The input audio buffer has been committed, either by the client or the      server (in `server_vad` mode). The server will take the content of the      input audio buffer and add it to a new user message Item.   - The client has sent a `conversation.item.create` event to add a new Item      to the Conversation. 
 * @export
 */
export type RealtimeServerEventConversationItemCreated = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemCreated
     */
    event_id: string;
    /**
     * The event type, must be `conversation.item.created`.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemCreated
     */
    type: RealtimeServerEventConversationItemCreatedTypeEnum;
    /**
     * The ID of the preceding item in the Conversation context, allows the  client to understand the order of the conversation. 
     * @type {string}
     * @memberof RealtimeServerEventConversationItemCreated
     */
    previous_item_id: string;
    /**
     * 
     * @type {RealtimeConversationItem}
     * @memberof RealtimeServerEventConversationItemCreated
     */
    item: RealtimeConversationItem;
}


            export type RealtimeServerEventConversationItemDeletedTypeEnum = 'conversation.item.deleted';
/**
 * Returned when an item in the conversation is deleted by the client with a  `conversation.item.delete` event. This event is used to synchronize the  server\'s understanding of the conversation history with the client\'s view. 
 * @export
 */
export type RealtimeServerEventConversationItemDeleted = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemDeleted
     */
    event_id: string;
    /**
     * The event type, must be `conversation.item.deleted`.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemDeleted
     */
    type: RealtimeServerEventConversationItemDeletedTypeEnum;
    /**
     * The ID of the item that was deleted.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemDeleted
     */
    item_id: string;
}


            export type RealtimeServerEventConversationItemInputAudioTranscriptionCompletedTypeEnum = 'conversation.item.input_audio_transcription.completed';
/**
 * This event is the output of audio transcription for user audio written to the  user audio buffer. Transcription begins when the input audio buffer is  committed by the client or server (in `server_vad` mode). Transcription runs  asynchronously with Response creation, so this event may come before or after  the Response events.  Realtime API models accept audio natively, and thus input transcription is a  separate process run on a separate ASR (Automatic Speech Recognition) model,  currently always `whisper-1`. Thus the transcript may diverge somewhat from  the model\'s interpretation, and should be treated as a rough guide. 
 * @export
 */
export type RealtimeServerEventConversationItemInputAudioTranscriptionCompleted = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemInputAudioTranscriptionCompleted
     */
    event_id: string;
    /**
     * The event type, must be `conversation.item.input_audio_transcription.completed`. 
     * @type {string}
     * @memberof RealtimeServerEventConversationItemInputAudioTranscriptionCompleted
     */
    type: RealtimeServerEventConversationItemInputAudioTranscriptionCompletedTypeEnum;
    /**
     * The ID of the user message item containing the audio.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemInputAudioTranscriptionCompleted
     */
    item_id: string;
    /**
     * The index of the content part containing the audio.
     * @type {number}
     * @memberof RealtimeServerEventConversationItemInputAudioTranscriptionCompleted
     */
    content_index: number;
    /**
     * The transcribed text.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemInputAudioTranscriptionCompleted
     */
    transcript: string;
}


            export type RealtimeServerEventConversationItemInputAudioTranscriptionFailedTypeEnum = 'conversation.item.input_audio_transcription.failed';
/**
 * Returned when input audio transcription is configured, and a transcription  request for a user message failed. These events are separate from other  `error` events so that the client can identify the related Item. 
 * @export
 */
export type RealtimeServerEventConversationItemInputAudioTranscriptionFailed = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemInputAudioTranscriptionFailed
     */
    event_id: string;
    /**
     * The event type, must be `conversation.item.input_audio_transcription.failed`. 
     * @type {string}
     * @memberof RealtimeServerEventConversationItemInputAudioTranscriptionFailed
     */
    type: RealtimeServerEventConversationItemInputAudioTranscriptionFailedTypeEnum;
    /**
     * The ID of the user message item.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemInputAudioTranscriptionFailed
     */
    item_id: string;
    /**
     * The index of the content part containing the audio.
     * @type {number}
     * @memberof RealtimeServerEventConversationItemInputAudioTranscriptionFailed
     */
    content_index: number;
    /**
     * 
     * @type {RealtimeServerEventConversationItemInputAudioTranscriptionFailedError}
     * @memberof RealtimeServerEventConversationItemInputAudioTranscriptionFailed
     */
    error: RealtimeServerEventConversationItemInputAudioTranscriptionFailedError;
}

/**
 * Details of the transcription error.
 * @export
 */
export type RealtimeServerEventConversationItemInputAudioTranscriptionFailedError = {
    /**
     * The type of error.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemInputAudioTranscriptionFailedError
     */
    type?: string;
    /**
     * Error code, if any.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemInputAudioTranscriptionFailedError
     */
    code?: string;
    /**
     * A human-readable error message.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemInputAudioTranscriptionFailedError
     */
    message?: string;
    /**
     * Parameter related to the error, if any.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemInputAudioTranscriptionFailedError
     */
    param?: string;
}


            export type RealtimeServerEventConversationItemTruncatedTypeEnum = 'conversation.item.truncated';
/**
 * Returned when an earlier assistant audio message item is truncated by the  client with a `conversation.item.truncate` event. This event is used to  synchronize the server\'s understanding of the audio with the client\'s playback.  This action will truncate the audio and remove the server-side text transcript  to ensure there is no text in the context that hasn\'t been heard by the user. 
 * @export
 */
export type RealtimeServerEventConversationItemTruncated = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemTruncated
     */
    event_id: string;
    /**
     * The event type, must be `conversation.item.truncated`.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemTruncated
     */
    type: RealtimeServerEventConversationItemTruncatedTypeEnum;
    /**
     * The ID of the assistant message item that was truncated.
     * @type {string}
     * @memberof RealtimeServerEventConversationItemTruncated
     */
    item_id: string;
    /**
     * The index of the content part that was truncated.
     * @type {number}
     * @memberof RealtimeServerEventConversationItemTruncated
     */
    content_index: number;
    /**
     * The duration up to which the audio was truncated, in milliseconds. 
     * @type {number}
     * @memberof RealtimeServerEventConversationItemTruncated
     */
    audio_end_ms: number;
}


            export type RealtimeServerEventErrorTypeEnum = 'error';
/**
 * Returned when an error occurs, which could be a client problem or a server  problem. Most errors are recoverable and the session will stay open, we  recommend to implementors to monitor and log error messages by default. 
 * @export
 */
export type RealtimeServerEventError = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventError
     */
    event_id: string;
    /**
     * The event type, must be `error`.
     * @type {string}
     * @memberof RealtimeServerEventError
     */
    type: RealtimeServerEventErrorTypeEnum;
    /**
     * 
     * @type {RealtimeServerEventErrorError}
     * @memberof RealtimeServerEventError
     */
    error: RealtimeServerEventErrorError;
}

/**
 * Details of the error.
 * @export
 */
export type RealtimeServerEventErrorError = {
    /**
     * The type of error (e.g., \"invalid_request_error\", \"server_error\"). 
     * @type {string}
     * @memberof RealtimeServerEventErrorError
     */
    type: string;
    /**
     * Error code, if any.
     * @type {string}
     * @memberof RealtimeServerEventErrorError
     */
    code?: string;
    /**
     * A human-readable error message.
     * @type {string}
     * @memberof RealtimeServerEventErrorError
     */
    message: string;
    /**
     * Parameter related to the error, if any.
     * @type {string}
     * @memberof RealtimeServerEventErrorError
     */
    param?: string;
    /**
     * The event_id of the client event that caused the error, if applicable. 
     * @type {string}
     * @memberof RealtimeServerEventErrorError
     */
    event_id?: string;
}


            export type RealtimeServerEventInputAudioBufferClearedTypeEnum = 'input_audio_buffer.cleared';
/**
 * Returned when the input audio buffer is cleared by the client with a  `input_audio_buffer.clear` event. 
 * @export
 */
export type RealtimeServerEventInputAudioBufferCleared = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventInputAudioBufferCleared
     */
    event_id: string;
    /**
     * The event type, must be `input_audio_buffer.cleared`.
     * @type {string}
     * @memberof RealtimeServerEventInputAudioBufferCleared
     */
    type: RealtimeServerEventInputAudioBufferClearedTypeEnum;
}


            export type RealtimeServerEventInputAudioBufferCommittedTypeEnum = 'input_audio_buffer.committed';
/**
 * Returned when an input audio buffer is committed, either by the client or  automatically in server VAD mode. The `item_id` property is the ID of the user message item that will be created, thus a `conversation.item.created` event  will also be sent to the client. 
 * @export
 */
export type RealtimeServerEventInputAudioBufferCommitted = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventInputAudioBufferCommitted
     */
    event_id: string;
    /**
     * The event type, must be `input_audio_buffer.committed`.
     * @type {string}
     * @memberof RealtimeServerEventInputAudioBufferCommitted
     */
    type: RealtimeServerEventInputAudioBufferCommittedTypeEnum;
    /**
     * The ID of the preceding item after which the new item will be inserted. 
     * @type {string}
     * @memberof RealtimeServerEventInputAudioBufferCommitted
     */
    previous_item_id: string;
    /**
     * The ID of the user message item that will be created.
     * @type {string}
     * @memberof RealtimeServerEventInputAudioBufferCommitted
     */
    item_id: string;
}


            export type RealtimeServerEventInputAudioBufferSpeechStartedTypeEnum = 'input_audio_buffer.speech_started';
/**
 * Sent by the server when in `server_vad` mode to indicate that speech has been  detected in the audio buffer. This can happen any time audio is added to the  buffer (unless speech is already detected). The client may want to use this  event to interrupt audio playback or provide visual feedback to the user.   The client should expect to receive a `input_audio_buffer.speech_stopped` event  when speech stops. The `item_id` property is the ID of the user message item  that will be created when speech stops and will also be included in the  `input_audio_buffer.speech_stopped` event (unless the client manually commits  the audio buffer during VAD activation). 
 * @export
 */
export type RealtimeServerEventInputAudioBufferSpeechStarted = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventInputAudioBufferSpeechStarted
     */
    event_id: string;
    /**
     * The event type, must be `input_audio_buffer.speech_started`.
     * @type {string}
     * @memberof RealtimeServerEventInputAudioBufferSpeechStarted
     */
    type: RealtimeServerEventInputAudioBufferSpeechStartedTypeEnum;
    /**
     * Milliseconds from the start of all audio written to the buffer during the  session when speech was first detected. This will correspond to the  beginning of audio sent to the model, and thus includes the  `prefix_padding_ms` configured in the Session. 
     * @type {number}
     * @memberof RealtimeServerEventInputAudioBufferSpeechStarted
     */
    audio_start_ms: number;
    /**
     * The ID of the user message item that will be created when speech stops. 
     * @type {string}
     * @memberof RealtimeServerEventInputAudioBufferSpeechStarted
     */
    item_id: string;
}


            export type RealtimeServerEventInputAudioBufferSpeechStoppedTypeEnum = 'input_audio_buffer.speech_stopped';
/**
 * Returned in `server_vad` mode when the server detects the end of speech in  the audio buffer. The server will also send an `conversation.item.created`  event with the user message item that is created from the audio buffer. 
 * @export
 */
export type RealtimeServerEventInputAudioBufferSpeechStopped = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventInputAudioBufferSpeechStopped
     */
    event_id: string;
    /**
     * The event type, must be `input_audio_buffer.speech_stopped`.
     * @type {string}
     * @memberof RealtimeServerEventInputAudioBufferSpeechStopped
     */
    type: RealtimeServerEventInputAudioBufferSpeechStoppedTypeEnum;
    /**
     * Milliseconds since the session started when speech stopped. This will  correspond to the end of audio sent to the model, and thus includes the  `min_silence_duration_ms` configured in the Session. 
     * @type {number}
     * @memberof RealtimeServerEventInputAudioBufferSpeechStopped
     */
    audio_end_ms: number;
    /**
     * The ID of the user message item that will be created.
     * @type {string}
     * @memberof RealtimeServerEventInputAudioBufferSpeechStopped
     */
    item_id: string;
}


            export type RealtimeServerEventRateLimitsUpdatedTypeEnum = 'rate_limits.updated';
/**
 * Emitted at the beginning of a Response to indicate the updated rate limits.  When a Response is created some tokens will be \"reserved\" for the output  tokens, the rate limits shown here reflect that reservation, which is then  adjusted accordingly once the Response is completed. 
 * @export
 */
export type RealtimeServerEventRateLimitsUpdated = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventRateLimitsUpdated
     */
    event_id: string;
    /**
     * The event type, must be `rate_limits.updated`.
     * @type {string}
     * @memberof RealtimeServerEventRateLimitsUpdated
     */
    type: RealtimeServerEventRateLimitsUpdatedTypeEnum;
    /**
     * List of rate limit information.
     * @type {Array<RealtimeServerEventRateLimitsUpdatedRateLimitsInner>}
     * @memberof RealtimeServerEventRateLimitsUpdated
     */
    rate_limits: Array<RealtimeServerEventRateLimitsUpdatedRateLimitsInner>;
}


            export type RealtimeServerEventRateLimitsUpdatedRateLimitsInnerNameEnum = 'requests' | 'tokens';
/**
 * 
 * @export
 */
export type RealtimeServerEventRateLimitsUpdatedRateLimitsInner = {
    /**
     * The name of the rate limit (`requests`, `tokens`). 
     * @type {string}
     * @memberof RealtimeServerEventRateLimitsUpdatedRateLimitsInner
     */
    name?: RealtimeServerEventRateLimitsUpdatedRateLimitsInnerNameEnum;
    /**
     * The maximum allowed value for the rate limit.
     * @type {number}
     * @memberof RealtimeServerEventRateLimitsUpdatedRateLimitsInner
     */
    limit?: number;
    /**
     * The remaining value before the limit is reached.
     * @type {number}
     * @memberof RealtimeServerEventRateLimitsUpdatedRateLimitsInner
     */
    remaining?: number;
    /**
     * Seconds until the rate limit resets.
     * @type {number}
     * @memberof RealtimeServerEventRateLimitsUpdatedRateLimitsInner
     */
    reset_seconds?: number;
}


            export type RealtimeServerEventResponseAudioDeltaTypeEnum = 'response.audio.delta';
/**
 * Returned when the model-generated audio is updated.
 * @export
 */
export type RealtimeServerEventResponseAudioDelta = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioDelta
     */
    event_id: string;
    /**
     * The event type, must be `response.audio.delta`.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioDelta
     */
    type: RealtimeServerEventResponseAudioDeltaTypeEnum;
    /**
     * The ID of the response.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioDelta
     */
    response_id: string;
    /**
     * The ID of the item.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioDelta
     */
    item_id: string;
    /**
     * The index of the output item in the response.
     * @type {number}
     * @memberof RealtimeServerEventResponseAudioDelta
     */
    output_index: number;
    /**
     * The index of the content part in the item\'s content array.
     * @type {number}
     * @memberof RealtimeServerEventResponseAudioDelta
     */
    content_index: number;
    /**
     * Base64-encoded audio data delta.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioDelta
     */
    delta: string;
}


            export type RealtimeServerEventResponseAudioDoneTypeEnum = 'response.audio.done';
/**
 * Returned when the model-generated audio is done. Also emitted when a Response is interrupted, incomplete, or cancelled. 
 * @export
 */
export type RealtimeServerEventResponseAudioDone = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioDone
     */
    event_id: string;
    /**
     * The event type, must be `response.audio.done`.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioDone
     */
    type: RealtimeServerEventResponseAudioDoneTypeEnum;
    /**
     * The ID of the response.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioDone
     */
    response_id: string;
    /**
     * The ID of the item.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioDone
     */
    item_id: string;
    /**
     * The index of the output item in the response.
     * @type {number}
     * @memberof RealtimeServerEventResponseAudioDone
     */
    output_index: number;
    /**
     * The index of the content part in the item\'s content array.
     * @type {number}
     * @memberof RealtimeServerEventResponseAudioDone
     */
    content_index: number;
}


            export type RealtimeServerEventResponseAudioTranscriptDeltaTypeEnum = 'response.audio_transcript.delta';
/**
 * Returned when the model-generated transcription of audio output is updated. 
 * @export
 */
export type RealtimeServerEventResponseAudioTranscriptDelta = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioTranscriptDelta
     */
    event_id: string;
    /**
     * The event type, must be `response.audio_transcript.delta`.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioTranscriptDelta
     */
    type: RealtimeServerEventResponseAudioTranscriptDeltaTypeEnum;
    /**
     * The ID of the response.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioTranscriptDelta
     */
    response_id: string;
    /**
     * The ID of the item.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioTranscriptDelta
     */
    item_id: string;
    /**
     * The index of the output item in the response.
     * @type {number}
     * @memberof RealtimeServerEventResponseAudioTranscriptDelta
     */
    output_index: number;
    /**
     * The index of the content part in the item\'s content array.
     * @type {number}
     * @memberof RealtimeServerEventResponseAudioTranscriptDelta
     */
    content_index: number;
    /**
     * The transcript delta.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioTranscriptDelta
     */
    delta: string;
}


            export type RealtimeServerEventResponseAudioTranscriptDoneTypeEnum = 'response.audio_transcript.done';
/**
 * Returned when the model-generated transcription of audio output is done streaming. Also emitted when a Response is interrupted, incomplete, or cancelled. 
 * @export
 */
export type RealtimeServerEventResponseAudioTranscriptDone = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioTranscriptDone
     */
    event_id: string;
    /**
     * The event type, must be `response.audio_transcript.done`.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioTranscriptDone
     */
    type: RealtimeServerEventResponseAudioTranscriptDoneTypeEnum;
    /**
     * The ID of the response.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioTranscriptDone
     */
    response_id: string;
    /**
     * The ID of the item.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioTranscriptDone
     */
    item_id: string;
    /**
     * The index of the output item in the response.
     * @type {number}
     * @memberof RealtimeServerEventResponseAudioTranscriptDone
     */
    output_index: number;
    /**
     * The index of the content part in the item\'s content array.
     * @type {number}
     * @memberof RealtimeServerEventResponseAudioTranscriptDone
     */
    content_index: number;
    /**
     * The final transcript of the audio.
     * @type {string}
     * @memberof RealtimeServerEventResponseAudioTranscriptDone
     */
    transcript: string;
}


            export type RealtimeServerEventResponseContentPartAddedTypeEnum = 'response.content_part.added';
/**
 * Returned when a new content part is added to an assistant message item during response generation. 
 * @export
 */
export type RealtimeServerEventResponseContentPartAdded = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartAdded
     */
    event_id: string;
    /**
     * The event type, must be `response.content_part.added`.
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartAdded
     */
    type: RealtimeServerEventResponseContentPartAddedTypeEnum;
    /**
     * The ID of the response.
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartAdded
     */
    response_id: string;
    /**
     * The ID of the item to which the content part was added.
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartAdded
     */
    item_id: string;
    /**
     * The index of the output item in the response.
     * @type {number}
     * @memberof RealtimeServerEventResponseContentPartAdded
     */
    output_index: number;
    /**
     * The index of the content part in the item\'s content array.
     * @type {number}
     * @memberof RealtimeServerEventResponseContentPartAdded
     */
    content_index: number;
    /**
     * 
     * @type {RealtimeServerEventResponseContentPartAddedPart}
     * @memberof RealtimeServerEventResponseContentPartAdded
     */
    part: RealtimeServerEventResponseContentPartAddedPart;
}


            export type RealtimeServerEventResponseContentPartAddedPartTypeEnum = 'audio' | 'text';
/**
 * The content part that was added.
 * @export
 */
export type RealtimeServerEventResponseContentPartAddedPart = {
    /**
     * The content type (\"text\", \"audio\").
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartAddedPart
     */
    type?: RealtimeServerEventResponseContentPartAddedPartTypeEnum;
    /**
     * The text content (if type is \"text\").
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartAddedPart
     */
    text?: string;
    /**
     * Base64-encoded audio data (if type is \"audio\").
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartAddedPart
     */
    audio?: string;
    /**
     * The transcript of the audio (if type is \"audio\").
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartAddedPart
     */
    transcript?: string;
}


            export type RealtimeServerEventResponseContentPartDoneTypeEnum = 'response.content_part.done';
/**
 * Returned when a content part is done streaming in an assistant message item. Also emitted when a Response is interrupted, incomplete, or cancelled. 
 * @export
 */
export type RealtimeServerEventResponseContentPartDone = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartDone
     */
    event_id: string;
    /**
     * The event type, must be `response.content_part.done`.
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartDone
     */
    type: RealtimeServerEventResponseContentPartDoneTypeEnum;
    /**
     * The ID of the response.
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartDone
     */
    response_id: string;
    /**
     * The ID of the item.
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartDone
     */
    item_id: string;
    /**
     * The index of the output item in the response.
     * @type {number}
     * @memberof RealtimeServerEventResponseContentPartDone
     */
    output_index: number;
    /**
     * The index of the content part in the item\'s content array.
     * @type {number}
     * @memberof RealtimeServerEventResponseContentPartDone
     */
    content_index: number;
    /**
     * 
     * @type {RealtimeServerEventResponseContentPartDonePart}
     * @memberof RealtimeServerEventResponseContentPartDone
     */
    part: RealtimeServerEventResponseContentPartDonePart;
}


            export type RealtimeServerEventResponseContentPartDonePartTypeEnum = 'audio' | 'text';
/**
 * The content part that is done.
 * @export
 */
export type RealtimeServerEventResponseContentPartDonePart = {
    /**
     * The content type (\"text\", \"audio\").
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartDonePart
     */
    type?: RealtimeServerEventResponseContentPartDonePartTypeEnum;
    /**
     * The text content (if type is \"text\").
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartDonePart
     */
    text?: string;
    /**
     * Base64-encoded audio data (if type is \"audio\").
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartDonePart
     */
    audio?: string;
    /**
     * The transcript of the audio (if type is \"audio\").
     * @type {string}
     * @memberof RealtimeServerEventResponseContentPartDonePart
     */
    transcript?: string;
}


            export type RealtimeServerEventResponseCreatedTypeEnum = 'response.created';
/**
 * Returned when a new Response is created. The first event of response creation, where the response is in an initial state of `in_progress`. 
 * @export
 */
export type RealtimeServerEventResponseCreated = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventResponseCreated
     */
    event_id: string;
    /**
     * The event type, must be `response.created`.
     * @type {string}
     * @memberof RealtimeServerEventResponseCreated
     */
    type: RealtimeServerEventResponseCreatedTypeEnum;
    /**
     * 
     * @type {RealtimeResponse}
     * @memberof RealtimeServerEventResponseCreated
     */
    response: RealtimeResponse;
}


            export type RealtimeServerEventResponseDoneTypeEnum = 'response.done';
/**
 * Returned when a Response is done streaming. Always emitted, no matter the  final state. The Response object included in the `response.done` event will  include all output Items in the Response but will omit the raw audio data. 
 * @export
 */
export type RealtimeServerEventResponseDone = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventResponseDone
     */
    event_id: string;
    /**
     * The event type, must be `response.done`.
     * @type {string}
     * @memberof RealtimeServerEventResponseDone
     */
    type: RealtimeServerEventResponseDoneTypeEnum;
    /**
     * 
     * @type {RealtimeResponse}
     * @memberof RealtimeServerEventResponseDone
     */
    response: RealtimeResponse;
}


            export type RealtimeServerEventResponseFunctionCallArgumentsDeltaTypeEnum = 'response.function_call_arguments.delta';
/**
 * Returned when the model-generated function call arguments are updated. 
 * @export
 */
export type RealtimeServerEventResponseFunctionCallArgumentsDelta = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventResponseFunctionCallArgumentsDelta
     */
    event_id: string;
    /**
     * The event type, must be `response.function_call_arguments.delta`. 
     * @type {string}
     * @memberof RealtimeServerEventResponseFunctionCallArgumentsDelta
     */
    type: RealtimeServerEventResponseFunctionCallArgumentsDeltaTypeEnum;
    /**
     * The ID of the response.
     * @type {string}
     * @memberof RealtimeServerEventResponseFunctionCallArgumentsDelta
     */
    response_id: string;
    /**
     * The ID of the function call item.
     * @type {string}
     * @memberof RealtimeServerEventResponseFunctionCallArgumentsDelta
     */
    item_id: string;
    /**
     * The index of the output item in the response.
     * @type {number}
     * @memberof RealtimeServerEventResponseFunctionCallArgumentsDelta
     */
    output_index: number;
    /**
     * The ID of the function call.
     * @type {string}
     * @memberof RealtimeServerEventResponseFunctionCallArgumentsDelta
     */
    call_id: string;
    /**
     * The arguments delta as a JSON string.
     * @type {string}
     * @memberof RealtimeServerEventResponseFunctionCallArgumentsDelta
     */
    delta: string;
}


            export type RealtimeServerEventResponseFunctionCallArgumentsDoneTypeEnum = 'response.function_call_arguments.done';
/**
 * Returned when the model-generated function call arguments are done streaming. Also emitted when a Response is interrupted, incomplete, or cancelled. 
 * @export
 */
export type RealtimeServerEventResponseFunctionCallArgumentsDone = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventResponseFunctionCallArgumentsDone
     */
    event_id: string;
    /**
     * The event type, must be `response.function_call_arguments.done`. 
     * @type {string}
     * @memberof RealtimeServerEventResponseFunctionCallArgumentsDone
     */
    type: RealtimeServerEventResponseFunctionCallArgumentsDoneTypeEnum;
    /**
     * The ID of the response.
     * @type {string}
     * @memberof RealtimeServerEventResponseFunctionCallArgumentsDone
     */
    response_id: string;
    /**
     * The ID of the function call item.
     * @type {string}
     * @memberof RealtimeServerEventResponseFunctionCallArgumentsDone
     */
    item_id: string;
    /**
     * The index of the output item in the response.
     * @type {number}
     * @memberof RealtimeServerEventResponseFunctionCallArgumentsDone
     */
    output_index: number;
    /**
     * The ID of the function call.
     * @type {string}
     * @memberof RealtimeServerEventResponseFunctionCallArgumentsDone
     */
    call_id: string;
    /**
     * The final arguments as a JSON string.
     * @type {string}
     * @memberof RealtimeServerEventResponseFunctionCallArgumentsDone
     */
    _arguments: string;
}


            export type RealtimeServerEventResponseOutputItemAddedTypeEnum = 'response.output_item.added';
/**
 * Returned when a new Item is created during Response generation.
 * @export
 */
export type RealtimeServerEventResponseOutputItemAdded = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventResponseOutputItemAdded
     */
    event_id: string;
    /**
     * The event type, must be `response.output_item.added`.
     * @type {string}
     * @memberof RealtimeServerEventResponseOutputItemAdded
     */
    type: RealtimeServerEventResponseOutputItemAddedTypeEnum;
    /**
     * The ID of the Response to which the item belongs.
     * @type {string}
     * @memberof RealtimeServerEventResponseOutputItemAdded
     */
    response_id: string;
    /**
     * The index of the output item in the Response.
     * @type {number}
     * @memberof RealtimeServerEventResponseOutputItemAdded
     */
    output_index: number;
    /**
     * 
     * @type {RealtimeConversationItem}
     * @memberof RealtimeServerEventResponseOutputItemAdded
     */
    item: RealtimeConversationItem;
}


            export type RealtimeServerEventResponseOutputItemDoneTypeEnum = 'response.output_item.done';
/**
 * Returned when an Item is done streaming. Also emitted when a Response is  interrupted, incomplete, or cancelled. 
 * @export
 */
export type RealtimeServerEventResponseOutputItemDone = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventResponseOutputItemDone
     */
    event_id: string;
    /**
     * The event type, must be `response.output_item.done`.
     * @type {string}
     * @memberof RealtimeServerEventResponseOutputItemDone
     */
    type: RealtimeServerEventResponseOutputItemDoneTypeEnum;
    /**
     * The ID of the Response to which the item belongs.
     * @type {string}
     * @memberof RealtimeServerEventResponseOutputItemDone
     */
    response_id: string;
    /**
     * The index of the output item in the Response.
     * @type {number}
     * @memberof RealtimeServerEventResponseOutputItemDone
     */
    output_index: number;
    /**
     * 
     * @type {RealtimeConversationItem}
     * @memberof RealtimeServerEventResponseOutputItemDone
     */
    item: RealtimeConversationItem;
}


            export type RealtimeServerEventResponseTextDeltaTypeEnum = 'response.text.delta';
/**
 * Returned when the text value of a \"text\" content part is updated.
 * @export
 */
export type RealtimeServerEventResponseTextDelta = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventResponseTextDelta
     */
    event_id: string;
    /**
     * The event type, must be `response.text.delta`.
     * @type {string}
     * @memberof RealtimeServerEventResponseTextDelta
     */
    type: RealtimeServerEventResponseTextDeltaTypeEnum;
    /**
     * The ID of the response.
     * @type {string}
     * @memberof RealtimeServerEventResponseTextDelta
     */
    response_id: string;
    /**
     * The ID of the item.
     * @type {string}
     * @memberof RealtimeServerEventResponseTextDelta
     */
    item_id: string;
    /**
     * The index of the output item in the response.
     * @type {number}
     * @memberof RealtimeServerEventResponseTextDelta
     */
    output_index: number;
    /**
     * The index of the content part in the item\'s content array.
     * @type {number}
     * @memberof RealtimeServerEventResponseTextDelta
     */
    content_index: number;
    /**
     * The text delta.
     * @type {string}
     * @memberof RealtimeServerEventResponseTextDelta
     */
    delta: string;
}


            export type RealtimeServerEventResponseTextDoneTypeEnum = 'response.text.done';
/**
 * Returned when the text value of a \"text\" content part is done streaming. Also emitted when a Response is interrupted, incomplete, or cancelled. 
 * @export
 */
export type RealtimeServerEventResponseTextDone = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventResponseTextDone
     */
    event_id: string;
    /**
     * The event type, must be `response.text.done`.
     * @type {string}
     * @memberof RealtimeServerEventResponseTextDone
     */
    type: RealtimeServerEventResponseTextDoneTypeEnum;
    /**
     * The ID of the response.
     * @type {string}
     * @memberof RealtimeServerEventResponseTextDone
     */
    response_id: string;
    /**
     * The ID of the item.
     * @type {string}
     * @memberof RealtimeServerEventResponseTextDone
     */
    item_id: string;
    /**
     * The index of the output item in the response.
     * @type {number}
     * @memberof RealtimeServerEventResponseTextDone
     */
    output_index: number;
    /**
     * The index of the content part in the item\'s content array.
     * @type {number}
     * @memberof RealtimeServerEventResponseTextDone
     */
    content_index: number;
    /**
     * The final text content.
     * @type {string}
     * @memberof RealtimeServerEventResponseTextDone
     */
    text: string;
}


            export type RealtimeServerEventSessionCreatedTypeEnum = 'session.created';
/**
 * Returned when a Session is created. Emitted automatically when a new  connection is established as the first server event. This event will contain  the default Session configuration. 
 * @export
 */
export type RealtimeServerEventSessionCreated = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventSessionCreated
     */
    event_id: string;
    /**
     * The event type, must be `session.created`.
     * @type {string}
     * @memberof RealtimeServerEventSessionCreated
     */
    type: RealtimeServerEventSessionCreatedTypeEnum;
    /**
     * 
     * @type {RealtimeSession}
     * @memberof RealtimeServerEventSessionCreated
     */
    session: RealtimeSession;
}


            export type RealtimeServerEventSessionUpdatedTypeEnum = 'session.updated';
/**
 * Returned when a session is updated with a `session.update` event, unless  there is an error. 
 * @export
 */
export type RealtimeServerEventSessionUpdated = {
    /**
     * The unique ID of the server event.
     * @type {string}
     * @memberof RealtimeServerEventSessionUpdated
     */
    event_id: string;
    /**
     * The event type, must be `session.updated`.
     * @type {string}
     * @memberof RealtimeServerEventSessionUpdated
     */
    type: RealtimeServerEventSessionUpdatedTypeEnum;
    /**
     * 
     * @type {RealtimeSession}
     * @memberof RealtimeServerEventSessionUpdated
     */
    session: RealtimeSession;
}


            export type RealtimeSessionModalitiesEnum = 'text' | 'audio';

            export type RealtimeSessionVoiceEnum = 'alloy' | 'ash' | 'ballad' | 'coral' | 'echo' | 'sage' | 'shimmer' | 'verse';

            export type RealtimeSessionInputAudioFormatEnum = 'pcm16' | 'g711_ulaw' | 'g711_alaw';

            export type RealtimeSessionOutputAudioFormatEnum = 'pcm16' | 'g711_ulaw' | 'g711_alaw';
/**
 * Realtime session object configuration.
 * @export
 */
export type RealtimeSession = {
    /**
     * Unique identifier for the session object. 
     * @type {string}
     * @memberof RealtimeSession
     */
    id?: string;
    /**
     * The set of modalities the model can respond with. To disable audio, set this to [\"text\"]. 
     * @type {Array<string>}
     * @memberof RealtimeSession
     */
    modalities?: Array<RealtimeSessionModalitiesEnum>;
    /**
     * 
     * @type {RealtimeSessionModel}
     * @memberof RealtimeSession
     */
    model?: RealtimeSessionModel;
    /**
     * The default system instructions (i.e. system message) prepended to model  calls. This field allows the client to guide the model on desired  responses. The model can be instructed on response content and format,  (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good  responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion  into your voice\", \"laugh frequently\"). The instructions are not guaranteed  to be followed by the model, but they provide guidance to the model on the  desired behavior.  Note that the server sets default instructions which will be used if this  field is not set and are visible in the `session.created` event at the  start of the session. 
     * @type {string}
     * @memberof RealtimeSession
     */
    instructions?: string;
    /**
     * The voice the model uses to respond. Voice cannot be changed during the  session once the model has responded with audio at least once. Current  voice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`,  `shimmer` and `verse`. 
     * @type {string}
     * @memberof RealtimeSession
     */
    voice?: RealtimeSessionVoiceEnum;
    /**
     * The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
     * @type {string}
     * @memberof RealtimeSession
     */
    input_audio_format?: RealtimeSessionInputAudioFormatEnum;
    /**
     * The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
     * @type {string}
     * @memberof RealtimeSession
     */
    output_audio_format?: RealtimeSessionOutputAudioFormatEnum;
    /**
     * 
     * @type {RealtimeSessionInputAudioTranscription}
     * @memberof RealtimeSession
     */
    input_audio_transcription?: RealtimeSessionInputAudioTranscription;
    /**
     * 
     * @type {RealtimeSessionTurnDetection}
     * @memberof RealtimeSession
     */
    turn_detection?: RealtimeSessionTurnDetection;
    /**
     * Tools (functions) available to the model.
     * @type {Array<RealtimeResponseCreateParamsToolsInner>}
     * @memberof RealtimeSession
     */
    tools?: Array<RealtimeResponseCreateParamsToolsInner>;
    /**
     * How the model chooses tools. Options are `auto`, `none`, `required`, or  specify a function. 
     * @type {string}
     * @memberof RealtimeSession
     */
    tool_choice?: string;
    /**
     * Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8. 
     * @type {number}
     * @memberof RealtimeSession
     */
    temperature?: number;
    /**
     * 
     * @type {RealtimeResponseCreateParamsMaxResponseOutputTokens}
     * @memberof RealtimeSession
     */
    max_response_output_tokens?: RealtimeResponseCreateParamsMaxResponseOutputTokens;
}


            export type RealtimeSessionCreateRequestModalitiesEnum = 'text' | 'audio';

            export type RealtimeSessionCreateRequestModelEnum = 'gpt-4o-realtime-preview' | 'gpt-4o-realtime-preview-2024-10-01' | 'gpt-4o-realtime-preview-2024-12-17' | 'gpt-4o-mini-realtime-preview' | 'gpt-4o-mini-realtime-preview-2024-12-17';

            export type RealtimeSessionCreateRequestVoiceEnum = 'alloy' | 'ash' | 'ballad' | 'coral' | 'echo' | 'sage' | 'shimmer' | 'verse';

            export type RealtimeSessionCreateRequestInputAudioFormatEnum = 'pcm16' | 'g711_ulaw' | 'g711_alaw';

            export type RealtimeSessionCreateRequestOutputAudioFormatEnum = 'pcm16' | 'g711_ulaw' | 'g711_alaw';
/**
 * Realtime session object configuration.
 * @export
 */
export type RealtimeSessionCreateRequest = {
    /**
     * The set of modalities the model can respond with. To disable audio, set this to [\"text\"]. 
     * @type {Array<string>}
     * @memberof RealtimeSessionCreateRequest
     */
    modalities?: Array<RealtimeSessionCreateRequestModalitiesEnum>;
    /**
     * The Realtime model used for this session. 
     * @type {string}
     * @memberof RealtimeSessionCreateRequest
     */
    model: RealtimeSessionCreateRequestModelEnum;
    /**
     * The default system instructions (i.e. system message) prepended to model  calls. This field allows the client to guide the model on desired  responses. The model can be instructed on response content and format,  (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good  responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion  into your voice\", \"laugh frequently\"). The instructions are not guaranteed  to be followed by the model, but they provide guidance to the model on the  desired behavior.  Note that the server sets default instructions which will be used if this  field is not set and are visible in the `session.created` event at the  start of the session. 
     * @type {string}
     * @memberof RealtimeSessionCreateRequest
     */
    instructions?: string;
    /**
     * The voice the model uses to respond. Voice cannot be changed during the  session once the model has responded with audio at least once. Current  voice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`,  `shimmer` and `verse`. 
     * @type {string}
     * @memberof RealtimeSessionCreateRequest
     */
    voice?: RealtimeSessionCreateRequestVoiceEnum;
    /**
     * The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
     * @type {string}
     * @memberof RealtimeSessionCreateRequest
     */
    input_audio_format?: RealtimeSessionCreateRequestInputAudioFormatEnum;
    /**
     * The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
     * @type {string}
     * @memberof RealtimeSessionCreateRequest
     */
    output_audio_format?: RealtimeSessionCreateRequestOutputAudioFormatEnum;
    /**
     * 
     * @type {RealtimeSessionInputAudioTranscription}
     * @memberof RealtimeSessionCreateRequest
     */
    input_audio_transcription?: RealtimeSessionInputAudioTranscription;
    /**
     * 
     * @type {RealtimeSessionCreateRequestTurnDetection}
     * @memberof RealtimeSessionCreateRequest
     */
    turn_detection?: RealtimeSessionCreateRequestTurnDetection;
    /**
     * Tools (functions) available to the model.
     * @type {Array<RealtimeResponseCreateParamsToolsInner>}
     * @memberof RealtimeSessionCreateRequest
     */
    tools?: Array<RealtimeResponseCreateParamsToolsInner>;
    /**
     * How the model chooses tools. Options are `auto`, `none`, `required`, or  specify a function. 
     * @type {string}
     * @memberof RealtimeSessionCreateRequest
     */
    tool_choice?: string;
    /**
     * Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8. 
     * @type {number}
     * @memberof RealtimeSessionCreateRequest
     */
    temperature?: number;
    /**
     * 
     * @type {RealtimeResponseCreateParamsMaxResponseOutputTokens}
     * @memberof RealtimeSessionCreateRequest
     */
    max_response_output_tokens?: RealtimeResponseCreateParamsMaxResponseOutputTokens;
}

/**
 * Configuration for turn detection. Can be set to `null` to turn off. Server  VAD means that the model will detect the start and end of speech based on  audio volume and respond at the end of user speech. 
 * @export
 */
export type RealtimeSessionCreateRequestTurnDetection = {
    /**
     * Type of turn detection, only `server_vad` is currently supported. 
     * @type {string}
     * @memberof RealtimeSessionCreateRequestTurnDetection
     */
    type?: string;
    /**
     * Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A  higher threshold will require louder audio to activate the model, and  thus might perform better in noisy environments. 
     * @type {number}
     * @memberof RealtimeSessionCreateRequestTurnDetection
     */
    threshold?: number;
    /**
     * Amount of audio to include before the VAD detected speech (in  milliseconds). Defaults to 300ms. 
     * @type {number}
     * @memberof RealtimeSessionCreateRequestTurnDetection
     */
    prefix_padding_ms?: number;
    /**
     * Duration of silence to detect speech stop (in milliseconds). Defaults  to 500ms. With shorter values the model will respond more quickly,  but may jump in on short pauses from the user. 
     * @type {number}
     * @memberof RealtimeSessionCreateRequestTurnDetection
     */
    silence_duration_ms?: number;
    /**
     * Whether or not to automatically generate a response when VAD is enabled. `true` by default. 
     * @type {boolean}
     * @memberof RealtimeSessionCreateRequestTurnDetection
     */
    create_response?: boolean;
}


            export type RealtimeSessionCreateResponseModalitiesEnum = 'text' | 'audio';

            export type RealtimeSessionCreateResponseVoiceEnum = 'alloy' | 'ash' | 'ballad' | 'coral' | 'echo' | 'sage' | 'shimmer' | 'verse';
/**
 * A new Realtime session configuration, with an ephermeral key. Default TTL for keys is one minute. 
 * @export
 */
export type RealtimeSessionCreateResponse = {
    /**
     * 
     * @type {RealtimeSessionCreateResponseClientSecret}
     * @memberof RealtimeSessionCreateResponse
     */
    client_secret?: RealtimeSessionCreateResponseClientSecret;
    /**
     * The set of modalities the model can respond with. To disable audio, set this to [\"text\"]. 
     * @type {Array<string>}
     * @memberof RealtimeSessionCreateResponse
     */
    modalities?: Array<RealtimeSessionCreateResponseModalitiesEnum>;
    /**
     * The default system instructions (i.e. system message) prepended to model  calls. This field allows the client to guide the model on desired  responses. The model can be instructed on response content and format,  (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good  responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion  into your voice\", \"laugh frequently\"). The instructions are not guaranteed  to be followed by the model, but they provide guidance to the model on the  desired behavior.  Note that the server sets default instructions which will be used if this  field is not set and are visible in the `session.created` event at the  start of the session. 
     * @type {string}
     * @memberof RealtimeSessionCreateResponse
     */
    instructions?: string;
    /**
     * The voice the model uses to respond. Voice cannot be changed during the  session once the model has responded with audio at least once. Current  voice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`,  `shimmer` and `verse`. 
     * @type {string}
     * @memberof RealtimeSessionCreateResponse
     */
    voice?: RealtimeSessionCreateResponseVoiceEnum;
    /**
     * The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
     * @type {string}
     * @memberof RealtimeSessionCreateResponse
     */
    input_audio_format?: string;
    /**
     * The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
     * @type {string}
     * @memberof RealtimeSessionCreateResponse
     */
    output_audio_format?: string;
    /**
     * 
     * @type {RealtimeSessionInputAudioTranscription}
     * @memberof RealtimeSessionCreateResponse
     */
    input_audio_transcription?: RealtimeSessionInputAudioTranscription;
    /**
     * 
     * @type {RealtimeSessionCreateResponseTurnDetection}
     * @memberof RealtimeSessionCreateResponse
     */
    turn_detection?: RealtimeSessionCreateResponseTurnDetection;
    /**
     * Tools (functions) available to the model.
     * @type {Array<RealtimeResponseCreateParamsToolsInner>}
     * @memberof RealtimeSessionCreateResponse
     */
    tools?: Array<RealtimeResponseCreateParamsToolsInner>;
    /**
     * How the model chooses tools. Options are `auto`, `none`, `required`, or  specify a function. 
     * @type {string}
     * @memberof RealtimeSessionCreateResponse
     */
    tool_choice?: string;
    /**
     * Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8. 
     * @type {number}
     * @memberof RealtimeSessionCreateResponse
     */
    temperature?: number;
    /**
     * 
     * @type {RealtimeResponseCreateParamsMaxResponseOutputTokens}
     * @memberof RealtimeSessionCreateResponse
     */
    max_response_output_tokens?: RealtimeResponseCreateParamsMaxResponseOutputTokens;
}

/**
 * Ephemeral key returned by the API.
 * @export
 */
export type RealtimeSessionCreateResponseClientSecret = {
    /**
     * Ephemeral key usable in client environments to authenticate connections to the Realtime API. Use this in client-side environments rather than a standard API token, which should only be used server-side. 
     * @type {string}
     * @memberof RealtimeSessionCreateResponseClientSecret
     */
    value?: string;
    /**
     * Timestamp for when the token expires. Currently, all tokens expire after one minute. 
     * @type {number}
     * @memberof RealtimeSessionCreateResponseClientSecret
     */
    expires_at?: number;
}

/**
 * Configuration for turn detection. Can be set to `null` to turn off. Server  VAD means that the model will detect the start and end of speech based on  audio volume and respond at the end of user speech. 
 * @export
 */
export type RealtimeSessionCreateResponseTurnDetection = {
    /**
     * Type of turn detection, only `server_vad` is currently supported. 
     * @type {string}
     * @memberof RealtimeSessionCreateResponseTurnDetection
     */
    type?: string;
    /**
     * Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A  higher threshold will require louder audio to activate the model, and  thus might perform better in noisy environments. 
     * @type {number}
     * @memberof RealtimeSessionCreateResponseTurnDetection
     */
    threshold?: number;
    /**
     * Amount of audio to include before the VAD detected speech (in  milliseconds). Defaults to 300ms. 
     * @type {number}
     * @memberof RealtimeSessionCreateResponseTurnDetection
     */
    prefix_padding_ms?: number;
    /**
     * Duration of silence to detect speech stop (in milliseconds). Defaults  to 500ms. With shorter values the model will respond more quickly,  but may jump in on short pauses from the user. 
     * @type {number}
     * @memberof RealtimeSessionCreateResponseTurnDetection
     */
    silence_duration_ms?: number;
}

/**
 * Configuration for input audio transcription, defaults to off and can be  set to `null` to turn off once on. Input audio transcription is not native  to the model, since the model consumes audio directly. Transcription runs  asynchronously through Whisper and should be treated as rough guidance  rather than the representation understood by the model. 
 * @export
 */
export type RealtimeSessionInputAudioTranscription = {
    /**
     * The model to use for transcription, `whisper-1` is the only currently  supported model. 
     * @type {string}
     * @memberof RealtimeSessionInputAudioTranscription
     */
    model?: string;
}

/**
 * The Realtime model used for this session. 
 * @export
 */
export type RealtimeSessionModel = {
}


            export type RealtimeSessionTurnDetectionTypeEnum = 'server_vad';
/**
 * Configuration for turn detection. Can be set to `null` to turn off. Server  VAD means that the model will detect the start and end of speech based on  audio volume and respond at the end of user speech. 
 * @export
 */
export type RealtimeSessionTurnDetection = {
    /**
     * Type of turn detection, only `server_vad` is currently supported. 
     * @type {string}
     * @memberof RealtimeSessionTurnDetection
     */
    type?: RealtimeSessionTurnDetectionTypeEnum;
    /**
     * Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A  higher threshold will require louder audio to activate the model, and  thus might perform better in noisy environments. 
     * @type {number}
     * @memberof RealtimeSessionTurnDetection
     */
    threshold?: number;
    /**
     * Amount of audio to include before the VAD detected speech (in  milliseconds). Defaults to 300ms. 
     * @type {number}
     * @memberof RealtimeSessionTurnDetection
     */
    prefix_padding_ms?: number;
    /**
     * Duration of silence to detect speech stop (in milliseconds). Defaults  to 500ms. With shorter values the model will respond more quickly,  but may jump in on short pauses from the user. 
     * @type {number}
     * @memberof RealtimeSessionTurnDetection
     */
    silence_duration_ms?: number;
}


            export type ResponseFormatJsonObjectTypeEnum = 'json_object';
/**
 * 
 * @export
 */
export type ResponseFormatJsonObject = {
    /**
     * The type of response format being defined: `json_object`
     * @type {string}
     * @memberof ResponseFormatJsonObject
     */
    type: ResponseFormatJsonObjectTypeEnum;
}


            export type ResponseFormatJsonSchemaTypeEnum = 'json_schema';
/**
 * 
 * @export
 */
export type ResponseFormatJsonSchema = {
    /**
     * The type of response format being defined: `json_schema`
     * @type {string}
     * @memberof ResponseFormatJsonSchema
     */
    type: ResponseFormatJsonSchemaTypeEnum;
    /**
     * 
     * @type {ResponseFormatJsonSchemaJsonSchema}
     * @memberof ResponseFormatJsonSchema
     */
    json_schema: ResponseFormatJsonSchemaJsonSchema;
}

/**
 * 
 * @export
 */
export type ResponseFormatJsonSchemaJsonSchema = {
    /**
     * A description of what the response format is for, used by the model to determine how to respond in the format.
     * @type {string}
     * @memberof ResponseFormatJsonSchemaJsonSchema
     */
    description?: string;
    /**
     * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     * @type {string}
     * @memberof ResponseFormatJsonSchemaJsonSchema
     */
    name: string;
    /**
     * The schema for the response format, described as a JSON Schema object.
     * @type {{ [key: string]: AnyType; }}
     * @memberof ResponseFormatJsonSchemaJsonSchema
     */
    schema?: { [key: string]: AnyType; };
    /**
     * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. To learn more, read the [Structured Outputs guide](/docs/guides/structured-outputs).
     * @type {boolean}
     * @memberof ResponseFormatJsonSchemaJsonSchema
     */
    strict?: boolean;
}


            export type ResponseFormatTextTypeEnum = 'text';
/**
 * 
 * @export
 */
export type ResponseFormatText = {
    /**
     * The type of response format being defined: `text`
     * @type {string}
     * @memberof ResponseFormatText
     */
    type: ResponseFormatTextTypeEnum;
}

/**
 * Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
 * @export
 */
export type RunCompletionUsage = {
    /**
     * Number of completion tokens used over the course of the run.
     * @type {number}
     * @memberof RunCompletionUsage
     */
    completion_tokens: number;
    /**
     * Number of prompt tokens used over the course of the run.
     * @type {number}
     * @memberof RunCompletionUsage
     */
    prompt_tokens: number;
    /**
     * Total number of tokens used (prompt + completion).
     * @type {number}
     * @memberof RunCompletionUsage
     */
    total_tokens: number;
}


            export type RunObjectObjectEnum = 'thread.run';

            export type RunObjectStatusEnum = 'queued' | 'in_progress' | 'requires_action' | 'cancelling' | 'cancelled' | 'failed' | 'completed' | 'incomplete' | 'expired';
/**
 * Represents an execution run on a [thread](/docs/api-reference/threads).
 * @export
 */
export type RunObject = {
    /**
     * The identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof RunObject
     */
    id: string;
    /**
     * The object type, which is always `thread.run`.
     * @type {string}
     * @memberof RunObject
     */
    _object: RunObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the run was created.
     * @type {number}
     * @memberof RunObject
     */
    created_at: number;
    /**
     * The ID of the [thread](/docs/api-reference/threads) that was executed on as a part of this run.
     * @type {string}
     * @memberof RunObject
     */
    thread_id: string;
    /**
     * The ID of the [assistant](/docs/api-reference/assistants) used for execution of this run.
     * @type {string}
     * @memberof RunObject
     */
    assistant_id: string;
    /**
     * The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`.
     * @type {string}
     * @memberof RunObject
     */
    status: RunObjectStatusEnum;
    /**
     * 
     * @type {RunObjectRequiredAction}
     * @memberof RunObject
     */
    required_action: RunObjectRequiredAction;
    /**
     * 
     * @type {RunObjectLastError}
     * @memberof RunObject
     */
    last_error: RunObjectLastError;
    /**
     * The Unix timestamp (in seconds) for when the run will expire.
     * @type {number}
     * @memberof RunObject
     */
    expires_at: number;
    /**
     * The Unix timestamp (in seconds) for when the run was started.
     * @type {number}
     * @memberof RunObject
     */
    started_at: number;
    /**
     * The Unix timestamp (in seconds) for when the run was cancelled.
     * @type {number}
     * @memberof RunObject
     */
    cancelled_at: number;
    /**
     * The Unix timestamp (in seconds) for when the run failed.
     * @type {number}
     * @memberof RunObject
     */
    failed_at: number;
    /**
     * The Unix timestamp (in seconds) for when the run was completed.
     * @type {number}
     * @memberof RunObject
     */
    completed_at: number;
    /**
     * 
     * @type {RunObjectIncompleteDetails}
     * @memberof RunObject
     */
    incomplete_details: RunObjectIncompleteDetails;
    /**
     * The model that the [assistant](/docs/api-reference/assistants) used for this run.
     * @type {string}
     * @memberof RunObject
     */
    model: string;
    /**
     * The instructions that the [assistant](/docs/api-reference/assistants) used for this run.
     * @type {string}
     * @memberof RunObject
     */
    instructions: string;
    /**
     * The list of tools that the [assistant](/docs/api-reference/assistants) used for this run.
     * @type {Array<AssistantObjectToolsInner>}
     * @memberof RunObject
     */
    tools: Array<AssistantObjectToolsInner>;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof RunObject
     */
    metadata: Object;
    /**
     * 
     * @type {RunCompletionUsage}
     * @memberof RunObject
     */
    usage: RunCompletionUsage;
    /**
     * The sampling temperature used for this run. If not set, defaults to 1.
     * @type {number}
     * @memberof RunObject
     */
    temperature?: number;
    /**
     * The nucleus sampling value used for this run. If not set, defaults to 1.
     * @type {number}
     * @memberof RunObject
     */
    top_p?: number;
    /**
     * The maximum number of prompt tokens specified to have been used over the course of the run. 
     * @type {number}
     * @memberof RunObject
     */
    max_prompt_tokens: number;
    /**
     * The maximum number of completion tokens specified to have been used over the course of the run. 
     * @type {number}
     * @memberof RunObject
     */
    max_completion_tokens: number;
    /**
     * 
     * @type {TruncationObject}
     * @memberof RunObject
     */
    truncation_strategy: TruncationObject;
    /**
     * 
     * @type {AssistantsApiToolChoiceOption}
     * @memberof RunObject
     */
    tool_choice: AssistantsApiToolChoiceOption;
    /**
     * Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
     * @type {boolean}
     * @memberof RunObject
     */
    parallel_tool_calls: boolean;
    /**
     * 
     * @type {AssistantsApiResponseFormatOption}
     * @memberof RunObject
     */
    response_format: AssistantsApiResponseFormatOption;
}


            export type RunObjectIncompleteDetailsReasonEnum = 'max_completion_tokens' | 'max_prompt_tokens';
/**
 * Details on why the run is incomplete. Will be `null` if the run is not incomplete.
 * @export
 */
export type RunObjectIncompleteDetails = {
    /**
     * The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run.
     * @type {string}
     * @memberof RunObjectIncompleteDetails
     */
    reason?: RunObjectIncompleteDetailsReasonEnum;
}


            export type RunObjectLastErrorCodeEnum = 'server_error' | 'rate_limit_exceeded' | 'invalid_prompt';
/**
 * The last error associated with this run. Will be `null` if there are no errors.
 * @export
 */
export type RunObjectLastError = {
    /**
     * One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
     * @type {string}
     * @memberof RunObjectLastError
     */
    code: RunObjectLastErrorCodeEnum;
    /**
     * A human-readable description of the error.
     * @type {string}
     * @memberof RunObjectLastError
     */
    message: string;
}


            export type RunObjectRequiredActionTypeEnum = 'submit_tool_outputs';
/**
 * Details on the action required to continue the run. Will be `null` if no action is required.
 * @export
 */
export type RunObjectRequiredAction = {
    /**
     * For now, this is always `submit_tool_outputs`.
     * @type {string}
     * @memberof RunObjectRequiredAction
     */
    type: RunObjectRequiredActionTypeEnum;
    /**
     * 
     * @type {RunObjectRequiredActionSubmitToolOutputs}
     * @memberof RunObjectRequiredAction
     */
    submit_tool_outputs: RunObjectRequiredActionSubmitToolOutputs;
}

/**
 * Details on the tool outputs needed for this run to continue.
 * @export
 */
export type RunObjectRequiredActionSubmitToolOutputs = {
    /**
     * A list of the relevant tool calls.
     * @type {Array<RunToolCallObject>}
     * @memberof RunObjectRequiredActionSubmitToolOutputs
     */
    tool_calls: Array<RunToolCallObject>;
}

/**
 * Usage statistics related to the run step. This value will be `null` while the run step\'s status is `in_progress`.
 * @export
 */
export type RunStepCompletionUsage = {
    /**
     * Number of completion tokens used over the course of the run step.
     * @type {number}
     * @memberof RunStepCompletionUsage
     */
    completion_tokens: number;
    /**
     * Number of prompt tokens used over the course of the run step.
     * @type {number}
     * @memberof RunStepCompletionUsage
     */
    prompt_tokens: number;
    /**
     * Total number of tokens used (prompt + completion).
     * @type {number}
     * @memberof RunStepCompletionUsage
     */
    total_tokens: number;
}


            export type RunStepDeltaObjectObjectEnum = 'thread.run.step.delta';
/**
 * Represents a run step delta i.e. any changed fields on a run step during streaming. 
 * @export
 */
export type RunStepDeltaObject = {
    /**
     * The identifier of the run step, which can be referenced in API endpoints.
     * @type {string}
     * @memberof RunStepDeltaObject
     */
    id: string;
    /**
     * The object type, which is always `thread.run.step.delta`.
     * @type {string}
     * @memberof RunStepDeltaObject
     */
    _object: RunStepDeltaObjectObjectEnum;
    /**
     * 
     * @type {RunStepDeltaObjectDelta}
     * @memberof RunStepDeltaObject
     */
    delta: RunStepDeltaObjectDelta;
}

/**
 * The delta containing the fields that have changed on the run step.
 * @export
 */
export type RunStepDeltaObjectDelta = {
    /**
     * 
     * @type {RunStepDeltaObjectDeltaStepDetails}
     * @memberof RunStepDeltaObjectDelta
     */
    step_details?: RunStepDeltaObjectDeltaStepDetails;
}


            export type RunStepDeltaObjectDeltaStepDetailsTypeEnum = 'message_creation' | 'tool_calls';
/**
 * The details of the run step.
 * @export
 */
export type RunStepDeltaObjectDeltaStepDetails = {
    /**
     * Always `message_creation`.
     * @type {string}
     * @memberof RunStepDeltaObjectDeltaStepDetails
     */
    type: RunStepDeltaObjectDeltaStepDetailsTypeEnum;
    /**
     * 
     * @type {RunStepDeltaStepDetailsMessageCreationObjectMessageCreation}
     * @memberof RunStepDeltaObjectDeltaStepDetails
     */
    message_creation?: RunStepDeltaStepDetailsMessageCreationObjectMessageCreation;
    /**
     * An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`. 
     * @type {Array<RunStepDeltaStepDetailsToolCallsObjectToolCallsInner>}
     * @memberof RunStepDeltaObjectDeltaStepDetails
     */
    tool_calls?: Array<RunStepDeltaStepDetailsToolCallsObjectToolCallsInner>;
}


            export type RunStepDeltaStepDetailsMessageCreationObjectTypeEnum = 'message_creation';
/**
 * Details of the message creation by the run step.
 * @export
 */
export type RunStepDeltaStepDetailsMessageCreationObject = {
    /**
     * Always `message_creation`.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsMessageCreationObject
     */
    type: RunStepDeltaStepDetailsMessageCreationObjectTypeEnum;
    /**
     * 
     * @type {RunStepDeltaStepDetailsMessageCreationObjectMessageCreation}
     * @memberof RunStepDeltaStepDetailsMessageCreationObject
     */
    message_creation?: RunStepDeltaStepDetailsMessageCreationObjectMessageCreation;
}

/**
 * 
 * @export
 */
export type RunStepDeltaStepDetailsMessageCreationObjectMessageCreation = {
    /**
     * The ID of the message that was created by this run step.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsMessageCreationObjectMessageCreation
     */
    message_id?: string;
}


            export type RunStepDeltaStepDetailsToolCallsCodeObjectTypeEnum = 'code_interpreter';
/**
 * Details of the Code Interpreter tool call the run step was involved in.
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsCodeObject = {
    /**
     * The index of the tool call in the tool calls array.
     * @type {number}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObject
     */
    index: number;
    /**
     * The ID of the tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObject
     */
    id?: string;
    /**
     * The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObject
     */
    type: RunStepDeltaStepDetailsToolCallsCodeObjectTypeEnum;
    /**
     * 
     * @type {RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObject
     */
    code_interpreter?: RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter;
}

/**
 * The Code Interpreter tool call definition.
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter = {
    /**
     * The input to the Code Interpreter tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter
     */
    input?: string;
    /**
     * The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
     * @type {Array<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter
     */
    outputs?: Array<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>;
}


            export type RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerTypeEnum = 'logs' | 'image';
/**
 * 
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner = {
    /**
     * The index of the output in the outputs array.
     * @type {number}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
     */
    index: number;
    /**
     * Always `logs`.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
     */
    type: RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerTypeEnum;
    /**
     * The text output from the Code Interpreter tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
     */
    logs?: string;
    /**
     * 
     * @type {RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
     */
    image?: RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage;
}


            export type RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectTypeEnum = 'image';
/**
 * 
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsCodeOutputImageObject = {
    /**
     * The index of the output in the outputs array.
     * @type {number}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeOutputImageObject
     */
    index: number;
    /**
     * Always `image`.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeOutputImageObject
     */
    type: RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectTypeEnum;
    /**
     * 
     * @type {RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeOutputImageObject
     */
    image?: RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage;
}

/**
 * 
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage = {
    /**
     * The [file](/docs/api-reference/files) ID of the image.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage
     */
    file_id?: string;
}


            export type RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectTypeEnum = 'logs';
/**
 * Text output from the Code Interpreter tool call as part of a run step.
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject = {
    /**
     * The index of the output in the outputs array.
     * @type {number}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject
     */
    index: number;
    /**
     * Always `logs`.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject
     */
    type: RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectTypeEnum;
    /**
     * The text output from the Code Interpreter tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject
     */
    logs?: string;
}


            export type RunStepDeltaStepDetailsToolCallsFileSearchObjectTypeEnum = 'file_search';
/**
 * 
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsFileSearchObject = {
    /**
     * The index of the tool call in the tool calls array.
     * @type {number}
     * @memberof RunStepDeltaStepDetailsToolCallsFileSearchObject
     */
    index: number;
    /**
     * The ID of the tool call object.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsFileSearchObject
     */
    id?: string;
    /**
     * The type of tool call. This is always going to be `file_search` for this type of tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsFileSearchObject
     */
    type: RunStepDeltaStepDetailsToolCallsFileSearchObjectTypeEnum;
    /**
     * For now, this is always going to be an empty object.
     * @type {Object}
     * @memberof RunStepDeltaStepDetailsToolCallsFileSearchObject
     */
    file_search: Object;
}


            export type RunStepDeltaStepDetailsToolCallsFunctionObjectTypeEnum = 'function';
/**
 * 
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsFunctionObject = {
    /**
     * The index of the tool call in the tool calls array.
     * @type {number}
     * @memberof RunStepDeltaStepDetailsToolCallsFunctionObject
     */
    index: number;
    /**
     * The ID of the tool call object.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsFunctionObject
     */
    id?: string;
    /**
     * The type of tool call. This is always going to be `function` for this type of tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsFunctionObject
     */
    type: RunStepDeltaStepDetailsToolCallsFunctionObjectTypeEnum;
    /**
     * 
     * @type {RunStepDeltaStepDetailsToolCallsFunctionObjectFunction}
     * @memberof RunStepDeltaStepDetailsToolCallsFunctionObject
     */
    _function?: RunStepDeltaStepDetailsToolCallsFunctionObjectFunction;
}

/**
 * The definition of the function that was called.
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsFunctionObjectFunction = {
    /**
     * The name of the function.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsFunctionObjectFunction
     */
    name?: string;
    /**
     * The arguments passed to the function.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsFunctionObjectFunction
     */
    _arguments?: string;
    /**
     * The output of the function. This will be `null` if the outputs have not been [submitted](/docs/api-reference/runs/submitToolOutputs) yet.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsFunctionObjectFunction
     */
    output?: string;
}


            export type RunStepDeltaStepDetailsToolCallsObjectTypeEnum = 'tool_calls';
/**
 * Details of the tool call.
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsObject = {
    /**
     * Always `tool_calls`.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsObject
     */
    type: RunStepDeltaStepDetailsToolCallsObjectTypeEnum;
    /**
     * An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`. 
     * @type {Array<RunStepDeltaStepDetailsToolCallsObjectToolCallsInner>}
     * @memberof RunStepDeltaStepDetailsToolCallsObject
     */
    tool_calls?: Array<RunStepDeltaStepDetailsToolCallsObjectToolCallsInner>;
}


            export type RunStepDeltaStepDetailsToolCallsObjectToolCallsInnerTypeEnum = 'code_interpreter' | 'file_search' | 'function';
/**
 * 
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsObjectToolCallsInner = {
    /**
     * The index of the tool call in the tool calls array.
     * @type {number}
     * @memberof RunStepDeltaStepDetailsToolCallsObjectToolCallsInner
     */
    index: number;
    /**
     * The ID of the tool call object.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsObjectToolCallsInner
     */
    id?: string;
    /**
     * The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsObjectToolCallsInner
     */
    type: RunStepDeltaStepDetailsToolCallsObjectToolCallsInnerTypeEnum;
    /**
     * 
     * @type {RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter}
     * @memberof RunStepDeltaStepDetailsToolCallsObjectToolCallsInner
     */
    code_interpreter?: RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter;
    /**
     * For now, this is always going to be an empty object.
     * @type {Object}
     * @memberof RunStepDeltaStepDetailsToolCallsObjectToolCallsInner
     */
    file_search: Object;
    /**
     * 
     * @type {RunStepDeltaStepDetailsToolCallsFunctionObjectFunction}
     * @memberof RunStepDeltaStepDetailsToolCallsObjectToolCallsInner
     */
    _function?: RunStepDeltaStepDetailsToolCallsFunctionObjectFunction;
}


            export type RunStepDetailsMessageCreationObjectTypeEnum = 'message_creation';
/**
 * Details of the message creation by the run step.
 * @export
 */
export type RunStepDetailsMessageCreationObject = {
    /**
     * Always `message_creation`.
     * @type {string}
     * @memberof RunStepDetailsMessageCreationObject
     */
    type: RunStepDetailsMessageCreationObjectTypeEnum;
    /**
     * 
     * @type {RunStepDetailsMessageCreationObjectMessageCreation}
     * @memberof RunStepDetailsMessageCreationObject
     */
    message_creation: RunStepDetailsMessageCreationObjectMessageCreation;
}

/**
 * 
 * @export
 */
export type RunStepDetailsMessageCreationObjectMessageCreation = {
    /**
     * The ID of the message that was created by this run step.
     * @type {string}
     * @memberof RunStepDetailsMessageCreationObjectMessageCreation
     */
    message_id: string;
}


            export type RunStepDetailsToolCallsCodeObjectTypeEnum = 'code_interpreter';
/**
 * Details of the Code Interpreter tool call the run step was involved in.
 * @export
 */
export type RunStepDetailsToolCallsCodeObject = {
    /**
     * The ID of the tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeObject
     */
    id: string;
    /**
     * The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeObject
     */
    type: RunStepDetailsToolCallsCodeObjectTypeEnum;
    /**
     * 
     * @type {RunStepDetailsToolCallsCodeObjectCodeInterpreter}
     * @memberof RunStepDetailsToolCallsCodeObject
     */
    code_interpreter: RunStepDetailsToolCallsCodeObjectCodeInterpreter;
}

/**
 * The Code Interpreter tool call definition.
 * @export
 */
export type RunStepDetailsToolCallsCodeObjectCodeInterpreter = {
    /**
     * The input to the Code Interpreter tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeObjectCodeInterpreter
     */
    input: string;
    /**
     * The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
     * @type {Array<RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>}
     * @memberof RunStepDetailsToolCallsCodeObjectCodeInterpreter
     */
    outputs: Array<RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>;
}


            export type RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerTypeEnum = 'logs' | 'image';
/**
 * 
 * @export
 */
export type RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner = {
    /**
     * Always `logs`.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
     */
    type: RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerTypeEnum;
    /**
     * The text output from the Code Interpreter tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
     */
    logs: string;
    /**
     * 
     * @type {RunStepDetailsToolCallsCodeOutputImageObjectImage}
     * @memberof RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
     */
    image: RunStepDetailsToolCallsCodeOutputImageObjectImage;
}


            export type RunStepDetailsToolCallsCodeOutputImageObjectTypeEnum = 'image';
/**
 * 
 * @export
 */
export type RunStepDetailsToolCallsCodeOutputImageObject = {
    /**
     * Always `image`.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeOutputImageObject
     */
    type: RunStepDetailsToolCallsCodeOutputImageObjectTypeEnum;
    /**
     * 
     * @type {RunStepDetailsToolCallsCodeOutputImageObjectImage}
     * @memberof RunStepDetailsToolCallsCodeOutputImageObject
     */
    image: RunStepDetailsToolCallsCodeOutputImageObjectImage;
}

/**
 * 
 * @export
 */
export type RunStepDetailsToolCallsCodeOutputImageObjectImage = {
    /**
     * The [file](/docs/api-reference/files) ID of the image.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeOutputImageObjectImage
     */
    file_id: string;
}


            export type RunStepDetailsToolCallsCodeOutputLogsObjectTypeEnum = 'logs';
/**
 * Text output from the Code Interpreter tool call as part of a run step.
 * @export
 */
export type RunStepDetailsToolCallsCodeOutputLogsObject = {
    /**
     * Always `logs`.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeOutputLogsObject
     */
    type: RunStepDetailsToolCallsCodeOutputLogsObjectTypeEnum;
    /**
     * The text output from the Code Interpreter tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeOutputLogsObject
     */
    logs: string;
}


            export type RunStepDetailsToolCallsFileSearchObjectTypeEnum = 'file_search';
/**
 * 
 * @export
 */
export type RunStepDetailsToolCallsFileSearchObject = {
    /**
     * The ID of the tool call object.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFileSearchObject
     */
    id: string;
    /**
     * The type of tool call. This is always going to be `file_search` for this type of tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFileSearchObject
     */
    type: RunStepDetailsToolCallsFileSearchObjectTypeEnum;
    /**
     * 
     * @type {RunStepDetailsToolCallsFileSearchObjectFileSearch}
     * @memberof RunStepDetailsToolCallsFileSearchObject
     */
    file_search: RunStepDetailsToolCallsFileSearchObjectFileSearch;
}

/**
 * For now, this is always going to be an empty object.
 * @export
 */
export type RunStepDetailsToolCallsFileSearchObjectFileSearch = {
    /**
     * 
     * @type {RunStepDetailsToolCallsFileSearchRankingOptionsObject}
     * @memberof RunStepDetailsToolCallsFileSearchObjectFileSearch
     */
    ranking_options?: RunStepDetailsToolCallsFileSearchRankingOptionsObject;
    /**
     * The results of the file search.
     * @type {Array<RunStepDetailsToolCallsFileSearchResultObject>}
     * @memberof RunStepDetailsToolCallsFileSearchObjectFileSearch
     */
    results?: Array<RunStepDetailsToolCallsFileSearchResultObject>;
}


            export type RunStepDetailsToolCallsFileSearchRankingOptionsObjectRankerEnum = 'default_2024_08_21';
/**
 * The ranking options for the file search.
 * @export
 */
export type RunStepDetailsToolCallsFileSearchRankingOptionsObject = {
    /**
     * The ranker used for the file search.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFileSearchRankingOptionsObject
     */
    ranker: RunStepDetailsToolCallsFileSearchRankingOptionsObjectRankerEnum;
    /**
     * The score threshold for the file search. All values must be a floating point number between 0 and 1.
     * @type {number}
     * @memberof RunStepDetailsToolCallsFileSearchRankingOptionsObject
     */
    score_threshold: number;
}

/**
 * A result instance of the file search.
 * @export
 */
export type RunStepDetailsToolCallsFileSearchResultObject = {
    /**
     * The ID of the file that result was found in.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFileSearchResultObject
     */
    file_id: string;
    /**
     * The name of the file that result was found in.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFileSearchResultObject
     */
    file_name: string;
    /**
     * The score of the result. All values must be a floating point number between 0 and 1.
     * @type {number}
     * @memberof RunStepDetailsToolCallsFileSearchResultObject
     */
    score: number;
    /**
     * The content of the result that was found. The content is only included if requested via the include query parameter.
     * @type {Array<RunStepDetailsToolCallsFileSearchResultObjectContentInner>}
     * @memberof RunStepDetailsToolCallsFileSearchResultObject
     */
    content?: Array<RunStepDetailsToolCallsFileSearchResultObjectContentInner>;
}


            export type RunStepDetailsToolCallsFileSearchResultObjectContentInnerTypeEnum = 'text';
/**
 * 
 * @export
 */
export type RunStepDetailsToolCallsFileSearchResultObjectContentInner = {
    /**
     * The type of the content.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFileSearchResultObjectContentInner
     */
    type?: RunStepDetailsToolCallsFileSearchResultObjectContentInnerTypeEnum;
    /**
     * The text content of the file.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFileSearchResultObjectContentInner
     */
    text?: string;
}


            export type RunStepDetailsToolCallsFunctionObjectTypeEnum = 'function';
/**
 * 
 * @export
 */
export type RunStepDetailsToolCallsFunctionObject = {
    /**
     * The ID of the tool call object.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFunctionObject
     */
    id: string;
    /**
     * The type of tool call. This is always going to be `function` for this type of tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFunctionObject
     */
    type: RunStepDetailsToolCallsFunctionObjectTypeEnum;
    /**
     * 
     * @type {RunStepDetailsToolCallsFunctionObjectFunction}
     * @memberof RunStepDetailsToolCallsFunctionObject
     */
    _function: RunStepDetailsToolCallsFunctionObjectFunction;
}

/**
 * The definition of the function that was called.
 * @export
 */
export type RunStepDetailsToolCallsFunctionObjectFunction = {
    /**
     * The name of the function.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFunctionObjectFunction
     */
    name: string;
    /**
     * The arguments passed to the function.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFunctionObjectFunction
     */
    _arguments: string;
    /**
     * The output of the function. This will be `null` if the outputs have not been [submitted](/docs/api-reference/runs/submitToolOutputs) yet.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFunctionObjectFunction
     */
    output: string;
}


            export type RunStepDetailsToolCallsObjectTypeEnum = 'tool_calls';
/**
 * Details of the tool call.
 * @export
 */
export type RunStepDetailsToolCallsObject = {
    /**
     * Always `tool_calls`.
     * @type {string}
     * @memberof RunStepDetailsToolCallsObject
     */
    type: RunStepDetailsToolCallsObjectTypeEnum;
    /**
     * An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`. 
     * @type {Array<RunStepDetailsToolCallsObjectToolCallsInner>}
     * @memberof RunStepDetailsToolCallsObject
     */
    tool_calls: Array<RunStepDetailsToolCallsObjectToolCallsInner>;
}


            export type RunStepDetailsToolCallsObjectToolCallsInnerTypeEnum = 'code_interpreter' | 'file_search' | 'function';
/**
 * 
 * @export
 */
export type RunStepDetailsToolCallsObjectToolCallsInner = {
    /**
     * The ID of the tool call object.
     * @type {string}
     * @memberof RunStepDetailsToolCallsObjectToolCallsInner
     */
    id: string;
    /**
     * The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsObjectToolCallsInner
     */
    type: RunStepDetailsToolCallsObjectToolCallsInnerTypeEnum;
    /**
     * 
     * @type {RunStepDetailsToolCallsCodeObjectCodeInterpreter}
     * @memberof RunStepDetailsToolCallsObjectToolCallsInner
     */
    code_interpreter: RunStepDetailsToolCallsCodeObjectCodeInterpreter;
    /**
     * 
     * @type {RunStepDetailsToolCallsFileSearchObjectFileSearch}
     * @memberof RunStepDetailsToolCallsObjectToolCallsInner
     */
    file_search: RunStepDetailsToolCallsFileSearchObjectFileSearch;
    /**
     * 
     * @type {RunStepDetailsToolCallsFunctionObjectFunction}
     * @memberof RunStepDetailsToolCallsObjectToolCallsInner
     */
    _function: RunStepDetailsToolCallsFunctionObjectFunction;
}


            export type RunStepObjectObjectEnum = 'thread.run.step';

            export type RunStepObjectTypeEnum = 'message_creation' | 'tool_calls';

            export type RunStepObjectStatusEnum = 'in_progress' | 'cancelled' | 'failed' | 'completed' | 'expired';
/**
 * Represents a step in execution of a run. 
 * @export
 */
export type RunStepObject = {
    /**
     * The identifier of the run step, which can be referenced in API endpoints.
     * @type {string}
     * @memberof RunStepObject
     */
    id: string;
    /**
     * The object type, which is always `thread.run.step`.
     * @type {string}
     * @memberof RunStepObject
     */
    _object: RunStepObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the run step was created.
     * @type {number}
     * @memberof RunStepObject
     */
    created_at: number;
    /**
     * The ID of the [assistant](/docs/api-reference/assistants) associated with the run step.
     * @type {string}
     * @memberof RunStepObject
     */
    assistant_id: string;
    /**
     * The ID of the [thread](/docs/api-reference/threads) that was run.
     * @type {string}
     * @memberof RunStepObject
     */
    thread_id: string;
    /**
     * The ID of the [run](/docs/api-reference/runs) that this run step is a part of.
     * @type {string}
     * @memberof RunStepObject
     */
    run_id: string;
    /**
     * The type of run step, which can be either `message_creation` or `tool_calls`.
     * @type {string}
     * @memberof RunStepObject
     */
    type: RunStepObjectTypeEnum;
    /**
     * The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
     * @type {string}
     * @memberof RunStepObject
     */
    status: RunStepObjectStatusEnum;
    /**
     * 
     * @type {RunStepObjectStepDetails}
     * @memberof RunStepObject
     */
    step_details: RunStepObjectStepDetails;
    /**
     * 
     * @type {RunStepObjectLastError}
     * @memberof RunStepObject
     */
    last_error: RunStepObjectLastError;
    /**
     * The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
     * @type {number}
     * @memberof RunStepObject
     */
    expired_at: number;
    /**
     * The Unix timestamp (in seconds) for when the run step was cancelled.
     * @type {number}
     * @memberof RunStepObject
     */
    cancelled_at: number;
    /**
     * The Unix timestamp (in seconds) for when the run step failed.
     * @type {number}
     * @memberof RunStepObject
     */
    failed_at: number;
    /**
     * The Unix timestamp (in seconds) for when the run step completed.
     * @type {number}
     * @memberof RunStepObject
     */
    completed_at: number;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof RunStepObject
     */
    metadata: Object;
    /**
     * 
     * @type {RunStepCompletionUsage}
     * @memberof RunStepObject
     */
    usage: RunStepCompletionUsage;
}


            export type RunStepObjectLastErrorCodeEnum = 'server_error' | 'rate_limit_exceeded';
/**
 * The last error associated with this run step. Will be `null` if there are no errors.
 * @export
 */
export type RunStepObjectLastError = {
    /**
     * One of `server_error` or `rate_limit_exceeded`.
     * @type {string}
     * @memberof RunStepObjectLastError
     */
    code: RunStepObjectLastErrorCodeEnum;
    /**
     * A human-readable description of the error.
     * @type {string}
     * @memberof RunStepObjectLastError
     */
    message: string;
}


            export type RunStepObjectStepDetailsTypeEnum = 'message_creation' | 'tool_calls';
/**
 * The details of the run step.
 * @export
 */
export type RunStepObjectStepDetails = {
    /**
     * Always `message_creation`.
     * @type {string}
     * @memberof RunStepObjectStepDetails
     */
    type: RunStepObjectStepDetailsTypeEnum;
    /**
     * 
     * @type {RunStepDetailsMessageCreationObjectMessageCreation}
     * @memberof RunStepObjectStepDetails
     */
    message_creation: RunStepDetailsMessageCreationObjectMessageCreation;
    /**
     * An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`. 
     * @type {Array<RunStepDetailsToolCallsObjectToolCallsInner>}
     * @memberof RunStepObjectStepDetails
     */
    tool_calls: Array<RunStepDetailsToolCallsObjectToolCallsInner>;
}


            export type RunStepStreamEventEventEnum = 'thread.run.step.expired';
/**
 * 
 * @export
 */
export type RunStepStreamEvent = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEvent
     */
    event: RunStepStreamEventEventEnum;
    /**
     * 
     * @type {RunStepObject}
     * @memberof RunStepStreamEvent
     */
    data: RunStepObject;
}


            export type RunStepStreamEventOneOfEventEnum = 'thread.run.step.created';
/**
 * Occurs when a [run step](/docs/api-reference/run-steps/step-object) is created.
 * @export
 */
export type RunStepStreamEventOneOf = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEventOneOf
     */
    event: RunStepStreamEventOneOfEventEnum;
    /**
     * 
     * @type {RunStepObject}
     * @memberof RunStepStreamEventOneOf
     */
    data: RunStepObject;
}


            export type RunStepStreamEventOneOf1EventEnum = 'thread.run.step.in_progress';
/**
 * Occurs when a [run step](/docs/api-reference/run-steps/step-object) moves to an `in_progress` state.
 * @export
 */
export type RunStepStreamEventOneOf1 = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEventOneOf1
     */
    event: RunStepStreamEventOneOf1EventEnum;
    /**
     * 
     * @type {RunStepObject}
     * @memberof RunStepStreamEventOneOf1
     */
    data: RunStepObject;
}


            export type RunStepStreamEventOneOf2EventEnum = 'thread.run.step.delta';
/**
 * Occurs when parts of a [run step](/docs/api-reference/run-steps/step-object) are being streamed.
 * @export
 */
export type RunStepStreamEventOneOf2 = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEventOneOf2
     */
    event: RunStepStreamEventOneOf2EventEnum;
    /**
     * 
     * @type {RunStepDeltaObject}
     * @memberof RunStepStreamEventOneOf2
     */
    data: RunStepDeltaObject;
}


            export type RunStepStreamEventOneOf3EventEnum = 'thread.run.step.completed';
/**
 * Occurs when a [run step](/docs/api-reference/run-steps/step-object) is completed.
 * @export
 */
export type RunStepStreamEventOneOf3 = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEventOneOf3
     */
    event: RunStepStreamEventOneOf3EventEnum;
    /**
     * 
     * @type {RunStepObject}
     * @memberof RunStepStreamEventOneOf3
     */
    data: RunStepObject;
}


            export type RunStepStreamEventOneOf4EventEnum = 'thread.run.step.failed';
/**
 * Occurs when a [run step](/docs/api-reference/run-steps/step-object) fails.
 * @export
 */
export type RunStepStreamEventOneOf4 = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEventOneOf4
     */
    event: RunStepStreamEventOneOf4EventEnum;
    /**
     * 
     * @type {RunStepObject}
     * @memberof RunStepStreamEventOneOf4
     */
    data: RunStepObject;
}


            export type RunStepStreamEventOneOf5EventEnum = 'thread.run.step.cancelled';
/**
 * Occurs when a [run step](/docs/api-reference/run-steps/step-object) is cancelled.
 * @export
 */
export type RunStepStreamEventOneOf5 = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEventOneOf5
     */
    event: RunStepStreamEventOneOf5EventEnum;
    /**
     * 
     * @type {RunStepObject}
     * @memberof RunStepStreamEventOneOf5
     */
    data: RunStepObject;
}


            export type RunStepStreamEventOneOf6EventEnum = 'thread.run.step.expired';
/**
 * Occurs when a [run step](/docs/api-reference/run-steps/step-object) expires.
 * @export
 */
export type RunStepStreamEventOneOf6 = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEventOneOf6
     */
    event: RunStepStreamEventOneOf6EventEnum;
    /**
     * 
     * @type {RunStepObject}
     * @memberof RunStepStreamEventOneOf6
     */
    data: RunStepObject;
}


            export type RunStreamEventEventEnum = 'thread.run.expired';
/**
 * 
 * @export
 */
export type RunStreamEvent = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEvent
     */
    event: RunStreamEventEventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEvent
     */
    data: RunObject;
}


            export type RunStreamEventOneOfEventEnum = 'thread.run.created';
/**
 * Occurs when a new [run](/docs/api-reference/runs/object) is created.
 * @export
 */
export type RunStreamEventOneOf = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf
     */
    event: RunStreamEventOneOfEventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf
     */
    data: RunObject;
}


            export type RunStreamEventOneOf1EventEnum = 'thread.run.queued';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) moves to a `queued` status.
 * @export
 */
export type RunStreamEventOneOf1 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf1
     */
    event: RunStreamEventOneOf1EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf1
     */
    data: RunObject;
}


            export type RunStreamEventOneOf2EventEnum = 'thread.run.in_progress';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) moves to an `in_progress` status.
 * @export
 */
export type RunStreamEventOneOf2 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf2
     */
    event: RunStreamEventOneOf2EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf2
     */
    data: RunObject;
}


            export type RunStreamEventOneOf3EventEnum = 'thread.run.requires_action';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) moves to a `requires_action` status.
 * @export
 */
export type RunStreamEventOneOf3 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf3
     */
    event: RunStreamEventOneOf3EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf3
     */
    data: RunObject;
}


            export type RunStreamEventOneOf4EventEnum = 'thread.run.completed';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) is completed.
 * @export
 */
export type RunStreamEventOneOf4 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf4
     */
    event: RunStreamEventOneOf4EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf4
     */
    data: RunObject;
}


            export type RunStreamEventOneOf5EventEnum = 'thread.run.incomplete';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) ends with status `incomplete`.
 * @export
 */
export type RunStreamEventOneOf5 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf5
     */
    event: RunStreamEventOneOf5EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf5
     */
    data: RunObject;
}


            export type RunStreamEventOneOf6EventEnum = 'thread.run.failed';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) fails.
 * @export
 */
export type RunStreamEventOneOf6 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf6
     */
    event: RunStreamEventOneOf6EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf6
     */
    data: RunObject;
}


            export type RunStreamEventOneOf7EventEnum = 'thread.run.cancelling';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) moves to a `cancelling` status.
 * @export
 */
export type RunStreamEventOneOf7 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf7
     */
    event: RunStreamEventOneOf7EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf7
     */
    data: RunObject;
}


            export type RunStreamEventOneOf8EventEnum = 'thread.run.cancelled';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) is cancelled.
 * @export
 */
export type RunStreamEventOneOf8 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf8
     */
    event: RunStreamEventOneOf8EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf8
     */
    data: RunObject;
}


            export type RunStreamEventOneOf9EventEnum = 'thread.run.expired';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) expires.
 * @export
 */
export type RunStreamEventOneOf9 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf9
     */
    event: RunStreamEventOneOf9EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf9
     */
    data: RunObject;
}


            export type RunToolCallObjectTypeEnum = 'function';
/**
 * Tool call objects
 * @export
 */
export type RunToolCallObject = {
    /**
     * The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](/docs/api-reference/runs/submitToolOutputs) endpoint.
     * @type {string}
     * @memberof RunToolCallObject
     */
    id: string;
    /**
     * The type of tool call the output is required for. For now, this is always `function`.
     * @type {string}
     * @memberof RunToolCallObject
     */
    type: RunToolCallObjectTypeEnum;
    /**
     * 
     * @type {RunToolCallObjectFunction}
     * @memberof RunToolCallObject
     */
    _function: RunToolCallObjectFunction;
}

/**
 * The function definition.
 * @export
 */
export type RunToolCallObjectFunction = {
    /**
     * The name of the function.
     * @type {string}
     * @memberof RunToolCallObjectFunction
     */
    name: string;
    /**
     * The arguments that the model expects you to pass to the function.
     * @type {string}
     * @memberof RunToolCallObjectFunction
     */
    _arguments: string;
}


            export type StaticChunkingStrategyTypeEnum = 'static';
/**
 * 
 * @export
 */
export type StaticChunkingStrategy = {
    /**
     * Always `static`.
     * @type {string}
     * @memberof StaticChunkingStrategy
     */
    type: StaticChunkingStrategyTypeEnum;
    /**
     * 
     * @type {StaticChunkingStrategyStatic}
     * @memberof StaticChunkingStrategy
     */
    _static: StaticChunkingStrategyStatic;
}


            export type StaticChunkingStrategyRequestParamTypeEnum = 'static';
/**
 * 
 * @export
 */
export type StaticChunkingStrategyRequestParam = {
    /**
     * Always `static`.
     * @type {string}
     * @memberof StaticChunkingStrategyRequestParam
     */
    type: StaticChunkingStrategyRequestParamTypeEnum;
    /**
     * 
     * @type {StaticChunkingStrategy}
     * @memberof StaticChunkingStrategyRequestParam
     */
    _static: StaticChunkingStrategy;
}


            export type StaticChunkingStrategyResponseParamTypeEnum = 'static';
/**
 * 
 * @export
 */
export type StaticChunkingStrategyResponseParam = {
    /**
     * Always `static`.
     * @type {string}
     * @memberof StaticChunkingStrategyResponseParam
     */
    type: StaticChunkingStrategyResponseParamTypeEnum;
    /**
     * 
     * @type {StaticChunkingStrategy}
     * @memberof StaticChunkingStrategyResponseParam
     */
    _static: StaticChunkingStrategy;
}

/**
 * 
 * @export
 */
export type StaticChunkingStrategyStatic = {
    /**
     * The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`.
     * @type {number}
     * @memberof StaticChunkingStrategyStatic
     */
    max_chunk_size_tokens: number;
    /**
     * The number of tokens that overlap between chunks. The default value is `400`.  Note that the overlap must not exceed half of `max_chunk_size_tokens`. 
     * @type {number}
     * @memberof StaticChunkingStrategyStatic
     */
    chunk_overlap_tokens: number;
}

/**
 * 
 * @export
 */
export type SubmitToolOutputsRunRequest = {
    /**
     * A list of tools for which the outputs are being submitted.
     * @type {Array<SubmitToolOutputsRunRequestToolOutputsInner>}
     * @memberof SubmitToolOutputsRunRequest
     */
    tool_outputs: Array<SubmitToolOutputsRunRequestToolOutputsInner>;
    /**
     * If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message. 
     * @type {boolean}
     * @memberof SubmitToolOutputsRunRequest
     */
    stream?: boolean;
}

/**
 * 
 * @export
 */
export type SubmitToolOutputsRunRequestToolOutputsInner = {
    /**
     * The ID of the tool call in the `required_action` object within the run object the output is being submitted for.
     * @type {string}
     * @memberof SubmitToolOutputsRunRequestToolOutputsInner
     */
    tool_call_id?: string;
    /**
     * The output of the tool call to be submitted to continue the run.
     * @type {string}
     * @memberof SubmitToolOutputsRunRequestToolOutputsInner
     */
    output?: string;
}


            export type ThreadObjectObjectEnum = 'thread';
/**
 * Represents a thread that contains [messages](/docs/api-reference/messages).
 * @export
 */
export type ThreadObject = {
    /**
     * The identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof ThreadObject
     */
    id: string;
    /**
     * The object type, which is always `thread`.
     * @type {string}
     * @memberof ThreadObject
     */
    _object: ThreadObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the thread was created.
     * @type {number}
     * @memberof ThreadObject
     */
    created_at: number;
    /**
     * 
     * @type {ModifyThreadRequestToolResources}
     * @memberof ThreadObject
     */
    tool_resources: ModifyThreadRequestToolResources;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof ThreadObject
     */
    metadata: Object;
}


            export type ThreadStreamEventEventEnum = 'thread.created';
/**
 * Occurs when a new [thread](/docs/api-reference/threads/object) is created.
 * @export
 */
export type ThreadStreamEvent = {
    /**
     * Whether to enable input audio transcription.
     * @type {boolean}
     * @memberof ThreadStreamEvent
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ThreadStreamEvent
     */
    event: ThreadStreamEventEventEnum;
    /**
     * 
     * @type {ThreadObject}
     * @memberof ThreadStreamEvent
     */
    data: ThreadObject;
}

/**
 * 
 * @export
 */
export type TranscriptionSegment = {
    /**
     * Unique identifier of the segment.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    id: number;
    /**
     * Seek offset of the segment.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    seek: number;
    /**
     * Start time of the segment in seconds.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    start: number;
    /**
     * End time of the segment in seconds.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    end: number;
    /**
     * Text content of the segment.
     * @type {string}
     * @memberof TranscriptionSegment
     */
    text: string;
    /**
     * Array of token IDs for the text content.
     * @type {Array<number>}
     * @memberof TranscriptionSegment
     */
    tokens: Array<number>;
    /**
     * Temperature parameter used for generating the segment.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    temperature: number;
    /**
     * Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    avg_logprob: number;
    /**
     * Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    compression_ratio: number;
    /**
     * Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    no_speech_prob: number;
}

/**
 * 
 * @export
 */
export type TranscriptionWord = {
    /**
     * The text content of the word.
     * @type {string}
     * @memberof TranscriptionWord
     */
    word: string;
    /**
     * Start time of the word in seconds.
     * @type {number}
     * @memberof TranscriptionWord
     */
    start: number;
    /**
     * End time of the word in seconds.
     * @type {number}
     * @memberof TranscriptionWord
     */
    end: number;
}


            export type TruncationObjectTypeEnum = 'auto' | 'last_messages';
/**
 * Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
 * @export
 */
export type TruncationObject = {
    /**
     * The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`.
     * @type {string}
     * @memberof TruncationObject
     */
    type: TruncationObjectTypeEnum;
    /**
     * The number of most recent messages from the thread when constructing the context for the run.
     * @type {number}
     * @memberof TruncationObject
     */
    last_messages?: number;
}

/**
 * 
 * @export
 */
export type UpdateVectorStoreRequest = {
    /**
     * The name of the vector store.
     * @type {string}
     * @memberof UpdateVectorStoreRequest
     */
    name?: string;
    /**
     * 
     * @type {VectorStoreExpirationAfter}
     * @memberof UpdateVectorStoreRequest
     */
    expires_after?: VectorStoreExpirationAfter;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof UpdateVectorStoreRequest
     */
    metadata?: Object;
}


            export type UploadStatusEnum = 'pending' | 'completed' | 'cancelled' | 'expired';

            export type UploadObjectEnum = 'upload';
/**
 * The Upload object can accept byte chunks in the form of Parts. 
 * @export
 */
export type Upload = {
    /**
     * The Upload unique identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof Upload
     */
    id: string;
    /**
     * The Unix timestamp (in seconds) for when the Upload was created.
     * @type {number}
     * @memberof Upload
     */
    created_at: number;
    /**
     * The name of the file to be uploaded.
     * @type {string}
     * @memberof Upload
     */
    filename: string;
    /**
     * The intended number of bytes to be uploaded.
     * @type {number}
     * @memberof Upload
     */
    bytes: number;
    /**
     * The intended purpose of the file. [Please refer here](/docs/api-reference/files/object#files/object-purpose) for acceptable values.
     * @type {string}
     * @memberof Upload
     */
    purpose: string;
    /**
     * The status of the Upload.
     * @type {string}
     * @memberof Upload
     */
    status: UploadStatusEnum;
    /**
     * The Unix timestamp (in seconds) for when the Upload was created.
     * @type {number}
     * @memberof Upload
     */
    expires_at: number;
    /**
     * The object type, which is always \"upload\".
     * @type {string}
     * @memberof Upload
     */
    _object?: UploadObjectEnum;
    /**
     * 
     * @type {OpenAIFile}
     * @memberof Upload
     */
    file?: OpenAIFile;
}


            export type UploadPartObjectEnum = 'upload.part';
/**
 * The upload Part represents a chunk of bytes we can add to an Upload object. 
 * @export
 */
export type UploadPart = {
    /**
     * The upload Part unique identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof UploadPart
     */
    id: string;
    /**
     * The Unix timestamp (in seconds) for when the Part was created.
     * @type {number}
     * @memberof UploadPart
     */
    created_at: number;
    /**
     * The ID of the Upload object that this Part was added to.
     * @type {string}
     * @memberof UploadPart
     */
    upload_id: string;
    /**
     * The object type, which is always `upload.part`.
     * @type {string}
     * @memberof UploadPart
     */
    _object: UploadPartObjectEnum;
}


            export type UsageAudioSpeechesResultObjectEnum = 'organization.usage.audio_speeches.result';
/**
 * The aggregated audio speeches usage details of the specific time bucket.
 * @export
 */
export type UsageAudioSpeechesResult = {
    /**
     * 
     * @type {string}
     * @memberof UsageAudioSpeechesResult
     */
    _object: UsageAudioSpeechesResultObjectEnum;
    /**
     * The number of characters processed.
     * @type {number}
     * @memberof UsageAudioSpeechesResult
     */
    characters: number;
    /**
     * The count of requests made to the model.
     * @type {number}
     * @memberof UsageAudioSpeechesResult
     */
    num_model_requests: number;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     * @type {string}
     * @memberof UsageAudioSpeechesResult
     */
    project_id?: string;
    /**
     * When `group_by=user_id`, this field provides the user ID of the grouped usage result.
     * @type {string}
     * @memberof UsageAudioSpeechesResult
     */
    user_id?: string;
    /**
     * When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
     * @type {string}
     * @memberof UsageAudioSpeechesResult
     */
    api_key_id?: string;
    /**
     * When `group_by=model`, this field provides the model name of the grouped usage result.
     * @type {string}
     * @memberof UsageAudioSpeechesResult
     */
    model?: string;
}


            export type UsageAudioTranscriptionsResultObjectEnum = 'organization.usage.audio_transcriptions.result';
/**
 * The aggregated audio transcriptions usage details of the specific time bucket.
 * @export
 */
export type UsageAudioTranscriptionsResult = {
    /**
     * 
     * @type {string}
     * @memberof UsageAudioTranscriptionsResult
     */
    _object: UsageAudioTranscriptionsResultObjectEnum;
    /**
     * The number of seconds processed.
     * @type {number}
     * @memberof UsageAudioTranscriptionsResult
     */
    seconds: number;
    /**
     * The count of requests made to the model.
     * @type {number}
     * @memberof UsageAudioTranscriptionsResult
     */
    num_model_requests: number;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     * @type {string}
     * @memberof UsageAudioTranscriptionsResult
     */
    project_id?: string;
    /**
     * When `group_by=user_id`, this field provides the user ID of the grouped usage result.
     * @type {string}
     * @memberof UsageAudioTranscriptionsResult
     */
    user_id?: string;
    /**
     * When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
     * @type {string}
     * @memberof UsageAudioTranscriptionsResult
     */
    api_key_id?: string;
    /**
     * When `group_by=model`, this field provides the model name of the grouped usage result.
     * @type {string}
     * @memberof UsageAudioTranscriptionsResult
     */
    model?: string;
}


            export type UsageCodeInterpreterSessionsResultObjectEnum = 'organization.usage.code_interpreter_sessions.result';
/**
 * The aggregated code interpreter sessions usage details of the specific time bucket.
 * @export
 */
export type UsageCodeInterpreterSessionsResult = {
    /**
     * 
     * @type {string}
     * @memberof UsageCodeInterpreterSessionsResult
     */
    _object: UsageCodeInterpreterSessionsResultObjectEnum;
    /**
     * The number of code interpreter sessions.
     * @type {number}
     * @memberof UsageCodeInterpreterSessionsResult
     */
    sessions: number;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     * @type {string}
     * @memberof UsageCodeInterpreterSessionsResult
     */
    project_id?: string;
}


            export type UsageCompletionsResultObjectEnum = 'organization.usage.completions.result';
/**
 * The aggregated completions usage details of the specific time bucket.
 * @export
 */
export type UsageCompletionsResult = {
    /**
     * 
     * @type {string}
     * @memberof UsageCompletionsResult
     */
    _object: UsageCompletionsResultObjectEnum;
    /**
     * The aggregated number of text input tokens used, including cached tokens. For customers subscribe to scale tier, this includes scale tier tokens.
     * @type {number}
     * @memberof UsageCompletionsResult
     */
    input_tokens: number;
    /**
     * The aggregated number of text input tokens that has been cached from previous requests. For customers subscribe to scale tier, this includes scale tier tokens.
     * @type {number}
     * @memberof UsageCompletionsResult
     */
    input_cached_tokens?: number;
    /**
     * The aggregated number of text output tokens used. For customers subscribe to scale tier, this includes scale tier tokens.
     * @type {number}
     * @memberof UsageCompletionsResult
     */
    output_tokens: number;
    /**
     * The aggregated number of audio input tokens used, including cached tokens.
     * @type {number}
     * @memberof UsageCompletionsResult
     */
    input_audio_tokens?: number;
    /**
     * The aggregated number of audio output tokens used.
     * @type {number}
     * @memberof UsageCompletionsResult
     */
    output_audio_tokens?: number;
    /**
     * The count of requests made to the model.
     * @type {number}
     * @memberof UsageCompletionsResult
     */
    num_model_requests: number;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     * @type {string}
     * @memberof UsageCompletionsResult
     */
    project_id?: string;
    /**
     * When `group_by=user_id`, this field provides the user ID of the grouped usage result.
     * @type {string}
     * @memberof UsageCompletionsResult
     */
    user_id?: string;
    /**
     * When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
     * @type {string}
     * @memberof UsageCompletionsResult
     */
    api_key_id?: string;
    /**
     * When `group_by=model`, this field provides the model name of the grouped usage result.
     * @type {string}
     * @memberof UsageCompletionsResult
     */
    model?: string;
    /**
     * When `group_by=batch`, this field tells whether the grouped usage result is batch or not.
     * @type {boolean}
     * @memberof UsageCompletionsResult
     */
    batch?: boolean;
}


            export type UsageEmbeddingsResultObjectEnum = 'organization.usage.embeddings.result';
/**
 * The aggregated embeddings usage details of the specific time bucket.
 * @export
 */
export type UsageEmbeddingsResult = {
    /**
     * 
     * @type {string}
     * @memberof UsageEmbeddingsResult
     */
    _object: UsageEmbeddingsResultObjectEnum;
    /**
     * The aggregated number of input tokens used.
     * @type {number}
     * @memberof UsageEmbeddingsResult
     */
    input_tokens: number;
    /**
     * The count of requests made to the model.
     * @type {number}
     * @memberof UsageEmbeddingsResult
     */
    num_model_requests: number;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     * @type {string}
     * @memberof UsageEmbeddingsResult
     */
    project_id?: string;
    /**
     * When `group_by=user_id`, this field provides the user ID of the grouped usage result.
     * @type {string}
     * @memberof UsageEmbeddingsResult
     */
    user_id?: string;
    /**
     * When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
     * @type {string}
     * @memberof UsageEmbeddingsResult
     */
    api_key_id?: string;
    /**
     * When `group_by=model`, this field provides the model name of the grouped usage result.
     * @type {string}
     * @memberof UsageEmbeddingsResult
     */
    model?: string;
}


            export type UsageImagesResultObjectEnum = 'organization.usage.images.result';
/**
 * The aggregated images usage details of the specific time bucket.
 * @export
 */
export type UsageImagesResult = {
    /**
     * 
     * @type {string}
     * @memberof UsageImagesResult
     */
    _object: UsageImagesResultObjectEnum;
    /**
     * The number of images processed.
     * @type {number}
     * @memberof UsageImagesResult
     */
    images: number;
    /**
     * The count of requests made to the model.
     * @type {number}
     * @memberof UsageImagesResult
     */
    num_model_requests: number;
    /**
     * When `group_by=source`, this field provides the source of the grouped usage result, possible values are `image.generation`, `image.edit`, `image.variation`.
     * @type {string}
     * @memberof UsageImagesResult
     */
    source?: string;
    /**
     * When `group_by=size`, this field provides the image size of the grouped usage result.
     * @type {string}
     * @memberof UsageImagesResult
     */
    size?: string;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     * @type {string}
     * @memberof UsageImagesResult
     */
    project_id?: string;
    /**
     * When `group_by=user_id`, this field provides the user ID of the grouped usage result.
     * @type {string}
     * @memberof UsageImagesResult
     */
    user_id?: string;
    /**
     * When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
     * @type {string}
     * @memberof UsageImagesResult
     */
    api_key_id?: string;
    /**
     * When `group_by=model`, this field provides the model name of the grouped usage result.
     * @type {string}
     * @memberof UsageImagesResult
     */
    model?: string;
}


            export type UsageModerationsResultObjectEnum = 'organization.usage.moderations.result';
/**
 * The aggregated moderations usage details of the specific time bucket.
 * @export
 */
export type UsageModerationsResult = {
    /**
     * 
     * @type {string}
     * @memberof UsageModerationsResult
     */
    _object: UsageModerationsResultObjectEnum;
    /**
     * The aggregated number of input tokens used.
     * @type {number}
     * @memberof UsageModerationsResult
     */
    input_tokens: number;
    /**
     * The count of requests made to the model.
     * @type {number}
     * @memberof UsageModerationsResult
     */
    num_model_requests: number;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     * @type {string}
     * @memberof UsageModerationsResult
     */
    project_id?: string;
    /**
     * When `group_by=user_id`, this field provides the user ID of the grouped usage result.
     * @type {string}
     * @memberof UsageModerationsResult
     */
    user_id?: string;
    /**
     * When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
     * @type {string}
     * @memberof UsageModerationsResult
     */
    api_key_id?: string;
    /**
     * When `group_by=model`, this field provides the model name of the grouped usage result.
     * @type {string}
     * @memberof UsageModerationsResult
     */
    model?: string;
}


            export type UsageResponseObjectEnum = 'page';
/**
 * 
 * @export
 */
export type UsageResponse = {
    /**
     * 
     * @type {string}
     * @memberof UsageResponse
     */
    _object: UsageResponseObjectEnum;
    /**
     * 
     * @type {Array<UsageTimeBucket>}
     * @memberof UsageResponse
     */
    data: Array<UsageTimeBucket>;
    /**
     * 
     * @type {boolean}
     * @memberof UsageResponse
     */
    has_more: boolean;
    /**
     * 
     * @type {string}
     * @memberof UsageResponse
     */
    next_page: string;
}


            export type UsageTimeBucketObjectEnum = 'bucket';
/**
 * 
 * @export
 */
export type UsageTimeBucket = {
    /**
     * 
     * @type {string}
     * @memberof UsageTimeBucket
     */
    _object: UsageTimeBucketObjectEnum;
    /**
     * 
     * @type {number}
     * @memberof UsageTimeBucket
     */
    start_time: number;
    /**
     * 
     * @type {number}
     * @memberof UsageTimeBucket
     */
    end_time: number;
    /**
     * 
     * @type {Array<UsageTimeBucketResultInner>}
     * @memberof UsageTimeBucket
     */
    result: Array<UsageTimeBucketResultInner>;
}


            export type UsageTimeBucketResultInnerObjectEnum = 'organization.costs.result';
/**
 * 
 * @export
 */
export type UsageTimeBucketResultInner = {
    /**
     * 
     * @type {string}
     * @memberof UsageTimeBucketResultInner
     */
    _object: UsageTimeBucketResultInnerObjectEnum;
    /**
     * The aggregated number of input tokens used.
     * @type {number}
     * @memberof UsageTimeBucketResultInner
     */
    input_tokens: number;
    /**
     * The aggregated number of text input tokens that has been cached from previous requests. For customers subscribe to scale tier, this includes scale tier tokens.
     * @type {number}
     * @memberof UsageTimeBucketResultInner
     */
    input_cached_tokens?: number;
    /**
     * The aggregated number of text output tokens used. For customers subscribe to scale tier, this includes scale tier tokens.
     * @type {number}
     * @memberof UsageTimeBucketResultInner
     */
    output_tokens: number;
    /**
     * The aggregated number of audio input tokens used, including cached tokens.
     * @type {number}
     * @memberof UsageTimeBucketResultInner
     */
    input_audio_tokens?: number;
    /**
     * The aggregated number of audio output tokens used.
     * @type {number}
     * @memberof UsageTimeBucketResultInner
     */
    output_audio_tokens?: number;
    /**
     * The count of requests made to the model.
     * @type {number}
     * @memberof UsageTimeBucketResultInner
     */
    num_model_requests: number;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped costs result.
     * @type {string}
     * @memberof UsageTimeBucketResultInner
     */
    project_id?: string;
    /**
     * When `group_by=user_id`, this field provides the user ID of the grouped usage result.
     * @type {string}
     * @memberof UsageTimeBucketResultInner
     */
    user_id?: string;
    /**
     * When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
     * @type {string}
     * @memberof UsageTimeBucketResultInner
     */
    api_key_id?: string;
    /**
     * When `group_by=model`, this field provides the model name of the grouped usage result.
     * @type {string}
     * @memberof UsageTimeBucketResultInner
     */
    model?: string;
    /**
     * When `group_by=batch`, this field tells whether the grouped usage result is batch or not.
     * @type {boolean}
     * @memberof UsageTimeBucketResultInner
     */
    batch?: boolean;
    /**
     * The number of images processed.
     * @type {number}
     * @memberof UsageTimeBucketResultInner
     */
    images: number;
    /**
     * When `group_by=source`, this field provides the source of the grouped usage result, possible values are `image.generation`, `image.edit`, `image.variation`.
     * @type {string}
     * @memberof UsageTimeBucketResultInner
     */
    source?: string;
    /**
     * When `group_by=size`, this field provides the image size of the grouped usage result.
     * @type {string}
     * @memberof UsageTimeBucketResultInner
     */
    size?: string;
    /**
     * The number of characters processed.
     * @type {number}
     * @memberof UsageTimeBucketResultInner
     */
    characters: number;
    /**
     * The number of seconds processed.
     * @type {number}
     * @memberof UsageTimeBucketResultInner
     */
    seconds: number;
    /**
     * The vector stores usage in bytes.
     * @type {number}
     * @memberof UsageTimeBucketResultInner
     */
    usage_bytes: number;
    /**
     * The number of code interpreter sessions.
     * @type {number}
     * @memberof UsageTimeBucketResultInner
     */
    sessions: number;
    /**
     * 
     * @type {CostsResultAmount}
     * @memberof UsageTimeBucketResultInner
     */
    amount?: CostsResultAmount;
    /**
     * When `group_by=line_item`, this field provides the line item of the grouped costs result.
     * @type {string}
     * @memberof UsageTimeBucketResultInner
     */
    line_item?: string;
}


            export type UsageVectorStoresResultObjectEnum = 'organization.usage.vector_stores.result';
/**
 * The aggregated vector stores usage details of the specific time bucket.
 * @export
 */
export type UsageVectorStoresResult = {
    /**
     * 
     * @type {string}
     * @memberof UsageVectorStoresResult
     */
    _object: UsageVectorStoresResultObjectEnum;
    /**
     * The vector stores usage in bytes.
     * @type {number}
     * @memberof UsageVectorStoresResult
     */
    usage_bytes: number;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     * @type {string}
     * @memberof UsageVectorStoresResult
     */
    project_id?: string;
}


            export type UserObjectEnum = 'organization.user';

            export type UserRoleEnum = 'owner' | 'reader';
/**
 * Represents an individual `user` within an organization.
 * @export
 */
export type User = {
    /**
     * The object type, which is always `organization.user`
     * @type {string}
     * @memberof User
     */
    _object: UserObjectEnum;
    /**
     * The identifier, which can be referenced in API endpoints
     * @type {string}
     * @memberof User
     */
    id: string;
    /**
     * The name of the user
     * @type {string}
     * @memberof User
     */
    name: string;
    /**
     * The email address of the user
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * `owner` or `reader`
     * @type {string}
     * @memberof User
     */
    role: UserRoleEnum;
    /**
     * The Unix timestamp (in seconds) of when the user was added.
     * @type {number}
     * @memberof User
     */
    added_at: number;
}


            export type UserDeleteResponseObjectEnum = 'organization.user.deleted';
/**
 * 
 * @export
 */
export type UserDeleteResponse = {
    /**
     * 
     * @type {string}
     * @memberof UserDeleteResponse
     */
    _object: UserDeleteResponseObjectEnum;
    /**
     * 
     * @type {string}
     * @memberof UserDeleteResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserDeleteResponse
     */
    deleted: boolean;
}


            export type UserListResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type UserListResponse = {
    /**
     * 
     * @type {string}
     * @memberof UserListResponse
     */
    _object: UserListResponseObjectEnum;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserListResponse
     */
    data: Array<User>;
    /**
     * 
     * @type {string}
     * @memberof UserListResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof UserListResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserListResponse
     */
    has_more: boolean;
}


            export type UserRoleUpdateRequestRoleEnum = 'owner' | 'reader';
/**
 * 
 * @export
 */
export type UserRoleUpdateRequest = {
    /**
     * `owner` or `reader`
     * @type {string}
     * @memberof UserRoleUpdateRequest
     */
    role: UserRoleUpdateRequestRoleEnum;
}


            export type VectorStoreExpirationAfterAnchorEnum = 'last_active_at';
/**
 * The expiration policy for a vector store.
 * @export
 */
export type VectorStoreExpirationAfter = {
    /**
     * Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.
     * @type {string}
     * @memberof VectorStoreExpirationAfter
     */
    anchor: VectorStoreExpirationAfterAnchorEnum;
    /**
     * The number of days after the anchor time that the vector store will expire.
     * @type {number}
     * @memberof VectorStoreExpirationAfter
     */
    days: number;
}


            export type VectorStoreFileBatchObjectObjectEnum = 'vector_store.files_batch';

            export type VectorStoreFileBatchObjectStatusEnum = 'in_progress' | 'completed' | 'cancelled' | 'failed';
/**
 * A batch of files attached to a vector store.
 * @export
 */
export type VectorStoreFileBatchObject = {
    /**
     * The identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof VectorStoreFileBatchObject
     */
    id: string;
    /**
     * The object type, which is always `vector_store.file_batch`.
     * @type {string}
     * @memberof VectorStoreFileBatchObject
     */
    _object: VectorStoreFileBatchObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the vector store files batch was created.
     * @type {number}
     * @memberof VectorStoreFileBatchObject
     */
    created_at: number;
    /**
     * The ID of the [vector store](/docs/api-reference/vector-stores/object) that the [File](/docs/api-reference/files) is attached to.
     * @type {string}
     * @memberof VectorStoreFileBatchObject
     */
    vector_store_id: string;
    /**
     * The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`.
     * @type {string}
     * @memberof VectorStoreFileBatchObject
     */
    status: VectorStoreFileBatchObjectStatusEnum;
    /**
     * 
     * @type {VectorStoreFileBatchObjectFileCounts}
     * @memberof VectorStoreFileBatchObject
     */
    file_counts: VectorStoreFileBatchObjectFileCounts;
}

/**
 * 
 * @export
 */
export type VectorStoreFileBatchObjectFileCounts = {
    /**
     * The number of files that are currently being processed.
     * @type {number}
     * @memberof VectorStoreFileBatchObjectFileCounts
     */
    in_progress: number;
    /**
     * The number of files that have been processed.
     * @type {number}
     * @memberof VectorStoreFileBatchObjectFileCounts
     */
    completed: number;
    /**
     * The number of files that have failed to process.
     * @type {number}
     * @memberof VectorStoreFileBatchObjectFileCounts
     */
    failed: number;
    /**
     * The number of files that where cancelled.
     * @type {number}
     * @memberof VectorStoreFileBatchObjectFileCounts
     */
    cancelled: number;
    /**
     * The total number of files.
     * @type {number}
     * @memberof VectorStoreFileBatchObjectFileCounts
     */
    total: number;
}


            export type VectorStoreFileObjectObjectEnum = 'vector_store.file';

            export type VectorStoreFileObjectStatusEnum = 'in_progress' | 'completed' | 'cancelled' | 'failed';
/**
 * A list of files attached to a vector store.
 * @export
 */
export type VectorStoreFileObject = {
    /**
     * The identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof VectorStoreFileObject
     */
    id: string;
    /**
     * The object type, which is always `vector_store.file`.
     * @type {string}
     * @memberof VectorStoreFileObject
     */
    _object: VectorStoreFileObjectObjectEnum;
    /**
     * The total vector store usage in bytes. Note that this may be different from the original file size.
     * @type {number}
     * @memberof VectorStoreFileObject
     */
    usage_bytes: number;
    /**
     * The Unix timestamp (in seconds) for when the vector store file was created.
     * @type {number}
     * @memberof VectorStoreFileObject
     */
    created_at: number;
    /**
     * The ID of the [vector store](/docs/api-reference/vector-stores/object) that the [File](/docs/api-reference/files) is attached to.
     * @type {string}
     * @memberof VectorStoreFileObject
     */
    vector_store_id: string;
    /**
     * The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.
     * @type {string}
     * @memberof VectorStoreFileObject
     */
    status: VectorStoreFileObjectStatusEnum;
    /**
     * 
     * @type {VectorStoreFileObjectLastError}
     * @memberof VectorStoreFileObject
     */
    last_error: VectorStoreFileObjectLastError;
    /**
     * 
     * @type {VectorStoreFileObjectChunkingStrategy}
     * @memberof VectorStoreFileObject
     */
    chunking_strategy?: VectorStoreFileObjectChunkingStrategy;
}


            export type VectorStoreFileObjectChunkingStrategyTypeEnum = 'static' | 'other';
/**
 * The strategy used to chunk the file.
 * @export
 */
export type VectorStoreFileObjectChunkingStrategy = {
    /**
     * Always `static`.
     * @type {string}
     * @memberof VectorStoreFileObjectChunkingStrategy
     */
    type: VectorStoreFileObjectChunkingStrategyTypeEnum;
    /**
     * 
     * @type {StaticChunkingStrategy}
     * @memberof VectorStoreFileObjectChunkingStrategy
     */
    _static: StaticChunkingStrategy;
}


            export type VectorStoreFileObjectLastErrorCodeEnum = 'server_error' | 'unsupported_file' | 'invalid_file';
/**
 * The last error associated with this vector store file. Will be `null` if there are no errors.
 * @export
 */
export type VectorStoreFileObjectLastError = {
    /**
     * One of `server_error` or `rate_limit_exceeded`.
     * @type {string}
     * @memberof VectorStoreFileObjectLastError
     */
    code: VectorStoreFileObjectLastErrorCodeEnum;
    /**
     * A human-readable description of the error.
     * @type {string}
     * @memberof VectorStoreFileObjectLastError
     */
    message: string;
}


            export type VectorStoreObjectObjectEnum = 'vector_store';

            export type VectorStoreObjectStatusEnum = 'expired' | 'in_progress' | 'completed';
/**
 * A vector store is a collection of processed files can be used by the `file_search` tool.
 * @export
 */
export type VectorStoreObject = {
    /**
     * The identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof VectorStoreObject
     */
    id: string;
    /**
     * The object type, which is always `vector_store`.
     * @type {string}
     * @memberof VectorStoreObject
     */
    _object: VectorStoreObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the vector store was created.
     * @type {number}
     * @memberof VectorStoreObject
     */
    created_at: number;
    /**
     * The name of the vector store.
     * @type {string}
     * @memberof VectorStoreObject
     */
    name: string;
    /**
     * The total number of bytes used by the files in the vector store.
     * @type {number}
     * @memberof VectorStoreObject
     */
    usage_bytes: number;
    /**
     * 
     * @type {VectorStoreObjectFileCounts}
     * @memberof VectorStoreObject
     */
    file_counts: VectorStoreObjectFileCounts;
    /**
     * The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use.
     * @type {string}
     * @memberof VectorStoreObject
     */
    status: VectorStoreObjectStatusEnum;
    /**
     * 
     * @type {VectorStoreExpirationAfter}
     * @memberof VectorStoreObject
     */
    expires_after?: VectorStoreExpirationAfter;
    /**
     * The Unix timestamp (in seconds) for when the vector store will expire.
     * @type {number}
     * @memberof VectorStoreObject
     */
    expires_at?: number;
    /**
     * The Unix timestamp (in seconds) for when the vector store was last active.
     * @type {number}
     * @memberof VectorStoreObject
     */
    last_active_at: number;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     * @type {Object}
     * @memberof VectorStoreObject
     */
    metadata: Object;
}

/**
 * 
 * @export
 */
export type VectorStoreObjectFileCounts = {
    /**
     * The number of files that are currently being processed.
     * @type {number}
     * @memberof VectorStoreObjectFileCounts
     */
    in_progress: number;
    /**
     * The number of files that have been successfully processed.
     * @type {number}
     * @memberof VectorStoreObjectFileCounts
     */
    completed: number;
    /**
     * The number of files that have failed to process.
     * @type {number}
     * @memberof VectorStoreObjectFileCounts
     */
    failed: number;
    /**
     * The number of files that were cancelled.
     * @type {number}
     * @memberof VectorStoreObjectFileCounts
     */
    cancelled: number;
    /**
     * The total number of files.
     * @type {number}
     * @memberof VectorStoreObjectFileCounts
     */
    total: number;
}



/**
 * AssistantsApi - fetch parameter creator
 * @export
 */
export const AssistantsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels a run that is `in_progress`.
         * @throws {RequiredError}
         */
        cancelRun(threadId: string, runId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling cancelRun.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling cancelRun.');
            }
            const localVarPath = `/threads/{thread_id}/runs/{run_id}/cancel`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an assistant with a model and instructions.
         * @throws {RequiredError}
         */
        createAssistant(createAssistantRequest: CreateAssistantRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createAssistantRequest' is not null or undefined
            if (createAssistantRequest === null || createAssistantRequest === undefined) {
                throw new RequiredError('createAssistantRequest','Required parameter createAssistantRequest was null or undefined when calling createAssistant.');
            }
            const localVarPath = `/assistants`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createAssistantRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createAssistantRequest != null ? createAssistantRequest : {}) : (((createAssistantRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a message.
         * @throws {RequiredError}
         */
        createMessage(threadId: string, createMessageRequest: CreateMessageRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling createMessage.');
            }
            // verify required parameter 'createMessageRequest' is not null or undefined
            if (createMessageRequest === null || createMessageRequest === undefined) {
                throw new RequiredError('createMessageRequest','Required parameter createMessageRequest was null or undefined when calling createMessage.');
            }
            const localVarPath = `/threads/{thread_id}/messages`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createMessageRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createMessageRequest != null ? createMessageRequest : {}) : (((createMessageRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a run.
         * @throws {RequiredError}
         */
        createRun(threadId: string, createRunRequest: CreateRunRequest, include?: Array<'step_details.tool_calls[*].file_search.results[*].content'>, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling createRun.');
            }
            // verify required parameter 'createRunRequest' is not null or undefined
            if (createRunRequest === null || createRunRequest === undefined) {
                throw new RequiredError('createRunRequest','Required parameter createRunRequest was null or undefined when calling createRun.');
            }
            const localVarPath = `/threads/{thread_id}/runs`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (include) {
                localVarQueryParameter['include[]'] = include;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createRunRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createRunRequest != null ? createRunRequest : {}) : (((createRunRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a thread.
         * @throws {RequiredError}
         */
        createThread(createThreadRequest?: CreateThreadRequest, options: RequestOptions): FetchArgs {
            const localVarPath = `/threads`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createThreadRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createThreadRequest != null ? createThreadRequest : {}) : (((createThreadRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a thread and run it in one request.
         * @throws {RequiredError}
         */
        createThreadAndRun(createThreadAndRunRequest: CreateThreadAndRunRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createThreadAndRunRequest' is not null or undefined
            if (createThreadAndRunRequest === null || createThreadAndRunRequest === undefined) {
                throw new RequiredError('createThreadAndRunRequest','Required parameter createThreadAndRunRequest was null or undefined when calling createThreadAndRun.');
            }
            const localVarPath = `/threads/runs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createThreadAndRunRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createThreadAndRunRequest != null ? createThreadAndRunRequest : {}) : (((createThreadAndRunRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an assistant.
         * @throws {RequiredError}
         */
        deleteAssistant(assistantId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assistantId' is not null or undefined
            if (assistantId === null || assistantId === undefined) {
                throw new RequiredError('assistantId','Required parameter assistantId was null or undefined when calling deleteAssistant.');
            }
            const localVarPath = `/assistants/{assistant_id}`
                .replace(`{${"assistant_id"}}`, encodeURIComponent(String(assistantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a message.
         * @throws {RequiredError}
         */
        deleteMessage(threadId: string, messageId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling deleteMessage.');
            }
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling deleteMessage.');
            }
            const localVarPath = `/threads/{thread_id}/messages/{message_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a thread.
         * @throws {RequiredError}
         */
        deleteThread(threadId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling deleteThread.');
            }
            const localVarPath = `/threads/{thread_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves an assistant.
         * @throws {RequiredError}
         */
        getAssistant(assistantId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assistantId' is not null or undefined
            if (assistantId === null || assistantId === undefined) {
                throw new RequiredError('assistantId','Required parameter assistantId was null or undefined when calling getAssistant.');
            }
            const localVarPath = `/assistants/{assistant_id}`
                .replace(`{${"assistant_id"}}`, encodeURIComponent(String(assistantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a message.
         * @throws {RequiredError}
         */
        getMessage(threadId: string, messageId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling getMessage.');
            }
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling getMessage.');
            }
            const localVarPath = `/threads/{thread_id}/messages/{message_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a run.
         * @throws {RequiredError}
         */
        getRun(threadId: string, runId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling getRun.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling getRun.');
            }
            const localVarPath = `/threads/{thread_id}/runs/{run_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a run step.
         * @throws {RequiredError}
         */
        getRunStep(threadId: string, runId: string, stepId: string, include?: Array<'step_details.tool_calls[*].file_search.results[*].content'>, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling getRunStep.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling getRunStep.');
            }
            // verify required parameter 'stepId' is not null or undefined
            if (stepId === null || stepId === undefined) {
                throw new RequiredError('stepId','Required parameter stepId was null or undefined when calling getRunStep.');
            }
            const localVarPath = `/threads/{thread_id}/runs/{run_id}/steps/{step_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"step_id"}}`, encodeURIComponent(String(stepId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (include) {
                localVarQueryParameter['include[]'] = include;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a thread.
         * @throws {RequiredError}
         */
        getThread(threadId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling getThread.');
            }
            const localVarPath = `/threads/{thread_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of assistants.
         * @throws {RequiredError}
         */
        listAssistants(limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/assistants`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = ((order:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = ((before:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of messages for a given thread.
         * @throws {RequiredError}
         */
        listMessages(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, runId?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling listMessages.');
            }
            const localVarPath = `/threads/{thread_id}/messages`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = ((order:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = ((before:any):string);
            }

            if (runId !== undefined) {
                localVarQueryParameter['run_id'] = ((runId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of run steps belonging to a run.
         * @throws {RequiredError}
         */
        listRunSteps(threadId: string, runId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, include?: Array<'step_details.tool_calls[*].file_search.results[*].content'>, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling listRunSteps.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling listRunSteps.');
            }
            const localVarPath = `/threads/{thread_id}/runs/{run_id}/steps`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = ((order:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = ((before:any):string);
            }

            if (include) {
                localVarQueryParameter['include[]'] = include;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of runs belonging to a thread.
         * @throws {RequiredError}
         */
        listRuns(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling listRuns.');
            }
            const localVarPath = `/threads/{thread_id}/runs`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = ((order:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = ((before:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies an assistant.
         * @throws {RequiredError}
         */
        modifyAssistant(assistantId: string, modifyAssistantRequest: ModifyAssistantRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'assistantId' is not null or undefined
            if (assistantId === null || assistantId === undefined) {
                throw new RequiredError('assistantId','Required parameter assistantId was null or undefined when calling modifyAssistant.');
            }
            // verify required parameter 'modifyAssistantRequest' is not null or undefined
            if (modifyAssistantRequest === null || modifyAssistantRequest === undefined) {
                throw new RequiredError('modifyAssistantRequest','Required parameter modifyAssistantRequest was null or undefined when calling modifyAssistant.');
            }
            const localVarPath = `/assistants/{assistant_id}`
                .replace(`{${"assistant_id"}}`, encodeURIComponent(String(assistantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof modifyAssistantRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(modifyAssistantRequest != null ? modifyAssistantRequest : {}) : (((modifyAssistantRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a message.
         * @throws {RequiredError}
         */
        modifyMessage(threadId: string, messageId: string, modifyMessageRequest: ModifyMessageRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling modifyMessage.');
            }
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling modifyMessage.');
            }
            // verify required parameter 'modifyMessageRequest' is not null or undefined
            if (modifyMessageRequest === null || modifyMessageRequest === undefined) {
                throw new RequiredError('modifyMessageRequest','Required parameter modifyMessageRequest was null or undefined when calling modifyMessage.');
            }
            const localVarPath = `/threads/{thread_id}/messages/{message_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof modifyMessageRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(modifyMessageRequest != null ? modifyMessageRequest : {}) : (((modifyMessageRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a run.
         * @throws {RequiredError}
         */
        modifyRun(threadId: string, runId: string, modifyRunRequest: ModifyRunRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling modifyRun.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling modifyRun.');
            }
            // verify required parameter 'modifyRunRequest' is not null or undefined
            if (modifyRunRequest === null || modifyRunRequest === undefined) {
                throw new RequiredError('modifyRunRequest','Required parameter modifyRunRequest was null or undefined when calling modifyRun.');
            }
            const localVarPath = `/threads/{thread_id}/runs/{run_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof modifyRunRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(modifyRunRequest != null ? modifyRunRequest : {}) : (((modifyRunRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a thread.
         * @throws {RequiredError}
         */
        modifyThread(threadId: string, modifyThreadRequest: ModifyThreadRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling modifyThread.');
            }
            // verify required parameter 'modifyThreadRequest' is not null or undefined
            if (modifyThreadRequest === null || modifyThreadRequest === undefined) {
                throw new RequiredError('modifyThreadRequest','Required parameter modifyThreadRequest was null or undefined when calling modifyThread.');
            }
            const localVarPath = `/threads/{thread_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof modifyThreadRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(modifyThreadRequest != null ? modifyThreadRequest : {}) : (((modifyThreadRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they\'re all completed. All outputs must be submitted in a single request. 
         * @throws {RequiredError}
         */
        submitToolOuputsToRun(threadId: string, runId: string, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling submitToolOuputsToRun.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling submitToolOuputsToRun.');
            }
            // verify required parameter 'submitToolOutputsRunRequest' is not null or undefined
            if (submitToolOutputsRunRequest === null || submitToolOutputsRunRequest === undefined) {
                throw new RequiredError('submitToolOutputsRunRequest','Required parameter submitToolOutputsRunRequest was null or undefined when calling submitToolOuputsToRun.');
            }
            const localVarPath = `/threads/{thread_id}/runs/{run_id}/submit_tool_outputs`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof submitToolOutputsRunRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(submitToolOutputsRunRequest != null ? submitToolOutputsRunRequest : {}) : (((submitToolOutputsRunRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type AssistantsApiType = { 
    cancelRun(threadId: string, runId: string, options?: RequestOptions): Promise<RunObject>,

    createAssistant(createAssistantRequest: CreateAssistantRequest, options?: RequestOptions): Promise<AssistantObject>,

    createMessage(threadId: string, createMessageRequest: CreateMessageRequest, options?: RequestOptions): Promise<MessageObject>,

    createRun(threadId: string, createRunRequest: CreateRunRequest, include?: Array<'step_details.tool_calls[*].file_search.results[*].content'>, options?: RequestOptions): Promise<RunObject>,

    createThread(createThreadRequest?: CreateThreadRequest, options?: RequestOptions): Promise<ThreadObject>,

    createThreadAndRun(createThreadAndRunRequest: CreateThreadAndRunRequest, options?: RequestOptions): Promise<RunObject>,

    deleteAssistant(assistantId: string, options?: RequestOptions): Promise<DeleteAssistantResponse>,

    deleteMessage(threadId: string, messageId: string, options?: RequestOptions): Promise<DeleteMessageResponse>,

    deleteThread(threadId: string, options?: RequestOptions): Promise<DeleteThreadResponse>,

    getAssistant(assistantId: string, options?: RequestOptions): Promise<AssistantObject>,

    getMessage(threadId: string, messageId: string, options?: RequestOptions): Promise<MessageObject>,

    getRun(threadId: string, runId: string, options?: RequestOptions): Promise<RunObject>,

    getRunStep(threadId: string, runId: string, stepId: string, include?: Array<'step_details.tool_calls[*].file_search.results[*].content'>, options?: RequestOptions): Promise<RunStepObject>,

    getThread(threadId: string, options?: RequestOptions): Promise<ThreadObject>,

    listAssistants(limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions): Promise<ListAssistantsResponse>,

    listMessages(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, runId?: string, options?: RequestOptions): Promise<ListMessagesResponse>,

    listRunSteps(threadId: string, runId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, include?: Array<'step_details.tool_calls[*].file_search.results[*].content'>, options?: RequestOptions): Promise<ListRunStepsResponse>,

    listRuns(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions): Promise<ListRunsResponse>,

    modifyAssistant(assistantId: string, modifyAssistantRequest: ModifyAssistantRequest, options?: RequestOptions): Promise<AssistantObject>,

    modifyMessage(threadId: string, messageId: string, modifyMessageRequest: ModifyMessageRequest, options?: RequestOptions): Promise<MessageObject>,

    modifyRun(threadId: string, runId: string, modifyRunRequest: ModifyRunRequest, options?: RequestOptions): Promise<RunObject>,

    modifyThread(threadId: string, modifyThreadRequest: ModifyThreadRequest, options?: RequestOptions): Promise<ThreadObject>,

    submitToolOuputsToRun(threadId: string, runId: string, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest, options?: RequestOptions): Promise<RunObject>,
}

/**
 * AssistantsApi - factory function to inject configuration 
 * @export
 */
export const AssistantsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): AssistantsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Cancels a run that is `in_progress`.
         * @throws {RequiredError}
         */
        cancelRun(threadId: string, runId: string, options?: RequestOptions = {}): Promise<RunObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).cancelRun(threadId, runId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create an assistant with a model and instructions.
         * @throws {RequiredError}
         */
        createAssistant(createAssistantRequest: CreateAssistantRequest, options?: RequestOptions = {}): Promise<AssistantObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).createAssistant(createAssistantRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create a message.
         * @throws {RequiredError}
         */
        createMessage(threadId: string, createMessageRequest: CreateMessageRequest, options?: RequestOptions = {}): Promise<MessageObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).createMessage(threadId, createMessageRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create a run.
         * @throws {RequiredError}
         */
        createRun(threadId: string, createRunRequest: CreateRunRequest, include?: Array<'step_details.tool_calls[*].file_search.results[*].content'>, options?: RequestOptions = {}): Promise<RunObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).createRun(threadId, createRunRequest, include, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create a thread.
         * @throws {RequiredError}
         */
        createThread(createThreadRequest?: CreateThreadRequest, options?: RequestOptions = {}): Promise<ThreadObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).createThread(createThreadRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create a thread and run it in one request.
         * @throws {RequiredError}
         */
        createThreadAndRun(createThreadAndRunRequest: CreateThreadAndRunRequest, options?: RequestOptions = {}): Promise<RunObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).createThreadAndRun(createThreadAndRunRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete an assistant.
         * @throws {RequiredError}
         */
        deleteAssistant(assistantId: string, options?: RequestOptions = {}): Promise<DeleteAssistantResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).deleteAssistant(assistantId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Deletes a message.
         * @throws {RequiredError}
         */
        deleteMessage(threadId: string, messageId: string, options?: RequestOptions = {}): Promise<DeleteMessageResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).deleteMessage(threadId, messageId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete a thread.
         * @throws {RequiredError}
         */
        deleteThread(threadId: string, options?: RequestOptions = {}): Promise<DeleteThreadResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).deleteThread(threadId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves an assistant.
         * @throws {RequiredError}
         */
        getAssistant(assistantId: string, options?: RequestOptions = {}): Promise<AssistantObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).getAssistant(assistantId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve a message.
         * @throws {RequiredError}
         */
        getMessage(threadId: string, messageId: string, options?: RequestOptions = {}): Promise<MessageObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).getMessage(threadId, messageId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a run.
         * @throws {RequiredError}
         */
        getRun(threadId: string, runId: string, options?: RequestOptions = {}): Promise<RunObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).getRun(threadId, runId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a run step.
         * @throws {RequiredError}
         */
        getRunStep(threadId: string, runId: string, stepId: string, include?: Array<'step_details.tool_calls[*].file_search.results[*].content'>, options?: RequestOptions = {}): Promise<RunStepObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).getRunStep(threadId, runId, stepId, include, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a thread.
         * @throws {RequiredError}
         */
        getThread(threadId: string, options?: RequestOptions = {}): Promise<ThreadObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).getThread(threadId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of assistants.
         * @throws {RequiredError}
         */
        listAssistants(limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions = {}): Promise<ListAssistantsResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).listAssistants(limit, order, after, before, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of messages for a given thread.
         * @throws {RequiredError}
         */
        listMessages(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, runId?: string, options?: RequestOptions = {}): Promise<ListMessagesResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).listMessages(threadId, limit, order, after, before, runId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of run steps belonging to a run.
         * @throws {RequiredError}
         */
        listRunSteps(threadId: string, runId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, include?: Array<'step_details.tool_calls[*].file_search.results[*].content'>, options?: RequestOptions = {}): Promise<ListRunStepsResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).listRunSteps(threadId, runId, limit, order, after, before, include, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of runs belonging to a thread.
         * @throws {RequiredError}
         */
        listRuns(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions = {}): Promise<ListRunsResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).listRuns(threadId, limit, order, after, before, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Modifies an assistant.
         * @throws {RequiredError}
         */
        modifyAssistant(assistantId: string, modifyAssistantRequest: ModifyAssistantRequest, options?: RequestOptions = {}): Promise<AssistantObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).modifyAssistant(assistantId, modifyAssistantRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Modifies a message.
         * @throws {RequiredError}
         */
        modifyMessage(threadId: string, messageId: string, modifyMessageRequest: ModifyMessageRequest, options?: RequestOptions = {}): Promise<MessageObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).modifyMessage(threadId, messageId, modifyMessageRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Modifies a run.
         * @throws {RequiredError}
         */
        modifyRun(threadId: string, runId: string, modifyRunRequest: ModifyRunRequest, options?: RequestOptions = {}): Promise<RunObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).modifyRun(threadId, runId, modifyRunRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Modifies a thread.
         * @throws {RequiredError}
         */
        modifyThread(threadId: string, modifyThreadRequest: ModifyThreadRequest, options?: RequestOptions = {}): Promise<ThreadObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).modifyThread(threadId, modifyThreadRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they\'re all completed. All outputs must be submitted in a single request. 
         * @throws {RequiredError}
         */
        submitToolOuputsToRun(threadId: string, runId: string, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest, options?: RequestOptions = {}): Promise<RunObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).submitToolOuputsToRun(threadId, runId, submitToolOutputsRunRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * AudioApi - fetch parameter creator
 * @export
 */
export const AudioApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generates audio from the input text.
         * @throws {RequiredError}
         */
        createSpeech(createSpeechRequest: CreateSpeechRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createSpeechRequest' is not null or undefined
            if (createSpeechRequest === null || createSpeechRequest === undefined) {
                throw new RequiredError('createSpeechRequest','Required parameter createSpeechRequest was null or undefined when calling createSpeech.');
            }
            const localVarPath = `/audio/speech`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createSpeechRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createSpeechRequest != null ? createSpeechRequest : {}) : (((createSpeechRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transcribes audio into the input language.
         * @throws {RequiredError}
         */
        createTranscription(file: File, model: CreateTranscriptionRequestModel, language?: string, prompt?: string, responseFormat?: AudioResponseFormat, temperature?: number, timestampGranularities?: Array<string>, options: RequestOptions): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling createTranscription.');
            }
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError('model','Required parameter model was null or undefined when calling createTranscription.');
            }
            const localVarPath = `/audio/transcriptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication ApiKeyAuth required

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (model !== undefined) {
                localVarFormParams.set('model', ((model:any):string));
            }

            if (language !== undefined) {
                localVarFormParams.set('language', ((language:any):string));
            }

            if (prompt !== undefined) {
                localVarFormParams.set('prompt', ((prompt:any):string));
            }

            if (responseFormat !== undefined) {
                localVarFormParams.set('response_format', ((responseFormat:any):string));
            }

            if (temperature !== undefined) {
                localVarFormParams.set('temperature', ((temperature:any):string));
            }

            if (timestampGranularities) {
                    localVarFormParams.set('timestamp_granularities[]', timestampGranularities.join(COLLECTION_FORMATS["csv"]));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Translates audio into English.
         * @throws {RequiredError}
         */
        createTranslation(file: File, model: CreateTranscriptionRequestModel, prompt?: string, responseFormat?: AudioResponseFormat, temperature?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling createTranslation.');
            }
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError('model','Required parameter model was null or undefined when calling createTranslation.');
            }
            const localVarPath = `/audio/translations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication ApiKeyAuth required

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (model !== undefined) {
                localVarFormParams.set('model', ((model:any):string));
            }

            if (prompt !== undefined) {
                localVarFormParams.set('prompt', ((prompt:any):string));
            }

            if (responseFormat !== undefined) {
                localVarFormParams.set('response_format', ((responseFormat:any):string));
            }

            if (temperature !== undefined) {
                localVarFormParams.set('temperature', ((temperature:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type AudioApiType = { 
    createSpeech(createSpeechRequest: CreateSpeechRequest, options?: RequestOptions): Promise<File>,

    createTranscription(file: File, model: CreateTranscriptionRequestModel, language?: string, prompt?: string, responseFormat?: AudioResponseFormat, temperature?: number, timestampGranularities?: Array<string>, options?: RequestOptions): Promise<CreateTranscription200Response>,

    createTranslation(file: File, model: CreateTranscriptionRequestModel, prompt?: string, responseFormat?: AudioResponseFormat, temperature?: number, options?: RequestOptions): Promise<CreateTranslation200Response>,
}

/**
 * AudioApi - factory function to inject configuration 
 * @export
 */
export const AudioApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): AudioApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Generates audio from the input text.
         * @throws {RequiredError}
         */
        createSpeech(createSpeechRequest: CreateSpeechRequest, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = AudioApiFetchParamCreator(configuration).createSpeech(createSpeechRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Transcribes audio into the input language.
         * @throws {RequiredError}
         */
        createTranscription(file: File, model: CreateTranscriptionRequestModel, language?: string, prompt?: string, responseFormat?: AudioResponseFormat, temperature?: number, timestampGranularities?: Array<string>, options?: RequestOptions = {}): Promise<CreateTranscription200Response> {
            const localVarFetchArgs = AudioApiFetchParamCreator(configuration).createTranscription(file, model, language, prompt, responseFormat, temperature, timestampGranularities, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Translates audio into English.
         * @throws {RequiredError}
         */
        createTranslation(file: File, model: CreateTranscriptionRequestModel, prompt?: string, responseFormat?: AudioResponseFormat, temperature?: number, options?: RequestOptions = {}): Promise<CreateTranslation200Response> {
            const localVarFetchArgs = AudioApiFetchParamCreator(configuration).createTranslation(file, model, prompt, responseFormat, temperature, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * AuditLogsApi - fetch parameter creator
 * @export
 */
export const AuditLogsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List user actions and configuration changes within this organization.
         * @throws {RequiredError}
         */
        listAuditLogs(effectiveAt?: ListAuditLogsEffectiveAtParameter, projectIds?: Array<string>, eventTypes?: Array<AuditLogEventType>, actorIds?: Array<string>, actorEmails?: Array<string>, resourceIds?: Array<string>, limit?: number, after?: string, before?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/organization/audit_logs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (effectiveAt !== undefined) {
                localVarQueryParameter['effective_at'] = ((effectiveAt:any):string);
            }

            if (projectIds) {
                localVarQueryParameter['project_ids[]'] = projectIds;
            }

            if (eventTypes) {
                localVarQueryParameter['event_types[]'] = eventTypes;
            }

            if (actorIds) {
                localVarQueryParameter['actor_ids[]'] = actorIds;
            }

            if (actorEmails) {
                localVarQueryParameter['actor_emails[]'] = actorEmails;
            }

            if (resourceIds) {
                localVarQueryParameter['resource_ids[]'] = resourceIds;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = ((before:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type AuditLogsApiType = { 
    listAuditLogs(effectiveAt?: ListAuditLogsEffectiveAtParameter, projectIds?: Array<string>, eventTypes?: Array<AuditLogEventType>, actorIds?: Array<string>, actorEmails?: Array<string>, resourceIds?: Array<string>, limit?: number, after?: string, before?: string, options?: RequestOptions): Promise<ListAuditLogsResponse>,
}

/**
 * AuditLogsApi - factory function to inject configuration 
 * @export
 */
export const AuditLogsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): AuditLogsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List user actions and configuration changes within this organization.
         * @throws {RequiredError}
         */
        listAuditLogs(effectiveAt?: ListAuditLogsEffectiveAtParameter, projectIds?: Array<string>, eventTypes?: Array<AuditLogEventType>, actorIds?: Array<string>, actorEmails?: Array<string>, resourceIds?: Array<string>, limit?: number, after?: string, before?: string, options?: RequestOptions = {}): Promise<ListAuditLogsResponse> {
            const localVarFetchArgs = AuditLogsApiFetchParamCreator(configuration).listAuditLogs(effectiveAt, projectIds, eventTypes, actorIds, actorEmails, resourceIds, limit, after, before, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * BatchApi - fetch parameter creator
 * @export
 */
export const BatchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels an in-progress batch. The batch will be in status `cancelling` for up to 10 minutes, before changing to `cancelled`, where it will have partial results (if any) available in the output file.
         * @throws {RequiredError}
         */
        cancelBatch(batchId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'batchId' is not null or undefined
            if (batchId === null || batchId === undefined) {
                throw new RequiredError('batchId','Required parameter batchId was null or undefined when calling cancelBatch.');
            }
            const localVarPath = `/batches/{batch_id}/cancel`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates and executes a batch from an uploaded file of requests
         * @throws {RequiredError}
         */
        createBatch(createBatchRequest: CreateBatchRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createBatchRequest' is not null or undefined
            if (createBatchRequest === null || createBatchRequest === undefined) {
                throw new RequiredError('createBatchRequest','Required parameter createBatchRequest was null or undefined when calling createBatch.');
            }
            const localVarPath = `/batches`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createBatchRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createBatchRequest != null ? createBatchRequest : {}) : (((createBatchRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List your organization\'s batches.
         * @throws {RequiredError}
         */
        listBatches(after?: string, limit?: number, options: RequestOptions): FetchArgs {
            const localVarPath = `/batches`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a batch.
         * @throws {RequiredError}
         */
        retrieveBatch(batchId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'batchId' is not null or undefined
            if (batchId === null || batchId === undefined) {
                throw new RequiredError('batchId','Required parameter batchId was null or undefined when calling retrieveBatch.');
            }
            const localVarPath = `/batches/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type BatchApiType = { 
    cancelBatch(batchId: string, options?: RequestOptions): Promise<Batch>,

    createBatch(createBatchRequest: CreateBatchRequest, options?: RequestOptions): Promise<Batch>,

    listBatches(after?: string, limit?: number, options?: RequestOptions): Promise<ListBatchesResponse>,

    retrieveBatch(batchId: string, options?: RequestOptions): Promise<Batch>,
}

/**
 * BatchApi - factory function to inject configuration 
 * @export
 */
export const BatchApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): BatchApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Cancels an in-progress batch. The batch will be in status `cancelling` for up to 10 minutes, before changing to `cancelled`, where it will have partial results (if any) available in the output file.
         * @throws {RequiredError}
         */
        cancelBatch(batchId: string, options?: RequestOptions = {}): Promise<Batch> {
            const localVarFetchArgs = BatchApiFetchParamCreator(configuration).cancelBatch(batchId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Creates and executes a batch from an uploaded file of requests
         * @throws {RequiredError}
         */
        createBatch(createBatchRequest: CreateBatchRequest, options?: RequestOptions = {}): Promise<Batch> {
            const localVarFetchArgs = BatchApiFetchParamCreator(configuration).createBatch(createBatchRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List your organization\'s batches.
         * @throws {RequiredError}
         */
        listBatches(after?: string, limit?: number, options?: RequestOptions = {}): Promise<ListBatchesResponse> {
            const localVarFetchArgs = BatchApiFetchParamCreator(configuration).listBatches(after, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a batch.
         * @throws {RequiredError}
         */
        retrieveBatch(batchId: string, options?: RequestOptions = {}): Promise<Batch> {
            const localVarFetchArgs = BatchApiFetchParamCreator(configuration).retrieveBatch(batchId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ChatApi - fetch parameter creator
 * @export
 */
export const ChatApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a model response for the given chat conversation. Learn more in the [text generation](/docs/guides/text-generation), [vision](/docs/guides/vision), and [audio](/docs/guides/audio) guides.  Parameter support can differ depending on the model used to generate the response, particularly for newer reasoning models. Parameters that are only supported for reasoning models are noted below. For the current state of  unsupported parameters in reasoning models,  [refer to the reasoning guide](/docs/guides/reasoning). 
         * @throws {RequiredError}
         */
        createChatCompletion(createChatCompletionRequest: CreateChatCompletionRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createChatCompletionRequest' is not null or undefined
            if (createChatCompletionRequest === null || createChatCompletionRequest === undefined) {
                throw new RequiredError('createChatCompletionRequest','Required parameter createChatCompletionRequest was null or undefined when calling createChatCompletion.');
            }
            const localVarPath = `/chat/completions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createChatCompletionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createChatCompletionRequest != null ? createChatCompletionRequest : {}) : (((createChatCompletionRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ChatApiType = { 
    createChatCompletion(createChatCompletionRequest: CreateChatCompletionRequest, options?: RequestOptions): Promise<CreateChatCompletionResponse>,
}

/**
 * ChatApi - factory function to inject configuration 
 * @export
 */
export const ChatApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ChatApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Creates a model response for the given chat conversation. Learn more in the [text generation](/docs/guides/text-generation), [vision](/docs/guides/vision), and [audio](/docs/guides/audio) guides.  Parameter support can differ depending on the model used to generate the response, particularly for newer reasoning models. Parameters that are only supported for reasoning models are noted below. For the current state of  unsupported parameters in reasoning models,  [refer to the reasoning guide](/docs/guides/reasoning). 
         * @throws {RequiredError}
         */
        createChatCompletion(createChatCompletionRequest: CreateChatCompletionRequest, options?: RequestOptions = {}): Promise<CreateChatCompletionResponse> {
            const localVarFetchArgs = ChatApiFetchParamCreator(configuration).createChatCompletion(createChatCompletionRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CompletionsApi - fetch parameter creator
 * @export
 */
export const CompletionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a completion for the provided prompt and parameters.
         * @throws {RequiredError}
         */
        createCompletion(createCompletionRequest: CreateCompletionRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createCompletionRequest' is not null or undefined
            if (createCompletionRequest === null || createCompletionRequest === undefined) {
                throw new RequiredError('createCompletionRequest','Required parameter createCompletionRequest was null or undefined when calling createCompletion.');
            }
            const localVarPath = `/completions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createCompletionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createCompletionRequest != null ? createCompletionRequest : {}) : (((createCompletionRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CompletionsApiType = { 
    createCompletion(createCompletionRequest: CreateCompletionRequest, options?: RequestOptions): Promise<CreateCompletionResponse>,
}

/**
 * CompletionsApi - factory function to inject configuration 
 * @export
 */
export const CompletionsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CompletionsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Creates a completion for the provided prompt and parameters.
         * @throws {RequiredError}
         */
        createCompletion(createCompletionRequest: CreateCompletionRequest, options?: RequestOptions = {}): Promise<CreateCompletionResponse> {
            const localVarFetchArgs = CompletionsApiFetchParamCreator(configuration).createCompletion(createCompletionRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new admin-level API key for the organization.
         * @summary Create an organization admin API key
         * @throws {RequiredError}
         */
        adminApiKeysCreate(adminApiKeysCreateRequest: AdminApiKeysCreateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'adminApiKeysCreateRequest' is not null or undefined
            if (adminApiKeysCreateRequest === null || adminApiKeysCreateRequest === undefined) {
                throw new RequiredError('adminApiKeysCreateRequest','Required parameter adminApiKeysCreateRequest was null or undefined when calling adminApiKeysCreate.');
            }
            const localVarPath = `/organization/admin_api_keys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof adminApiKeysCreateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(adminApiKeysCreateRequest != null ? adminApiKeysCreateRequest : {}) : (((adminApiKeysCreateRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified admin API key.
         * @summary Delete an organization admin API key
         * @throws {RequiredError}
         */
        adminApiKeysDelete(keyId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'keyId' is not null or undefined
            if (keyId === null || keyId === undefined) {
                throw new RequiredError('keyId','Required parameter keyId was null or undefined when calling adminApiKeysDelete.');
            }
            const localVarPath = `/organization/admin_api_keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details for a specific organization API key by its ID.
         * @summary Retrieve a single organization API key
         * @throws {RequiredError}
         */
        adminApiKeysGet(keyId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'keyId' is not null or undefined
            if (keyId === null || keyId === undefined) {
                throw new RequiredError('keyId','Required parameter keyId was null or undefined when calling adminApiKeysGet.');
            }
            const localVarPath = `/organization/admin_api_keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a paginated list of organization admin API keys.
         * @summary List organization API keys
         * @throws {RequiredError}
         */
        adminApiKeysList(after?: string, order?: 'asc' | 'desc', limit?: number, options: RequestOptions): FetchArgs {
            const localVarPath = `/organization/admin_api_keys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = ((order:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type DefaultApiType = { 
    adminApiKeysCreate(adminApiKeysCreateRequest: AdminApiKeysCreateRequest, options?: RequestOptions): Promise<AdminApiKey>,

    adminApiKeysDelete(keyId: string, options?: RequestOptions): Promise<AdminApiKeysDelete200Response>,

    adminApiKeysGet(keyId: string, options?: RequestOptions): Promise<AdminApiKey>,

    adminApiKeysList(after?: string, order?: 'asc' | 'desc', limit?: number, options?: RequestOptions): Promise<ApiKeyList>,
}

/**
 * DefaultApi - factory function to inject configuration 
 * @export
 */
export const DefaultApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): DefaultApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Create a new admin-level API key for the organization.
         * @summary Create an organization admin API key
         * @throws {RequiredError}
         */
        adminApiKeysCreate(adminApiKeysCreateRequest: AdminApiKeysCreateRequest, options?: RequestOptions = {}): Promise<AdminApiKey> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).adminApiKeysCreate(adminApiKeysCreateRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Delete the specified admin API key.
         * @summary Delete an organization admin API key
         * @throws {RequiredError}
         */
        adminApiKeysDelete(keyId: string, options?: RequestOptions = {}): Promise<AdminApiKeysDelete200Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).adminApiKeysDelete(keyId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get details for a specific organization API key by its ID.
         * @summary Retrieve a single organization API key
         * @throws {RequiredError}
         */
        adminApiKeysGet(keyId: string, options?: RequestOptions = {}): Promise<AdminApiKey> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).adminApiKeysGet(keyId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Retrieve a paginated list of organization admin API keys.
         * @summary List organization API keys
         * @throws {RequiredError}
         */
        adminApiKeysList(after?: string, order?: 'asc' | 'desc', limit?: number, options?: RequestOptions = {}): Promise<ApiKeyList> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).adminApiKeysList(after, order, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * EmbeddingsApi - fetch parameter creator
 * @export
 */
export const EmbeddingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an embedding vector representing the input text.
         * @throws {RequiredError}
         */
        createEmbedding(createEmbeddingRequest: CreateEmbeddingRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createEmbeddingRequest' is not null or undefined
            if (createEmbeddingRequest === null || createEmbeddingRequest === undefined) {
                throw new RequiredError('createEmbeddingRequest','Required parameter createEmbeddingRequest was null or undefined when calling createEmbedding.');
            }
            const localVarPath = `/embeddings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createEmbeddingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createEmbeddingRequest != null ? createEmbeddingRequest : {}) : (((createEmbeddingRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type EmbeddingsApiType = { 
    createEmbedding(createEmbeddingRequest: CreateEmbeddingRequest, options?: RequestOptions): Promise<CreateEmbeddingResponse>,
}

/**
 * EmbeddingsApi - factory function to inject configuration 
 * @export
 */
export const EmbeddingsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): EmbeddingsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Creates an embedding vector representing the input text.
         * @throws {RequiredError}
         */
        createEmbedding(createEmbeddingRequest: CreateEmbeddingRequest, options?: RequestOptions = {}): Promise<CreateEmbeddingResponse> {
            const localVarFetchArgs = EmbeddingsApiFetchParamCreator(configuration).createEmbedding(createEmbeddingRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * FilesApi - fetch parameter creator
 * @export
 */
export const FilesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload a file that can be used across various endpoints. Individual files can be up to 512 MB, and the size of all files uploaded by one organization can be up to 100 GB.  The Assistants API supports files up to 2 million tokens and of specific file types. See the [Assistants Tools guide](/docs/assistants/tools) for details.  The Fine-tuning API only supports `.jsonl` files. The input also has certain required formats for fine-tuning [chat](/docs/api-reference/fine-tuning/chat-input) or [completions](/docs/api-reference/fine-tuning/completions-input) models.  The Batch API only supports `.jsonl` files up to 200 MB in size. The input also has a specific required [format](/docs/api-reference/batch/request-input).  Please [contact us](https://help.openai.com/) if you need to increase these storage limits. 
         * @throws {RequiredError}
         */
        createFile(file: File, purpose: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling createFile.');
            }
            // verify required parameter 'purpose' is not null or undefined
            if (purpose === null || purpose === undefined) {
                throw new RequiredError('purpose','Required parameter purpose was null or undefined when calling createFile.');
            }
            const localVarPath = `/files`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication ApiKeyAuth required

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (purpose !== undefined) {
                localVarFormParams.set('purpose', ((purpose:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a file.
         * @throws {RequiredError}
         */
        deleteFile(fileId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling deleteFile.');
            }
            const localVarPath = `/files/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the contents of the specified file.
         * @throws {RequiredError}
         */
        downloadFile(fileId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling downloadFile.');
            }
            const localVarPath = `/files/{file_id}/content`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of files.
         * @throws {RequiredError}
         */
        listFiles(purpose?: string, limit?: number, order?: 'asc' | 'desc', after?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/files`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (purpose !== undefined) {
                localVarQueryParameter['purpose'] = ((purpose:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = ((order:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns information about a specific file.
         * @throws {RequiredError}
         */
        retrieveFile(fileId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling retrieveFile.');
            }
            const localVarPath = `/files/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type FilesApiType = { 
    createFile(file: File, purpose: string, options?: RequestOptions): Promise<OpenAIFile>,

    deleteFile(fileId: string, options?: RequestOptions): Promise<DeleteFileResponse>,

    downloadFile(fileId: string, options?: RequestOptions): Promise<string>,

    listFiles(purpose?: string, limit?: number, order?: 'asc' | 'desc', after?: string, options?: RequestOptions): Promise<ListFilesResponse>,

    retrieveFile(fileId: string, options?: RequestOptions): Promise<OpenAIFile>,
}

/**
 * FilesApi - factory function to inject configuration 
 * @export
 */
export const FilesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): FilesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Upload a file that can be used across various endpoints. Individual files can be up to 512 MB, and the size of all files uploaded by one organization can be up to 100 GB.  The Assistants API supports files up to 2 million tokens and of specific file types. See the [Assistants Tools guide](/docs/assistants/tools) for details.  The Fine-tuning API only supports `.jsonl` files. The input also has certain required formats for fine-tuning [chat](/docs/api-reference/fine-tuning/chat-input) or [completions](/docs/api-reference/fine-tuning/completions-input) models.  The Batch API only supports `.jsonl` files up to 200 MB in size. The input also has a specific required [format](/docs/api-reference/batch/request-input).  Please [contact us](https://help.openai.com/) if you need to increase these storage limits. 
         * @throws {RequiredError}
         */
        createFile(file: File, purpose: string, options?: RequestOptions = {}): Promise<OpenAIFile> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).createFile(file, purpose, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete a file.
         * @throws {RequiredError}
         */
        deleteFile(fileId: string, options?: RequestOptions = {}): Promise<DeleteFileResponse> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).deleteFile(fileId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns the contents of the specified file.
         * @throws {RequiredError}
         */
        downloadFile(fileId: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).downloadFile(fileId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of files.
         * @throws {RequiredError}
         */
        listFiles(purpose?: string, limit?: number, order?: 'asc' | 'desc', after?: string, options?: RequestOptions = {}): Promise<ListFilesResponse> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).listFiles(purpose, limit, order, after, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns information about a specific file.
         * @throws {RequiredError}
         */
        retrieveFile(fileId: string, options?: RequestOptions = {}): Promise<OpenAIFile> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).retrieveFile(fileId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * FineTuningApi - fetch parameter creator
 * @export
 */
export const FineTuningApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Immediately cancel a fine-tune job. 
         * @throws {RequiredError}
         */
        cancelFineTuningJob(fineTuningJobId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'fineTuningJobId' is not null or undefined
            if (fineTuningJobId === null || fineTuningJobId === undefined) {
                throw new RequiredError('fineTuningJobId','Required parameter fineTuningJobId was null or undefined when calling cancelFineTuningJob.');
            }
            const localVarPath = `/fine_tuning/jobs/{fine_tuning_job_id}/cancel`
                .replace(`{${"fine_tuning_job_id"}}`, encodeURIComponent(String(fineTuningJobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a fine-tuning job which begins the process of creating a new model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
         * @throws {RequiredError}
         */
        createFineTuningJob(createFineTuningJobRequest: CreateFineTuningJobRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createFineTuningJobRequest' is not null or undefined
            if (createFineTuningJobRequest === null || createFineTuningJobRequest === undefined) {
                throw new RequiredError('createFineTuningJobRequest','Required parameter createFineTuningJobRequest was null or undefined when calling createFineTuningJob.');
            }
            const localVarPath = `/fine_tuning/jobs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createFineTuningJobRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createFineTuningJobRequest != null ? createFineTuningJobRequest : {}) : (((createFineTuningJobRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get status updates for a fine-tuning job. 
         * @throws {RequiredError}
         */
        listFineTuningEvents(fineTuningJobId: string, after?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'fineTuningJobId' is not null or undefined
            if (fineTuningJobId === null || fineTuningJobId === undefined) {
                throw new RequiredError('fineTuningJobId','Required parameter fineTuningJobId was null or undefined when calling listFineTuningEvents.');
            }
            const localVarPath = `/fine_tuning/jobs/{fine_tuning_job_id}/events`
                .replace(`{${"fine_tuning_job_id"}}`, encodeURIComponent(String(fineTuningJobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List checkpoints for a fine-tuning job. 
         * @throws {RequiredError}
         */
        listFineTuningJobCheckpoints(fineTuningJobId: string, after?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'fineTuningJobId' is not null or undefined
            if (fineTuningJobId === null || fineTuningJobId === undefined) {
                throw new RequiredError('fineTuningJobId','Required parameter fineTuningJobId was null or undefined when calling listFineTuningJobCheckpoints.');
            }
            const localVarPath = `/fine_tuning/jobs/{fine_tuning_job_id}/checkpoints`
                .replace(`{${"fine_tuning_job_id"}}`, encodeURIComponent(String(fineTuningJobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List your organization\'s fine-tuning jobs 
         * @throws {RequiredError}
         */
        listPaginatedFineTuningJobs(after?: string, limit?: number, options: RequestOptions): FetchArgs {
            const localVarPath = `/fine_tuning/jobs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get info about a fine-tuning job.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
         * @throws {RequiredError}
         */
        retrieveFineTuningJob(fineTuningJobId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'fineTuningJobId' is not null or undefined
            if (fineTuningJobId === null || fineTuningJobId === undefined) {
                throw new RequiredError('fineTuningJobId','Required parameter fineTuningJobId was null or undefined when calling retrieveFineTuningJob.');
            }
            const localVarPath = `/fine_tuning/jobs/{fine_tuning_job_id}`
                .replace(`{${"fine_tuning_job_id"}}`, encodeURIComponent(String(fineTuningJobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type FineTuningApiType = { 
    cancelFineTuningJob(fineTuningJobId: string, options?: RequestOptions): Promise<FineTuningJob>,

    createFineTuningJob(createFineTuningJobRequest: CreateFineTuningJobRequest, options?: RequestOptions): Promise<FineTuningJob>,

    listFineTuningEvents(fineTuningJobId: string, after?: string, limit?: number, options?: RequestOptions): Promise<ListFineTuningJobEventsResponse>,

    listFineTuningJobCheckpoints(fineTuningJobId: string, after?: string, limit?: number, options?: RequestOptions): Promise<ListFineTuningJobCheckpointsResponse>,

    listPaginatedFineTuningJobs(after?: string, limit?: number, options?: RequestOptions): Promise<ListPaginatedFineTuningJobsResponse>,

    retrieveFineTuningJob(fineTuningJobId: string, options?: RequestOptions): Promise<FineTuningJob>,
}

/**
 * FineTuningApi - factory function to inject configuration 
 * @export
 */
export const FineTuningApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): FineTuningApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Immediately cancel a fine-tune job. 
         * @throws {RequiredError}
         */
        cancelFineTuningJob(fineTuningJobId: string, options?: RequestOptions = {}): Promise<FineTuningJob> {
            const localVarFetchArgs = FineTuningApiFetchParamCreator(configuration).cancelFineTuningJob(fineTuningJobId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Creates a fine-tuning job which begins the process of creating a new model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
         * @throws {RequiredError}
         */
        createFineTuningJob(createFineTuningJobRequest: CreateFineTuningJobRequest, options?: RequestOptions = {}): Promise<FineTuningJob> {
            const localVarFetchArgs = FineTuningApiFetchParamCreator(configuration).createFineTuningJob(createFineTuningJobRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get status updates for a fine-tuning job. 
         * @throws {RequiredError}
         */
        listFineTuningEvents(fineTuningJobId: string, after?: string, limit?: number, options?: RequestOptions = {}): Promise<ListFineTuningJobEventsResponse> {
            const localVarFetchArgs = FineTuningApiFetchParamCreator(configuration).listFineTuningEvents(fineTuningJobId, after, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List checkpoints for a fine-tuning job. 
         * @throws {RequiredError}
         */
        listFineTuningJobCheckpoints(fineTuningJobId: string, after?: string, limit?: number, options?: RequestOptions = {}): Promise<ListFineTuningJobCheckpointsResponse> {
            const localVarFetchArgs = FineTuningApiFetchParamCreator(configuration).listFineTuningJobCheckpoints(fineTuningJobId, after, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List your organization\'s fine-tuning jobs 
         * @throws {RequiredError}
         */
        listPaginatedFineTuningJobs(after?: string, limit?: number, options?: RequestOptions = {}): Promise<ListPaginatedFineTuningJobsResponse> {
            const localVarFetchArgs = FineTuningApiFetchParamCreator(configuration).listPaginatedFineTuningJobs(after, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get info about a fine-tuning job.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
         * @throws {RequiredError}
         */
        retrieveFineTuningJob(fineTuningJobId: string, options?: RequestOptions = {}): Promise<FineTuningJob> {
            const localVarFetchArgs = FineTuningApiFetchParamCreator(configuration).retrieveFineTuningJob(fineTuningJobId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ImagesApi - fetch parameter creator
 * @export
 */
export const ImagesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an image given a prompt.
         * @throws {RequiredError}
         */
        createImage(createImageRequest: CreateImageRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createImageRequest' is not null or undefined
            if (createImageRequest === null || createImageRequest === undefined) {
                throw new RequiredError('createImageRequest','Required parameter createImageRequest was null or undefined when calling createImage.');
            }
            const localVarPath = `/images/generations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createImageRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createImageRequest != null ? createImageRequest : {}) : (((createImageRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @throws {RequiredError}
         */
        createImageEdit(image: File, prompt: string, mask?: File, model?: CreateImageEditRequestModel, n?: number, size?: string, responseFormat?: string, user?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling createImageEdit.');
            }
            // verify required parameter 'prompt' is not null or undefined
            if (prompt === null || prompt === undefined) {
                throw new RequiredError('prompt','Required parameter prompt was null or undefined when calling createImageEdit.');
            }
            const localVarPath = `/images/edits`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication ApiKeyAuth required

            if (image !== undefined) {
                localVarFormParams.set('image', ((image:any):string));
            }

            if (prompt !== undefined) {
                localVarFormParams.set('prompt', ((prompt:any):string));
            }

            if (mask !== undefined) {
                localVarFormParams.set('mask', ((mask:any):string));
            }

            if (model !== undefined) {
                localVarFormParams.set('model', ((model:any):string));
            }

            if (n !== undefined) {
                localVarFormParams.set('n', ((n:any):string));
            }

            if (size !== undefined) {
                localVarFormParams.set('size', ((size:any):string));
            }

            if (responseFormat !== undefined) {
                localVarFormParams.set('response_format', ((responseFormat:any):string));
            }

            if (user !== undefined) {
                localVarFormParams.set('user', ((user:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a variation of a given image.
         * @throws {RequiredError}
         */
        createImageVariation(image: File, model?: CreateImageEditRequestModel, n?: number, responseFormat?: string, size?: string, user?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling createImageVariation.');
            }
            const localVarPath = `/images/variations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication ApiKeyAuth required

            if (image !== undefined) {
                localVarFormParams.set('image', ((image:any):string));
            }

            if (model !== undefined) {
                localVarFormParams.set('model', ((model:any):string));
            }

            if (n !== undefined) {
                localVarFormParams.set('n', ((n:any):string));
            }

            if (responseFormat !== undefined) {
                localVarFormParams.set('response_format', ((responseFormat:any):string));
            }

            if (size !== undefined) {
                localVarFormParams.set('size', ((size:any):string));
            }

            if (user !== undefined) {
                localVarFormParams.set('user', ((user:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ImagesApiType = { 
    createImage(createImageRequest: CreateImageRequest, options?: RequestOptions): Promise<ImagesResponse>,

    createImageEdit(image: File, prompt: string, mask?: File, model?: CreateImageEditRequestModel, n?: number, size?: string, responseFormat?: string, user?: string, options?: RequestOptions): Promise<ImagesResponse>,

    createImageVariation(image: File, model?: CreateImageEditRequestModel, n?: number, responseFormat?: string, size?: string, user?: string, options?: RequestOptions): Promise<ImagesResponse>,
}

/**
 * ImagesApi - factory function to inject configuration 
 * @export
 */
export const ImagesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ImagesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Creates an image given a prompt.
         * @throws {RequiredError}
         */
        createImage(createImageRequest: CreateImageRequest, options?: RequestOptions = {}): Promise<ImagesResponse> {
            const localVarFetchArgs = ImagesApiFetchParamCreator(configuration).createImage(createImageRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @throws {RequiredError}
         */
        createImageEdit(image: File, prompt: string, mask?: File, model?: CreateImageEditRequestModel, n?: number, size?: string, responseFormat?: string, user?: string, options?: RequestOptions = {}): Promise<ImagesResponse> {
            const localVarFetchArgs = ImagesApiFetchParamCreator(configuration).createImageEdit(image, prompt, mask, model, n, size, responseFormat, user, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Creates a variation of a given image.
         * @throws {RequiredError}
         */
        createImageVariation(image: File, model?: CreateImageEditRequestModel, n?: number, responseFormat?: string, size?: string, user?: string, options?: RequestOptions = {}): Promise<ImagesResponse> {
            const localVarFetchArgs = ImagesApiFetchParamCreator(configuration).createImageVariation(image, model, n, responseFormat, size, user, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * InvitesApi - fetch parameter creator
 * @export
 */
export const InvitesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an invite. If the invite has already been accepted, it cannot be deleted.
         * @throws {RequiredError}
         */
        deleteInvite(inviteId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'inviteId' is not null or undefined
            if (inviteId === null || inviteId === undefined) {
                throw new RequiredError('inviteId','Required parameter inviteId was null or undefined when calling deleteInvite.');
            }
            const localVarPath = `/organization/invites/{invite_id}`
                .replace(`{${"invite_id"}}`, encodeURIComponent(String(inviteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an invite for a user to the organization. The invite must be accepted by the user before they have access to the organization.
         * @throws {RequiredError}
         */
        inviteUser(inviteRequest: InviteRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'inviteRequest' is not null or undefined
            if (inviteRequest === null || inviteRequest === undefined) {
                throw new RequiredError('inviteRequest','Required parameter inviteRequest was null or undefined when calling inviteUser.');
            }
            const localVarPath = `/organization/invites`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof inviteRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inviteRequest != null ? inviteRequest : {}) : (((inviteRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of invites in the organization.
         * @throws {RequiredError}
         */
        listInvites(limit?: number, after?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/organization/invites`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves an invite.
         * @throws {RequiredError}
         */
        retrieveInvite(inviteId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'inviteId' is not null or undefined
            if (inviteId === null || inviteId === undefined) {
                throw new RequiredError('inviteId','Required parameter inviteId was null or undefined when calling retrieveInvite.');
            }
            const localVarPath = `/organization/invites/{invite_id}`
                .replace(`{${"invite_id"}}`, encodeURIComponent(String(inviteId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type InvitesApiType = { 
    deleteInvite(inviteId: string, options?: RequestOptions): Promise<InviteDeleteResponse>,

    inviteUser(inviteRequest: InviteRequest, options?: RequestOptions): Promise<Invite>,

    listInvites(limit?: number, after?: string, options?: RequestOptions): Promise<InviteListResponse>,

    retrieveInvite(inviteId: string, options?: RequestOptions): Promise<Invite>,
}

/**
 * InvitesApi - factory function to inject configuration 
 * @export
 */
export const InvitesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): InvitesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Delete an invite. If the invite has already been accepted, it cannot be deleted.
         * @throws {RequiredError}
         */
        deleteInvite(inviteId: string, options?: RequestOptions = {}): Promise<InviteDeleteResponse> {
            const localVarFetchArgs = InvitesApiFetchParamCreator(configuration).deleteInvite(inviteId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create an invite for a user to the organization. The invite must be accepted by the user before they have access to the organization.
         * @throws {RequiredError}
         */
        inviteUser(inviteRequest: InviteRequest, options?: RequestOptions = {}): Promise<Invite> {
            const localVarFetchArgs = InvitesApiFetchParamCreator(configuration).inviteUser(inviteRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of invites in the organization.
         * @throws {RequiredError}
         */
        listInvites(limit?: number, after?: string, options?: RequestOptions = {}): Promise<InviteListResponse> {
            const localVarFetchArgs = InvitesApiFetchParamCreator(configuration).listInvites(limit, after, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves an invite.
         * @throws {RequiredError}
         */
        retrieveInvite(inviteId: string, options?: RequestOptions = {}): Promise<Invite> {
            const localVarFetchArgs = InvitesApiFetchParamCreator(configuration).retrieveInvite(inviteId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ModelsApi - fetch parameter creator
 * @export
 */
export const ModelsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization to delete a model.
         * @throws {RequiredError}
         */
        deleteModel(model: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError('model','Required parameter model was null or undefined when calling deleteModel.');
            }
            const localVarPath = `/models/{model}`
                .replace(`{${"model"}}`, encodeURIComponent(String(model)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @throws {RequiredError}
         */
        listModels(options: RequestOptions): FetchArgs {
            const localVarPath = `/models`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @throws {RequiredError}
         */
        retrieveModel(model: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError('model','Required parameter model was null or undefined when calling retrieveModel.');
            }
            const localVarPath = `/models/{model}`
                .replace(`{${"model"}}`, encodeURIComponent(String(model)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ModelsApiType = { 
    deleteModel(model: string, options?: RequestOptions): Promise<DeleteModelResponse>,

    listModels(options?: RequestOptions): Promise<ListModelsResponse>,

    retrieveModel(model: string, options?: RequestOptions): Promise<Model>,
}

/**
 * ModelsApi - factory function to inject configuration 
 * @export
 */
export const ModelsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ModelsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization to delete a model.
         * @throws {RequiredError}
         */
        deleteModel(model: string, options?: RequestOptions = {}): Promise<DeleteModelResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).deleteModel(model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @throws {RequiredError}
         */
        listModels(options?: RequestOptions = {}): Promise<ListModelsResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).listModels(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @throws {RequiredError}
         */
        retrieveModel(model: string, options?: RequestOptions = {}): Promise<Model> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).retrieveModel(model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ModerationsApi - fetch parameter creator
 * @export
 */
export const ModerationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Classifies if text and/or image inputs are potentially harmful. Learn more in the [moderation guide](/docs/guides/moderation). 
         * @throws {RequiredError}
         */
        createModeration(createModerationRequest: CreateModerationRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createModerationRequest' is not null or undefined
            if (createModerationRequest === null || createModerationRequest === undefined) {
                throw new RequiredError('createModerationRequest','Required parameter createModerationRequest was null or undefined when calling createModeration.');
            }
            const localVarPath = `/moderations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createModerationRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createModerationRequest != null ? createModerationRequest : {}) : (((createModerationRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ModerationsApiType = { 
    createModeration(createModerationRequest: CreateModerationRequest, options?: RequestOptions): Promise<CreateModerationResponse>,
}

/**
 * ModerationsApi - factory function to inject configuration 
 * @export
 */
export const ModerationsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ModerationsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Classifies if text and/or image inputs are potentially harmful. Learn more in the [moderation guide](/docs/guides/moderation). 
         * @throws {RequiredError}
         */
        createModeration(createModerationRequest: CreateModerationRequest, options?: RequestOptions = {}): Promise<CreateModerationResponse> {
            const localVarFetchArgs = ModerationsApiFetchParamCreator(configuration).createModeration(createModerationRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ProjectsApi - fetch parameter creator
 * @export
 */
export const ProjectsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archives a project in the organization. Archived projects cannot be used or updated.
         * @throws {RequiredError}
         */
        archiveProject(projectId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling archiveProject.');
            }
            const localVarPath = `/organization/projects/{project_id}/archive`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new project in the organization. Projects can be created and archived, but cannot be deleted.
         * @throws {RequiredError}
         */
        createProject(projectCreateRequest: ProjectCreateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectCreateRequest' is not null or undefined
            if (projectCreateRequest === null || projectCreateRequest === undefined) {
                throw new RequiredError('projectCreateRequest','Required parameter projectCreateRequest was null or undefined when calling createProject.');
            }
            const localVarPath = `/organization/projects`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof projectCreateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(projectCreateRequest != null ? projectCreateRequest : {}) : (((projectCreateRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new service account in the project. This also returns an unredacted API key for the service account.
         * @throws {RequiredError}
         */
        createProjectServiceAccount(projectId: string, projectServiceAccountCreateRequest: ProjectServiceAccountCreateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling createProjectServiceAccount.');
            }
            // verify required parameter 'projectServiceAccountCreateRequest' is not null or undefined
            if (projectServiceAccountCreateRequest === null || projectServiceAccountCreateRequest === undefined) {
                throw new RequiredError('projectServiceAccountCreateRequest','Required parameter projectServiceAccountCreateRequest was null or undefined when calling createProjectServiceAccount.');
            }
            const localVarPath = `/organization/projects/{project_id}/service_accounts`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof projectServiceAccountCreateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(projectServiceAccountCreateRequest != null ? projectServiceAccountCreateRequest : {}) : (((projectServiceAccountCreateRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a user to the project. Users must already be members of the organization to be added to a project.
         * @throws {RequiredError}
         */
        createProjectUser(projectId: string, projectUserCreateRequest: ProjectUserCreateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling createProjectUser.');
            }
            // verify required parameter 'projectUserCreateRequest' is not null or undefined
            if (projectUserCreateRequest === null || projectUserCreateRequest === undefined) {
                throw new RequiredError('projectUserCreateRequest','Required parameter projectUserCreateRequest was null or undefined when calling createProjectUser.');
            }
            const localVarPath = `/organization/projects/{project_id}/users`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof projectUserCreateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(projectUserCreateRequest != null ? projectUserCreateRequest : {}) : (((projectUserCreateRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an API key from the project.
         * @throws {RequiredError}
         */
        deleteProjectApiKey(projectId: string, keyId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling deleteProjectApiKey.');
            }
            // verify required parameter 'keyId' is not null or undefined
            if (keyId === null || keyId === undefined) {
                throw new RequiredError('keyId','Required parameter keyId was null or undefined when calling deleteProjectApiKey.');
            }
            const localVarPath = `/organization/projects/{project_id}/api_keys/{key_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a service account from the project.
         * @throws {RequiredError}
         */
        deleteProjectServiceAccount(projectId: string, serviceAccountId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling deleteProjectServiceAccount.');
            }
            // verify required parameter 'serviceAccountId' is not null or undefined
            if (serviceAccountId === null || serviceAccountId === undefined) {
                throw new RequiredError('serviceAccountId','Required parameter serviceAccountId was null or undefined when calling deleteProjectServiceAccount.');
            }
            const localVarPath = `/organization/projects/{project_id}/service_accounts/{service_account_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"service_account_id"}}`, encodeURIComponent(String(serviceAccountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a user from the project.
         * @throws {RequiredError}
         */
        deleteProjectUser(projectId: string, userId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling deleteProjectUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteProjectUser.');
            }
            const localVarPath = `/organization/projects/{project_id}/users/{user_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of API keys in the project.
         * @throws {RequiredError}
         */
        listProjectApiKeys(projectId: string, limit?: number, after?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling listProjectApiKeys.');
            }
            const localVarPath = `/organization/projects/{project_id}/api_keys`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the rate limits per model for a project.
         * @throws {RequiredError}
         */
        listProjectRateLimits(projectId: string, limit?: number, after?: string, before?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling listProjectRateLimits.');
            }
            const localVarPath = `/organization/projects/{project_id}/rate_limits`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = ((before:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of service accounts in the project.
         * @throws {RequiredError}
         */
        listProjectServiceAccounts(projectId: string, limit?: number, after?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling listProjectServiceAccounts.');
            }
            const localVarPath = `/organization/projects/{project_id}/service_accounts`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of users in the project.
         * @throws {RequiredError}
         */
        listProjectUsers(projectId: string, limit?: number, after?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling listProjectUsers.');
            }
            const localVarPath = `/organization/projects/{project_id}/users`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of projects.
         * @throws {RequiredError}
         */
        listProjects(limit?: number, after?: string, includeArchived?: boolean, options: RequestOptions): FetchArgs {
            const localVarPath = `/organization/projects`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (includeArchived !== undefined) {
                localVarQueryParameter['include_archived'] = ((includeArchived:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a project in the organization.
         * @throws {RequiredError}
         */
        modifyProject(projectId: string, projectUpdateRequest: ProjectUpdateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling modifyProject.');
            }
            // verify required parameter 'projectUpdateRequest' is not null or undefined
            if (projectUpdateRequest === null || projectUpdateRequest === undefined) {
                throw new RequiredError('projectUpdateRequest','Required parameter projectUpdateRequest was null or undefined when calling modifyProject.');
            }
            const localVarPath = `/organization/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof projectUpdateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(projectUpdateRequest != null ? projectUpdateRequest : {}) : (((projectUpdateRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a user\'s role in the project.
         * @throws {RequiredError}
         */
        modifyProjectUser(projectId: string, userId: string, projectUserUpdateRequest: ProjectUserUpdateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling modifyProjectUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling modifyProjectUser.');
            }
            // verify required parameter 'projectUserUpdateRequest' is not null or undefined
            if (projectUserUpdateRequest === null || projectUserUpdateRequest === undefined) {
                throw new RequiredError('projectUserUpdateRequest','Required parameter projectUserUpdateRequest was null or undefined when calling modifyProjectUser.');
            }
            const localVarPath = `/organization/projects/{project_id}/users/{user_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof projectUserUpdateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(projectUserUpdateRequest != null ? projectUserUpdateRequest : {}) : (((projectUserUpdateRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a project.
         * @throws {RequiredError}
         */
        retrieveProject(projectId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling retrieveProject.');
            }
            const localVarPath = `/organization/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves an API key in the project.
         * @throws {RequiredError}
         */
        retrieveProjectApiKey(projectId: string, keyId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling retrieveProjectApiKey.');
            }
            // verify required parameter 'keyId' is not null or undefined
            if (keyId === null || keyId === undefined) {
                throw new RequiredError('keyId','Required parameter keyId was null or undefined when calling retrieveProjectApiKey.');
            }
            const localVarPath = `/organization/projects/{project_id}/api_keys/{key_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a service account in the project.
         * @throws {RequiredError}
         */
        retrieveProjectServiceAccount(projectId: string, serviceAccountId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling retrieveProjectServiceAccount.');
            }
            // verify required parameter 'serviceAccountId' is not null or undefined
            if (serviceAccountId === null || serviceAccountId === undefined) {
                throw new RequiredError('serviceAccountId','Required parameter serviceAccountId was null or undefined when calling retrieveProjectServiceAccount.');
            }
            const localVarPath = `/organization/projects/{project_id}/service_accounts/{service_account_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"service_account_id"}}`, encodeURIComponent(String(serviceAccountId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a user in the project.
         * @throws {RequiredError}
         */
        retrieveProjectUser(projectId: string, userId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling retrieveProjectUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling retrieveProjectUser.');
            }
            const localVarPath = `/organization/projects/{project_id}/users/{user_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a project rate limit.
         * @throws {RequiredError}
         */
        updateProjectRateLimits(projectId: string, rateLimitId: string, projectRateLimitUpdateRequest: ProjectRateLimitUpdateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling updateProjectRateLimits.');
            }
            // verify required parameter 'rateLimitId' is not null or undefined
            if (rateLimitId === null || rateLimitId === undefined) {
                throw new RequiredError('rateLimitId','Required parameter rateLimitId was null or undefined when calling updateProjectRateLimits.');
            }
            // verify required parameter 'projectRateLimitUpdateRequest' is not null or undefined
            if (projectRateLimitUpdateRequest === null || projectRateLimitUpdateRequest === undefined) {
                throw new RequiredError('projectRateLimitUpdateRequest','Required parameter projectRateLimitUpdateRequest was null or undefined when calling updateProjectRateLimits.');
            }
            const localVarPath = `/organization/projects/{project_id}/rate_limits/{rate_limit_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"rate_limit_id"}}`, encodeURIComponent(String(rateLimitId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof projectRateLimitUpdateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(projectRateLimitUpdateRequest != null ? projectRateLimitUpdateRequest : {}) : (((projectRateLimitUpdateRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ProjectsApiType = { 
    archiveProject(projectId: string, options?: RequestOptions): Promise<Project>,

    createProject(projectCreateRequest: ProjectCreateRequest, options?: RequestOptions): Promise<Project>,

    createProjectServiceAccount(projectId: string, projectServiceAccountCreateRequest: ProjectServiceAccountCreateRequest, options?: RequestOptions): Promise<ProjectServiceAccountCreateResponse>,

    createProjectUser(projectId: string, projectUserCreateRequest: ProjectUserCreateRequest, options?: RequestOptions): Promise<ProjectUser>,

    deleteProjectApiKey(projectId: string, keyId: string, options?: RequestOptions): Promise<ProjectApiKeyDeleteResponse>,

    deleteProjectServiceAccount(projectId: string, serviceAccountId: string, options?: RequestOptions): Promise<ProjectServiceAccountDeleteResponse>,

    deleteProjectUser(projectId: string, userId: string, options?: RequestOptions): Promise<ProjectUserDeleteResponse>,

    listProjectApiKeys(projectId: string, limit?: number, after?: string, options?: RequestOptions): Promise<ProjectApiKeyListResponse>,

    listProjectRateLimits(projectId: string, limit?: number, after?: string, before?: string, options?: RequestOptions): Promise<ProjectRateLimitListResponse>,

    listProjectServiceAccounts(projectId: string, limit?: number, after?: string, options?: RequestOptions): Promise<ProjectServiceAccountListResponse>,

    listProjectUsers(projectId: string, limit?: number, after?: string, options?: RequestOptions): Promise<ProjectUserListResponse>,

    listProjects(limit?: number, after?: string, includeArchived?: boolean, options?: RequestOptions): Promise<ProjectListResponse>,

    modifyProject(projectId: string, projectUpdateRequest: ProjectUpdateRequest, options?: RequestOptions): Promise<Project>,

    modifyProjectUser(projectId: string, userId: string, projectUserUpdateRequest: ProjectUserUpdateRequest, options?: RequestOptions): Promise<ProjectUser>,

    retrieveProject(projectId: string, options?: RequestOptions): Promise<Project>,

    retrieveProjectApiKey(projectId: string, keyId: string, options?: RequestOptions): Promise<ProjectApiKey>,

    retrieveProjectServiceAccount(projectId: string, serviceAccountId: string, options?: RequestOptions): Promise<ProjectServiceAccount>,

    retrieveProjectUser(projectId: string, userId: string, options?: RequestOptions): Promise<ProjectUser>,

    updateProjectRateLimits(projectId: string, rateLimitId: string, projectRateLimitUpdateRequest: ProjectRateLimitUpdateRequest, options?: RequestOptions): Promise<ProjectRateLimit>,
}

/**
 * ProjectsApi - factory function to inject configuration 
 * @export
 */
export const ProjectsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ProjectsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Archives a project in the organization. Archived projects cannot be used or updated.
         * @throws {RequiredError}
         */
        archiveProject(projectId: string, options?: RequestOptions = {}): Promise<Project> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).archiveProject(projectId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create a new project in the organization. Projects can be created and archived, but cannot be deleted.
         * @throws {RequiredError}
         */
        createProject(projectCreateRequest: ProjectCreateRequest, options?: RequestOptions = {}): Promise<Project> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).createProject(projectCreateRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Creates a new service account in the project. This also returns an unredacted API key for the service account.
         * @throws {RequiredError}
         */
        createProjectServiceAccount(projectId: string, projectServiceAccountCreateRequest: ProjectServiceAccountCreateRequest, options?: RequestOptions = {}): Promise<ProjectServiceAccountCreateResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).createProjectServiceAccount(projectId, projectServiceAccountCreateRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Adds a user to the project. Users must already be members of the organization to be added to a project.
         * @throws {RequiredError}
         */
        createProjectUser(projectId: string, projectUserCreateRequest: ProjectUserCreateRequest, options?: RequestOptions = {}): Promise<ProjectUser> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).createProjectUser(projectId, projectUserCreateRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Deletes an API key from the project.
         * @throws {RequiredError}
         */
        deleteProjectApiKey(projectId: string, keyId: string, options?: RequestOptions = {}): Promise<ProjectApiKeyDeleteResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).deleteProjectApiKey(projectId, keyId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Deletes a service account from the project.
         * @throws {RequiredError}
         */
        deleteProjectServiceAccount(projectId: string, serviceAccountId: string, options?: RequestOptions = {}): Promise<ProjectServiceAccountDeleteResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).deleteProjectServiceAccount(projectId, serviceAccountId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Deletes a user from the project.
         * @throws {RequiredError}
         */
        deleteProjectUser(projectId: string, userId: string, options?: RequestOptions = {}): Promise<ProjectUserDeleteResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).deleteProjectUser(projectId, userId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of API keys in the project.
         * @throws {RequiredError}
         */
        listProjectApiKeys(projectId: string, limit?: number, after?: string, options?: RequestOptions = {}): Promise<ProjectApiKeyListResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjectApiKeys(projectId, limit, after, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns the rate limits per model for a project.
         * @throws {RequiredError}
         */
        listProjectRateLimits(projectId: string, limit?: number, after?: string, before?: string, options?: RequestOptions = {}): Promise<ProjectRateLimitListResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjectRateLimits(projectId, limit, after, before, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of service accounts in the project.
         * @throws {RequiredError}
         */
        listProjectServiceAccounts(projectId: string, limit?: number, after?: string, options?: RequestOptions = {}): Promise<ProjectServiceAccountListResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjectServiceAccounts(projectId, limit, after, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of users in the project.
         * @throws {RequiredError}
         */
        listProjectUsers(projectId: string, limit?: number, after?: string, options?: RequestOptions = {}): Promise<ProjectUserListResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjectUsers(projectId, limit, after, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of projects.
         * @throws {RequiredError}
         */
        listProjects(limit?: number, after?: string, includeArchived?: boolean, options?: RequestOptions = {}): Promise<ProjectListResponse> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).listProjects(limit, after, includeArchived, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Modifies a project in the organization.
         * @throws {RequiredError}
         */
        modifyProject(projectId: string, projectUpdateRequest: ProjectUpdateRequest, options?: RequestOptions = {}): Promise<Project> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).modifyProject(projectId, projectUpdateRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Modifies a user\'s role in the project.
         * @throws {RequiredError}
         */
        modifyProjectUser(projectId: string, userId: string, projectUserUpdateRequest: ProjectUserUpdateRequest, options?: RequestOptions = {}): Promise<ProjectUser> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).modifyProjectUser(projectId, userId, projectUserUpdateRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a project.
         * @throws {RequiredError}
         */
        retrieveProject(projectId: string, options?: RequestOptions = {}): Promise<Project> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).retrieveProject(projectId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves an API key in the project.
         * @throws {RequiredError}
         */
        retrieveProjectApiKey(projectId: string, keyId: string, options?: RequestOptions = {}): Promise<ProjectApiKey> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).retrieveProjectApiKey(projectId, keyId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a service account in the project.
         * @throws {RequiredError}
         */
        retrieveProjectServiceAccount(projectId: string, serviceAccountId: string, options?: RequestOptions = {}): Promise<ProjectServiceAccount> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).retrieveProjectServiceAccount(projectId, serviceAccountId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a user in the project.
         * @throws {RequiredError}
         */
        retrieveProjectUser(projectId: string, userId: string, options?: RequestOptions = {}): Promise<ProjectUser> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).retrieveProjectUser(projectId, userId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Updates a project rate limit.
         * @throws {RequiredError}
         */
        updateProjectRateLimits(projectId: string, rateLimitId: string, projectRateLimitUpdateRequest: ProjectRateLimitUpdateRequest, options?: RequestOptions = {}): Promise<ProjectRateLimit> {
            const localVarFetchArgs = ProjectsApiFetchParamCreator(configuration).updateProjectRateLimits(projectId, rateLimitId, projectRateLimitUpdateRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * RealtimeApi - fetch parameter creator
 * @export
 */
export const RealtimeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an ephemeral API token for use in client-side applications with the Realtime API. Can be configured with the same session parameters as the `session.update` client event.  It responds with a session object, plus a `client_secret` key which contains a usable ephemeral API token that can be used to authenticate browser clients for the Realtime API. 
         * @throws {RequiredError}
         */
        createRealtimeSession(realtimeSessionCreateRequest: RealtimeSessionCreateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'realtimeSessionCreateRequest' is not null or undefined
            if (realtimeSessionCreateRequest === null || realtimeSessionCreateRequest === undefined) {
                throw new RequiredError('realtimeSessionCreateRequest','Required parameter realtimeSessionCreateRequest was null or undefined when calling createRealtimeSession.');
            }
            const localVarPath = `/realtime/sessions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof realtimeSessionCreateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(realtimeSessionCreateRequest != null ? realtimeSessionCreateRequest : {}) : (((realtimeSessionCreateRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type RealtimeApiType = { 
    createRealtimeSession(realtimeSessionCreateRequest: RealtimeSessionCreateRequest, options?: RequestOptions): Promise<RealtimeSessionCreateResponse>,
}

/**
 * RealtimeApi - factory function to inject configuration 
 * @export
 */
export const RealtimeApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): RealtimeApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Create an ephemeral API token for use in client-side applications with the Realtime API. Can be configured with the same session parameters as the `session.update` client event.  It responds with a session object, plus a `client_secret` key which contains a usable ephemeral API token that can be used to authenticate browser clients for the Realtime API. 
         * @throws {RequiredError}
         */
        createRealtimeSession(realtimeSessionCreateRequest: RealtimeSessionCreateRequest, options?: RequestOptions = {}): Promise<RealtimeSessionCreateResponse> {
            const localVarFetchArgs = RealtimeApiFetchParamCreator(configuration).createRealtimeSession(realtimeSessionCreateRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UploadsApi - fetch parameter creator
 * @export
 */
export const UploadsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a [Part](/docs/api-reference/uploads/part-object) to an [Upload](/docs/api-reference/uploads/object) object. A Part represents a chunk of bytes from the file you are trying to upload.   Each Part can be at most 64 MB, and you can add Parts until you hit the Upload maximum of 8 GB.  It is possible to add multiple Parts in parallel. You can decide the intended order of the Parts when you [complete the Upload](/docs/api-reference/uploads/complete). 
         * @throws {RequiredError}
         */
        addUploadPart(uploadId: string, data: File, options: RequestOptions): FetchArgs {
            // verify required parameter 'uploadId' is not null or undefined
            if (uploadId === null || uploadId === undefined) {
                throw new RequiredError('uploadId','Required parameter uploadId was null or undefined when calling addUploadPart.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new RequiredError('data','Required parameter data was null or undefined when calling addUploadPart.');
            }
            const localVarPath = `/uploads/{upload_id}/parts`
                .replace(`{${"upload_id"}}`, encodeURIComponent(String(uploadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication ApiKeyAuth required

            if (data !== undefined) {
                localVarFormParams.set('data', ((data:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels the Upload. No Parts may be added after an Upload is cancelled. 
         * @throws {RequiredError}
         */
        cancelUpload(uploadId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'uploadId' is not null or undefined
            if (uploadId === null || uploadId === undefined) {
                throw new RequiredError('uploadId','Required parameter uploadId was null or undefined when calling cancelUpload.');
            }
            const localVarPath = `/uploads/{upload_id}/cancel`
                .replace(`{${"upload_id"}}`, encodeURIComponent(String(uploadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Completes the [Upload](/docs/api-reference/uploads/object).   Within the returned Upload object, there is a nested [File](/docs/api-reference/files/object) object that is ready to use in the rest of the platform.  You can specify the order of the Parts by passing in an ordered list of the Part IDs.  The number of bytes uploaded upon completion must match the number of bytes initially specified when creating the Upload object. No Parts may be added after an Upload is completed. 
         * @throws {RequiredError}
         */
        completeUpload(uploadId: string, completeUploadRequest: CompleteUploadRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'uploadId' is not null or undefined
            if (uploadId === null || uploadId === undefined) {
                throw new RequiredError('uploadId','Required parameter uploadId was null or undefined when calling completeUpload.');
            }
            // verify required parameter 'completeUploadRequest' is not null or undefined
            if (completeUploadRequest === null || completeUploadRequest === undefined) {
                throw new RequiredError('completeUploadRequest','Required parameter completeUploadRequest was null or undefined when calling completeUpload.');
            }
            const localVarPath = `/uploads/{upload_id}/complete`
                .replace(`{${"upload_id"}}`, encodeURIComponent(String(uploadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof completeUploadRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(completeUploadRequest != null ? completeUploadRequest : {}) : (((completeUploadRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an intermediate [Upload](/docs/api-reference/uploads/object) object that you can add [Parts](/docs/api-reference/uploads/part-object) to. Currently, an Upload can accept at most 8 GB in total and expires after an hour after you create it.  Once you complete the Upload, we will create a [File](/docs/api-reference/files/object) object that contains all the parts you uploaded. This File is usable in the rest of our platform as a regular File object.  For certain `purpose`s, the correct `mime_type` must be specified. Please refer to documentation for the supported MIME types for your use case: - [Assistants](/docs/assistants/tools/file-search#supported-files)  For guidance on the proper filename extensions for each purpose, please follow the documentation on [creating a File](/docs/api-reference/files/create). 
         * @throws {RequiredError}
         */
        createUpload(createUploadRequest: CreateUploadRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createUploadRequest' is not null or undefined
            if (createUploadRequest === null || createUploadRequest === undefined) {
                throw new RequiredError('createUploadRequest','Required parameter createUploadRequest was null or undefined when calling createUpload.');
            }
            const localVarPath = `/uploads`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createUploadRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createUploadRequest != null ? createUploadRequest : {}) : (((createUploadRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UploadsApiType = { 
    addUploadPart(uploadId: string, data: File, options?: RequestOptions): Promise<UploadPart>,

    cancelUpload(uploadId: string, options?: RequestOptions): Promise<Upload>,

    completeUpload(uploadId: string, completeUploadRequest: CompleteUploadRequest, options?: RequestOptions): Promise<Upload>,

    createUpload(createUploadRequest: CreateUploadRequest, options?: RequestOptions): Promise<Upload>,
}

/**
 * UploadsApi - factory function to inject configuration 
 * @export
 */
export const UploadsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UploadsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Adds a [Part](/docs/api-reference/uploads/part-object) to an [Upload](/docs/api-reference/uploads/object) object. A Part represents a chunk of bytes from the file you are trying to upload.   Each Part can be at most 64 MB, and you can add Parts until you hit the Upload maximum of 8 GB.  It is possible to add multiple Parts in parallel. You can decide the intended order of the Parts when you [complete the Upload](/docs/api-reference/uploads/complete). 
         * @throws {RequiredError}
         */
        addUploadPart(uploadId: string, data: File, options?: RequestOptions = {}): Promise<UploadPart> {
            const localVarFetchArgs = UploadsApiFetchParamCreator(configuration).addUploadPart(uploadId, data, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Cancels the Upload. No Parts may be added after an Upload is cancelled. 
         * @throws {RequiredError}
         */
        cancelUpload(uploadId: string, options?: RequestOptions = {}): Promise<Upload> {
            const localVarFetchArgs = UploadsApiFetchParamCreator(configuration).cancelUpload(uploadId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Completes the [Upload](/docs/api-reference/uploads/object).   Within the returned Upload object, there is a nested [File](/docs/api-reference/files/object) object that is ready to use in the rest of the platform.  You can specify the order of the Parts by passing in an ordered list of the Part IDs.  The number of bytes uploaded upon completion must match the number of bytes initially specified when creating the Upload object. No Parts may be added after an Upload is completed. 
         * @throws {RequiredError}
         */
        completeUpload(uploadId: string, completeUploadRequest: CompleteUploadRequest, options?: RequestOptions = {}): Promise<Upload> {
            const localVarFetchArgs = UploadsApiFetchParamCreator(configuration).completeUpload(uploadId, completeUploadRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Creates an intermediate [Upload](/docs/api-reference/uploads/object) object that you can add [Parts](/docs/api-reference/uploads/part-object) to. Currently, an Upload can accept at most 8 GB in total and expires after an hour after you create it.  Once you complete the Upload, we will create a [File](/docs/api-reference/files/object) object that contains all the parts you uploaded. This File is usable in the rest of our platform as a regular File object.  For certain `purpose`s, the correct `mime_type` must be specified. Please refer to documentation for the supported MIME types for your use case: - [Assistants](/docs/assistants/tools/file-search#supported-files)  For guidance on the proper filename extensions for each purpose, please follow the documentation on [creating a File](/docs/api-reference/files/create). 
         * @throws {RequiredError}
         */
        createUpload(createUploadRequest: CreateUploadRequest, options?: RequestOptions = {}): Promise<Upload> {
            const localVarFetchArgs = UploadsApiFetchParamCreator(configuration).createUpload(createUploadRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UsageApi - fetch parameter creator
 * @export
 */
export const UsageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get audio speeches usage details for the organization.
         * @throws {RequiredError}
         */
        usageAudioSpeeches(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'startTime' is not null or undefined
            if (startTime === null || startTime === undefined) {
                throw new RequiredError('startTime','Required parameter startTime was null or undefined when calling usageAudioSpeeches.');
            }
            const localVarPath = `/organization/usage/audio_speeches`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = ((startTime:any):string);
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = ((endTime:any):string);
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = ((bucketWidth:any):string);
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }

            if (apiKeyIds) {
                localVarQueryParameter['api_key_ids'] = apiKeyIds;
            }

            if (models) {
                localVarQueryParameter['models'] = models;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get audio transcriptions usage details for the organization.
         * @throws {RequiredError}
         */
        usageAudioTranscriptions(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'startTime' is not null or undefined
            if (startTime === null || startTime === undefined) {
                throw new RequiredError('startTime','Required parameter startTime was null or undefined when calling usageAudioTranscriptions.');
            }
            const localVarPath = `/organization/usage/audio_transcriptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = ((startTime:any):string);
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = ((endTime:any):string);
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = ((bucketWidth:any):string);
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }

            if (apiKeyIds) {
                localVarQueryParameter['api_key_ids'] = apiKeyIds;
            }

            if (models) {
                localVarQueryParameter['models'] = models;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get code interpreter sessions usage details for the organization.
         * @throws {RequiredError}
         */
        usageCodeInterpreterSessions(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, groupBy?: Array<'project_id'>, limit?: number, page?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'startTime' is not null or undefined
            if (startTime === null || startTime === undefined) {
                throw new RequiredError('startTime','Required parameter startTime was null or undefined when calling usageCodeInterpreterSessions.');
            }
            const localVarPath = `/organization/usage/code_interpreter_sessions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = ((startTime:any):string);
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = ((endTime:any):string);
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = ((bucketWidth:any):string);
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get completions usage details for the organization.
         * @throws {RequiredError}
         */
        usageCompletions(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, batch?: boolean, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model' | 'batch'>, limit?: number, page?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'startTime' is not null or undefined
            if (startTime === null || startTime === undefined) {
                throw new RequiredError('startTime','Required parameter startTime was null or undefined when calling usageCompletions.');
            }
            const localVarPath = `/organization/usage/completions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = ((startTime:any):string);
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = ((endTime:any):string);
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = ((bucketWidth:any):string);
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }

            if (apiKeyIds) {
                localVarQueryParameter['api_key_ids'] = apiKeyIds;
            }

            if (models) {
                localVarQueryParameter['models'] = models;
            }

            if (batch !== undefined) {
                localVarQueryParameter['batch'] = ((batch:any):string);
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get costs details for the organization.
         * @throws {RequiredError}
         */
        usageCosts(startTime: number, endTime?: number, bucketWidth?: '1d', projectIds?: Array<string>, groupBy?: Array<'project_id' | 'line_item'>, limit?: number, page?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'startTime' is not null or undefined
            if (startTime === null || startTime === undefined) {
                throw new RequiredError('startTime','Required parameter startTime was null or undefined when calling usageCosts.');
            }
            const localVarPath = `/organization/costs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = ((startTime:any):string);
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = ((endTime:any):string);
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = ((bucketWidth:any):string);
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get embeddings usage details for the organization.
         * @throws {RequiredError}
         */
        usageEmbeddings(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'startTime' is not null or undefined
            if (startTime === null || startTime === undefined) {
                throw new RequiredError('startTime','Required parameter startTime was null or undefined when calling usageEmbeddings.');
            }
            const localVarPath = `/organization/usage/embeddings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = ((startTime:any):string);
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = ((endTime:any):string);
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = ((bucketWidth:any):string);
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }

            if (apiKeyIds) {
                localVarQueryParameter['api_key_ids'] = apiKeyIds;
            }

            if (models) {
                localVarQueryParameter['models'] = models;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get images usage details for the organization.
         * @throws {RequiredError}
         */
        usageImages(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', sources?: Array<'image.generation' | 'image.edit' | 'image.variation'>, sizes?: Array<'256x256' | '512x512' | '1024x1024' | '1792x1792' | '1024x1792'>, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model' | 'size' | 'source'>, limit?: number, page?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'startTime' is not null or undefined
            if (startTime === null || startTime === undefined) {
                throw new RequiredError('startTime','Required parameter startTime was null or undefined when calling usageImages.');
            }
            const localVarPath = `/organization/usage/images`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = ((startTime:any):string);
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = ((endTime:any):string);
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = ((bucketWidth:any):string);
            }

            if (sources) {
                localVarQueryParameter['sources'] = sources;
            }

            if (sizes) {
                localVarQueryParameter['sizes'] = sizes;
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }

            if (apiKeyIds) {
                localVarQueryParameter['api_key_ids'] = apiKeyIds;
            }

            if (models) {
                localVarQueryParameter['models'] = models;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get moderations usage details for the organization.
         * @throws {RequiredError}
         */
        usageModerations(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'startTime' is not null or undefined
            if (startTime === null || startTime === undefined) {
                throw new RequiredError('startTime','Required parameter startTime was null or undefined when calling usageModerations.');
            }
            const localVarPath = `/organization/usage/moderations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = ((startTime:any):string);
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = ((endTime:any):string);
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = ((bucketWidth:any):string);
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }

            if (apiKeyIds) {
                localVarQueryParameter['api_key_ids'] = apiKeyIds;
            }

            if (models) {
                localVarQueryParameter['models'] = models;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get vector stores usage details for the organization.
         * @throws {RequiredError}
         */
        usageVectorStores(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, groupBy?: Array<'project_id'>, limit?: number, page?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'startTime' is not null or undefined
            if (startTime === null || startTime === undefined) {
                throw new RequiredError('startTime','Required parameter startTime was null or undefined when calling usageVectorStores.');
            }
            const localVarPath = `/organization/usage/vector_stores`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = ((startTime:any):string);
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = ((endTime:any):string);
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = ((bucketWidth:any):string);
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = ((page:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UsageApiType = { 
    usageAudioSpeeches(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, options?: RequestOptions): Promise<UsageResponse>,

    usageAudioTranscriptions(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, options?: RequestOptions): Promise<UsageResponse>,

    usageCodeInterpreterSessions(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, groupBy?: Array<'project_id'>, limit?: number, page?: string, options?: RequestOptions): Promise<UsageResponse>,

    usageCompletions(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, batch?: boolean, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model' | 'batch'>, limit?: number, page?: string, options?: RequestOptions): Promise<UsageResponse>,

    usageCosts(startTime: number, endTime?: number, bucketWidth?: '1d', projectIds?: Array<string>, groupBy?: Array<'project_id' | 'line_item'>, limit?: number, page?: string, options?: RequestOptions): Promise<UsageResponse>,

    usageEmbeddings(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, options?: RequestOptions): Promise<UsageResponse>,

    usageImages(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', sources?: Array<'image.generation' | 'image.edit' | 'image.variation'>, sizes?: Array<'256x256' | '512x512' | '1024x1024' | '1792x1792' | '1024x1792'>, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model' | 'size' | 'source'>, limit?: number, page?: string, options?: RequestOptions): Promise<UsageResponse>,

    usageModerations(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, options?: RequestOptions): Promise<UsageResponse>,

    usageVectorStores(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, groupBy?: Array<'project_id'>, limit?: number, page?: string, options?: RequestOptions): Promise<UsageResponse>,
}

/**
 * UsageApi - factory function to inject configuration 
 * @export
 */
export const UsageApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UsageApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Get audio speeches usage details for the organization.
         * @throws {RequiredError}
         */
        usageAudioSpeeches(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, options?: RequestOptions = {}): Promise<UsageResponse> {
            const localVarFetchArgs = UsageApiFetchParamCreator(configuration).usageAudioSpeeches(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get audio transcriptions usage details for the organization.
         * @throws {RequiredError}
         */
        usageAudioTranscriptions(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, options?: RequestOptions = {}): Promise<UsageResponse> {
            const localVarFetchArgs = UsageApiFetchParamCreator(configuration).usageAudioTranscriptions(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get code interpreter sessions usage details for the organization.
         * @throws {RequiredError}
         */
        usageCodeInterpreterSessions(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, groupBy?: Array<'project_id'>, limit?: number, page?: string, options?: RequestOptions = {}): Promise<UsageResponse> {
            const localVarFetchArgs = UsageApiFetchParamCreator(configuration).usageCodeInterpreterSessions(startTime, endTime, bucketWidth, projectIds, groupBy, limit, page, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get completions usage details for the organization.
         * @throws {RequiredError}
         */
        usageCompletions(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, batch?: boolean, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model' | 'batch'>, limit?: number, page?: string, options?: RequestOptions = {}): Promise<UsageResponse> {
            const localVarFetchArgs = UsageApiFetchParamCreator(configuration).usageCompletions(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, batch, groupBy, limit, page, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get costs details for the organization.
         * @throws {RequiredError}
         */
        usageCosts(startTime: number, endTime?: number, bucketWidth?: '1d', projectIds?: Array<string>, groupBy?: Array<'project_id' | 'line_item'>, limit?: number, page?: string, options?: RequestOptions = {}): Promise<UsageResponse> {
            const localVarFetchArgs = UsageApiFetchParamCreator(configuration).usageCosts(startTime, endTime, bucketWidth, projectIds, groupBy, limit, page, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get embeddings usage details for the organization.
         * @throws {RequiredError}
         */
        usageEmbeddings(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, options?: RequestOptions = {}): Promise<UsageResponse> {
            const localVarFetchArgs = UsageApiFetchParamCreator(configuration).usageEmbeddings(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get images usage details for the organization.
         * @throws {RequiredError}
         */
        usageImages(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', sources?: Array<'image.generation' | 'image.edit' | 'image.variation'>, sizes?: Array<'256x256' | '512x512' | '1024x1024' | '1792x1792' | '1024x1792'>, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model' | 'size' | 'source'>, limit?: number, page?: string, options?: RequestOptions = {}): Promise<UsageResponse> {
            const localVarFetchArgs = UsageApiFetchParamCreator(configuration).usageImages(startTime, endTime, bucketWidth, sources, sizes, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get moderations usage details for the organization.
         * @throws {RequiredError}
         */
        usageModerations(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, options?: RequestOptions = {}): Promise<UsageResponse> {
            const localVarFetchArgs = UsageApiFetchParamCreator(configuration).usageModerations(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get vector stores usage details for the organization.
         * @throws {RequiredError}
         */
        usageVectorStores(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, groupBy?: Array<'project_id'>, limit?: number, page?: string, options?: RequestOptions = {}): Promise<UsageResponse> {
            const localVarFetchArgs = UsageApiFetchParamCreator(configuration).usageVectorStores(startTime, endTime, bucketWidth, projectIds, groupBy, limit, page, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a user from the organization.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/organization/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all of the users in the organization.
         * @throws {RequiredError}
         */
        listUsers(limit?: number, after?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/organization/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a user\'s role in the organization.
         * @throws {RequiredError}
         */
        modifyUser(userId: string, userRoleUpdateRequest: UserRoleUpdateRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling modifyUser.');
            }
            // verify required parameter 'userRoleUpdateRequest' is not null or undefined
            if (userRoleUpdateRequest === null || userRoleUpdateRequest === undefined) {
                throw new RequiredError('userRoleUpdateRequest','Required parameter userRoleUpdateRequest was null or undefined when calling modifyUser.');
            }
            const localVarPath = `/organization/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof userRoleUpdateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(userRoleUpdateRequest != null ? userRoleUpdateRequest : {}) : (((userRoleUpdateRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a user by their identifier.
         * @throws {RequiredError}
         */
        retrieveUser(userId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling retrieveUser.');
            }
            const localVarPath = `/organization/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UsersApiType = { 
    deleteUser(userId: string, options?: RequestOptions): Promise<UserDeleteResponse>,

    listUsers(limit?: number, after?: string, options?: RequestOptions): Promise<UserListResponse>,

    modifyUser(userId: string, userRoleUpdateRequest: UserRoleUpdateRequest, options?: RequestOptions): Promise<User>,

    retrieveUser(userId: string, options?: RequestOptions): Promise<User>,
}

/**
 * UsersApi - factory function to inject configuration 
 * @export
 */
export const UsersApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UsersApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Deletes a user from the organization.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: RequestOptions = {}): Promise<UserDeleteResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteUser(userId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Lists all of the users in the organization.
         * @throws {RequiredError}
         */
        listUsers(limit?: number, after?: string, options?: RequestOptions = {}): Promise<UserListResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).listUsers(limit, after, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Modifies a user\'s role in the organization.
         * @throws {RequiredError}
         */
        modifyUser(userId: string, userRoleUpdateRequest: UserRoleUpdateRequest, options?: RequestOptions = {}): Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).modifyUser(userId, userRoleUpdateRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a user by their identifier.
         * @throws {RequiredError}
         */
        retrieveUser(userId: string, options?: RequestOptions = {}): Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).retrieveUser(userId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * VectorStoresApi - fetch parameter creator
 * @export
 */
export const VectorStoresApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
         * @throws {RequiredError}
         */
        cancelVectorStoreFileBatch(vectorStoreId: string, batchId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'vectorStoreId' is not null or undefined
            if (vectorStoreId === null || vectorStoreId === undefined) {
                throw new RequiredError('vectorStoreId','Required parameter vectorStoreId was null or undefined when calling cancelVectorStoreFileBatch.');
            }
            // verify required parameter 'batchId' is not null or undefined
            if (batchId === null || batchId === undefined) {
                throw new RequiredError('batchId','Required parameter batchId was null or undefined when calling cancelVectorStoreFileBatch.');
            }
            const localVarPath = `/vector_stores/{vector_store_id}/file_batches/{batch_id}/cancel`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)))
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a vector store.
         * @throws {RequiredError}
         */
        createVectorStore(createVectorStoreRequest: CreateVectorStoreRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createVectorStoreRequest' is not null or undefined
            if (createVectorStoreRequest === null || createVectorStoreRequest === undefined) {
                throw new RequiredError('createVectorStoreRequest','Required parameter createVectorStoreRequest was null or undefined when calling createVectorStore.');
            }
            const localVarPath = `/vector_stores`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createVectorStoreRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createVectorStoreRequest != null ? createVectorStoreRequest : {}) : (((createVectorStoreRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
         * @throws {RequiredError}
         */
        createVectorStoreFile(vectorStoreId: string, createVectorStoreFileRequest: CreateVectorStoreFileRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'vectorStoreId' is not null or undefined
            if (vectorStoreId === null || vectorStoreId === undefined) {
                throw new RequiredError('vectorStoreId','Required parameter vectorStoreId was null or undefined when calling createVectorStoreFile.');
            }
            // verify required parameter 'createVectorStoreFileRequest' is not null or undefined
            if (createVectorStoreFileRequest === null || createVectorStoreFileRequest === undefined) {
                throw new RequiredError('createVectorStoreFileRequest','Required parameter createVectorStoreFileRequest was null or undefined when calling createVectorStoreFile.');
            }
            const localVarPath = `/vector_stores/{vector_store_id}/files`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createVectorStoreFileRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createVectorStoreFileRequest != null ? createVectorStoreFileRequest : {}) : (((createVectorStoreFileRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a vector store file batch.
         * @throws {RequiredError}
         */
        createVectorStoreFileBatch(vectorStoreId: string, createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'vectorStoreId' is not null or undefined
            if (vectorStoreId === null || vectorStoreId === undefined) {
                throw new RequiredError('vectorStoreId','Required parameter vectorStoreId was null or undefined when calling createVectorStoreFileBatch.');
            }
            // verify required parameter 'createVectorStoreFileBatchRequest' is not null or undefined
            if (createVectorStoreFileBatchRequest === null || createVectorStoreFileBatchRequest === undefined) {
                throw new RequiredError('createVectorStoreFileBatchRequest','Required parameter createVectorStoreFileBatchRequest was null or undefined when calling createVectorStoreFileBatch.');
            }
            const localVarPath = `/vector_stores/{vector_store_id}/file_batches`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createVectorStoreFileBatchRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createVectorStoreFileBatchRequest != null ? createVectorStoreFileBatchRequest : {}) : (((createVectorStoreFileBatchRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a vector store.
         * @throws {RequiredError}
         */
        deleteVectorStore(vectorStoreId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'vectorStoreId' is not null or undefined
            if (vectorStoreId === null || vectorStoreId === undefined) {
                throw new RequiredError('vectorStoreId','Required parameter vectorStoreId was null or undefined when calling deleteVectorStore.');
            }
            const localVarPath = `/vector_stores/{vector_store_id}`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
         * @throws {RequiredError}
         */
        deleteVectorStoreFile(vectorStoreId: string, fileId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'vectorStoreId' is not null or undefined
            if (vectorStoreId === null || vectorStoreId === undefined) {
                throw new RequiredError('vectorStoreId','Required parameter vectorStoreId was null or undefined when calling deleteVectorStoreFile.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling deleteVectorStoreFile.');
            }
            const localVarPath = `/vector_stores/{vector_store_id}/files/{file_id}`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a vector store.
         * @throws {RequiredError}
         */
        getVectorStore(vectorStoreId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'vectorStoreId' is not null or undefined
            if (vectorStoreId === null || vectorStoreId === undefined) {
                throw new RequiredError('vectorStoreId','Required parameter vectorStoreId was null or undefined when calling getVectorStore.');
            }
            const localVarPath = `/vector_stores/{vector_store_id}`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a vector store file.
         * @throws {RequiredError}
         */
        getVectorStoreFile(vectorStoreId: string, fileId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'vectorStoreId' is not null or undefined
            if (vectorStoreId === null || vectorStoreId === undefined) {
                throw new RequiredError('vectorStoreId','Required parameter vectorStoreId was null or undefined when calling getVectorStoreFile.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling getVectorStoreFile.');
            }
            const localVarPath = `/vector_stores/{vector_store_id}/files/{file_id}`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a vector store file batch.
         * @throws {RequiredError}
         */
        getVectorStoreFileBatch(vectorStoreId: string, batchId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'vectorStoreId' is not null or undefined
            if (vectorStoreId === null || vectorStoreId === undefined) {
                throw new RequiredError('vectorStoreId','Required parameter vectorStoreId was null or undefined when calling getVectorStoreFileBatch.');
            }
            // verify required parameter 'batchId' is not null or undefined
            if (batchId === null || batchId === undefined) {
                throw new RequiredError('batchId','Required parameter batchId was null or undefined when calling getVectorStoreFileBatch.');
            }
            const localVarPath = `/vector_stores/{vector_store_id}/file_batches/{batch_id}`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)))
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of vector store files in a batch.
         * @throws {RequiredError}
         */
        listFilesInVectorStoreBatch(vectorStoreId: string, batchId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, filter?: 'in_progress' | 'completed' | 'failed' | 'cancelled', options: RequestOptions): FetchArgs {
            // verify required parameter 'vectorStoreId' is not null or undefined
            if (vectorStoreId === null || vectorStoreId === undefined) {
                throw new RequiredError('vectorStoreId','Required parameter vectorStoreId was null or undefined when calling listFilesInVectorStoreBatch.');
            }
            // verify required parameter 'batchId' is not null or undefined
            if (batchId === null || batchId === undefined) {
                throw new RequiredError('batchId','Required parameter batchId was null or undefined when calling listFilesInVectorStoreBatch.');
            }
            const localVarPath = `/vector_stores/{vector_store_id}/file_batches/{batch_id}/files`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)))
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = ((order:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = ((before:any):string);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of vector store files.
         * @throws {RequiredError}
         */
        listVectorStoreFiles(vectorStoreId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, filter?: 'in_progress' | 'completed' | 'failed' | 'cancelled', options: RequestOptions): FetchArgs {
            // verify required parameter 'vectorStoreId' is not null or undefined
            if (vectorStoreId === null || vectorStoreId === undefined) {
                throw new RequiredError('vectorStoreId','Required parameter vectorStoreId was null or undefined when calling listVectorStoreFiles.');
            }
            const localVarPath = `/vector_stores/{vector_store_id}/files`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = ((order:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = ((before:any):string);
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of vector stores.
         * @throws {RequiredError}
         */
        listVectorStores(limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/vector_stores`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = ((order:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = ((before:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a vector store.
         * @throws {RequiredError}
         */
        modifyVectorStore(vectorStoreId: string, updateVectorStoreRequest: UpdateVectorStoreRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'vectorStoreId' is not null or undefined
            if (vectorStoreId === null || vectorStoreId === undefined) {
                throw new RequiredError('vectorStoreId','Required parameter vectorStoreId was null or undefined when calling modifyVectorStore.');
            }
            // verify required parameter 'updateVectorStoreRequest' is not null or undefined
            if (updateVectorStoreRequest === null || updateVectorStoreRequest === undefined) {
                throw new RequiredError('updateVectorStoreRequest','Required parameter updateVectorStoreRequest was null or undefined when calling modifyVectorStore.');
            }
            const localVarPath = `/vector_stores/{vector_store_id}`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof updateVectorStoreRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(updateVectorStoreRequest != null ? updateVectorStoreRequest : {}) : (((updateVectorStoreRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type VectorStoresApiType = { 
    cancelVectorStoreFileBatch(vectorStoreId: string, batchId: string, options?: RequestOptions): Promise<VectorStoreFileBatchObject>,

    createVectorStore(createVectorStoreRequest: CreateVectorStoreRequest, options?: RequestOptions): Promise<VectorStoreObject>,

    createVectorStoreFile(vectorStoreId: string, createVectorStoreFileRequest: CreateVectorStoreFileRequest, options?: RequestOptions): Promise<VectorStoreFileObject>,

    createVectorStoreFileBatch(vectorStoreId: string, createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest, options?: RequestOptions): Promise<VectorStoreFileBatchObject>,

    deleteVectorStore(vectorStoreId: string, options?: RequestOptions): Promise<DeleteVectorStoreResponse>,

    deleteVectorStoreFile(vectorStoreId: string, fileId: string, options?: RequestOptions): Promise<DeleteVectorStoreFileResponse>,

    getVectorStore(vectorStoreId: string, options?: RequestOptions): Promise<VectorStoreObject>,

    getVectorStoreFile(vectorStoreId: string, fileId: string, options?: RequestOptions): Promise<VectorStoreFileObject>,

    getVectorStoreFileBatch(vectorStoreId: string, batchId: string, options?: RequestOptions): Promise<VectorStoreFileBatchObject>,

    listFilesInVectorStoreBatch(vectorStoreId: string, batchId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, filter?: 'in_progress' | 'completed' | 'failed' | 'cancelled', options?: RequestOptions): Promise<ListVectorStoreFilesResponse>,

    listVectorStoreFiles(vectorStoreId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, filter?: 'in_progress' | 'completed' | 'failed' | 'cancelled', options?: RequestOptions): Promise<ListVectorStoreFilesResponse>,

    listVectorStores(limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions): Promise<ListVectorStoresResponse>,

    modifyVectorStore(vectorStoreId: string, updateVectorStoreRequest: UpdateVectorStoreRequest, options?: RequestOptions): Promise<VectorStoreObject>,
}

/**
 * VectorStoresApi - factory function to inject configuration 
 * @export
 */
export const VectorStoresApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): VectorStoresApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
         * @throws {RequiredError}
         */
        cancelVectorStoreFileBatch(vectorStoreId: string, batchId: string, options?: RequestOptions = {}): Promise<VectorStoreFileBatchObject> {
            const localVarFetchArgs = VectorStoresApiFetchParamCreator(configuration).cancelVectorStoreFileBatch(vectorStoreId, batchId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create a vector store.
         * @throws {RequiredError}
         */
        createVectorStore(createVectorStoreRequest: CreateVectorStoreRequest, options?: RequestOptions = {}): Promise<VectorStoreObject> {
            const localVarFetchArgs = VectorStoresApiFetchParamCreator(configuration).createVectorStore(createVectorStoreRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
         * @throws {RequiredError}
         */
        createVectorStoreFile(vectorStoreId: string, createVectorStoreFileRequest: CreateVectorStoreFileRequest, options?: RequestOptions = {}): Promise<VectorStoreFileObject> {
            const localVarFetchArgs = VectorStoresApiFetchParamCreator(configuration).createVectorStoreFile(vectorStoreId, createVectorStoreFileRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create a vector store file batch.
         * @throws {RequiredError}
         */
        createVectorStoreFileBatch(vectorStoreId: string, createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest, options?: RequestOptions = {}): Promise<VectorStoreFileBatchObject> {
            const localVarFetchArgs = VectorStoresApiFetchParamCreator(configuration).createVectorStoreFileBatch(vectorStoreId, createVectorStoreFileBatchRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete a vector store.
         * @throws {RequiredError}
         */
        deleteVectorStore(vectorStoreId: string, options?: RequestOptions = {}): Promise<DeleteVectorStoreResponse> {
            const localVarFetchArgs = VectorStoresApiFetchParamCreator(configuration).deleteVectorStore(vectorStoreId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
         * @throws {RequiredError}
         */
        deleteVectorStoreFile(vectorStoreId: string, fileId: string, options?: RequestOptions = {}): Promise<DeleteVectorStoreFileResponse> {
            const localVarFetchArgs = VectorStoresApiFetchParamCreator(configuration).deleteVectorStoreFile(vectorStoreId, fileId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a vector store.
         * @throws {RequiredError}
         */
        getVectorStore(vectorStoreId: string, options?: RequestOptions = {}): Promise<VectorStoreObject> {
            const localVarFetchArgs = VectorStoresApiFetchParamCreator(configuration).getVectorStore(vectorStoreId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a vector store file.
         * @throws {RequiredError}
         */
        getVectorStoreFile(vectorStoreId: string, fileId: string, options?: RequestOptions = {}): Promise<VectorStoreFileObject> {
            const localVarFetchArgs = VectorStoresApiFetchParamCreator(configuration).getVectorStoreFile(vectorStoreId, fileId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a vector store file batch.
         * @throws {RequiredError}
         */
        getVectorStoreFileBatch(vectorStoreId: string, batchId: string, options?: RequestOptions = {}): Promise<VectorStoreFileBatchObject> {
            const localVarFetchArgs = VectorStoresApiFetchParamCreator(configuration).getVectorStoreFileBatch(vectorStoreId, batchId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of vector store files in a batch.
         * @throws {RequiredError}
         */
        listFilesInVectorStoreBatch(vectorStoreId: string, batchId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, filter?: 'in_progress' | 'completed' | 'failed' | 'cancelled', options?: RequestOptions = {}): Promise<ListVectorStoreFilesResponse> {
            const localVarFetchArgs = VectorStoresApiFetchParamCreator(configuration).listFilesInVectorStoreBatch(vectorStoreId, batchId, limit, order, after, before, filter, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of vector store files.
         * @throws {RequiredError}
         */
        listVectorStoreFiles(vectorStoreId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, filter?: 'in_progress' | 'completed' | 'failed' | 'cancelled', options?: RequestOptions = {}): Promise<ListVectorStoreFilesResponse> {
            const localVarFetchArgs = VectorStoresApiFetchParamCreator(configuration).listVectorStoreFiles(vectorStoreId, limit, order, after, before, filter, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of vector stores.
         * @throws {RequiredError}
         */
        listVectorStores(limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions = {}): Promise<ListVectorStoresResponse> {
            const localVarFetchArgs = VectorStoresApiFetchParamCreator(configuration).listVectorStores(limit, order, after, before, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Modifies a vector store.
         * @throws {RequiredError}
         */
        modifyVectorStore(vectorStoreId: string, updateVectorStoreRequest: UpdateVectorStoreRequest, options?: RequestOptions = {}): Promise<VectorStoreObject> {
            const localVarFetchArgs = VectorStoresApiFetchParamCreator(configuration).modifyVectorStore(vectorStoreId, updateVectorStoreRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    AssistantsApi: AssistantsApiType,

    AudioApi: AudioApiType,

    AuditLogsApi: AuditLogsApiType,

    BatchApi: BatchApiType,

    ChatApi: ChatApiType,

    CompletionsApi: CompletionsApiType,

    DefaultApi: DefaultApiType,

    EmbeddingsApi: EmbeddingsApiType,

    FilesApi: FilesApiType,

    FineTuningApi: FineTuningApiType,

    ImagesApi: ImagesApiType,

    InvitesApi: InvitesApiType,

    ModelsApi: ModelsApiType,

    ModerationsApi: ModerationsApiType,

    ProjectsApi: ProjectsApiType,

    RealtimeApi: RealtimeApiType,

    UploadsApi: UploadsApiType,

    UsageApi: UsageApiType,

    UsersApi: UsersApiType,

    VectorStoresApi: VectorStoresApiType,
 }
