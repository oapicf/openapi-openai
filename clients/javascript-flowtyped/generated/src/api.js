// @flow
/* eslint-disable no-use-before-define */
/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://api.openai.com/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}


            export type AssistantFileObjectObjectEnum = 'assistant.file';
/**
 * A list of [Files](/docs/api-reference/files) attached to an `assistant`.
 * @export
 */
export type AssistantFileObject = {
    /**
     * The identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof AssistantFileObject
     */
    id: string;
    /**
     * The object type, which is always `assistant.file`.
     * @type {string}
     * @memberof AssistantFileObject
     */
    _object: AssistantFileObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the assistant file was created.
     * @type {number}
     * @memberof AssistantFileObject
     */
    created_at: number;
    /**
     * The assistant ID that the file is attached to.
     * @type {string}
     * @memberof AssistantFileObject
     */
    assistant_id: string;
}


            export type AssistantObjectObjectEnum = 'assistant';
/**
 * Represents an `assistant` that can call the model and use tools.
 * @export
 */
export type AssistantObject = {
    /**
     * The identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof AssistantObject
     */
    id: string;
    /**
     * The object type, which is always `assistant`.
     * @type {string}
     * @memberof AssistantObject
     */
    _object: AssistantObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the assistant was created.
     * @type {number}
     * @memberof AssistantObject
     */
    created_at: number;
    /**
     * The name of the assistant. The maximum length is 256 characters. 
     * @type {string}
     * @memberof AssistantObject
     */
    name: string;
    /**
     * The description of the assistant. The maximum length is 512 characters. 
     * @type {string}
     * @memberof AssistantObject
     */
    description: string;
    /**
     * ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them. 
     * @type {string}
     * @memberof AssistantObject
     */
    model: string;
    /**
     * The system instructions that the assistant uses. The maximum length is 256,000 characters. 
     * @type {string}
     * @memberof AssistantObject
     */
    instructions: string;
    /**
     * A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`. 
     * @type {Array<AssistantObjectToolsInner>}
     * @memberof AssistantObject
     */
    tools: Array<AssistantObjectToolsInner>;
    /**
     * A list of [file](/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. 
     * @type {Array<string>}
     * @memberof AssistantObject
     */
    file_ids: Array<string>;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
     * @type {Object}
     * @memberof AssistantObject
     */
    metadata: Object;
}


            export type AssistantObjectToolsInnerTypeEnum = 'code_interpreter' | 'retrieval' | 'function';
/**
 * 
 * @export
 */
export type AssistantObjectToolsInner = {
    /**
     * The type of tool being defined: `code_interpreter`
     * @type {string}
     * @memberof AssistantObjectToolsInner
     */
    type: AssistantObjectToolsInnerTypeEnum;
    /**
     * 
     * @type {FunctionObject}
     * @memberof AssistantObjectToolsInner
     */
    _function: FunctionObject;
}


            export type AssistantStreamEventEventEnum = 'done';

            export type AssistantStreamEventDataEnum = '[DONE]';
/**
 * Represents an event emitted when streaming a Run.  Each event in a server-sent events stream has an `event` and `data` property:  ``` event: thread.created data: {\"id\": \"thread_123\", \"object\": \"thread\", ...} ```  We emit events whenever a new object is created, transitions to a new state, or is being streamed in parts (deltas). For example, we emit `thread.run.created` when a new run is created, `thread.run.completed` when a run completes, and so on. When an Assistant chooses to create a message during a run, we emit a `thread.message.created event`, a `thread.message.in_progress` event, many `thread.message.delta` events, and finally a `thread.message.completed` event.  We may add additional events over time, so we recommend handling unknown events gracefully in your code. See the [Assistants API quickstart](/docs/assistants/overview) to learn how to integrate the Assistants API with streaming. 
 * @export
 */
export type AssistantStreamEvent = {
    /**
     * 
     * @type {string}
     * @memberof AssistantStreamEvent
     */
    event: AssistantStreamEventEventEnum;
    /**
     * 
     * @type {string}
     * @memberof AssistantStreamEvent
     */
    data: AssistantStreamEventDataEnum;
}


            export type AssistantToolsCodeTypeEnum = 'code_interpreter';
/**
 * 
 * @export
 */
export type AssistantToolsCode = {
    /**
     * The type of tool being defined: `code_interpreter`
     * @type {string}
     * @memberof AssistantToolsCode
     */
    type: AssistantToolsCodeTypeEnum;
}


            export type AssistantToolsFunctionTypeEnum = 'function';
/**
 * 
 * @export
 */
export type AssistantToolsFunction = {
    /**
     * The type of tool being defined: `function`
     * @type {string}
     * @memberof AssistantToolsFunction
     */
    type: AssistantToolsFunctionTypeEnum;
    /**
     * 
     * @type {FunctionObject}
     * @memberof AssistantToolsFunction
     */
    _function: FunctionObject;
}


            export type AssistantToolsRetrievalTypeEnum = 'retrieval';
/**
 * 
 * @export
 */
export type AssistantToolsRetrieval = {
    /**
     * The type of tool being defined: `retrieval`
     * @type {string}
     * @memberof AssistantToolsRetrieval
     */
    type: AssistantToolsRetrievalTypeEnum;
}


            export type AssistantsApiNamedToolChoiceTypeEnum = 'function' | 'code_interpreter' | 'retrieval';
/**
 * Specifies a tool the model should use. Use to force the model to call a specific tool.
 * @export
 */
export type AssistantsApiNamedToolChoice = {
    /**
     * The type of the tool. If type is `function`, the function name must be set
     * @type {string}
     * @memberof AssistantsApiNamedToolChoice
     */
    type: AssistantsApiNamedToolChoiceTypeEnum;
    /**
     * 
     * @type {ChatCompletionNamedToolChoiceFunction}
     * @memberof AssistantsApiNamedToolChoice
     */
    _function?: ChatCompletionNamedToolChoiceFunction;
}


            export type AssistantsApiResponseFormatTypeEnum = 'text' | 'json_object';
/**
 * An object describing the expected output of the model. If `json_object` only `function` type `tools` are allowed to be passed to the Run. If `text` the model can return text or any value needed. 
 * @export
 */
export type AssistantsApiResponseFormat = {
    /**
     * Must be one of `text` or `json_object`.
     * @type {string}
     * @memberof AssistantsApiResponseFormat
     */
    type?: AssistantsApiResponseFormatTypeEnum;
}


            export type AssistantsApiResponseFormatOptionTypeEnum = 'text' | 'json_object';
/**
 * Specifies the format that the model must output. Compatible with [GPT-4 Turbo](/docs/models/gpt-4-and-gpt-4-turbo) and all GPT-3.5 Turbo models newer than `gpt-3.5-turbo-1106`.  Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which guarantees the message the model generates is valid JSON.  **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \"stuck\" request. Also note that the message content may be partially cut off if `finish_reason=\"length\"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length. 
 * @export
 */
export type AssistantsApiResponseFormatOption = {
    /**
     * Must be one of `text` or `json_object`.
     * @type {string}
     * @memberof AssistantsApiResponseFormatOption
     */
    type?: AssistantsApiResponseFormatOptionTypeEnum;
}


            export type AssistantsApiToolChoiceOptionTypeEnum = 'function' | 'code_interpreter' | 'retrieval';
/**
 * Controls which (if any) tool is called by the model. `none` means the model will not call any tools and instead generates a message. `auto` is the default value and means the model can pick between generating a message or calling a tool. Specifying a particular tool like `{\"type\": \"TOOL_TYPE\"}` or `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool. 
 * @export
 */
export type AssistantsApiToolChoiceOption = {
    /**
     * The type of the tool. If type is `function`, the function name must be set
     * @type {string}
     * @memberof AssistantsApiToolChoiceOption
     */
    type: AssistantsApiToolChoiceOptionTypeEnum;
    /**
     * 
     * @type {ChatCompletionNamedToolChoiceFunction}
     * @memberof AssistantsApiToolChoiceOption
     */
    _function?: ChatCompletionNamedToolChoiceFunction;
}

/**
 * Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function. 
 * @export
 */
export type ChatCompletionFunctionCallOption = {
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionFunctionCallOption
     */
    name: string;
}

/**
 * 
 * @export
 */
export type ChatCompletionFunctions = {
    /**
     * A description of what the function does, used by the model to choose when and how to call the function.
     * @type {string}
     * @memberof ChatCompletionFunctions
     */
    description?: string;
    /**
     * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     * @type {string}
     * @memberof ChatCompletionFunctions
     */
    name: string;
    /**
     * The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/text-generation/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.   Omitting `parameters` defines a function with an empty parameter list.
     * @type {{ [key: string]: AnyType; }}
     * @memberof ChatCompletionFunctions
     */
    parameters?: { [key: string]: AnyType; };
}


            export type ChatCompletionMessageToolCallTypeEnum = 'function';
/**
 * 
 * @export
 */
export type ChatCompletionMessageToolCall = {
    /**
     * The ID of the tool call.
     * @type {string}
     * @memberof ChatCompletionMessageToolCall
     */
    id: string;
    /**
     * The type of the tool. Currently, only `function` is supported.
     * @type {string}
     * @memberof ChatCompletionMessageToolCall
     */
    type: ChatCompletionMessageToolCallTypeEnum;
    /**
     * 
     * @type {ChatCompletionMessageToolCallFunction}
     * @memberof ChatCompletionMessageToolCall
     */
    _function: ChatCompletionMessageToolCallFunction;
}


            export type ChatCompletionMessageToolCallChunkTypeEnum = 'function';
/**
 * 
 * @export
 */
export type ChatCompletionMessageToolCallChunk = {
    /**
     * 
     * @type {number}
     * @memberof ChatCompletionMessageToolCallChunk
     */
    index: number;
    /**
     * The ID of the tool call.
     * @type {string}
     * @memberof ChatCompletionMessageToolCallChunk
     */
    id?: string;
    /**
     * The type of the tool. Currently, only `function` is supported.
     * @type {string}
     * @memberof ChatCompletionMessageToolCallChunk
     */
    type?: ChatCompletionMessageToolCallChunkTypeEnum;
    /**
     * 
     * @type {ChatCompletionMessageToolCallChunkFunction}
     * @memberof ChatCompletionMessageToolCallChunk
     */
    _function?: ChatCompletionMessageToolCallChunkFunction;
}

/**
 * 
 * @export
 */
export type ChatCompletionMessageToolCallChunkFunction = {
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionMessageToolCallChunkFunction
     */
    name?: string;
    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     * @type {string}
     * @memberof ChatCompletionMessageToolCallChunkFunction
     */
    _arguments?: string;
}

/**
 * The function that the model called.
 * @export
 */
export type ChatCompletionMessageToolCallFunction = {
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionMessageToolCallFunction
     */
    name: string;
    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     * @type {string}
     * @memberof ChatCompletionMessageToolCallFunction
     */
    _arguments: string;
}


            export type ChatCompletionNamedToolChoiceTypeEnum = 'function';
/**
 * Specifies a tool the model should use. Use to force the model to call a specific function.
 * @export
 */
export type ChatCompletionNamedToolChoice = {
    /**
     * The type of the tool. Currently, only `function` is supported.
     * @type {string}
     * @memberof ChatCompletionNamedToolChoice
     */
    type: ChatCompletionNamedToolChoiceTypeEnum;
    /**
     * 
     * @type {ChatCompletionNamedToolChoiceFunction}
     * @memberof ChatCompletionNamedToolChoice
     */
    _function: ChatCompletionNamedToolChoiceFunction;
}

/**
 * 
 * @export
 */
export type ChatCompletionNamedToolChoiceFunction = {
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionNamedToolChoiceFunction
     */
    name: string;
}


            export type ChatCompletionRequestAssistantMessageRoleEnum = 'assistant';
/**
 * 
 * @export
 */
export type ChatCompletionRequestAssistantMessage = {
    /**
     * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified. 
     * @type {string}
     * @memberof ChatCompletionRequestAssistantMessage
     */
    content?: string;
    /**
     * The role of the messages author, in this case `assistant`.
     * @type {string}
     * @memberof ChatCompletionRequestAssistantMessage
     */
    role: ChatCompletionRequestAssistantMessageRoleEnum;
    /**
     * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     * @type {string}
     * @memberof ChatCompletionRequestAssistantMessage
     */
    name?: string;
    /**
     * The tool calls generated by the model, such as function calls.
     * @type {Array<ChatCompletionMessageToolCall>}
     * @memberof ChatCompletionRequestAssistantMessage
     */
    tool_calls?: Array<ChatCompletionMessageToolCall>;
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageFunctionCall}
     * @memberof ChatCompletionRequestAssistantMessage
     */
    function_call?: ChatCompletionRequestAssistantMessageFunctionCall;
}

/**
 * Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
 * @export
 */
export type ChatCompletionRequestAssistantMessageFunctionCall = {
    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     * @type {string}
     * @memberof ChatCompletionRequestAssistantMessageFunctionCall
     */
    _arguments: string;
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionRequestAssistantMessageFunctionCall
     */
    name: string;
}


            export type ChatCompletionRequestFunctionMessageRoleEnum = 'function';
/**
 * 
 * @export
 */
export type ChatCompletionRequestFunctionMessage = {
    /**
     * The role of the messages author, in this case `function`.
     * @type {string}
     * @memberof ChatCompletionRequestFunctionMessage
     */
    role: ChatCompletionRequestFunctionMessageRoleEnum;
    /**
     * The contents of the function message.
     * @type {string}
     * @memberof ChatCompletionRequestFunctionMessage
     */
    content: string;
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionRequestFunctionMessage
     */
    name: string;
}


            export type ChatCompletionRequestMessageRoleEnum = 'function';
/**
 * 
 * @export
 */
export type ChatCompletionRequestMessage = {
    /**
     * The contents of the function message.
     * @type {string}
     * @memberof ChatCompletionRequestMessage
     */
    content: string;
    /**
     * The role of the messages author, in this case `function`.
     * @type {string}
     * @memberof ChatCompletionRequestMessage
     */
    role: ChatCompletionRequestMessageRoleEnum;
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionRequestMessage
     */
    name: string;
    /**
     * The tool calls generated by the model, such as function calls.
     * @type {Array<ChatCompletionMessageToolCall>}
     * @memberof ChatCompletionRequestMessage
     */
    tool_calls?: Array<ChatCompletionMessageToolCall>;
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageFunctionCall}
     * @memberof ChatCompletionRequestMessage
     */
    function_call?: ChatCompletionRequestAssistantMessageFunctionCall;
    /**
     * Tool call that this message is responding to.
     * @type {string}
     * @memberof ChatCompletionRequestMessage
     */
    tool_call_id: string;
}


            export type ChatCompletionRequestMessageContentPartTypeEnum = 'text' | 'image_url';
/**
 * 
 * @export
 */
export type ChatCompletionRequestMessageContentPart = {
    /**
     * The type of the content part.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPart
     */
    type: ChatCompletionRequestMessageContentPartTypeEnum;
    /**
     * The text content.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPart
     */
    text: string;
    /**
     * 
     * @type {ChatCompletionRequestMessageContentPartImageImageUrl}
     * @memberof ChatCompletionRequestMessageContentPart
     */
    image_url: ChatCompletionRequestMessageContentPartImageImageUrl;
}


            export type ChatCompletionRequestMessageContentPartImageTypeEnum = 'image_url';
/**
 * 
 * @export
 */
export type ChatCompletionRequestMessageContentPartImage = {
    /**
     * The type of the content part.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartImage
     */
    type: ChatCompletionRequestMessageContentPartImageTypeEnum;
    /**
     * 
     * @type {ChatCompletionRequestMessageContentPartImageImageUrl}
     * @memberof ChatCompletionRequestMessageContentPartImage
     */
    image_url: ChatCompletionRequestMessageContentPartImageImageUrl;
}


            export type ChatCompletionRequestMessageContentPartImageImageUrlDetailEnum = 'auto' | 'low' | 'high';
/**
 * 
 * @export
 */
export type ChatCompletionRequestMessageContentPartImageImageUrl = {
    /**
     * Either a URL of the image or the base64 encoded image data.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartImageImageUrl
     */
    url: string;
    /**
     * Specifies the detail level of the image. Learn more in the [Vision guide](/docs/guides/vision/low-or-high-fidelity-image-understanding).
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartImageImageUrl
     */
    detail?: ChatCompletionRequestMessageContentPartImageImageUrlDetailEnum;
}


            export type ChatCompletionRequestMessageContentPartTextTypeEnum = 'text';
/**
 * 
 * @export
 */
export type ChatCompletionRequestMessageContentPartText = {
    /**
     * The type of the content part.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartText
     */
    type: ChatCompletionRequestMessageContentPartTextTypeEnum;
    /**
     * The text content.
     * @type {string}
     * @memberof ChatCompletionRequestMessageContentPartText
     */
    text: string;
}


            export type ChatCompletionRequestSystemMessageRoleEnum = 'system';
/**
 * 
 * @export
 */
export type ChatCompletionRequestSystemMessage = {
    /**
     * The contents of the system message.
     * @type {string}
     * @memberof ChatCompletionRequestSystemMessage
     */
    content: string;
    /**
     * The role of the messages author, in this case `system`.
     * @type {string}
     * @memberof ChatCompletionRequestSystemMessage
     */
    role: ChatCompletionRequestSystemMessageRoleEnum;
    /**
     * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     * @type {string}
     * @memberof ChatCompletionRequestSystemMessage
     */
    name?: string;
}


            export type ChatCompletionRequestToolMessageRoleEnum = 'tool';
/**
 * 
 * @export
 */
export type ChatCompletionRequestToolMessage = {
    /**
     * The role of the messages author, in this case `tool`.
     * @type {string}
     * @memberof ChatCompletionRequestToolMessage
     */
    role: ChatCompletionRequestToolMessageRoleEnum;
    /**
     * The contents of the tool message.
     * @type {string}
     * @memberof ChatCompletionRequestToolMessage
     */
    content: string;
    /**
     * Tool call that this message is responding to.
     * @type {string}
     * @memberof ChatCompletionRequestToolMessage
     */
    tool_call_id: string;
}


            export type ChatCompletionRequestUserMessageRoleEnum = 'user';
/**
 * 
 * @export
 */
export type ChatCompletionRequestUserMessage = {
    /**
     * 
     * @type {ChatCompletionRequestUserMessageContent}
     * @memberof ChatCompletionRequestUserMessage
     */
    content: ChatCompletionRequestUserMessageContent;
    /**
     * The role of the messages author, in this case `user`.
     * @type {string}
     * @memberof ChatCompletionRequestUserMessage
     */
    role: ChatCompletionRequestUserMessageRoleEnum;
    /**
     * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     * @type {string}
     * @memberof ChatCompletionRequestUserMessage
     */
    name?: string;
}

/**
 * The contents of the user message. 
 * @export
 */
export type ChatCompletionRequestUserMessageContent = {
}


            export type ChatCompletionResponseMessageRoleEnum = 'assistant';
/**
 * A chat completion message generated by the model.
 * @export
 */
export type ChatCompletionResponseMessage = {
    /**
     * The contents of the message.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    content: string;
    /**
     * The tool calls generated by the model, such as function calls.
     * @type {Array<ChatCompletionMessageToolCall>}
     * @memberof ChatCompletionResponseMessage
     */
    tool_calls?: Array<ChatCompletionMessageToolCall>;
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ChatCompletionResponseMessage
     */
    role: ChatCompletionResponseMessageRoleEnum;
    /**
     * 
     * @type {ChatCompletionRequestAssistantMessageFunctionCall}
     * @memberof ChatCompletionResponseMessage
     */
    function_call?: ChatCompletionRequestAssistantMessageFunctionCall;
}

/**
 * The role of the author of a message
 * @export
 * @enum {string}
 */
export type ChatCompletionRole = 'system' | 'user' | 'assistant' | 'tool' | 'function';


            export type ChatCompletionStreamResponseDeltaRoleEnum = 'system' | 'user' | 'assistant' | 'tool';
/**
 * A chat completion delta generated by streamed model responses.
 * @export
 */
export type ChatCompletionStreamResponseDelta = {
    /**
     * The contents of the chunk message.
     * @type {string}
     * @memberof ChatCompletionStreamResponseDelta
     */
    content?: string;
    /**
     * 
     * @type {ChatCompletionStreamResponseDeltaFunctionCall}
     * @memberof ChatCompletionStreamResponseDelta
     */
    function_call?: ChatCompletionStreamResponseDeltaFunctionCall;
    /**
     * 
     * @type {Array<ChatCompletionMessageToolCallChunk>}
     * @memberof ChatCompletionStreamResponseDelta
     */
    tool_calls?: Array<ChatCompletionMessageToolCallChunk>;
    /**
     * The role of the author of this message.
     * @type {string}
     * @memberof ChatCompletionStreamResponseDelta
     */
    role?: ChatCompletionStreamResponseDeltaRoleEnum;
}

/**
 * Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
 * @export
 */
export type ChatCompletionStreamResponseDeltaFunctionCall = {
    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     * @type {string}
     * @memberof ChatCompletionStreamResponseDeltaFunctionCall
     */
    _arguments?: string;
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof ChatCompletionStreamResponseDeltaFunctionCall
     */
    name?: string;
}

/**
 * 
 * @export
 */
export type ChatCompletionTokenLogprob = {
    /**
     * The token.
     * @type {string}
     * @memberof ChatCompletionTokenLogprob
     */
    token: string;
    /**
     * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
     * @type {number}
     * @memberof ChatCompletionTokenLogprob
     */
    logprob: number;
    /**
     * A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
     * @type {Array<number>}
     * @memberof ChatCompletionTokenLogprob
     */
    bytes: Array<number>;
    /**
     * List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
     * @type {Array<ChatCompletionTokenLogprobTopLogprobsInner>}
     * @memberof ChatCompletionTokenLogprob
     */
    top_logprobs: Array<ChatCompletionTokenLogprobTopLogprobsInner>;
}

/**
 * 
 * @export
 */
export type ChatCompletionTokenLogprobTopLogprobsInner = {
    /**
     * The token.
     * @type {string}
     * @memberof ChatCompletionTokenLogprobTopLogprobsInner
     */
    token: string;
    /**
     * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
     * @type {number}
     * @memberof ChatCompletionTokenLogprobTopLogprobsInner
     */
    logprob: number;
    /**
     * A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
     * @type {Array<number>}
     * @memberof ChatCompletionTokenLogprobTopLogprobsInner
     */
    bytes: Array<number>;
}


            export type ChatCompletionToolTypeEnum = 'function';
/**
 * 
 * @export
 */
export type ChatCompletionTool = {
    /**
     * The type of the tool. Currently, only `function` is supported.
     * @type {string}
     * @memberof ChatCompletionTool
     */
    type: ChatCompletionToolTypeEnum;
    /**
     * 
     * @type {FunctionObject}
     * @memberof ChatCompletionTool
     */
    _function: FunctionObject;
}


            export type ChatCompletionToolChoiceOptionTypeEnum = 'function';
/**
 * Controls which (if any) function is called by the model. `none` means the model will not call a function and instead generates a message. `auto` means the model can pick between generating a message or calling a function. Specifying a particular function via `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that function.  `none` is the default when no functions are present. `auto` is the default if functions are present. 
 * @export
 */
export type ChatCompletionToolChoiceOption = {
    /**
     * The type of the tool. Currently, only `function` is supported.
     * @type {string}
     * @memberof ChatCompletionToolChoiceOption
     */
    type: ChatCompletionToolChoiceOptionTypeEnum;
    /**
     * 
     * @type {ChatCompletionNamedToolChoiceFunction}
     * @memberof ChatCompletionToolChoiceOption
     */
    _function: ChatCompletionNamedToolChoiceFunction;
}

/**
 * Usage statistics for the completion request.
 * @export
 */
export type CompletionUsage = {
    /**
     * Number of tokens in the generated completion.
     * @type {number}
     * @memberof CompletionUsage
     */
    completion_tokens: number;
    /**
     * Number of tokens in the prompt.
     * @type {number}
     * @memberof CompletionUsage
     */
    prompt_tokens: number;
    /**
     * Total number of tokens used in the request (prompt + completion).
     * @type {number}
     * @memberof CompletionUsage
     */
    total_tokens: number;
}

/**
 * 
 * @export
 */
export type CreateAssistantFileRequest = {
    /**
     * A [File](/docs/api-reference/files) ID (with `purpose=\"assistants\"`) that the assistant should use. Useful for tools like `retrieval` and `code_interpreter` that can access files.
     * @type {string}
     * @memberof CreateAssistantFileRequest
     */
    file_id: string;
}

/**
 * 
 * @export
 */
export type CreateAssistantRequest = {
    /**
     * 
     * @type {CreateAssistantRequestModel}
     * @memberof CreateAssistantRequest
     */
    model: CreateAssistantRequestModel;
    /**
     * The name of the assistant. The maximum length is 256 characters. 
     * @type {string}
     * @memberof CreateAssistantRequest
     */
    name?: string;
    /**
     * The description of the assistant. The maximum length is 512 characters. 
     * @type {string}
     * @memberof CreateAssistantRequest
     */
    description?: string;
    /**
     * The system instructions that the assistant uses. The maximum length is 256,000 characters. 
     * @type {string}
     * @memberof CreateAssistantRequest
     */
    instructions?: string;
    /**
     * A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`. 
     * @type {Array<AssistantObjectToolsInner>}
     * @memberof CreateAssistantRequest
     */
    tools?: Array<AssistantObjectToolsInner>;
    /**
     * A list of [file](/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. 
     * @type {Array<string>}
     * @memberof CreateAssistantRequest
     */
    file_ids?: Array<string>;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
     * @type {Object}
     * @memberof CreateAssistantRequest
     */
    metadata?: Object;
}

/**
 * ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them. 
 * @export
 */
export type CreateAssistantRequestModel = {
}


            export type CreateChatCompletionFunctionResponseObjectEnum = 'chat.completion';
/**
 * Represents a chat completion response returned by model, based on the provided input.
 * @export
 */
export type CreateChatCompletionFunctionResponse = {
    /**
     * A unique identifier for the chat completion.
     * @type {string}
     * @memberof CreateChatCompletionFunctionResponse
     */
    id: string;
    /**
     * A list of chat completion choices. Can be more than one if `n` is greater than 1.
     * @type {Array<CreateChatCompletionFunctionResponseChoicesInner>}
     * @memberof CreateChatCompletionFunctionResponse
     */
    choices: Array<CreateChatCompletionFunctionResponseChoicesInner>;
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created.
     * @type {number}
     * @memberof CreateChatCompletionFunctionResponse
     */
    created: number;
    /**
     * The model used for the chat completion.
     * @type {string}
     * @memberof CreateChatCompletionFunctionResponse
     */
    model: string;
    /**
     * This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
     * @type {string}
     * @memberof CreateChatCompletionFunctionResponse
     */
    system_fingerprint?: string;
    /**
     * The object type, which is always `chat.completion`.
     * @type {string}
     * @memberof CreateChatCompletionFunctionResponse
     */
    _object: CreateChatCompletionFunctionResponseObjectEnum;
    /**
     * 
     * @type {CompletionUsage}
     * @memberof CreateChatCompletionFunctionResponse
     */
    usage?: CompletionUsage;
}


            export type CreateChatCompletionFunctionResponseChoicesInnerFinishReasonEnum = 'stop' | 'length' | 'function_call' | 'content_filter';
/**
 * 
 * @export
 */
export type CreateChatCompletionFunctionResponseChoicesInner = {
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, or `function_call` if the model called a function. 
     * @type {string}
     * @memberof CreateChatCompletionFunctionResponseChoicesInner
     */
    finish_reason: CreateChatCompletionFunctionResponseChoicesInnerFinishReasonEnum;
    /**
     * The index of the choice in the list of choices.
     * @type {number}
     * @memberof CreateChatCompletionFunctionResponseChoicesInner
     */
    index: number;
    /**
     * 
     * @type {ChatCompletionResponseMessage}
     * @memberof CreateChatCompletionFunctionResponseChoicesInner
     */
    message: ChatCompletionResponseMessage;
}

/**
 * 
 * @export
 */
export type CreateChatCompletionRequest = {
    /**
     * A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
     * @type {Array<ChatCompletionRequestMessage>}
     * @memberof CreateChatCompletionRequest
     */
    messages: Array<ChatCompletionRequestMessage>;
    /**
     * 
     * @type {CreateChatCompletionRequestModel}
     * @memberof CreateChatCompletionRequest
     */
    model: CreateChatCompletionRequestModel;
    /**
     * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model\'s likelihood to repeat the same line verbatim.  [See more information about frequency and presence penalties.](/docs/guides/text-generation/parameter-details) 
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    frequency_penalty?: number;
    /**
     * Modify the likelihood of specified tokens appearing in the completion.  Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token. 
     * @type {{ [key: string]: number; }}
     * @memberof CreateChatCompletionRequest
     */
    logit_bias?: { [key: string]: number; };
    /**
     * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the `content` of `message`.
     * @type {boolean}
     * @memberof CreateChatCompletionRequest
     */
    logprobs?: boolean;
    /**
     * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. `logprobs` must be set to `true` if this parameter is used.
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    top_logprobs?: number;
    /**
     * The maximum number of [tokens](/tokenizer) that can be generated in the chat completion.  The total length of input tokens and generated tokens is limited by the model\'s context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. 
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    max_tokens?: number;
    /**
     * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    n?: number;
    /**
     * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model\'s likelihood to talk about new topics.  [See more information about frequency and presence penalties.](/docs/guides/text-generation/parameter-details) 
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    presence_penalty?: number;
    /**
     * 
     * @type {CreateChatCompletionRequestResponseFormat}
     * @memberof CreateChatCompletionRequest
     */
    response_format?: CreateChatCompletionRequestResponseFormat;
    /**
     * This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result. Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend. 
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    seed?: number;
    /**
     * 
     * @type {CreateChatCompletionRequestStop}
     * @memberof CreateChatCompletionRequest
     */
    stop?: CreateChatCompletionRequestStop;
    /**
     * If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions). 
     * @type {boolean}
     * @memberof CreateChatCompletionRequest
     */
    stream?: boolean;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or `top_p` but not both. 
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    temperature?: number;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or `temperature` but not both. 
     * @type {number}
     * @memberof CreateChatCompletionRequest
     */
    top_p?: number;
    /**
     * A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported. 
     * @type {Array<ChatCompletionTool>}
     * @memberof CreateChatCompletionRequest
     */
    tools?: Array<ChatCompletionTool>;
    /**
     * 
     * @type {ChatCompletionToolChoiceOption}
     * @memberof CreateChatCompletionRequest
     */
    tool_choice?: ChatCompletionToolChoiceOption;
    /**
     * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
     * @type {string}
     * @memberof CreateChatCompletionRequest
     */
    user?: string;
    /**
     * 
     * @type {CreateChatCompletionRequestFunctionCall}
     * @memberof CreateChatCompletionRequest
     */
    function_call?: CreateChatCompletionRequestFunctionCall;
    /**
     * Deprecated in favor of `tools`.  A list of functions the model may generate JSON inputs for. 
     * @type {Array<ChatCompletionFunctions>}
     * @memberof CreateChatCompletionRequest
     */
    functions?: Array<ChatCompletionFunctions>;
}

/**
 * Deprecated in favor of `tool_choice`.  Controls which (if any) function is called by the model. `none` means the model will not call a function and instead generates a message. `auto` means the model can pick between generating a message or calling a function. Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function.  `none` is the default when no functions are present. `auto` is the default if functions are present. 
 * @export
 */
export type CreateChatCompletionRequestFunctionCall = {
    /**
     * The name of the function to call.
     * @type {string}
     * @memberof CreateChatCompletionRequestFunctionCall
     */
    name: string;
}

/**
 * ID of the model to use. See the [model endpoint compatibility](/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.
 * @export
 */
export type CreateChatCompletionRequestModel = {
}


            export type CreateChatCompletionRequestResponseFormatTypeEnum = 'text' | 'json_object';
/**
 * An object specifying the format that the model must output. Compatible with [GPT-4 Turbo](/docs/models/gpt-4-and-gpt-4-turbo) and all GPT-3.5 Turbo models newer than `gpt-3.5-turbo-1106`.  Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which guarantees the message the model generates is valid JSON.  **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \"stuck\" request. Also note that the message content may be partially cut off if `finish_reason=\"length\"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length. 
 * @export
 */
export type CreateChatCompletionRequestResponseFormat = {
    /**
     * Must be one of `text` or `json_object`.
     * @type {string}
     * @memberof CreateChatCompletionRequestResponseFormat
     */
    type?: CreateChatCompletionRequestResponseFormatTypeEnum;
}

/**
 * Up to 4 sequences where the API will stop generating further tokens. 
 * @export
 */
export type CreateChatCompletionRequestStop = {
}


            export type CreateChatCompletionResponseObjectEnum = 'chat.completion';
/**
 * Represents a chat completion response returned by model, based on the provided input.
 * @export
 */
export type CreateChatCompletionResponse = {
    /**
     * A unique identifier for the chat completion.
     * @type {string}
     * @memberof CreateChatCompletionResponse
     */
    id: string;
    /**
     * A list of chat completion choices. Can be more than one if `n` is greater than 1.
     * @type {Array<CreateChatCompletionResponseChoicesInner>}
     * @memberof CreateChatCompletionResponse
     */
    choices: Array<CreateChatCompletionResponseChoicesInner>;
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created.
     * @type {number}
     * @memberof CreateChatCompletionResponse
     */
    created: number;
    /**
     * The model used for the chat completion.
     * @type {string}
     * @memberof CreateChatCompletionResponse
     */
    model: string;
    /**
     * This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
     * @type {string}
     * @memberof CreateChatCompletionResponse
     */
    system_fingerprint?: string;
    /**
     * The object type, which is always `chat.completion`.
     * @type {string}
     * @memberof CreateChatCompletionResponse
     */
    _object: CreateChatCompletionResponseObjectEnum;
    /**
     * 
     * @type {CompletionUsage}
     * @memberof CreateChatCompletionResponse
     */
    usage?: CompletionUsage;
}


            export type CreateChatCompletionResponseChoicesInnerFinishReasonEnum = 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
/**
 * 
 * @export
 */
export type CreateChatCompletionResponseChoicesInner = {
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
     * @type {string}
     * @memberof CreateChatCompletionResponseChoicesInner
     */
    finish_reason: CreateChatCompletionResponseChoicesInnerFinishReasonEnum;
    /**
     * The index of the choice in the list of choices.
     * @type {number}
     * @memberof CreateChatCompletionResponseChoicesInner
     */
    index: number;
    /**
     * 
     * @type {ChatCompletionResponseMessage}
     * @memberof CreateChatCompletionResponseChoicesInner
     */
    message: ChatCompletionResponseMessage;
    /**
     * 
     * @type {CreateChatCompletionResponseChoicesInnerLogprobs}
     * @memberof CreateChatCompletionResponseChoicesInner
     */
    logprobs: CreateChatCompletionResponseChoicesInnerLogprobs;
}

/**
 * Log probability information for the choice.
 * @export
 */
export type CreateChatCompletionResponseChoicesInnerLogprobs = {
    /**
     * A list of message content tokens with log probability information.
     * @type {Array<ChatCompletionTokenLogprob>}
     * @memberof CreateChatCompletionResponseChoicesInnerLogprobs
     */
    content: Array<ChatCompletionTokenLogprob>;
}


            export type CreateChatCompletionStreamResponseObjectEnum = 'chat.completion.chunk';
/**
 * Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
 * @export
 */
export type CreateChatCompletionStreamResponse = {
    /**
     * A unique identifier for the chat completion. Each chunk has the same ID.
     * @type {string}
     * @memberof CreateChatCompletionStreamResponse
     */
    id: string;
    /**
     * A list of chat completion choices. Can be more than one if `n` is greater than 1.
     * @type {Array<CreateChatCompletionStreamResponseChoicesInner>}
     * @memberof CreateChatCompletionStreamResponse
     */
    choices: Array<CreateChatCompletionStreamResponseChoicesInner>;
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
     * @type {number}
     * @memberof CreateChatCompletionStreamResponse
     */
    created: number;
    /**
     * The model to generate the completion.
     * @type {string}
     * @memberof CreateChatCompletionStreamResponse
     */
    model: string;
    /**
     * This fingerprint represents the backend configuration that the model runs with. Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
     * @type {string}
     * @memberof CreateChatCompletionStreamResponse
     */
    system_fingerprint?: string;
    /**
     * The object type, which is always `chat.completion.chunk`.
     * @type {string}
     * @memberof CreateChatCompletionStreamResponse
     */
    _object: CreateChatCompletionStreamResponseObjectEnum;
}


            export type CreateChatCompletionStreamResponseChoicesInnerFinishReasonEnum = 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
/**
 * 
 * @export
 */
export type CreateChatCompletionStreamResponseChoicesInner = {
    /**
     * 
     * @type {ChatCompletionStreamResponseDelta}
     * @memberof CreateChatCompletionStreamResponseChoicesInner
     */
    delta: ChatCompletionStreamResponseDelta;
    /**
     * 
     * @type {CreateChatCompletionResponseChoicesInnerLogprobs}
     * @memberof CreateChatCompletionStreamResponseChoicesInner
     */
    logprobs?: CreateChatCompletionResponseChoicesInnerLogprobs;
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
     * @type {string}
     * @memberof CreateChatCompletionStreamResponseChoicesInner
     */
    finish_reason: CreateChatCompletionStreamResponseChoicesInnerFinishReasonEnum;
    /**
     * The index of the choice in the list of choices.
     * @type {number}
     * @memberof CreateChatCompletionStreamResponseChoicesInner
     */
    index: number;
}

/**
 * 
 * @export
 */
export type CreateCompletionRequest = {
    /**
     * 
     * @type {CreateCompletionRequestModel}
     * @memberof CreateCompletionRequest
     */
    model: CreateCompletionRequestModel;
    /**
     * 
     * @type {CreateCompletionRequestPrompt}
     * @memberof CreateCompletionRequest
     */
    prompt: CreateCompletionRequestPrompt;
    /**
     * Generates `best_of` completions server-side and returns the \"best\" (the one with the highest log probability per token). Results cannot be streamed.  When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return – `best_of` must be greater than `n`.  **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`. 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    best_of?: number;
    /**
     * Echo back the prompt in addition to the completion 
     * @type {boolean}
     * @memberof CreateCompletionRequest
     */
    echo?: boolean;
    /**
     * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model\'s likelihood to repeat the same line verbatim.  [See more information about frequency and presence penalties.](/docs/guides/text-generation/parameter-details) 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    frequency_penalty?: number;
    /**
     * Modify the likelihood of specified tokens appearing in the completion.  Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.  As an example, you can pass `{\"50256\": -100}` to prevent the <|endoftext|> token from being generated. 
     * @type {{ [key: string]: number; }}
     * @memberof CreateCompletionRequest
     */
    logit_bias?: { [key: string]: number; };
    /**
     * Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.  The maximum value for `logprobs` is 5. 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    logprobs?: number;
    /**
     * The maximum number of [tokens](/tokenizer) that can be generated in the completion.  The token count of your prompt plus `max_tokens` cannot exceed the model\'s context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    max_tokens?: number;
    /**
     * How many completions to generate for each prompt.  **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`. 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    n?: number;
    /**
     * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model\'s likelihood to talk about new topics.  [See more information about frequency and presence penalties.](/docs/guides/text-generation/parameter-details) 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    presence_penalty?: number;
    /**
     * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.  Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend. 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    seed?: number;
    /**
     * 
     * @type {CreateCompletionRequestStop}
     * @memberof CreateCompletionRequest
     */
    stop?: CreateCompletionRequestStop;
    /**
     * Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions). 
     * @type {boolean}
     * @memberof CreateCompletionRequest
     */
    stream?: boolean;
    /**
     * The suffix that comes after a completion of inserted text.  This parameter is only supported for `gpt-3.5-turbo-instruct`. 
     * @type {string}
     * @memberof CreateCompletionRequest
     */
    suffix?: string;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or `top_p` but not both. 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    temperature?: number;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or `temperature` but not both. 
     * @type {number}
     * @memberof CreateCompletionRequest
     */
    top_p?: number;
    /**
     * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
     * @type {string}
     * @memberof CreateCompletionRequest
     */
    user?: string;
}

/**
 * ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them. 
 * @export
 */
export type CreateCompletionRequestModel = {
}

/**
 * The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.  Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document. 
 * @export
 */
export type CreateCompletionRequestPrompt = {
}

/**
 * Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence. 
 * @export
 */
export type CreateCompletionRequestStop = {
}


            export type CreateCompletionResponseObjectEnum = 'text_completion';
/**
 * Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape (unlike the chat endpoint). 
 * @export
 */
export type CreateCompletionResponse = {
    /**
     * A unique identifier for the completion.
     * @type {string}
     * @memberof CreateCompletionResponse
     */
    id: string;
    /**
     * The list of completion choices the model generated for the input prompt.
     * @type {Array<CreateCompletionResponseChoicesInner>}
     * @memberof CreateCompletionResponse
     */
    choices: Array<CreateCompletionResponseChoicesInner>;
    /**
     * The Unix timestamp (in seconds) of when the completion was created.
     * @type {number}
     * @memberof CreateCompletionResponse
     */
    created: number;
    /**
     * The model used for completion.
     * @type {string}
     * @memberof CreateCompletionResponse
     */
    model: string;
    /**
     * This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
     * @type {string}
     * @memberof CreateCompletionResponse
     */
    system_fingerprint?: string;
    /**
     * The object type, which is always \"text_completion\"
     * @type {string}
     * @memberof CreateCompletionResponse
     */
    _object: CreateCompletionResponseObjectEnum;
    /**
     * 
     * @type {CompletionUsage}
     * @memberof CreateCompletionResponse
     */
    usage?: CompletionUsage;
}


            export type CreateCompletionResponseChoicesInnerFinishReasonEnum = 'stop' | 'length' | 'content_filter';
/**
 * 
 * @export
 */
export type CreateCompletionResponseChoicesInner = {
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, or `content_filter` if content was omitted due to a flag from our content filters. 
     * @type {string}
     * @memberof CreateCompletionResponseChoicesInner
     */
    finish_reason: CreateCompletionResponseChoicesInnerFinishReasonEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateCompletionResponseChoicesInner
     */
    index: number;
    /**
     * 
     * @type {CreateCompletionResponseChoicesInnerLogprobs}
     * @memberof CreateCompletionResponseChoicesInner
     */
    logprobs: CreateCompletionResponseChoicesInnerLogprobs;
    /**
     * 
     * @type {string}
     * @memberof CreateCompletionResponseChoicesInner
     */
    text: string;
}

/**
 * 
 * @export
 */
export type CreateCompletionResponseChoicesInnerLogprobs = {
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateCompletionResponseChoicesInnerLogprobs
     */
    text_offset?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateCompletionResponseChoicesInnerLogprobs
     */
    token_logprobs?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCompletionResponseChoicesInnerLogprobs
     */
    tokens?: Array<string>;
    /**
     * 
     * @type {Array<{ [key: string]: number; }>}
     * @memberof CreateCompletionResponseChoicesInnerLogprobs
     */
    top_logprobs?: Array<{ [key: string]: number; }>;
}


            export type CreateEmbeddingRequestEncodingFormatEnum = 'float' | 'base64';
/**
 * 
 * @export
 */
export type CreateEmbeddingRequest = {
    /**
     * 
     * @type {CreateEmbeddingRequestInput}
     * @memberof CreateEmbeddingRequest
     */
    input: CreateEmbeddingRequestInput;
    /**
     * 
     * @type {CreateEmbeddingRequestModel}
     * @memberof CreateEmbeddingRequest
     */
    model: CreateEmbeddingRequestModel;
    /**
     * The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
     * @type {string}
     * @memberof CreateEmbeddingRequest
     */
    encoding_format?: CreateEmbeddingRequestEncodingFormatEnum;
    /**
     * The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models. 
     * @type {number}
     * @memberof CreateEmbeddingRequest
     */
    dimensions?: number;
    /**
     * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
     * @type {string}
     * @memberof CreateEmbeddingRequest
     */
    user?: string;
}

/**
 * Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. 
 * @export
 */
export type CreateEmbeddingRequestInput = {
}

/**
 * ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them. 
 * @export
 */
export type CreateEmbeddingRequestModel = {
}


            export type CreateEmbeddingResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type CreateEmbeddingResponse = {
    /**
     * The list of embeddings generated by the model.
     * @type {Array<Embedding>}
     * @memberof CreateEmbeddingResponse
     */
    data: Array<Embedding>;
    /**
     * The name of the model used to generate the embedding.
     * @type {string}
     * @memberof CreateEmbeddingResponse
     */
    model: string;
    /**
     * The object type, which is always \"list\".
     * @type {string}
     * @memberof CreateEmbeddingResponse
     */
    _object: CreateEmbeddingResponseObjectEnum;
    /**
     * 
     * @type {CreateEmbeddingResponseUsage}
     * @memberof CreateEmbeddingResponse
     */
    usage: CreateEmbeddingResponseUsage;
}

/**
 * The usage information for the request.
 * @export
 */
export type CreateEmbeddingResponseUsage = {
    /**
     * The number of tokens used by the prompt.
     * @type {number}
     * @memberof CreateEmbeddingResponseUsage
     */
    prompt_tokens: number;
    /**
     * The total number of tokens used by the request.
     * @type {number}
     * @memberof CreateEmbeddingResponseUsage
     */
    total_tokens: number;
}

/**
 * 
 * @export
 */
export type CreateFineTuningJobRequest = {
    /**
     * 
     * @type {CreateFineTuningJobRequestModel}
     * @memberof CreateFineTuningJobRequest
     */
    model: CreateFineTuningJobRequestModel;
    /**
     * The ID of an uploaded file that contains training data.  See [upload file](/docs/api-reference/files/upload) for how to upload a file.  Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.  See the [fine-tuning guide](/docs/guides/fine-tuning) for more details. 
     * @type {string}
     * @memberof CreateFineTuningJobRequest
     */
    training_file: string;
    /**
     * 
     * @type {CreateFineTuningJobRequestHyperparameters}
     * @memberof CreateFineTuningJobRequest
     */
    hyperparameters?: CreateFineTuningJobRequestHyperparameters;
    /**
     * A string of up to 18 characters that will be added to your fine-tuned model name.  For example, a `suffix` of \"custom-model-name\" would produce a model name like `ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel`. 
     * @type {string}
     * @memberof CreateFineTuningJobRequest
     */
    suffix?: string;
    /**
     * The ID of an uploaded file that contains validation data.  If you provide this file, the data is used to generate validation metrics periodically during fine-tuning. These metrics can be viewed in the fine-tuning results file. The same data should not be present in both train and validation files.  Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.  See the [fine-tuning guide](/docs/guides/fine-tuning) for more details. 
     * @type {string}
     * @memberof CreateFineTuningJobRequest
     */
    validation_file?: string;
    /**
     * A list of integrations to enable for your fine-tuning job.
     * @type {Array<CreateFineTuningJobRequestIntegrationsInner>}
     * @memberof CreateFineTuningJobRequest
     */
    integrations?: Array<CreateFineTuningJobRequestIntegrationsInner>;
    /**
     * The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases. If a seed is not specified, one will be generated for you. 
     * @type {number}
     * @memberof CreateFineTuningJobRequest
     */
    seed?: number;
}

/**
 * The hyperparameters used for the fine-tuning job.
 * @export
 */
export type CreateFineTuningJobRequestHyperparameters = {
    /**
     * 
     * @type {CreateFineTuningJobRequestHyperparametersBatchSize}
     * @memberof CreateFineTuningJobRequestHyperparameters
     */
    batch_size?: CreateFineTuningJobRequestHyperparametersBatchSize;
    /**
     * 
     * @type {CreateFineTuningJobRequestHyperparametersLearningRateMultiplier}
     * @memberof CreateFineTuningJobRequestHyperparameters
     */
    learning_rate_multiplier?: CreateFineTuningJobRequestHyperparametersLearningRateMultiplier;
    /**
     * 
     * @type {CreateFineTuningJobRequestHyperparametersNEpochs}
     * @memberof CreateFineTuningJobRequestHyperparameters
     */
    n_epochs?: CreateFineTuningJobRequestHyperparametersNEpochs;
}

/**
 * Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance. 
 * @export
 */
export type CreateFineTuningJobRequestHyperparametersBatchSize = {
}

/**
 * Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting. 
 * @export
 */
export type CreateFineTuningJobRequestHyperparametersLearningRateMultiplier = {
}

/**
 * The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset. 
 * @export
 */
export type CreateFineTuningJobRequestHyperparametersNEpochs = {
}

/**
 * 
 * @export
 */
export type CreateFineTuningJobRequestIntegrationsInner = {
    /**
     * 
     * @type {CreateFineTuningJobRequestIntegrationsInnerType}
     * @memberof CreateFineTuningJobRequestIntegrationsInner
     */
    type: CreateFineTuningJobRequestIntegrationsInnerType;
    /**
     * 
     * @type {CreateFineTuningJobRequestIntegrationsInnerWandb}
     * @memberof CreateFineTuningJobRequestIntegrationsInner
     */
    wandb: CreateFineTuningJobRequestIntegrationsInnerWandb;
}

/**
 * The type of integration to enable. Currently, only \"wandb\" (Weights and Biases) is supported. 
 * @export
 */
export type CreateFineTuningJobRequestIntegrationsInnerType = {
}

/**
 * The settings for your integration with Weights and Biases. This payload specifies the project that metrics will be sent to. Optionally, you can set an explicit display name for your run, add tags to your run, and set a default entity (team, username, etc) to be associated with your run. 
 * @export
 */
export type CreateFineTuningJobRequestIntegrationsInnerWandb = {
    /**
     * The name of the project that the new run will be created under. 
     * @type {string}
     * @memberof CreateFineTuningJobRequestIntegrationsInnerWandb
     */
    project: string;
    /**
     * A display name to set for the run. If not set, we will use the Job ID as the name. 
     * @type {string}
     * @memberof CreateFineTuningJobRequestIntegrationsInnerWandb
     */
    name?: string;
    /**
     * The entity to use for the run. This allows you to set the team or username of the WandB user that you would like associated with the run. If not set, the default entity for the registered WandB API key is used. 
     * @type {string}
     * @memberof CreateFineTuningJobRequestIntegrationsInnerWandb
     */
    entity?: string;
    /**
     * A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some default tags are generated by OpenAI: \"openai/finetune\", \"openai/{base-model}\", \"openai/{ftjob-abcdef}\". 
     * @type {Array<string>}
     * @memberof CreateFineTuningJobRequestIntegrationsInnerWandb
     */
    tags?: Array<string>;
}

/**
 * The name of the model to fine-tune. You can select one of the [supported models](/docs/guides/fine-tuning/what-models-can-be-fine-tuned). 
 * @export
 */
export type CreateFineTuningJobRequestModel = {
}

/**
 * The model to use for image generation. Only `dall-e-2` is supported at this time.
 * @export
 */
export type CreateImageEditRequestModel = {
}


            export type CreateImageRequestQualityEnum = 'standard' | 'hd';

            export type CreateImageRequestResponseFormatEnum = 'url' | 'b64_json';

            export type CreateImageRequestSizeEnum = '256x256' | '512x512' | '1024x1024' | '1792x1024' | '1024x1792';

            export type CreateImageRequestStyleEnum = 'vivid' | 'natural';
/**
 * 
 * @export
 */
export type CreateImageRequest = {
    /**
     * A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
     * @type {string}
     * @memberof CreateImageRequest
     */
    prompt: string;
    /**
     * 
     * @type {CreateImageRequestModel}
     * @memberof CreateImageRequest
     */
    model?: CreateImageRequestModel;
    /**
     * The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
     * @type {number}
     * @memberof CreateImageRequest
     */
    n?: number;
    /**
     * The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
     * @type {string}
     * @memberof CreateImageRequest
     */
    quality?: CreateImageRequestQualityEnum;
    /**
     * The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
     * @type {string}
     * @memberof CreateImageRequest
     */
    response_format?: CreateImageRequestResponseFormatEnum;
    /**
     * The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
     * @type {string}
     * @memberof CreateImageRequest
     */
    size?: CreateImageRequestSizeEnum;
    /**
     * The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
     * @type {string}
     * @memberof CreateImageRequest
     */
    style?: CreateImageRequestStyleEnum;
    /**
     * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
     * @type {string}
     * @memberof CreateImageRequest
     */
    user?: string;
}

/**
 * The model to use for image generation.
 * @export
 */
export type CreateImageRequestModel = {
}


            export type CreateMessageRequestRoleEnum = 'user' | 'assistant';
/**
 * 
 * @export
 */
export type CreateMessageRequest = {
    /**
     * The role of the entity that is creating the message. Allowed values include: - `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages. - `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation. 
     * @type {string}
     * @memberof CreateMessageRequest
     */
    role: CreateMessageRequestRoleEnum;
    /**
     * The content of the message.
     * @type {string}
     * @memberof CreateMessageRequest
     */
    content: string;
    /**
     * A list of [File](/docs/api-reference/files) IDs that the message should use. There can be a maximum of 10 files attached to a message. Useful for tools like `retrieval` and `code_interpreter` that can access and use files.
     * @type {Array<string>}
     * @memberof CreateMessageRequest
     */
    file_ids?: Array<string>;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
     * @type {Object}
     * @memberof CreateMessageRequest
     */
    metadata?: Object;
}

/**
 * 
 * @export
 */
export type CreateModerationRequest = {
    /**
     * 
     * @type {CreateModerationRequestInput}
     * @memberof CreateModerationRequest
     */
    input: CreateModerationRequestInput;
    /**
     * 
     * @type {CreateModerationRequestModel}
     * @memberof CreateModerationRequest
     */
    model?: CreateModerationRequestModel;
}

/**
 * The input text to classify
 * @export
 */
export type CreateModerationRequestInput = {
}

/**
 * Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.  The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`. 
 * @export
 */
export type CreateModerationRequestModel = {
}

/**
 * Represents if a given text input is potentially harmful.
 * @export
 */
export type CreateModerationResponse = {
    /**
     * The unique identifier for the moderation request.
     * @type {string}
     * @memberof CreateModerationResponse
     */
    id: string;
    /**
     * The model used to generate the moderation results.
     * @type {string}
     * @memberof CreateModerationResponse
     */
    model: string;
    /**
     * A list of moderation objects.
     * @type {Array<CreateModerationResponseResultsInner>}
     * @memberof CreateModerationResponse
     */
    results: Array<CreateModerationResponseResultsInner>;
}

/**
 * 
 * @export
 */
export type CreateModerationResponseResultsInner = {
    /**
     * Whether any of the below categories are flagged.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInner
     */
    flagged: boolean;
    /**
     * 
     * @type {CreateModerationResponseResultsInnerCategories}
     * @memberof CreateModerationResponseResultsInner
     */
    categories: CreateModerationResponseResultsInnerCategories;
    /**
     * 
     * @type {CreateModerationResponseResultsInnerCategoryScores}
     * @memberof CreateModerationResponseResultsInner
     */
    category_scores: CreateModerationResponseResultsInnerCategoryScores;
}

/**
 * A list of the categories, and whether they are flagged or not.
 * @export
 */
export type CreateModerationResponseResultsInnerCategories = {
    /**
     * Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    hate: boolean;
    /**
     * Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    hate_threatening: boolean;
    /**
     * Content that expresses, incites, or promotes harassing language towards any target.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    harassment: boolean;
    /**
     * Harassment content that also includes violence or serious harm towards any target.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    harassment_threatening: boolean;
    /**
     * Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    self_harm: boolean;
    /**
     * Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    self_harm_intent: boolean;
    /**
     * Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    self_harm_instructions: boolean;
    /**
     * Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    sexual: boolean;
    /**
     * Sexual content that includes an individual who is under 18 years old.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    sexual_minors: boolean;
    /**
     * Content that depicts death, violence, or physical injury.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    violence: boolean;
    /**
     * Content that depicts death, violence, or physical injury in graphic detail.
     * @type {boolean}
     * @memberof CreateModerationResponseResultsInnerCategories
     */
    violence_graphic: boolean;
}

/**
 * A list of the categories along with their scores as predicted by model.
 * @export
 */
export type CreateModerationResponseResultsInnerCategoryScores = {
    /**
     * The score for the category \'hate\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    hate: number;
    /**
     * The score for the category \'hate/threatening\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    hate_threatening: number;
    /**
     * The score for the category \'harassment\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    harassment: number;
    /**
     * The score for the category \'harassment/threatening\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    harassment_threatening: number;
    /**
     * The score for the category \'self-harm\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    self_harm: number;
    /**
     * The score for the category \'self-harm/intent\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    self_harm_intent: number;
    /**
     * The score for the category \'self-harm/instructions\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    self_harm_instructions: number;
    /**
     * The score for the category \'sexual\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    sexual: number;
    /**
     * The score for the category \'sexual/minors\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    sexual_minors: number;
    /**
     * The score for the category \'violence\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    violence: number;
    /**
     * The score for the category \'violence/graphic\'.
     * @type {number}
     * @memberof CreateModerationResponseResultsInnerCategoryScores
     */
    violence_graphic: number;
}

/**
 * 
 * @export
 */
export type CreateRunRequest = {
    /**
     * The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
     * @type {string}
     * @memberof CreateRunRequest
     */
    assistant_id: string;
    /**
     * 
     * @type {CreateRunRequestModel}
     * @memberof CreateRunRequest
     */
    model?: CreateRunRequestModel;
    /**
     * Overrides the [instructions](/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis.
     * @type {string}
     * @memberof CreateRunRequest
     */
    instructions?: string;
    /**
     * Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.
     * @type {string}
     * @memberof CreateRunRequest
     */
    additional_instructions?: string;
    /**
     * Adds additional messages to the thread before creating the run.
     * @type {Array<CreateMessageRequest>}
     * @memberof CreateRunRequest
     */
    additional_messages?: Array<CreateMessageRequest>;
    /**
     * Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
     * @type {Array<AssistantObjectToolsInner>}
     * @memberof CreateRunRequest
     */
    tools?: Array<AssistantObjectToolsInner>;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
     * @type {Object}
     * @memberof CreateRunRequest
     */
    metadata?: Object;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
     * @type {number}
     * @memberof CreateRunRequest
     */
    temperature?: number;
    /**
     * If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message. 
     * @type {boolean}
     * @memberof CreateRunRequest
     */
    stream?: boolean;
    /**
     * The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `complete`. See `incomplete_details` for more info. 
     * @type {number}
     * @memberof CreateRunRequest
     */
    max_prompt_tokens?: number;
    /**
     * The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `complete`. See `incomplete_details` for more info. 
     * @type {number}
     * @memberof CreateRunRequest
     */
    max_completion_tokens?: number;
    /**
     * 
     * @type {TruncationObject}
     * @memberof CreateRunRequest
     */
    truncation_strategy?: TruncationObject;
    /**
     * 
     * @type {AssistantsApiToolChoiceOption}
     * @memberof CreateRunRequest
     */
    tool_choice?: AssistantsApiToolChoiceOption;
    /**
     * 
     * @type {AssistantsApiResponseFormatOption}
     * @memberof CreateRunRequest
     */
    response_format?: AssistantsApiResponseFormatOption;
}

/**
 * The ID of the [Model](/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
 * @export
 */
export type CreateRunRequestModel = {
}


            export type CreateSpeechRequestVoiceEnum = 'alloy' | 'echo' | 'fable' | 'onyx' | 'nova' | 'shimmer';

            export type CreateSpeechRequestResponseFormatEnum = 'mp3' | 'opus' | 'aac' | 'flac' | 'wav' | 'pcm';
/**
 * 
 * @export
 */
export type CreateSpeechRequest = {
    /**
     * 
     * @type {CreateSpeechRequestModel}
     * @memberof CreateSpeechRequest
     */
    model: CreateSpeechRequestModel;
    /**
     * The text to generate audio for. The maximum length is 4096 characters.
     * @type {string}
     * @memberof CreateSpeechRequest
     */
    input: string;
    /**
     * The voice to use when generating the audio. Supported voices are `alloy`, `echo`, `fable`, `onyx`, `nova`, and `shimmer`. Previews of the voices are available in the [Text to speech guide](/docs/guides/text-to-speech/voice-options).
     * @type {string}
     * @memberof CreateSpeechRequest
     */
    voice: CreateSpeechRequestVoiceEnum;
    /**
     * The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`.
     * @type {string}
     * @memberof CreateSpeechRequest
     */
    response_format?: CreateSpeechRequestResponseFormatEnum;
    /**
     * The speed of the generated audio. Select a value from `0.25` to `4.0`. `1.0` is the default.
     * @type {number}
     * @memberof CreateSpeechRequest
     */
    speed?: number;
}

/**
 * One of the available [TTS models](/docs/models/tts): `tts-1` or `tts-1-hd` 
 * @export
 */
export type CreateSpeechRequestModel = {
}

/**
 * 
 * @export
 */
export type CreateThreadAndRunRequest = {
    /**
     * The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
     * @type {string}
     * @memberof CreateThreadAndRunRequest
     */
    assistant_id: string;
    /**
     * 
     * @type {CreateThreadRequest}
     * @memberof CreateThreadAndRunRequest
     */
    thread?: CreateThreadRequest;
    /**
     * 
     * @type {CreateRunRequestModel}
     * @memberof CreateThreadAndRunRequest
     */
    model?: CreateRunRequestModel;
    /**
     * Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.
     * @type {string}
     * @memberof CreateThreadAndRunRequest
     */
    instructions?: string;
    /**
     * Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
     * @type {Array<CreateThreadAndRunRequestToolsInner>}
     * @memberof CreateThreadAndRunRequest
     */
    tools?: Array<CreateThreadAndRunRequestToolsInner>;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
     * @type {Object}
     * @memberof CreateThreadAndRunRequest
     */
    metadata?: Object;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
     * @type {number}
     * @memberof CreateThreadAndRunRequest
     */
    temperature?: number;
    /**
     * If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message. 
     * @type {boolean}
     * @memberof CreateThreadAndRunRequest
     */
    stream?: boolean;
    /**
     * The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `complete`. See `incomplete_details` for more info. 
     * @type {number}
     * @memberof CreateThreadAndRunRequest
     */
    max_prompt_tokens?: number;
    /**
     * The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info. 
     * @type {number}
     * @memberof CreateThreadAndRunRequest
     */
    max_completion_tokens?: number;
    /**
     * 
     * @type {TruncationObject}
     * @memberof CreateThreadAndRunRequest
     */
    truncation_strategy?: TruncationObject;
    /**
     * 
     * @type {AssistantsApiToolChoiceOption}
     * @memberof CreateThreadAndRunRequest
     */
    tool_choice?: AssistantsApiToolChoiceOption;
    /**
     * 
     * @type {AssistantsApiResponseFormatOption}
     * @memberof CreateThreadAndRunRequest
     */
    response_format?: AssistantsApiResponseFormatOption;
}


            export type CreateThreadAndRunRequestToolsInnerTypeEnum = 'code_interpreter' | 'retrieval' | 'function';
/**
 * 
 * @export
 */
export type CreateThreadAndRunRequestToolsInner = {
    /**
     * The type of tool being defined: `code_interpreter`
     * @type {string}
     * @memberof CreateThreadAndRunRequestToolsInner
     */
    type: CreateThreadAndRunRequestToolsInnerTypeEnum;
    /**
     * 
     * @type {FunctionObject}
     * @memberof CreateThreadAndRunRequestToolsInner
     */
    _function: FunctionObject;
}

/**
 * 
 * @export
 */
export type CreateThreadRequest = {
    /**
     * A list of [messages](/docs/api-reference/messages) to start the thread with.
     * @type {Array<CreateMessageRequest>}
     * @memberof CreateThreadRequest
     */
    messages?: Array<CreateMessageRequest>;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
     * @type {Object}
     * @memberof CreateThreadRequest
     */
    metadata?: Object;
}

/**
 * 
 * @export
 */
export type CreateTranscription200Response = {
    /**
     * The transcribed text.
     * @type {string}
     * @memberof CreateTranscription200Response
     */
    text: string;
    /**
     * The language of the input audio.
     * @type {string}
     * @memberof CreateTranscription200Response
     */
    language: string;
    /**
     * The duration of the input audio.
     * @type {string}
     * @memberof CreateTranscription200Response
     */
    duration: string;
    /**
     * Extracted words and their corresponding timestamps.
     * @type {Array<TranscriptionWord>}
     * @memberof CreateTranscription200Response
     */
    words?: Array<TranscriptionWord>;
    /**
     * Segments of the transcribed text and their corresponding details.
     * @type {Array<TranscriptionSegment>}
     * @memberof CreateTranscription200Response
     */
    segments?: Array<TranscriptionSegment>;
}

/**
 * ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available. 
 * @export
 */
export type CreateTranscriptionRequestModel = {
}

/**
 * Represents a transcription response returned by model, based on the provided input.
 * @export
 */
export type CreateTranscriptionResponseJson = {
    /**
     * The transcribed text.
     * @type {string}
     * @memberof CreateTranscriptionResponseJson
     */
    text: string;
}

/**
 * Represents a verbose json transcription response returned by model, based on the provided input.
 * @export
 */
export type CreateTranscriptionResponseVerboseJson = {
    /**
     * The language of the input audio.
     * @type {string}
     * @memberof CreateTranscriptionResponseVerboseJson
     */
    language: string;
    /**
     * The duration of the input audio.
     * @type {string}
     * @memberof CreateTranscriptionResponseVerboseJson
     */
    duration: string;
    /**
     * The transcribed text.
     * @type {string}
     * @memberof CreateTranscriptionResponseVerboseJson
     */
    text: string;
    /**
     * Extracted words and their corresponding timestamps.
     * @type {Array<TranscriptionWord>}
     * @memberof CreateTranscriptionResponseVerboseJson
     */
    words?: Array<TranscriptionWord>;
    /**
     * Segments of the transcribed text and their corresponding details.
     * @type {Array<TranscriptionSegment>}
     * @memberof CreateTranscriptionResponseVerboseJson
     */
    segments?: Array<TranscriptionSegment>;
}

/**
 * 
 * @export
 */
export type CreateTranslation200Response = {
    /**
     * The translated text.
     * @type {string}
     * @memberof CreateTranslation200Response
     */
    text: string;
    /**
     * The language of the output translation (always `english`).
     * @type {string}
     * @memberof CreateTranslation200Response
     */
    language: string;
    /**
     * The duration of the input audio.
     * @type {string}
     * @memberof CreateTranslation200Response
     */
    duration: string;
    /**
     * Segments of the translated text and their corresponding details.
     * @type {Array<TranscriptionSegment>}
     * @memberof CreateTranslation200Response
     */
    segments?: Array<TranscriptionSegment>;
}

/**
 * 
 * @export
 */
export type CreateTranslationResponseJson = {
    /**
     * 
     * @type {string}
     * @memberof CreateTranslationResponseJson
     */
    text: string;
}

/**
 * 
 * @export
 */
export type CreateTranslationResponseVerboseJson = {
    /**
     * The language of the output translation (always `english`).
     * @type {string}
     * @memberof CreateTranslationResponseVerboseJson
     */
    language: string;
    /**
     * The duration of the input audio.
     * @type {string}
     * @memberof CreateTranslationResponseVerboseJson
     */
    duration: string;
    /**
     * The translated text.
     * @type {string}
     * @memberof CreateTranslationResponseVerboseJson
     */
    text: string;
    /**
     * Segments of the translated text and their corresponding details.
     * @type {Array<TranscriptionSegment>}
     * @memberof CreateTranslationResponseVerboseJson
     */
    segments?: Array<TranscriptionSegment>;
}


            export type DeleteAssistantFileResponseObjectEnum = 'assistant.file.deleted';
/**
 * Deletes the association between the assistant and the file, but does not delete the [File](/docs/api-reference/files) object itself.
 * @export
 */
export type DeleteAssistantFileResponse = {
    /**
     * 
     * @type {string}
     * @memberof DeleteAssistantFileResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteAssistantFileResponse
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeleteAssistantFileResponse
     */
    _object: DeleteAssistantFileResponseObjectEnum;
}


            export type DeleteAssistantResponseObjectEnum = 'assistant.deleted';
/**
 * 
 * @export
 */
export type DeleteAssistantResponse = {
    /**
     * 
     * @type {string}
     * @memberof DeleteAssistantResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteAssistantResponse
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeleteAssistantResponse
     */
    _object: DeleteAssistantResponseObjectEnum;
}


            export type DeleteFileResponseObjectEnum = 'file';
/**
 * 
 * @export
 */
export type DeleteFileResponse = {
    /**
     * 
     * @type {string}
     * @memberof DeleteFileResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DeleteFileResponse
     */
    _object: DeleteFileResponseObjectEnum;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteFileResponse
     */
    deleted: boolean;
}


            export type DeleteMessageResponseObjectEnum = 'thread.message.deleted';
/**
 * 
 * @export
 */
export type DeleteMessageResponse = {
    /**
     * 
     * @type {string}
     * @memberof DeleteMessageResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteMessageResponse
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeleteMessageResponse
     */
    _object: DeleteMessageResponseObjectEnum;
}

/**
 * 
 * @export
 */
export type DeleteModelResponse = {
    /**
     * 
     * @type {string}
     * @memberof DeleteModelResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteModelResponse
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeleteModelResponse
     */
    _object: string;
}


            export type DeleteThreadResponseObjectEnum = 'thread.deleted';
/**
 * 
 * @export
 */
export type DeleteThreadResponse = {
    /**
     * 
     * @type {string}
     * @memberof DeleteThreadResponse
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeleteThreadResponse
     */
    deleted: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeleteThreadResponse
     */
    _object: DeleteThreadResponseObjectEnum;
}


            export type DoneEventEventEnum = 'done';

            export type DoneEventDataEnum = '[DONE]';
/**
 * Occurs when a stream ends.
 * @export
 */
export type DoneEvent = {
    /**
     * 
     * @type {string}
     * @memberof DoneEvent
     */
    event: DoneEventEventEnum;
    /**
     * 
     * @type {string}
     * @memberof DoneEvent
     */
    data: DoneEventDataEnum;
}


            export type EmbeddingObjectEnum = 'embedding';
/**
 * Represents an embedding vector returned by embedding endpoint. 
 * @export
 */
export type Embedding = {
    /**
     * The index of the embedding in the list of embeddings.
     * @type {number}
     * @memberof Embedding
     */
    index: number;
    /**
     * The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](/docs/guides/embeddings). 
     * @type {Array<number>}
     * @memberof Embedding
     */
    embedding: Array<number>;
    /**
     * The object type, which is always \"embedding\".
     * @type {string}
     * @memberof Embedding
     */
    _object: EmbeddingObjectEnum;
}

/**
 * 
 * @export
 */
export type Error = {
    /**
     * 
     * @type {string}
     * @memberof Error
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof Error
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof Error
     */
    param: string;
    /**
     * 
     * @type {string}
     * @memberof Error
     */
    type: string;
}


            export type ErrorEventEventEnum = 'error';
/**
 * Occurs when an [error](/docs/guides/error-codes/api-errors) occurs. This can happen due to an internal server error or a timeout.
 * @export
 */
export type ErrorEvent = {
    /**
     * 
     * @type {string}
     * @memberof ErrorEvent
     */
    event: ErrorEventEventEnum;
    /**
     * 
     * @type {Error}
     * @memberof ErrorEvent
     */
    data: Error;
}

/**
 * 
 * @export
 */
export type ErrorResponse = {
    /**
     * 
     * @type {Error}
     * @memberof ErrorResponse
     */
    error: Error;
}


            export type FineTuningIntegrationTypeEnum = 'wandb';
/**
 * 
 * @export
 */
export type FineTuningIntegration = {
    /**
     * The type of the integration being enabled for the fine-tuning job
     * @type {string}
     * @memberof FineTuningIntegration
     */
    type: FineTuningIntegrationTypeEnum;
    /**
     * 
     * @type {CreateFineTuningJobRequestIntegrationsInnerWandb}
     * @memberof FineTuningIntegration
     */
    wandb: CreateFineTuningJobRequestIntegrationsInnerWandb;
}


            export type FineTuningJobObjectEnum = 'fine_tuning.job';

            export type FineTuningJobStatusEnum = 'validating_files' | 'queued' | 'running' | 'succeeded' | 'failed' | 'cancelled';
/**
 * The `fine_tuning.job` object represents a fine-tuning job that has been created through the API. 
 * @export
 */
export type FineTuningJob = {
    /**
     * The object identifier, which can be referenced in the API endpoints.
     * @type {string}
     * @memberof FineTuningJob
     */
    id: string;
    /**
     * The Unix timestamp (in seconds) for when the fine-tuning job was created.
     * @type {number}
     * @memberof FineTuningJob
     */
    created_at: number;
    /**
     * 
     * @type {FineTuningJobError}
     * @memberof FineTuningJob
     */
    error: FineTuningJobError;
    /**
     * The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
     * @type {string}
     * @memberof FineTuningJob
     */
    fine_tuned_model: string;
    /**
     * The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
     * @type {number}
     * @memberof FineTuningJob
     */
    finished_at: number;
    /**
     * 
     * @type {FineTuningJobHyperparameters}
     * @memberof FineTuningJob
     */
    hyperparameters: FineTuningJobHyperparameters;
    /**
     * The base model that is being fine-tuned.
     * @type {string}
     * @memberof FineTuningJob
     */
    model: string;
    /**
     * The object type, which is always \"fine_tuning.job\".
     * @type {string}
     * @memberof FineTuningJob
     */
    _object: FineTuningJobObjectEnum;
    /**
     * The organization that owns the fine-tuning job.
     * @type {string}
     * @memberof FineTuningJob
     */
    organization_id: string;
    /**
     * The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](/docs/api-reference/files/retrieve-contents).
     * @type {Array<string>}
     * @memberof FineTuningJob
     */
    result_files: Array<string>;
    /**
     * The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
     * @type {string}
     * @memberof FineTuningJob
     */
    status: FineTuningJobStatusEnum;
    /**
     * The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
     * @type {number}
     * @memberof FineTuningJob
     */
    trained_tokens: number;
    /**
     * The file ID used for training. You can retrieve the training data with the [Files API](/docs/api-reference/files/retrieve-contents).
     * @type {string}
     * @memberof FineTuningJob
     */
    training_file: string;
    /**
     * The file ID used for validation. You can retrieve the validation results with the [Files API](/docs/api-reference/files/retrieve-contents).
     * @type {string}
     * @memberof FineTuningJob
     */
    validation_file: string;
    /**
     * A list of integrations to enable for this fine-tuning job.
     * @type {Array<FineTuningJobIntegrationsInner>}
     * @memberof FineTuningJob
     */
    integrations?: Array<FineTuningJobIntegrationsInner>;
    /**
     * The seed used for the fine-tuning job.
     * @type {number}
     * @memberof FineTuningJob
     */
    seed: number;
}


            export type FineTuningJobCheckpointObjectEnum = 'fine_tuning.job.checkpoint';
/**
 * The `fine_tuning.job.checkpoint` object represents a model checkpoint for a fine-tuning job that is ready to use. 
 * @export
 */
export type FineTuningJobCheckpoint = {
    /**
     * The checkpoint identifier, which can be referenced in the API endpoints.
     * @type {string}
     * @memberof FineTuningJobCheckpoint
     */
    id: string;
    /**
     * The Unix timestamp (in seconds) for when the checkpoint was created.
     * @type {number}
     * @memberof FineTuningJobCheckpoint
     */
    created_at: number;
    /**
     * The name of the fine-tuned checkpoint model that is created.
     * @type {string}
     * @memberof FineTuningJobCheckpoint
     */
    fine_tuned_model_checkpoint: string;
    /**
     * The step number that the checkpoint was created at.
     * @type {number}
     * @memberof FineTuningJobCheckpoint
     */
    step_number: number;
    /**
     * 
     * @type {FineTuningJobCheckpointMetrics}
     * @memberof FineTuningJobCheckpoint
     */
    metrics: FineTuningJobCheckpointMetrics;
    /**
     * The name of the fine-tuning job that this checkpoint was created from.
     * @type {string}
     * @memberof FineTuningJobCheckpoint
     */
    fine_tuning_job_id: string;
    /**
     * The object type, which is always \"fine_tuning.job.checkpoint\".
     * @type {string}
     * @memberof FineTuningJobCheckpoint
     */
    _object: FineTuningJobCheckpointObjectEnum;
}

/**
 * Metrics at the step number during the fine-tuning job.
 * @export
 */
export type FineTuningJobCheckpointMetrics = {
    /**
     * 
     * @type {number}
     * @memberof FineTuningJobCheckpointMetrics
     */
    step?: number;
    /**
     * 
     * @type {number}
     * @memberof FineTuningJobCheckpointMetrics
     */
    train_loss?: number;
    /**
     * 
     * @type {number}
     * @memberof FineTuningJobCheckpointMetrics
     */
    train_mean_token_accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof FineTuningJobCheckpointMetrics
     */
    valid_loss?: number;
    /**
     * 
     * @type {number}
     * @memberof FineTuningJobCheckpointMetrics
     */
    valid_mean_token_accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof FineTuningJobCheckpointMetrics
     */
    full_valid_loss?: number;
    /**
     * 
     * @type {number}
     * @memberof FineTuningJobCheckpointMetrics
     */
    full_valid_mean_token_accuracy?: number;
}

/**
 * For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
 * @export
 */
export type FineTuningJobError = {
    /**
     * A machine-readable error code.
     * @type {string}
     * @memberof FineTuningJobError
     */
    code: string;
    /**
     * A human-readable error message.
     * @type {string}
     * @memberof FineTuningJobError
     */
    message: string;
    /**
     * The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
     * @type {string}
     * @memberof FineTuningJobError
     */
    param: string;
}


            export type FineTuningJobEventLevelEnum = 'info' | 'warn' | 'error';

            export type FineTuningJobEventObjectEnum = 'fine_tuning.job.event';
/**
 * Fine-tuning job event object
 * @export
 */
export type FineTuningJobEvent = {
    /**
     * 
     * @type {string}
     * @memberof FineTuningJobEvent
     */
    id: string;
    /**
     * 
     * @type {number}
     * @memberof FineTuningJobEvent
     */
    created_at: number;
    /**
     * 
     * @type {string}
     * @memberof FineTuningJobEvent
     */
    level: FineTuningJobEventLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof FineTuningJobEvent
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FineTuningJobEvent
     */
    _object: FineTuningJobEventObjectEnum;
}

/**
 * The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](/docs/guides/fine-tuning) for more details.
 * @export
 */
export type FineTuningJobHyperparameters = {
    /**
     * 
     * @type {FineTuningJobHyperparametersNEpochs}
     * @memberof FineTuningJobHyperparameters
     */
    n_epochs: FineTuningJobHyperparametersNEpochs;
}

/**
 * The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset. \"auto\" decides the optimal number of epochs based on the size of the dataset. If setting the number manually, we support any number between 1 and 50 epochs.
 * @export
 */
export type FineTuningJobHyperparametersNEpochs = {
}


            export type FineTuningJobIntegrationsInnerTypeEnum = 'wandb';
/**
 * 
 * @export
 */
export type FineTuningJobIntegrationsInner = {
    /**
     * The type of the integration being enabled for the fine-tuning job
     * @type {string}
     * @memberof FineTuningJobIntegrationsInner
     */
    type: FineTuningJobIntegrationsInnerTypeEnum;
    /**
     * 
     * @type {CreateFineTuningJobRequestIntegrationsInnerWandb}
     * @memberof FineTuningJobIntegrationsInner
     */
    wandb: CreateFineTuningJobRequestIntegrationsInnerWandb;
}

/**
 * 
 * @export
 */
export type FunctionObject = {
    /**
     * A description of what the function does, used by the model to choose when and how to call the function.
     * @type {string}
     * @memberof FunctionObject
     */
    description?: string;
    /**
     * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     * @type {string}
     * @memberof FunctionObject
     */
    name: string;
    /**
     * The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/text-generation/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.   Omitting `parameters` defines a function with an empty parameter list.
     * @type {{ [key: string]: AnyType; }}
     * @memberof FunctionObject
     */
    parameters?: { [key: string]: AnyType; };
}

/**
 * Represents the url or the content of an image generated by the OpenAI API.
 * @export
 */
export type Image = {
    /**
     * The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
     * @type {string}
     * @memberof Image
     */
    b64_json?: string;
    /**
     * The URL of the generated image, if `response_format` is `url` (default).
     * @type {string}
     * @memberof Image
     */
    url?: string;
    /**
     * The prompt that was used to generate the image, if there was any revision to the prompt.
     * @type {string}
     * @memberof Image
     */
    revised_prompt?: string;
}

/**
 * 
 * @export
 */
export type ImagesResponse = {
    /**
     * 
     * @type {number}
     * @memberof ImagesResponse
     */
    created: number;
    /**
     * 
     * @type {Array<Image>}
     * @memberof ImagesResponse
     */
    data: Array<Image>;
}

/**
 * 
 * @export
 */
export type ListAssistantFilesResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListAssistantFilesResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<AssistantFileObject>}
     * @memberof ListAssistantFilesResponse
     */
    data: Array<AssistantFileObject>;
    /**
     * 
     * @type {string}
     * @memberof ListAssistantFilesResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListAssistantFilesResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListAssistantFilesResponse
     */
    has_more: boolean;
}

/**
 * 
 * @export
 */
export type ListAssistantsResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListAssistantsResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<AssistantObject>}
     * @memberof ListAssistantsResponse
     */
    data: Array<AssistantObject>;
    /**
     * 
     * @type {string}
     * @memberof ListAssistantsResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListAssistantsResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListAssistantsResponse
     */
    has_more: boolean;
}


            export type ListFilesResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type ListFilesResponse = {
    /**
     * 
     * @type {Array<OpenAIFile>}
     * @memberof ListFilesResponse
     */
    data: Array<OpenAIFile>;
    /**
     * 
     * @type {string}
     * @memberof ListFilesResponse
     */
    _object: ListFilesResponseObjectEnum;
}


            export type ListFineTuningJobCheckpointsResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type ListFineTuningJobCheckpointsResponse = {
    /**
     * 
     * @type {Array<FineTuningJobCheckpoint>}
     * @memberof ListFineTuningJobCheckpointsResponse
     */
    data: Array<FineTuningJobCheckpoint>;
    /**
     * 
     * @type {string}
     * @memberof ListFineTuningJobCheckpointsResponse
     */
    _object: ListFineTuningJobCheckpointsResponseObjectEnum;
    /**
     * 
     * @type {string}
     * @memberof ListFineTuningJobCheckpointsResponse
     */
    first_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ListFineTuningJobCheckpointsResponse
     */
    last_id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListFineTuningJobCheckpointsResponse
     */
    has_more: boolean;
}


            export type ListFineTuningJobEventsResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type ListFineTuningJobEventsResponse = {
    /**
     * 
     * @type {Array<FineTuningJobEvent>}
     * @memberof ListFineTuningJobEventsResponse
     */
    data: Array<FineTuningJobEvent>;
    /**
     * 
     * @type {string}
     * @memberof ListFineTuningJobEventsResponse
     */
    _object: ListFineTuningJobEventsResponseObjectEnum;
}

/**
 * 
 * @export
 */
export type ListMessageFilesResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListMessageFilesResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<MessageFileObject>}
     * @memberof ListMessageFilesResponse
     */
    data: Array<MessageFileObject>;
    /**
     * 
     * @type {string}
     * @memberof ListMessageFilesResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListMessageFilesResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListMessageFilesResponse
     */
    has_more: boolean;
}

/**
 * 
 * @export
 */
export type ListMessagesResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListMessagesResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<MessageObject>}
     * @memberof ListMessagesResponse
     */
    data: Array<MessageObject>;
    /**
     * 
     * @type {string}
     * @memberof ListMessagesResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListMessagesResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListMessagesResponse
     */
    has_more: boolean;
}


            export type ListModelsResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type ListModelsResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListModelsResponse
     */
    _object: ListModelsResponseObjectEnum;
    /**
     * 
     * @type {Array<Model>}
     * @memberof ListModelsResponse
     */
    data: Array<Model>;
}


            export type ListPaginatedFineTuningJobsResponseObjectEnum = 'list';
/**
 * 
 * @export
 */
export type ListPaginatedFineTuningJobsResponse = {
    /**
     * 
     * @type {Array<FineTuningJob>}
     * @memberof ListPaginatedFineTuningJobsResponse
     */
    data: Array<FineTuningJob>;
    /**
     * 
     * @type {boolean}
     * @memberof ListPaginatedFineTuningJobsResponse
     */
    has_more: boolean;
    /**
     * 
     * @type {string}
     * @memberof ListPaginatedFineTuningJobsResponse
     */
    _object: ListPaginatedFineTuningJobsResponseObjectEnum;
}

/**
 * 
 * @export
 */
export type ListRunStepsResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListRunStepsResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<RunStepObject>}
     * @memberof ListRunStepsResponse
     */
    data: Array<RunStepObject>;
    /**
     * 
     * @type {string}
     * @memberof ListRunStepsResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListRunStepsResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListRunStepsResponse
     */
    has_more: boolean;
}

/**
 * 
 * @export
 */
export type ListRunsResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListRunsResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<RunObject>}
     * @memberof ListRunsResponse
     */
    data: Array<RunObject>;
    /**
     * 
     * @type {string}
     * @memberof ListRunsResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListRunsResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListRunsResponse
     */
    has_more: boolean;
}

/**
 * 
 * @export
 */
export type ListThreadsResponse = {
    /**
     * 
     * @type {string}
     * @memberof ListThreadsResponse
     */
    _object: string;
    /**
     * 
     * @type {Array<ThreadObject>}
     * @memberof ListThreadsResponse
     */
    data: Array<ThreadObject>;
    /**
     * 
     * @type {string}
     * @memberof ListThreadsResponse
     */
    first_id: string;
    /**
     * 
     * @type {string}
     * @memberof ListThreadsResponse
     */
    last_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListThreadsResponse
     */
    has_more: boolean;
}


            export type MessageContentImageFileObjectTypeEnum = 'image_file';
/**
 * References an image [File](/docs/api-reference/files) in the content of a message.
 * @export
 */
export type MessageContentImageFileObject = {
    /**
     * Always `image_file`.
     * @type {string}
     * @memberof MessageContentImageFileObject
     */
    type: MessageContentImageFileObjectTypeEnum;
    /**
     * 
     * @type {MessageContentImageFileObjectImageFile}
     * @memberof MessageContentImageFileObject
     */
    image_file: MessageContentImageFileObjectImageFile;
}

/**
 * 
 * @export
 */
export type MessageContentImageFileObjectImageFile = {
    /**
     * The [File](/docs/api-reference/files) ID of the image in the message content.
     * @type {string}
     * @memberof MessageContentImageFileObjectImageFile
     */
    file_id: string;
}


            export type MessageContentTextAnnotationsFileCitationObjectTypeEnum = 'file_citation';
/**
 * A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"retrieval\" tool to search files.
 * @export
 */
export type MessageContentTextAnnotationsFileCitationObject = {
    /**
     * Always `file_citation`.
     * @type {string}
     * @memberof MessageContentTextAnnotationsFileCitationObject
     */
    type: MessageContentTextAnnotationsFileCitationObjectTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     * @type {string}
     * @memberof MessageContentTextAnnotationsFileCitationObject
     */
    text: string;
    /**
     * 
     * @type {MessageContentTextAnnotationsFileCitationObjectFileCitation}
     * @memberof MessageContentTextAnnotationsFileCitationObject
     */
    file_citation: MessageContentTextAnnotationsFileCitationObjectFileCitation;
    /**
     * 
     * @type {number}
     * @memberof MessageContentTextAnnotationsFileCitationObject
     */
    start_index: number;
    /**
     * 
     * @type {number}
     * @memberof MessageContentTextAnnotationsFileCitationObject
     */
    end_index: number;
}

/**
 * 
 * @export
 */
export type MessageContentTextAnnotationsFileCitationObjectFileCitation = {
    /**
     * The ID of the specific File the citation is from.
     * @type {string}
     * @memberof MessageContentTextAnnotationsFileCitationObjectFileCitation
     */
    file_id: string;
    /**
     * The specific quote in the file.
     * @type {string}
     * @memberof MessageContentTextAnnotationsFileCitationObjectFileCitation
     */
    quote: string;
}


            export type MessageContentTextAnnotationsFilePathObjectTypeEnum = 'file_path';
/**
 * A URL for the file that\'s generated when the assistant used the `code_interpreter` tool to generate a file.
 * @export
 */
export type MessageContentTextAnnotationsFilePathObject = {
    /**
     * Always `file_path`.
     * @type {string}
     * @memberof MessageContentTextAnnotationsFilePathObject
     */
    type: MessageContentTextAnnotationsFilePathObjectTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     * @type {string}
     * @memberof MessageContentTextAnnotationsFilePathObject
     */
    text: string;
    /**
     * 
     * @type {MessageContentTextAnnotationsFilePathObjectFilePath}
     * @memberof MessageContentTextAnnotationsFilePathObject
     */
    file_path: MessageContentTextAnnotationsFilePathObjectFilePath;
    /**
     * 
     * @type {number}
     * @memberof MessageContentTextAnnotationsFilePathObject
     */
    start_index: number;
    /**
     * 
     * @type {number}
     * @memberof MessageContentTextAnnotationsFilePathObject
     */
    end_index: number;
}

/**
 * 
 * @export
 */
export type MessageContentTextAnnotationsFilePathObjectFilePath = {
    /**
     * The ID of the file that was generated.
     * @type {string}
     * @memberof MessageContentTextAnnotationsFilePathObjectFilePath
     */
    file_id: string;
}


            export type MessageContentTextObjectTypeEnum = 'text';
/**
 * The text content that is part of a message.
 * @export
 */
export type MessageContentTextObject = {
    /**
     * Always `text`.
     * @type {string}
     * @memberof MessageContentTextObject
     */
    type: MessageContentTextObjectTypeEnum;
    /**
     * 
     * @type {MessageContentTextObjectText}
     * @memberof MessageContentTextObject
     */
    text: MessageContentTextObjectText;
}

/**
 * 
 * @export
 */
export type MessageContentTextObjectText = {
    /**
     * The data that makes up the text.
     * @type {string}
     * @memberof MessageContentTextObjectText
     */
    value: string;
    /**
     * 
     * @type {Array<MessageContentTextObjectTextAnnotationsInner>}
     * @memberof MessageContentTextObjectText
     */
    annotations: Array<MessageContentTextObjectTextAnnotationsInner>;
}


            export type MessageContentTextObjectTextAnnotationsInnerTypeEnum = 'file_citation' | 'file_path';
/**
 * 
 * @export
 */
export type MessageContentTextObjectTextAnnotationsInner = {
    /**
     * Always `file_citation`.
     * @type {string}
     * @memberof MessageContentTextObjectTextAnnotationsInner
     */
    type: MessageContentTextObjectTextAnnotationsInnerTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     * @type {string}
     * @memberof MessageContentTextObjectTextAnnotationsInner
     */
    text: string;
    /**
     * 
     * @type {MessageContentTextAnnotationsFileCitationObjectFileCitation}
     * @memberof MessageContentTextObjectTextAnnotationsInner
     */
    file_citation: MessageContentTextAnnotationsFileCitationObjectFileCitation;
    /**
     * 
     * @type {number}
     * @memberof MessageContentTextObjectTextAnnotationsInner
     */
    start_index: number;
    /**
     * 
     * @type {number}
     * @memberof MessageContentTextObjectTextAnnotationsInner
     */
    end_index: number;
    /**
     * 
     * @type {MessageContentTextAnnotationsFilePathObjectFilePath}
     * @memberof MessageContentTextObjectTextAnnotationsInner
     */
    file_path: MessageContentTextAnnotationsFilePathObjectFilePath;
}


            export type MessageDeltaContentImageFileObjectTypeEnum = 'image_file';
/**
 * References an image [File](/docs/api-reference/files) in the content of a message.
 * @export
 */
export type MessageDeltaContentImageFileObject = {
    /**
     * The index of the content part in the message.
     * @type {number}
     * @memberof MessageDeltaContentImageFileObject
     */
    index: number;
    /**
     * Always `image_file`.
     * @type {string}
     * @memberof MessageDeltaContentImageFileObject
     */
    type: MessageDeltaContentImageFileObjectTypeEnum;
    /**
     * 
     * @type {MessageDeltaContentImageFileObjectImageFile}
     * @memberof MessageDeltaContentImageFileObject
     */
    image_file?: MessageDeltaContentImageFileObjectImageFile;
}

/**
 * 
 * @export
 */
export type MessageDeltaContentImageFileObjectImageFile = {
    /**
     * The [File](/docs/api-reference/files) ID of the image in the message content.
     * @type {string}
     * @memberof MessageDeltaContentImageFileObjectImageFile
     */
    file_id?: string;
}


            export type MessageDeltaContentTextAnnotationsFileCitationObjectTypeEnum = 'file_citation';
/**
 * A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"retrieval\" tool to search files.
 * @export
 */
export type MessageDeltaContentTextAnnotationsFileCitationObject = {
    /**
     * The index of the annotation in the text content part.
     * @type {number}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObject
     */
    index: number;
    /**
     * Always `file_citation`.
     * @type {string}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObject
     */
    type: MessageDeltaContentTextAnnotationsFileCitationObjectTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     * @type {string}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObject
     */
    text?: string;
    /**
     * 
     * @type {MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObject
     */
    file_citation?: MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation;
    /**
     * 
     * @type {number}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObject
     */
    start_index?: number;
    /**
     * 
     * @type {number}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObject
     */
    end_index?: number;
}

/**
 * 
 * @export
 */
export type MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation = {
    /**
     * The ID of the specific File the citation is from.
     * @type {string}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation
     */
    file_id?: string;
    /**
     * The specific quote in the file.
     * @type {string}
     * @memberof MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation
     */
    quote?: string;
}


            export type MessageDeltaContentTextAnnotationsFilePathObjectTypeEnum = 'file_path';
/**
 * A URL for the file that\'s generated when the assistant used the `code_interpreter` tool to generate a file.
 * @export
 */
export type MessageDeltaContentTextAnnotationsFilePathObject = {
    /**
     * The index of the annotation in the text content part.
     * @type {number}
     * @memberof MessageDeltaContentTextAnnotationsFilePathObject
     */
    index: number;
    /**
     * Always `file_path`.
     * @type {string}
     * @memberof MessageDeltaContentTextAnnotationsFilePathObject
     */
    type: MessageDeltaContentTextAnnotationsFilePathObjectTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     * @type {string}
     * @memberof MessageDeltaContentTextAnnotationsFilePathObject
     */
    text?: string;
    /**
     * 
     * @type {MessageDeltaContentTextAnnotationsFilePathObjectFilePath}
     * @memberof MessageDeltaContentTextAnnotationsFilePathObject
     */
    file_path?: MessageDeltaContentTextAnnotationsFilePathObjectFilePath;
    /**
     * 
     * @type {number}
     * @memberof MessageDeltaContentTextAnnotationsFilePathObject
     */
    start_index?: number;
    /**
     * 
     * @type {number}
     * @memberof MessageDeltaContentTextAnnotationsFilePathObject
     */
    end_index?: number;
}

/**
 * 
 * @export
 */
export type MessageDeltaContentTextAnnotationsFilePathObjectFilePath = {
    /**
     * The ID of the file that was generated.
     * @type {string}
     * @memberof MessageDeltaContentTextAnnotationsFilePathObjectFilePath
     */
    file_id?: string;
}


            export type MessageDeltaContentTextObjectTypeEnum = 'text';
/**
 * The text content that is part of a message.
 * @export
 */
export type MessageDeltaContentTextObject = {
    /**
     * The index of the content part in the message.
     * @type {number}
     * @memberof MessageDeltaContentTextObject
     */
    index: number;
    /**
     * Always `text`.
     * @type {string}
     * @memberof MessageDeltaContentTextObject
     */
    type: MessageDeltaContentTextObjectTypeEnum;
    /**
     * 
     * @type {MessageDeltaContentTextObjectText}
     * @memberof MessageDeltaContentTextObject
     */
    text?: MessageDeltaContentTextObjectText;
}

/**
 * 
 * @export
 */
export type MessageDeltaContentTextObjectText = {
    /**
     * The data that makes up the text.
     * @type {string}
     * @memberof MessageDeltaContentTextObjectText
     */
    value?: string;
    /**
     * 
     * @type {Array<MessageDeltaContentTextObjectTextAnnotationsInner>}
     * @memberof MessageDeltaContentTextObjectText
     */
    annotations?: Array<MessageDeltaContentTextObjectTextAnnotationsInner>;
}


            export type MessageDeltaContentTextObjectTextAnnotationsInnerTypeEnum = 'file_citation' | 'file_path';
/**
 * 
 * @export
 */
export type MessageDeltaContentTextObjectTextAnnotationsInner = {
    /**
     * The index of the annotation in the text content part.
     * @type {number}
     * @memberof MessageDeltaContentTextObjectTextAnnotationsInner
     */
    index: number;
    /**
     * Always `file_citation`.
     * @type {string}
     * @memberof MessageDeltaContentTextObjectTextAnnotationsInner
     */
    type: MessageDeltaContentTextObjectTextAnnotationsInnerTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     * @type {string}
     * @memberof MessageDeltaContentTextObjectTextAnnotationsInner
     */
    text?: string;
    /**
     * 
     * @type {MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation}
     * @memberof MessageDeltaContentTextObjectTextAnnotationsInner
     */
    file_citation?: MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation;
    /**
     * 
     * @type {number}
     * @memberof MessageDeltaContentTextObjectTextAnnotationsInner
     */
    start_index?: number;
    /**
     * 
     * @type {number}
     * @memberof MessageDeltaContentTextObjectTextAnnotationsInner
     */
    end_index?: number;
    /**
     * 
     * @type {MessageDeltaContentTextAnnotationsFilePathObjectFilePath}
     * @memberof MessageDeltaContentTextObjectTextAnnotationsInner
     */
    file_path?: MessageDeltaContentTextAnnotationsFilePathObjectFilePath;
}


            export type MessageDeltaObjectObjectEnum = 'thread.message.delta';
/**
 * Represents a message delta i.e. any changed fields on a message during streaming. 
 * @export
 */
export type MessageDeltaObject = {
    /**
     * The identifier of the message, which can be referenced in API endpoints.
     * @type {string}
     * @memberof MessageDeltaObject
     */
    id: string;
    /**
     * The object type, which is always `thread.message.delta`.
     * @type {string}
     * @memberof MessageDeltaObject
     */
    _object: MessageDeltaObjectObjectEnum;
    /**
     * 
     * @type {MessageDeltaObjectDelta}
     * @memberof MessageDeltaObject
     */
    delta: MessageDeltaObjectDelta;
}


            export type MessageDeltaObjectDeltaRoleEnum = 'user' | 'assistant';
/**
 * The delta containing the fields that have changed on the Message.
 * @export
 */
export type MessageDeltaObjectDelta = {
    /**
     * The entity that produced the message. One of `user` or `assistant`.
     * @type {string}
     * @memberof MessageDeltaObjectDelta
     */
    role?: MessageDeltaObjectDeltaRoleEnum;
    /**
     * The content of the message in array of text and/or images.
     * @type {Array<MessageDeltaObjectDeltaContentInner>}
     * @memberof MessageDeltaObjectDelta
     */
    content?: Array<MessageDeltaObjectDeltaContentInner>;
    /**
     * A list of [file](/docs/api-reference/files) IDs that the assistant should use. Useful for tools like retrieval and code_interpreter that can access files. A maximum of 10 files can be attached to a message.
     * @type {Array<string>}
     * @memberof MessageDeltaObjectDelta
     */
    file_ids?: Array<string>;
}


            export type MessageDeltaObjectDeltaContentInnerTypeEnum = 'image_file' | 'text';
/**
 * 
 * @export
 */
export type MessageDeltaObjectDeltaContentInner = {
    /**
     * The index of the content part in the message.
     * @type {number}
     * @memberof MessageDeltaObjectDeltaContentInner
     */
    index: number;
    /**
     * Always `image_file`.
     * @type {string}
     * @memberof MessageDeltaObjectDeltaContentInner
     */
    type: MessageDeltaObjectDeltaContentInnerTypeEnum;
    /**
     * 
     * @type {MessageDeltaContentImageFileObjectImageFile}
     * @memberof MessageDeltaObjectDeltaContentInner
     */
    image_file?: MessageDeltaContentImageFileObjectImageFile;
    /**
     * 
     * @type {MessageDeltaContentTextObjectText}
     * @memberof MessageDeltaObjectDeltaContentInner
     */
    text?: MessageDeltaContentTextObjectText;
}


            export type MessageFileObjectObjectEnum = 'thread.message.file';
/**
 * A list of files attached to a `message`.
 * @export
 */
export type MessageFileObject = {
    /**
     * The identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof MessageFileObject
     */
    id: string;
    /**
     * The object type, which is always `thread.message.file`.
     * @type {string}
     * @memberof MessageFileObject
     */
    _object: MessageFileObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the message file was created.
     * @type {number}
     * @memberof MessageFileObject
     */
    created_at: number;
    /**
     * The ID of the [message](/docs/api-reference/messages) that the [File](/docs/api-reference/files) is attached to.
     * @type {string}
     * @memberof MessageFileObject
     */
    message_id: string;
}


            export type MessageObjectObjectEnum = 'thread.message';

            export type MessageObjectStatusEnum = 'in_progress' | 'incomplete' | 'completed';

            export type MessageObjectRoleEnum = 'user' | 'assistant';
/**
 * Represents a message within a [thread](/docs/api-reference/threads).
 * @export
 */
export type MessageObject = {
    /**
     * The identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof MessageObject
     */
    id: string;
    /**
     * The object type, which is always `thread.message`.
     * @type {string}
     * @memberof MessageObject
     */
    _object: MessageObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the message was created.
     * @type {number}
     * @memberof MessageObject
     */
    created_at: number;
    /**
     * The [thread](/docs/api-reference/threads) ID that this message belongs to.
     * @type {string}
     * @memberof MessageObject
     */
    thread_id: string;
    /**
     * The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
     * @type {string}
     * @memberof MessageObject
     */
    status: MessageObjectStatusEnum;
    /**
     * 
     * @type {MessageObjectIncompleteDetails}
     * @memberof MessageObject
     */
    incomplete_details: MessageObjectIncompleteDetails;
    /**
     * The Unix timestamp (in seconds) for when the message was completed.
     * @type {number}
     * @memberof MessageObject
     */
    completed_at: number;
    /**
     * The Unix timestamp (in seconds) for when the message was marked as incomplete.
     * @type {number}
     * @memberof MessageObject
     */
    incomplete_at: number;
    /**
     * The entity that produced the message. One of `user` or `assistant`.
     * @type {string}
     * @memberof MessageObject
     */
    role: MessageObjectRoleEnum;
    /**
     * The content of the message in array of text and/or images.
     * @type {Array<MessageObjectContentInner>}
     * @memberof MessageObject
     */
    content: Array<MessageObjectContentInner>;
    /**
     * If applicable, the ID of the [assistant](/docs/api-reference/assistants) that authored this message.
     * @type {string}
     * @memberof MessageObject
     */
    assistant_id: string;
    /**
     * The ID of the [run](/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints.
     * @type {string}
     * @memberof MessageObject
     */
    run_id: string;
    /**
     * A list of [file](/docs/api-reference/files) IDs that the assistant should use. Useful for tools like retrieval and code_interpreter that can access files. A maximum of 10 files can be attached to a message.
     * @type {Array<string>}
     * @memberof MessageObject
     */
    file_ids: Array<string>;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
     * @type {Object}
     * @memberof MessageObject
     */
    metadata: Object;
}


            export type MessageObjectContentInnerTypeEnum = 'image_file' | 'text';
/**
 * 
 * @export
 */
export type MessageObjectContentInner = {
    /**
     * Always `image_file`.
     * @type {string}
     * @memberof MessageObjectContentInner
     */
    type: MessageObjectContentInnerTypeEnum;
    /**
     * 
     * @type {MessageContentImageFileObjectImageFile}
     * @memberof MessageObjectContentInner
     */
    image_file: MessageContentImageFileObjectImageFile;
    /**
     * 
     * @type {MessageContentTextObjectText}
     * @memberof MessageObjectContentInner
     */
    text: MessageContentTextObjectText;
}


            export type MessageObjectIncompleteDetailsReasonEnum = 'content_filter' | 'max_tokens' | 'run_cancelled' | 'run_expired' | 'run_failed';
/**
 * On an incomplete message, details about why the message is incomplete.
 * @export
 */
export type MessageObjectIncompleteDetails = {
    /**
     * The reason the message is incomplete.
     * @type {string}
     * @memberof MessageObjectIncompleteDetails
     */
    reason: MessageObjectIncompleteDetailsReasonEnum;
}


            export type MessageStreamEventEventEnum = 'thread.message.incomplete';
/**
 * 
 * @export
 */
export type MessageStreamEvent = {
    /**
     * 
     * @type {string}
     * @memberof MessageStreamEvent
     */
    event: MessageStreamEventEventEnum;
    /**
     * 
     * @type {MessageObject}
     * @memberof MessageStreamEvent
     */
    data: MessageObject;
}


            export type MessageStreamEventOneOfEventEnum = 'thread.message.created';
/**
 * Occurs when a [message](/docs/api-reference/messages/object) is created.
 * @export
 */
export type MessageStreamEventOneOf = {
    /**
     * 
     * @type {string}
     * @memberof MessageStreamEventOneOf
     */
    event: MessageStreamEventOneOfEventEnum;
    /**
     * 
     * @type {MessageObject}
     * @memberof MessageStreamEventOneOf
     */
    data: MessageObject;
}


            export type MessageStreamEventOneOf1EventEnum = 'thread.message.in_progress';
/**
 * Occurs when a [message](/docs/api-reference/messages/object) moves to an `in_progress` state.
 * @export
 */
export type MessageStreamEventOneOf1 = {
    /**
     * 
     * @type {string}
     * @memberof MessageStreamEventOneOf1
     */
    event: MessageStreamEventOneOf1EventEnum;
    /**
     * 
     * @type {MessageObject}
     * @memberof MessageStreamEventOneOf1
     */
    data: MessageObject;
}


            export type MessageStreamEventOneOf2EventEnum = 'thread.message.delta';
/**
 * Occurs when parts of a [Message](/docs/api-reference/messages/object) are being streamed.
 * @export
 */
export type MessageStreamEventOneOf2 = {
    /**
     * 
     * @type {string}
     * @memberof MessageStreamEventOneOf2
     */
    event: MessageStreamEventOneOf2EventEnum;
    /**
     * 
     * @type {MessageDeltaObject}
     * @memberof MessageStreamEventOneOf2
     */
    data: MessageDeltaObject;
}


            export type MessageStreamEventOneOf3EventEnum = 'thread.message.completed';
/**
 * Occurs when a [message](/docs/api-reference/messages/object) is completed.
 * @export
 */
export type MessageStreamEventOneOf3 = {
    /**
     * 
     * @type {string}
     * @memberof MessageStreamEventOneOf3
     */
    event: MessageStreamEventOneOf3EventEnum;
    /**
     * 
     * @type {MessageObject}
     * @memberof MessageStreamEventOneOf3
     */
    data: MessageObject;
}


            export type MessageStreamEventOneOf4EventEnum = 'thread.message.incomplete';
/**
 * Occurs when a [message](/docs/api-reference/messages/object) ends before it is completed.
 * @export
 */
export type MessageStreamEventOneOf4 = {
    /**
     * 
     * @type {string}
     * @memberof MessageStreamEventOneOf4
     */
    event: MessageStreamEventOneOf4EventEnum;
    /**
     * 
     * @type {MessageObject}
     * @memberof MessageStreamEventOneOf4
     */
    data: MessageObject;
}


            export type ModelObjectEnum = 'model';
/**
 * Describes an OpenAI model offering that can be used with the API.
 * @export
 */
export type Model = {
    /**
     * The model identifier, which can be referenced in the API endpoints.
     * @type {string}
     * @memberof Model
     */
    id: string;
    /**
     * The Unix timestamp (in seconds) when the model was created.
     * @type {number}
     * @memberof Model
     */
    created: number;
    /**
     * The object type, which is always \"model\".
     * @type {string}
     * @memberof Model
     */
    _object: ModelObjectEnum;
    /**
     * The organization that owns the model.
     * @type {string}
     * @memberof Model
     */
    owned_by: string;
}

/**
 * 
 * @export
 */
export type ModifyAssistantRequest = {
    /**
     * 
     * @type {string}
     * @memberof ModifyAssistantRequest
     */
    model?: string;
    /**
     * The name of the assistant. The maximum length is 256 characters. 
     * @type {string}
     * @memberof ModifyAssistantRequest
     */
    name?: string;
    /**
     * The description of the assistant. The maximum length is 512 characters. 
     * @type {string}
     * @memberof ModifyAssistantRequest
     */
    description?: string;
    /**
     * The system instructions that the assistant uses. The maximum length is 256,000 characters. 
     * @type {string}
     * @memberof ModifyAssistantRequest
     */
    instructions?: string;
    /**
     * A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`. 
     * @type {Array<AssistantObjectToolsInner>}
     * @memberof ModifyAssistantRequest
     */
    tools?: Array<AssistantObjectToolsInner>;
    /**
     * A list of [File](/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. If a file was previously attached to the list but does not show up in the list, it will be deleted from the assistant. 
     * @type {Array<string>}
     * @memberof ModifyAssistantRequest
     */
    file_ids?: Array<string>;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
     * @type {Object}
     * @memberof ModifyAssistantRequest
     */
    metadata?: Object;
}

/**
 * 
 * @export
 */
export type ModifyMessageRequest = {
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
     * @type {Object}
     * @memberof ModifyMessageRequest
     */
    metadata?: Object;
}

/**
 * 
 * @export
 */
export type ModifyRunRequest = {
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
     * @type {Object}
     * @memberof ModifyRunRequest
     */
    metadata?: Object;
}

/**
 * 
 * @export
 */
export type ModifyThreadRequest = {
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
     * @type {Object}
     * @memberof ModifyThreadRequest
     */
    metadata?: Object;
}


            export type OpenAIFileObjectEnum = 'file';

            export type OpenAIFilePurposeEnum = 'fine-tune' | 'fine-tune-results' | 'assistants' | 'assistants_output';

            export type OpenAIFileStatusEnum = 'uploaded' | 'processed' | 'error';
/**
 * The `File` object represents a document that has been uploaded to OpenAI.
 * @export
 */
export type OpenAIFile = {
    /**
     * The file identifier, which can be referenced in the API endpoints.
     * @type {string}
     * @memberof OpenAIFile
     */
    id: string;
    /**
     * The size of the file, in bytes.
     * @type {number}
     * @memberof OpenAIFile
     */
    bytes: number;
    /**
     * The Unix timestamp (in seconds) for when the file was created.
     * @type {number}
     * @memberof OpenAIFile
     */
    created_at: number;
    /**
     * The name of the file.
     * @type {string}
     * @memberof OpenAIFile
     */
    filename: string;
    /**
     * The object type, which is always `file`.
     * @type {string}
     * @memberof OpenAIFile
     */
    _object: OpenAIFileObjectEnum;
    /**
     * The intended purpose of the file. Supported values are `fine-tune`, `fine-tune-results`, `assistants`, and `assistants_output`.
     * @type {string}
     * @memberof OpenAIFile
     */
    purpose: OpenAIFilePurposeEnum;
    /**
     * Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`.
     * @type {string}
     * @memberof OpenAIFile
     */
    status: OpenAIFileStatusEnum;
    /**
     * Deprecated. For details on why a fine-tuning training file failed validation, see the `error` field on `fine_tuning.job`.
     * @type {string}
     * @memberof OpenAIFile
     */
    status_details?: string;
}

/**
 * Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
 * @export
 */
export type RunCompletionUsage = {
    /**
     * Number of completion tokens used over the course of the run.
     * @type {number}
     * @memberof RunCompletionUsage
     */
    completion_tokens: number;
    /**
     * Number of prompt tokens used over the course of the run.
     * @type {number}
     * @memberof RunCompletionUsage
     */
    prompt_tokens: number;
    /**
     * Total number of tokens used (prompt + completion).
     * @type {number}
     * @memberof RunCompletionUsage
     */
    total_tokens: number;
}


            export type RunObjectObjectEnum = 'thread.run';

            export type RunObjectStatusEnum = 'queued' | 'in_progress' | 'requires_action' | 'cancelling' | 'cancelled' | 'failed' | 'completed' | 'expired';
/**
 * Represents an execution run on a [thread](/docs/api-reference/threads).
 * @export
 */
export type RunObject = {
    /**
     * The identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof RunObject
     */
    id: string;
    /**
     * The object type, which is always `thread.run`.
     * @type {string}
     * @memberof RunObject
     */
    _object: RunObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the run was created.
     * @type {number}
     * @memberof RunObject
     */
    created_at: number;
    /**
     * The ID of the [thread](/docs/api-reference/threads) that was executed on as a part of this run.
     * @type {string}
     * @memberof RunObject
     */
    thread_id: string;
    /**
     * The ID of the [assistant](/docs/api-reference/assistants) used for execution of this run.
     * @type {string}
     * @memberof RunObject
     */
    assistant_id: string;
    /**
     * The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, or `expired`.
     * @type {string}
     * @memberof RunObject
     */
    status: RunObjectStatusEnum;
    /**
     * 
     * @type {RunObjectRequiredAction}
     * @memberof RunObject
     */
    required_action: RunObjectRequiredAction;
    /**
     * 
     * @type {RunObjectLastError}
     * @memberof RunObject
     */
    last_error: RunObjectLastError;
    /**
     * The Unix timestamp (in seconds) for when the run will expire.
     * @type {number}
     * @memberof RunObject
     */
    expires_at: number;
    /**
     * The Unix timestamp (in seconds) for when the run was started.
     * @type {number}
     * @memberof RunObject
     */
    started_at: number;
    /**
     * The Unix timestamp (in seconds) for when the run was cancelled.
     * @type {number}
     * @memberof RunObject
     */
    cancelled_at: number;
    /**
     * The Unix timestamp (in seconds) for when the run failed.
     * @type {number}
     * @memberof RunObject
     */
    failed_at: number;
    /**
     * The Unix timestamp (in seconds) for when the run was completed.
     * @type {number}
     * @memberof RunObject
     */
    completed_at: number;
    /**
     * 
     * @type {RunObjectIncompleteDetails}
     * @memberof RunObject
     */
    incomplete_details: RunObjectIncompleteDetails;
    /**
     * The model that the [assistant](/docs/api-reference/assistants) used for this run.
     * @type {string}
     * @memberof RunObject
     */
    model: string;
    /**
     * The instructions that the [assistant](/docs/api-reference/assistants) used for this run.
     * @type {string}
     * @memberof RunObject
     */
    instructions: string;
    /**
     * The list of tools that the [assistant](/docs/api-reference/assistants) used for this run.
     * @type {Array<AssistantObjectToolsInner>}
     * @memberof RunObject
     */
    tools: Array<AssistantObjectToolsInner>;
    /**
     * The list of [File](/docs/api-reference/files) IDs the [assistant](/docs/api-reference/assistants) used for this run.
     * @type {Array<string>}
     * @memberof RunObject
     */
    file_ids: Array<string>;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
     * @type {Object}
     * @memberof RunObject
     */
    metadata: Object;
    /**
     * 
     * @type {RunCompletionUsage}
     * @memberof RunObject
     */
    usage: RunCompletionUsage;
    /**
     * The sampling temperature used for this run. If not set, defaults to 1.
     * @type {number}
     * @memberof RunObject
     */
    temperature?: number;
    /**
     * The maximum number of prompt tokens specified to have been used over the course of the run. 
     * @type {number}
     * @memberof RunObject
     */
    max_prompt_tokens: number;
    /**
     * The maximum number of completion tokens specified to have been used over the course of the run. 
     * @type {number}
     * @memberof RunObject
     */
    max_completion_tokens: number;
    /**
     * 
     * @type {TruncationObject}
     * @memberof RunObject
     */
    truncation_strategy: TruncationObject;
    /**
     * 
     * @type {AssistantsApiToolChoiceOption}
     * @memberof RunObject
     */
    tool_choice: AssistantsApiToolChoiceOption;
    /**
     * 
     * @type {AssistantsApiResponseFormatOption}
     * @memberof RunObject
     */
    response_format: AssistantsApiResponseFormatOption;
}


            export type RunObjectIncompleteDetailsReasonEnum = 'max_completion_tokens' | 'max_prompt_tokens';
/**
 * Details on why the run is incomplete. Will be `null` if the run is not incomplete.
 * @export
 */
export type RunObjectIncompleteDetails = {
    /**
     * The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run.
     * @type {string}
     * @memberof RunObjectIncompleteDetails
     */
    reason?: RunObjectIncompleteDetailsReasonEnum;
}


            export type RunObjectLastErrorCodeEnum = 'server_error' | 'rate_limit_exceeded' | 'invalid_prompt';
/**
 * The last error associated with this run. Will be `null` if there are no errors.
 * @export
 */
export type RunObjectLastError = {
    /**
     * One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
     * @type {string}
     * @memberof RunObjectLastError
     */
    code: RunObjectLastErrorCodeEnum;
    /**
     * A human-readable description of the error.
     * @type {string}
     * @memberof RunObjectLastError
     */
    message: string;
}


            export type RunObjectRequiredActionTypeEnum = 'submit_tool_outputs';
/**
 * Details on the action required to continue the run. Will be `null` if no action is required.
 * @export
 */
export type RunObjectRequiredAction = {
    /**
     * For now, this is always `submit_tool_outputs`.
     * @type {string}
     * @memberof RunObjectRequiredAction
     */
    type: RunObjectRequiredActionTypeEnum;
    /**
     * 
     * @type {RunObjectRequiredActionSubmitToolOutputs}
     * @memberof RunObjectRequiredAction
     */
    submit_tool_outputs: RunObjectRequiredActionSubmitToolOutputs;
}

/**
 * Details on the tool outputs needed for this run to continue.
 * @export
 */
export type RunObjectRequiredActionSubmitToolOutputs = {
    /**
     * A list of the relevant tool calls.
     * @type {Array<RunToolCallObject>}
     * @memberof RunObjectRequiredActionSubmitToolOutputs
     */
    tool_calls: Array<RunToolCallObject>;
}

/**
 * Usage statistics related to the run step. This value will be `null` while the run step\'s status is `in_progress`.
 * @export
 */
export type RunStepCompletionUsage = {
    /**
     * Number of completion tokens used over the course of the run step.
     * @type {number}
     * @memberof RunStepCompletionUsage
     */
    completion_tokens: number;
    /**
     * Number of prompt tokens used over the course of the run step.
     * @type {number}
     * @memberof RunStepCompletionUsage
     */
    prompt_tokens: number;
    /**
     * Total number of tokens used (prompt + completion).
     * @type {number}
     * @memberof RunStepCompletionUsage
     */
    total_tokens: number;
}


            export type RunStepDeltaObjectObjectEnum = 'thread.run.step.delta';
/**
 * Represents a run step delta i.e. any changed fields on a run step during streaming. 
 * @export
 */
export type RunStepDeltaObject = {
    /**
     * The identifier of the run step, which can be referenced in API endpoints.
     * @type {string}
     * @memberof RunStepDeltaObject
     */
    id: string;
    /**
     * The object type, which is always `thread.run.step.delta`.
     * @type {string}
     * @memberof RunStepDeltaObject
     */
    _object: RunStepDeltaObjectObjectEnum;
    /**
     * 
     * @type {RunStepDeltaObjectDelta}
     * @memberof RunStepDeltaObject
     */
    delta: RunStepDeltaObjectDelta;
}

/**
 * The delta containing the fields that have changed on the run step.
 * @export
 */
export type RunStepDeltaObjectDelta = {
    /**
     * 
     * @type {RunStepDeltaObjectDeltaStepDetails}
     * @memberof RunStepDeltaObjectDelta
     */
    step_details?: RunStepDeltaObjectDeltaStepDetails;
}


            export type RunStepDeltaObjectDeltaStepDetailsTypeEnum = 'message_creation' | 'tool_calls';
/**
 * The details of the run step.
 * @export
 */
export type RunStepDeltaObjectDeltaStepDetails = {
    /**
     * Always `message_creation`.
     * @type {string}
     * @memberof RunStepDeltaObjectDeltaStepDetails
     */
    type: RunStepDeltaObjectDeltaStepDetailsTypeEnum;
    /**
     * 
     * @type {RunStepDeltaStepDetailsMessageCreationObjectMessageCreation}
     * @memberof RunStepDeltaObjectDeltaStepDetails
     */
    message_creation?: RunStepDeltaStepDetailsMessageCreationObjectMessageCreation;
    /**
     * An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `retrieval`, or `function`. 
     * @type {Array<RunStepDeltaStepDetailsToolCallsObjectToolCallsInner>}
     * @memberof RunStepDeltaObjectDeltaStepDetails
     */
    tool_calls?: Array<RunStepDeltaStepDetailsToolCallsObjectToolCallsInner>;
}


            export type RunStepDeltaStepDetailsMessageCreationObjectTypeEnum = 'message_creation';
/**
 * Details of the message creation by the run step.
 * @export
 */
export type RunStepDeltaStepDetailsMessageCreationObject = {
    /**
     * Always `message_creation`.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsMessageCreationObject
     */
    type: RunStepDeltaStepDetailsMessageCreationObjectTypeEnum;
    /**
     * 
     * @type {RunStepDeltaStepDetailsMessageCreationObjectMessageCreation}
     * @memberof RunStepDeltaStepDetailsMessageCreationObject
     */
    message_creation?: RunStepDeltaStepDetailsMessageCreationObjectMessageCreation;
}

/**
 * 
 * @export
 */
export type RunStepDeltaStepDetailsMessageCreationObjectMessageCreation = {
    /**
     * The ID of the message that was created by this run step.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsMessageCreationObjectMessageCreation
     */
    message_id?: string;
}


            export type RunStepDeltaStepDetailsToolCallsCodeObjectTypeEnum = 'code_interpreter';
/**
 * Details of the Code Interpreter tool call the run step was involved in.
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsCodeObject = {
    /**
     * The index of the tool call in the tool calls array.
     * @type {number}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObject
     */
    index: number;
    /**
     * The ID of the tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObject
     */
    id?: string;
    /**
     * The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObject
     */
    type: RunStepDeltaStepDetailsToolCallsCodeObjectTypeEnum;
    /**
     * 
     * @type {RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObject
     */
    code_interpreter?: RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter;
}

/**
 * The Code Interpreter tool call definition.
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter = {
    /**
     * The input to the Code Interpreter tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter
     */
    input?: string;
    /**
     * The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
     * @type {Array<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter
     */
    outputs?: Array<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>;
}


            export type RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerTypeEnum = 'logs' | 'image';
/**
 * 
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner = {
    /**
     * The index of the output in the outputs array.
     * @type {number}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
     */
    index: number;
    /**
     * Always `logs`.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
     */
    type: RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerTypeEnum;
    /**
     * The text output from the Code Interpreter tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
     */
    logs?: string;
    /**
     * 
     * @type {RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
     */
    image?: RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage;
}


            export type RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectTypeEnum = 'image';
/**
 * 
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsCodeOutputImageObject = {
    /**
     * The index of the output in the outputs array.
     * @type {number}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeOutputImageObject
     */
    index: number;
    /**
     * Always `image`.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeOutputImageObject
     */
    type: RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectTypeEnum;
    /**
     * 
     * @type {RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeOutputImageObject
     */
    image?: RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage;
}

/**
 * 
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage = {
    /**
     * The [file](/docs/api-reference/files) ID of the image.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage
     */
    file_id?: string;
}


            export type RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectTypeEnum = 'logs';
/**
 * Text output from the Code Interpreter tool call as part of a run step.
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject = {
    /**
     * The index of the output in the outputs array.
     * @type {number}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject
     */
    index: number;
    /**
     * Always `logs`.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject
     */
    type: RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectTypeEnum;
    /**
     * The text output from the Code Interpreter tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject
     */
    logs?: string;
}


            export type RunStepDeltaStepDetailsToolCallsFunctionObjectTypeEnum = 'function';
/**
 * 
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsFunctionObject = {
    /**
     * The index of the tool call in the tool calls array.
     * @type {number}
     * @memberof RunStepDeltaStepDetailsToolCallsFunctionObject
     */
    index: number;
    /**
     * The ID of the tool call object.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsFunctionObject
     */
    id?: string;
    /**
     * The type of tool call. This is always going to be `function` for this type of tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsFunctionObject
     */
    type: RunStepDeltaStepDetailsToolCallsFunctionObjectTypeEnum;
    /**
     * 
     * @type {RunStepDeltaStepDetailsToolCallsFunctionObjectFunction}
     * @memberof RunStepDeltaStepDetailsToolCallsFunctionObject
     */
    _function?: RunStepDeltaStepDetailsToolCallsFunctionObjectFunction;
}

/**
 * The definition of the function that was called.
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsFunctionObjectFunction = {
    /**
     * The name of the function.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsFunctionObjectFunction
     */
    name?: string;
    /**
     * The arguments passed to the function.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsFunctionObjectFunction
     */
    _arguments?: string;
    /**
     * The output of the function. This will be `null` if the outputs have not been [submitted](/docs/api-reference/runs/submitToolOutputs) yet.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsFunctionObjectFunction
     */
    output?: string;
}


            export type RunStepDeltaStepDetailsToolCallsObjectTypeEnum = 'tool_calls';
/**
 * Details of the tool call.
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsObject = {
    /**
     * Always `tool_calls`.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsObject
     */
    type: RunStepDeltaStepDetailsToolCallsObjectTypeEnum;
    /**
     * An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `retrieval`, or `function`. 
     * @type {Array<RunStepDeltaStepDetailsToolCallsObjectToolCallsInner>}
     * @memberof RunStepDeltaStepDetailsToolCallsObject
     */
    tool_calls?: Array<RunStepDeltaStepDetailsToolCallsObjectToolCallsInner>;
}


            export type RunStepDeltaStepDetailsToolCallsObjectToolCallsInnerTypeEnum = 'code_interpreter' | 'retrieval' | 'function';
/**
 * 
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsObjectToolCallsInner = {
    /**
     * The index of the tool call in the tool calls array.
     * @type {number}
     * @memberof RunStepDeltaStepDetailsToolCallsObjectToolCallsInner
     */
    index: number;
    /**
     * The ID of the tool call object.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsObjectToolCallsInner
     */
    id?: string;
    /**
     * The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsObjectToolCallsInner
     */
    type: RunStepDeltaStepDetailsToolCallsObjectToolCallsInnerTypeEnum;
    /**
     * 
     * @type {RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter}
     * @memberof RunStepDeltaStepDetailsToolCallsObjectToolCallsInner
     */
    code_interpreter?: RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter;
    /**
     * For now, this is always going to be an empty object.
     * @type {Object}
     * @memberof RunStepDeltaStepDetailsToolCallsObjectToolCallsInner
     */
    retrieval?: Object;
    /**
     * 
     * @type {RunStepDeltaStepDetailsToolCallsFunctionObjectFunction}
     * @memberof RunStepDeltaStepDetailsToolCallsObjectToolCallsInner
     */
    _function?: RunStepDeltaStepDetailsToolCallsFunctionObjectFunction;
}


            export type RunStepDeltaStepDetailsToolCallsRetrievalObjectTypeEnum = 'retrieval';
/**
 * 
 * @export
 */
export type RunStepDeltaStepDetailsToolCallsRetrievalObject = {
    /**
     * The index of the tool call in the tool calls array.
     * @type {number}
     * @memberof RunStepDeltaStepDetailsToolCallsRetrievalObject
     */
    index: number;
    /**
     * The ID of the tool call object.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsRetrievalObject
     */
    id?: string;
    /**
     * The type of tool call. This is always going to be `retrieval` for this type of tool call.
     * @type {string}
     * @memberof RunStepDeltaStepDetailsToolCallsRetrievalObject
     */
    type: RunStepDeltaStepDetailsToolCallsRetrievalObjectTypeEnum;
    /**
     * For now, this is always going to be an empty object.
     * @type {Object}
     * @memberof RunStepDeltaStepDetailsToolCallsRetrievalObject
     */
    retrieval?: Object;
}


            export type RunStepDetailsMessageCreationObjectTypeEnum = 'message_creation';
/**
 * Details of the message creation by the run step.
 * @export
 */
export type RunStepDetailsMessageCreationObject = {
    /**
     * Always `message_creation`.
     * @type {string}
     * @memberof RunStepDetailsMessageCreationObject
     */
    type: RunStepDetailsMessageCreationObjectTypeEnum;
    /**
     * 
     * @type {RunStepDetailsMessageCreationObjectMessageCreation}
     * @memberof RunStepDetailsMessageCreationObject
     */
    message_creation: RunStepDetailsMessageCreationObjectMessageCreation;
}

/**
 * 
 * @export
 */
export type RunStepDetailsMessageCreationObjectMessageCreation = {
    /**
     * The ID of the message that was created by this run step.
     * @type {string}
     * @memberof RunStepDetailsMessageCreationObjectMessageCreation
     */
    message_id: string;
}


            export type RunStepDetailsToolCallsCodeObjectTypeEnum = 'code_interpreter';
/**
 * Details of the Code Interpreter tool call the run step was involved in.
 * @export
 */
export type RunStepDetailsToolCallsCodeObject = {
    /**
     * The ID of the tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeObject
     */
    id: string;
    /**
     * The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeObject
     */
    type: RunStepDetailsToolCallsCodeObjectTypeEnum;
    /**
     * 
     * @type {RunStepDetailsToolCallsCodeObjectCodeInterpreter}
     * @memberof RunStepDetailsToolCallsCodeObject
     */
    code_interpreter: RunStepDetailsToolCallsCodeObjectCodeInterpreter;
}

/**
 * The Code Interpreter tool call definition.
 * @export
 */
export type RunStepDetailsToolCallsCodeObjectCodeInterpreter = {
    /**
     * The input to the Code Interpreter tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeObjectCodeInterpreter
     */
    input: string;
    /**
     * The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
     * @type {Array<RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>}
     * @memberof RunStepDetailsToolCallsCodeObjectCodeInterpreter
     */
    outputs: Array<RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>;
}


            export type RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerTypeEnum = 'logs' | 'image';
/**
 * 
 * @export
 */
export type RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner = {
    /**
     * Always `logs`.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
     */
    type: RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerTypeEnum;
    /**
     * The text output from the Code Interpreter tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
     */
    logs: string;
    /**
     * 
     * @type {RunStepDetailsToolCallsCodeOutputImageObjectImage}
     * @memberof RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
     */
    image: RunStepDetailsToolCallsCodeOutputImageObjectImage;
}


            export type RunStepDetailsToolCallsCodeOutputImageObjectTypeEnum = 'image';
/**
 * 
 * @export
 */
export type RunStepDetailsToolCallsCodeOutputImageObject = {
    /**
     * Always `image`.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeOutputImageObject
     */
    type: RunStepDetailsToolCallsCodeOutputImageObjectTypeEnum;
    /**
     * 
     * @type {RunStepDetailsToolCallsCodeOutputImageObjectImage}
     * @memberof RunStepDetailsToolCallsCodeOutputImageObject
     */
    image: RunStepDetailsToolCallsCodeOutputImageObjectImage;
}

/**
 * 
 * @export
 */
export type RunStepDetailsToolCallsCodeOutputImageObjectImage = {
    /**
     * The [file](/docs/api-reference/files) ID of the image.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeOutputImageObjectImage
     */
    file_id: string;
}


            export type RunStepDetailsToolCallsCodeOutputLogsObjectTypeEnum = 'logs';
/**
 * Text output from the Code Interpreter tool call as part of a run step.
 * @export
 */
export type RunStepDetailsToolCallsCodeOutputLogsObject = {
    /**
     * Always `logs`.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeOutputLogsObject
     */
    type: RunStepDetailsToolCallsCodeOutputLogsObjectTypeEnum;
    /**
     * The text output from the Code Interpreter tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsCodeOutputLogsObject
     */
    logs: string;
}


            export type RunStepDetailsToolCallsFunctionObjectTypeEnum = 'function';
/**
 * 
 * @export
 */
export type RunStepDetailsToolCallsFunctionObject = {
    /**
     * The ID of the tool call object.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFunctionObject
     */
    id: string;
    /**
     * The type of tool call. This is always going to be `function` for this type of tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFunctionObject
     */
    type: RunStepDetailsToolCallsFunctionObjectTypeEnum;
    /**
     * 
     * @type {RunStepDetailsToolCallsFunctionObjectFunction}
     * @memberof RunStepDetailsToolCallsFunctionObject
     */
    _function: RunStepDetailsToolCallsFunctionObjectFunction;
}

/**
 * The definition of the function that was called.
 * @export
 */
export type RunStepDetailsToolCallsFunctionObjectFunction = {
    /**
     * The name of the function.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFunctionObjectFunction
     */
    name: string;
    /**
     * The arguments passed to the function.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFunctionObjectFunction
     */
    _arguments: string;
    /**
     * The output of the function. This will be `null` if the outputs have not been [submitted](/docs/api-reference/runs/submitToolOutputs) yet.
     * @type {string}
     * @memberof RunStepDetailsToolCallsFunctionObjectFunction
     */
    output: string;
}


            export type RunStepDetailsToolCallsObjectTypeEnum = 'tool_calls';
/**
 * Details of the tool call.
 * @export
 */
export type RunStepDetailsToolCallsObject = {
    /**
     * Always `tool_calls`.
     * @type {string}
     * @memberof RunStepDetailsToolCallsObject
     */
    type: RunStepDetailsToolCallsObjectTypeEnum;
    /**
     * An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `retrieval`, or `function`. 
     * @type {Array<RunStepDetailsToolCallsObjectToolCallsInner>}
     * @memberof RunStepDetailsToolCallsObject
     */
    tool_calls: Array<RunStepDetailsToolCallsObjectToolCallsInner>;
}


            export type RunStepDetailsToolCallsObjectToolCallsInnerTypeEnum = 'code_interpreter' | 'retrieval' | 'function';
/**
 * 
 * @export
 */
export type RunStepDetailsToolCallsObjectToolCallsInner = {
    /**
     * The ID of the tool call object.
     * @type {string}
     * @memberof RunStepDetailsToolCallsObjectToolCallsInner
     */
    id: string;
    /**
     * The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsObjectToolCallsInner
     */
    type: RunStepDetailsToolCallsObjectToolCallsInnerTypeEnum;
    /**
     * 
     * @type {RunStepDetailsToolCallsCodeObjectCodeInterpreter}
     * @memberof RunStepDetailsToolCallsObjectToolCallsInner
     */
    code_interpreter: RunStepDetailsToolCallsCodeObjectCodeInterpreter;
    /**
     * For now, this is always going to be an empty object.
     * @type {Object}
     * @memberof RunStepDetailsToolCallsObjectToolCallsInner
     */
    retrieval: Object;
    /**
     * 
     * @type {RunStepDetailsToolCallsFunctionObjectFunction}
     * @memberof RunStepDetailsToolCallsObjectToolCallsInner
     */
    _function: RunStepDetailsToolCallsFunctionObjectFunction;
}


            export type RunStepDetailsToolCallsRetrievalObjectTypeEnum = 'retrieval';
/**
 * 
 * @export
 */
export type RunStepDetailsToolCallsRetrievalObject = {
    /**
     * The ID of the tool call object.
     * @type {string}
     * @memberof RunStepDetailsToolCallsRetrievalObject
     */
    id: string;
    /**
     * The type of tool call. This is always going to be `retrieval` for this type of tool call.
     * @type {string}
     * @memberof RunStepDetailsToolCallsRetrievalObject
     */
    type: RunStepDetailsToolCallsRetrievalObjectTypeEnum;
    /**
     * For now, this is always going to be an empty object.
     * @type {Object}
     * @memberof RunStepDetailsToolCallsRetrievalObject
     */
    retrieval: Object;
}


            export type RunStepObjectObjectEnum = 'thread.run.step';

            export type RunStepObjectTypeEnum = 'message_creation' | 'tool_calls';

            export type RunStepObjectStatusEnum = 'in_progress' | 'cancelled' | 'failed' | 'completed' | 'expired';
/**
 * Represents a step in execution of a run. 
 * @export
 */
export type RunStepObject = {
    /**
     * The identifier of the run step, which can be referenced in API endpoints.
     * @type {string}
     * @memberof RunStepObject
     */
    id: string;
    /**
     * The object type, which is always `thread.run.step`.
     * @type {string}
     * @memberof RunStepObject
     */
    _object: RunStepObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the run step was created.
     * @type {number}
     * @memberof RunStepObject
     */
    created_at: number;
    /**
     * The ID of the [assistant](/docs/api-reference/assistants) associated with the run step.
     * @type {string}
     * @memberof RunStepObject
     */
    assistant_id: string;
    /**
     * The ID of the [thread](/docs/api-reference/threads) that was run.
     * @type {string}
     * @memberof RunStepObject
     */
    thread_id: string;
    /**
     * The ID of the [run](/docs/api-reference/runs) that this run step is a part of.
     * @type {string}
     * @memberof RunStepObject
     */
    run_id: string;
    /**
     * The type of run step, which can be either `message_creation` or `tool_calls`.
     * @type {string}
     * @memberof RunStepObject
     */
    type: RunStepObjectTypeEnum;
    /**
     * The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
     * @type {string}
     * @memberof RunStepObject
     */
    status: RunStepObjectStatusEnum;
    /**
     * 
     * @type {RunStepObjectStepDetails}
     * @memberof RunStepObject
     */
    step_details: RunStepObjectStepDetails;
    /**
     * 
     * @type {RunStepObjectLastError}
     * @memberof RunStepObject
     */
    last_error: RunStepObjectLastError;
    /**
     * The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
     * @type {number}
     * @memberof RunStepObject
     */
    expired_at: number;
    /**
     * The Unix timestamp (in seconds) for when the run step was cancelled.
     * @type {number}
     * @memberof RunStepObject
     */
    cancelled_at: number;
    /**
     * The Unix timestamp (in seconds) for when the run step failed.
     * @type {number}
     * @memberof RunStepObject
     */
    failed_at: number;
    /**
     * The Unix timestamp (in seconds) for when the run step completed.
     * @type {number}
     * @memberof RunStepObject
     */
    completed_at: number;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
     * @type {Object}
     * @memberof RunStepObject
     */
    metadata: Object;
    /**
     * 
     * @type {RunStepCompletionUsage}
     * @memberof RunStepObject
     */
    usage: RunStepCompletionUsage;
}


            export type RunStepObjectLastErrorCodeEnum = 'server_error' | 'rate_limit_exceeded';
/**
 * The last error associated with this run step. Will be `null` if there are no errors.
 * @export
 */
export type RunStepObjectLastError = {
    /**
     * One of `server_error` or `rate_limit_exceeded`.
     * @type {string}
     * @memberof RunStepObjectLastError
     */
    code: RunStepObjectLastErrorCodeEnum;
    /**
     * A human-readable description of the error.
     * @type {string}
     * @memberof RunStepObjectLastError
     */
    message: string;
}


            export type RunStepObjectStepDetailsTypeEnum = 'message_creation' | 'tool_calls';
/**
 * The details of the run step.
 * @export
 */
export type RunStepObjectStepDetails = {
    /**
     * Always `message_creation`.
     * @type {string}
     * @memberof RunStepObjectStepDetails
     */
    type: RunStepObjectStepDetailsTypeEnum;
    /**
     * 
     * @type {RunStepDetailsMessageCreationObjectMessageCreation}
     * @memberof RunStepObjectStepDetails
     */
    message_creation: RunStepDetailsMessageCreationObjectMessageCreation;
    /**
     * An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `retrieval`, or `function`. 
     * @type {Array<RunStepDetailsToolCallsObjectToolCallsInner>}
     * @memberof RunStepObjectStepDetails
     */
    tool_calls: Array<RunStepDetailsToolCallsObjectToolCallsInner>;
}


            export type RunStepStreamEventEventEnum = 'thread.run.step.expired';
/**
 * 
 * @export
 */
export type RunStepStreamEvent = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEvent
     */
    event: RunStepStreamEventEventEnum;
    /**
     * 
     * @type {RunStepObject}
     * @memberof RunStepStreamEvent
     */
    data: RunStepObject;
}


            export type RunStepStreamEventOneOfEventEnum = 'thread.run.step.created';
/**
 * Occurs when a [run step](/docs/api-reference/runs/step-object) is created.
 * @export
 */
export type RunStepStreamEventOneOf = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEventOneOf
     */
    event: RunStepStreamEventOneOfEventEnum;
    /**
     * 
     * @type {RunStepObject}
     * @memberof RunStepStreamEventOneOf
     */
    data: RunStepObject;
}


            export type RunStepStreamEventOneOf1EventEnum = 'thread.run.step.in_progress';
/**
 * Occurs when a [run step](/docs/api-reference/runs/step-object) moves to an `in_progress` state.
 * @export
 */
export type RunStepStreamEventOneOf1 = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEventOneOf1
     */
    event: RunStepStreamEventOneOf1EventEnum;
    /**
     * 
     * @type {RunStepObject}
     * @memberof RunStepStreamEventOneOf1
     */
    data: RunStepObject;
}


            export type RunStepStreamEventOneOf2EventEnum = 'thread.run.step.delta';
/**
 * Occurs when parts of a [run step](/docs/api-reference/runs/step-object) are being streamed.
 * @export
 */
export type RunStepStreamEventOneOf2 = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEventOneOf2
     */
    event: RunStepStreamEventOneOf2EventEnum;
    /**
     * 
     * @type {RunStepDeltaObject}
     * @memberof RunStepStreamEventOneOf2
     */
    data: RunStepDeltaObject;
}


            export type RunStepStreamEventOneOf3EventEnum = 'thread.run.step.completed';
/**
 * Occurs when a [run step](/docs/api-reference/runs/step-object) is completed.
 * @export
 */
export type RunStepStreamEventOneOf3 = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEventOneOf3
     */
    event: RunStepStreamEventOneOf3EventEnum;
    /**
     * 
     * @type {RunStepObject}
     * @memberof RunStepStreamEventOneOf3
     */
    data: RunStepObject;
}


            export type RunStepStreamEventOneOf4EventEnum = 'thread.run.step.failed';
/**
 * Occurs when a [run step](/docs/api-reference/runs/step-object) fails.
 * @export
 */
export type RunStepStreamEventOneOf4 = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEventOneOf4
     */
    event: RunStepStreamEventOneOf4EventEnum;
    /**
     * 
     * @type {RunStepObject}
     * @memberof RunStepStreamEventOneOf4
     */
    data: RunStepObject;
}


            export type RunStepStreamEventOneOf5EventEnum = 'thread.run.step.cancelled';
/**
 * Occurs when a [run step](/docs/api-reference/runs/step-object) is cancelled.
 * @export
 */
export type RunStepStreamEventOneOf5 = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEventOneOf5
     */
    event: RunStepStreamEventOneOf5EventEnum;
    /**
     * 
     * @type {RunStepObject}
     * @memberof RunStepStreamEventOneOf5
     */
    data: RunStepObject;
}


            export type RunStepStreamEventOneOf6EventEnum = 'thread.run.step.expired';
/**
 * Occurs when a [run step](/docs/api-reference/runs/step-object) expires.
 * @export
 */
export type RunStepStreamEventOneOf6 = {
    /**
     * 
     * @type {string}
     * @memberof RunStepStreamEventOneOf6
     */
    event: RunStepStreamEventOneOf6EventEnum;
    /**
     * 
     * @type {RunStepObject}
     * @memberof RunStepStreamEventOneOf6
     */
    data: RunStepObject;
}


            export type RunStreamEventEventEnum = 'thread.run.expired';
/**
 * 
 * @export
 */
export type RunStreamEvent = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEvent
     */
    event: RunStreamEventEventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEvent
     */
    data: RunObject;
}


            export type RunStreamEventOneOfEventEnum = 'thread.run.created';
/**
 * Occurs when a new [run](/docs/api-reference/runs/object) is created.
 * @export
 */
export type RunStreamEventOneOf = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf
     */
    event: RunStreamEventOneOfEventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf
     */
    data: RunObject;
}


            export type RunStreamEventOneOf1EventEnum = 'thread.run.queued';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) moves to a `queued` status.
 * @export
 */
export type RunStreamEventOneOf1 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf1
     */
    event: RunStreamEventOneOf1EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf1
     */
    data: RunObject;
}


            export type RunStreamEventOneOf2EventEnum = 'thread.run.in_progress';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) moves to an `in_progress` status.
 * @export
 */
export type RunStreamEventOneOf2 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf2
     */
    event: RunStreamEventOneOf2EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf2
     */
    data: RunObject;
}


            export type RunStreamEventOneOf3EventEnum = 'thread.run.requires_action';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) moves to a `requires_action` status.
 * @export
 */
export type RunStreamEventOneOf3 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf3
     */
    event: RunStreamEventOneOf3EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf3
     */
    data: RunObject;
}


            export type RunStreamEventOneOf4EventEnum = 'thread.run.completed';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) is completed.
 * @export
 */
export type RunStreamEventOneOf4 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf4
     */
    event: RunStreamEventOneOf4EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf4
     */
    data: RunObject;
}


            export type RunStreamEventOneOf5EventEnum = 'thread.run.failed';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) fails.
 * @export
 */
export type RunStreamEventOneOf5 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf5
     */
    event: RunStreamEventOneOf5EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf5
     */
    data: RunObject;
}


            export type RunStreamEventOneOf6EventEnum = 'thread.run.cancelling';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) moves to a `cancelling` status.
 * @export
 */
export type RunStreamEventOneOf6 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf6
     */
    event: RunStreamEventOneOf6EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf6
     */
    data: RunObject;
}


            export type RunStreamEventOneOf7EventEnum = 'thread.run.cancelled';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) is cancelled.
 * @export
 */
export type RunStreamEventOneOf7 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf7
     */
    event: RunStreamEventOneOf7EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf7
     */
    data: RunObject;
}


            export type RunStreamEventOneOf8EventEnum = 'thread.run.expired';
/**
 * Occurs when a [run](/docs/api-reference/runs/object) expires.
 * @export
 */
export type RunStreamEventOneOf8 = {
    /**
     * 
     * @type {string}
     * @memberof RunStreamEventOneOf8
     */
    event: RunStreamEventOneOf8EventEnum;
    /**
     * 
     * @type {RunObject}
     * @memberof RunStreamEventOneOf8
     */
    data: RunObject;
}


            export type RunToolCallObjectTypeEnum = 'function';
/**
 * Tool call objects
 * @export
 */
export type RunToolCallObject = {
    /**
     * The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](/docs/api-reference/runs/submitToolOutputs) endpoint.
     * @type {string}
     * @memberof RunToolCallObject
     */
    id: string;
    /**
     * The type of tool call the output is required for. For now, this is always `function`.
     * @type {string}
     * @memberof RunToolCallObject
     */
    type: RunToolCallObjectTypeEnum;
    /**
     * 
     * @type {RunToolCallObjectFunction}
     * @memberof RunToolCallObject
     */
    _function: RunToolCallObjectFunction;
}

/**
 * The function definition.
 * @export
 */
export type RunToolCallObjectFunction = {
    /**
     * The name of the function.
     * @type {string}
     * @memberof RunToolCallObjectFunction
     */
    name: string;
    /**
     * The arguments that the model expects you to pass to the function.
     * @type {string}
     * @memberof RunToolCallObjectFunction
     */
    _arguments: string;
}

/**
 * 
 * @export
 */
export type SubmitToolOutputsRunRequest = {
    /**
     * A list of tools for which the outputs are being submitted.
     * @type {Array<SubmitToolOutputsRunRequestToolOutputsInner>}
     * @memberof SubmitToolOutputsRunRequest
     */
    tool_outputs: Array<SubmitToolOutputsRunRequestToolOutputsInner>;
    /**
     * If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message. 
     * @type {boolean}
     * @memberof SubmitToolOutputsRunRequest
     */
    stream?: boolean;
}

/**
 * 
 * @export
 */
export type SubmitToolOutputsRunRequestToolOutputsInner = {
    /**
     * The ID of the tool call in the `required_action` object within the run object the output is being submitted for.
     * @type {string}
     * @memberof SubmitToolOutputsRunRequestToolOutputsInner
     */
    tool_call_id?: string;
    /**
     * The output of the tool call to be submitted to continue the run.
     * @type {string}
     * @memberof SubmitToolOutputsRunRequestToolOutputsInner
     */
    output?: string;
}


            export type ThreadObjectObjectEnum = 'thread';
/**
 * Represents a thread that contains [messages](/docs/api-reference/messages).
 * @export
 */
export type ThreadObject = {
    /**
     * The identifier, which can be referenced in API endpoints.
     * @type {string}
     * @memberof ThreadObject
     */
    id: string;
    /**
     * The object type, which is always `thread`.
     * @type {string}
     * @memberof ThreadObject
     */
    _object: ThreadObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the thread was created.
     * @type {number}
     * @memberof ThreadObject
     */
    created_at: number;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
     * @type {Object}
     * @memberof ThreadObject
     */
    metadata: Object;
}


            export type ThreadStreamEventEventEnum = 'thread.created';
/**
 * 
 * @export
 */
export type ThreadStreamEvent = {
    /**
     * 
     * @type {string}
     * @memberof ThreadStreamEvent
     */
    event: ThreadStreamEventEventEnum;
    /**
     * 
     * @type {ThreadObject}
     * @memberof ThreadStreamEvent
     */
    data: ThreadObject;
}


            export type ThreadStreamEventOneOfEventEnum = 'thread.created';
/**
 * Occurs when a new [thread](/docs/api-reference/threads/object) is created.
 * @export
 */
export type ThreadStreamEventOneOf = {
    /**
     * 
     * @type {string}
     * @memberof ThreadStreamEventOneOf
     */
    event: ThreadStreamEventOneOfEventEnum;
    /**
     * 
     * @type {ThreadObject}
     * @memberof ThreadStreamEventOneOf
     */
    data: ThreadObject;
}

/**
 * 
 * @export
 */
export type TranscriptionSegment = {
    /**
     * Unique identifier of the segment.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    id: number;
    /**
     * Seek offset of the segment.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    seek: number;
    /**
     * Start time of the segment in seconds.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    start: number;
    /**
     * End time of the segment in seconds.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    end: number;
    /**
     * Text content of the segment.
     * @type {string}
     * @memberof TranscriptionSegment
     */
    text: string;
    /**
     * Array of token IDs for the text content.
     * @type {Array<number>}
     * @memberof TranscriptionSegment
     */
    tokens: Array<number>;
    /**
     * Temperature parameter used for generating the segment.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    temperature: number;
    /**
     * Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    avg_logprob: number;
    /**
     * Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    compression_ratio: number;
    /**
     * Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent.
     * @type {number}
     * @memberof TranscriptionSegment
     */
    no_speech_prob: number;
}

/**
 * 
 * @export
 */
export type TranscriptionWord = {
    /**
     * The text content of the word.
     * @type {string}
     * @memberof TranscriptionWord
     */
    word: string;
    /**
     * Start time of the word in seconds.
     * @type {number}
     * @memberof TranscriptionWord
     */
    start: number;
    /**
     * End time of the word in seconds.
     * @type {number}
     * @memberof TranscriptionWord
     */
    end: number;
}


            export type TruncationObjectTypeEnum = 'auto' | 'last_messages';
/**
 * 
 * @export
 */
export type TruncationObject = {
    /**
     * The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`.
     * @type {string}
     * @memberof TruncationObject
     */
    type?: TruncationObjectTypeEnum;
    /**
     * The number of most recent messages from the thread when constructing the context for the run.
     * @type {number}
     * @memberof TruncationObject
     */
    last_messages?: number;
}



/**
 * AssistantsApi - fetch parameter creator
 * @export
 */
export const AssistantsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels a run that is `in_progress`.
         * @throws {RequiredError}
         */
        cancelRun(threadId: string, runId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling cancelRun.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling cancelRun.');
            }
            const localVarPath = `/threads/{thread_id}/runs/{run_id}/cancel`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an assistant with a model and instructions.
         * @throws {RequiredError}
         */
        createAssistant(createAssistantRequest: CreateAssistantRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createAssistantRequest' is not null or undefined
            if (createAssistantRequest === null || createAssistantRequest === undefined) {
                throw new RequiredError('createAssistantRequest','Required parameter createAssistantRequest was null or undefined when calling createAssistant.');
            }
            const localVarPath = `/assistants`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createAssistantRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createAssistantRequest != null ? createAssistantRequest : {}) : (((createAssistantRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants).
         * @throws {RequiredError}
         */
        createAssistantFile(assistantId: string, createAssistantFileRequest: CreateAssistantFileRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'assistantId' is not null or undefined
            if (assistantId === null || assistantId === undefined) {
                throw new RequiredError('assistantId','Required parameter assistantId was null or undefined when calling createAssistantFile.');
            }
            // verify required parameter 'createAssistantFileRequest' is not null or undefined
            if (createAssistantFileRequest === null || createAssistantFileRequest === undefined) {
                throw new RequiredError('createAssistantFileRequest','Required parameter createAssistantFileRequest was null or undefined when calling createAssistantFile.');
            }
            const localVarPath = `/assistants/{assistant_id}/files`
                .replace(`{${"assistant_id"}}`, encodeURIComponent(String(assistantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createAssistantFileRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createAssistantFileRequest != null ? createAssistantFileRequest : {}) : (((createAssistantFileRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a message.
         * @throws {RequiredError}
         */
        createMessage(threadId: string, createMessageRequest: CreateMessageRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling createMessage.');
            }
            // verify required parameter 'createMessageRequest' is not null or undefined
            if (createMessageRequest === null || createMessageRequest === undefined) {
                throw new RequiredError('createMessageRequest','Required parameter createMessageRequest was null or undefined when calling createMessage.');
            }
            const localVarPath = `/threads/{thread_id}/messages`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createMessageRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createMessageRequest != null ? createMessageRequest : {}) : (((createMessageRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a run.
         * @throws {RequiredError}
         */
        createRun(threadId: string, createRunRequest: CreateRunRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling createRun.');
            }
            // verify required parameter 'createRunRequest' is not null or undefined
            if (createRunRequest === null || createRunRequest === undefined) {
                throw new RequiredError('createRunRequest','Required parameter createRunRequest was null or undefined when calling createRun.');
            }
            const localVarPath = `/threads/{thread_id}/runs`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createRunRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createRunRequest != null ? createRunRequest : {}) : (((createRunRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a thread.
         * @throws {RequiredError}
         */
        createThread(createThreadRequest?: CreateThreadRequest, options: RequestOptions): FetchArgs {
            const localVarPath = `/threads`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createThreadRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createThreadRequest != null ? createThreadRequest : {}) : (((createThreadRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a thread and run it in one request.
         * @throws {RequiredError}
         */
        createThreadAndRun(createThreadAndRunRequest: CreateThreadAndRunRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createThreadAndRunRequest' is not null or undefined
            if (createThreadAndRunRequest === null || createThreadAndRunRequest === undefined) {
                throw new RequiredError('createThreadAndRunRequest','Required parameter createThreadAndRunRequest was null or undefined when calling createThreadAndRun.');
            }
            const localVarPath = `/threads/runs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createThreadAndRunRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createThreadAndRunRequest != null ? createThreadAndRunRequest : {}) : (((createThreadAndRunRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an assistant.
         * @throws {RequiredError}
         */
        deleteAssistant(assistantId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assistantId' is not null or undefined
            if (assistantId === null || assistantId === undefined) {
                throw new RequiredError('assistantId','Required parameter assistantId was null or undefined when calling deleteAssistant.');
            }
            const localVarPath = `/assistants/{assistant_id}`
                .replace(`{${"assistant_id"}}`, encodeURIComponent(String(assistantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an assistant file.
         * @throws {RequiredError}
         */
        deleteAssistantFile(assistantId: string, fileId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assistantId' is not null or undefined
            if (assistantId === null || assistantId === undefined) {
                throw new RequiredError('assistantId','Required parameter assistantId was null or undefined when calling deleteAssistantFile.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling deleteAssistantFile.');
            }
            const localVarPath = `/assistants/{assistant_id}/files/{file_id}`
                .replace(`{${"assistant_id"}}`, encodeURIComponent(String(assistantId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a thread.
         * @throws {RequiredError}
         */
        deleteThread(threadId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling deleteThread.');
            }
            const localVarPath = `/threads/{thread_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves an assistant.
         * @throws {RequiredError}
         */
        getAssistant(assistantId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assistantId' is not null or undefined
            if (assistantId === null || assistantId === undefined) {
                throw new RequiredError('assistantId','Required parameter assistantId was null or undefined when calling getAssistant.');
            }
            const localVarPath = `/assistants/{assistant_id}`
                .replace(`{${"assistant_id"}}`, encodeURIComponent(String(assistantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves an AssistantFile.
         * @throws {RequiredError}
         */
        getAssistantFile(assistantId: string, fileId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assistantId' is not null or undefined
            if (assistantId === null || assistantId === undefined) {
                throw new RequiredError('assistantId','Required parameter assistantId was null or undefined when calling getAssistantFile.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling getAssistantFile.');
            }
            const localVarPath = `/assistants/{assistant_id}/files/{file_id}`
                .replace(`{${"assistant_id"}}`, encodeURIComponent(String(assistantId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a message.
         * @throws {RequiredError}
         */
        getMessage(threadId: string, messageId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling getMessage.');
            }
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling getMessage.');
            }
            const localVarPath = `/threads/{thread_id}/messages/{message_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a message file.
         * @throws {RequiredError}
         */
        getMessageFile(threadId: string, messageId: string, fileId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling getMessageFile.');
            }
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling getMessageFile.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling getMessageFile.');
            }
            const localVarPath = `/threads/{thread_id}/messages/{message_id}/files/{file_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a run.
         * @throws {RequiredError}
         */
        getRun(threadId: string, runId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling getRun.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling getRun.');
            }
            const localVarPath = `/threads/{thread_id}/runs/{run_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a run step.
         * @throws {RequiredError}
         */
        getRunStep(threadId: string, runId: string, stepId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling getRunStep.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling getRunStep.');
            }
            // verify required parameter 'stepId' is not null or undefined
            if (stepId === null || stepId === undefined) {
                throw new RequiredError('stepId','Required parameter stepId was null or undefined when calling getRunStep.');
            }
            const localVarPath = `/threads/{thread_id}/runs/{run_id}/steps/{step_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"step_id"}}`, encodeURIComponent(String(stepId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a thread.
         * @throws {RequiredError}
         */
        getThread(threadId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling getThread.');
            }
            const localVarPath = `/threads/{thread_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of assistant files.
         * @throws {RequiredError}
         */
        listAssistantFiles(assistantId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assistantId' is not null or undefined
            if (assistantId === null || assistantId === undefined) {
                throw new RequiredError('assistantId','Required parameter assistantId was null or undefined when calling listAssistantFiles.');
            }
            const localVarPath = `/assistants/{assistant_id}/files`
                .replace(`{${"assistant_id"}}`, encodeURIComponent(String(assistantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = ((order:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = ((before:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of assistants.
         * @throws {RequiredError}
         */
        listAssistants(limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/assistants`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = ((order:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = ((before:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of message files.
         * @throws {RequiredError}
         */
        listMessageFiles(threadId: string, messageId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling listMessageFiles.');
            }
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling listMessageFiles.');
            }
            const localVarPath = `/threads/{thread_id}/messages/{message_id}/files`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = ((order:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = ((before:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of messages for a given thread.
         * @throws {RequiredError}
         */
        listMessages(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, runId?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling listMessages.');
            }
            const localVarPath = `/threads/{thread_id}/messages`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = ((order:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = ((before:any):string);
            }

            if (runId !== undefined) {
                localVarQueryParameter['run_id'] = ((runId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of run steps belonging to a run.
         * @throws {RequiredError}
         */
        listRunSteps(threadId: string, runId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling listRunSteps.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling listRunSteps.');
            }
            const localVarPath = `/threads/{thread_id}/runs/{run_id}/steps`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = ((order:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = ((before:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of runs belonging to a thread.
         * @throws {RequiredError}
         */
        listRuns(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling listRuns.');
            }
            const localVarPath = `/threads/{thread_id}/runs`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = ((order:any):string);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = ((before:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies an assistant.
         * @throws {RequiredError}
         */
        modifyAssistant(assistantId: string, modifyAssistantRequest: ModifyAssistantRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'assistantId' is not null or undefined
            if (assistantId === null || assistantId === undefined) {
                throw new RequiredError('assistantId','Required parameter assistantId was null or undefined when calling modifyAssistant.');
            }
            // verify required parameter 'modifyAssistantRequest' is not null or undefined
            if (modifyAssistantRequest === null || modifyAssistantRequest === undefined) {
                throw new RequiredError('modifyAssistantRequest','Required parameter modifyAssistantRequest was null or undefined when calling modifyAssistant.');
            }
            const localVarPath = `/assistants/{assistant_id}`
                .replace(`{${"assistant_id"}}`, encodeURIComponent(String(assistantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof modifyAssistantRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(modifyAssistantRequest != null ? modifyAssistantRequest : {}) : (((modifyAssistantRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a message.
         * @throws {RequiredError}
         */
        modifyMessage(threadId: string, messageId: string, modifyMessageRequest: ModifyMessageRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling modifyMessage.');
            }
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling modifyMessage.');
            }
            // verify required parameter 'modifyMessageRequest' is not null or undefined
            if (modifyMessageRequest === null || modifyMessageRequest === undefined) {
                throw new RequiredError('modifyMessageRequest','Required parameter modifyMessageRequest was null or undefined when calling modifyMessage.');
            }
            const localVarPath = `/threads/{thread_id}/messages/{message_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof modifyMessageRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(modifyMessageRequest != null ? modifyMessageRequest : {}) : (((modifyMessageRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a run.
         * @throws {RequiredError}
         */
        modifyRun(threadId: string, runId: string, modifyRunRequest: ModifyRunRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling modifyRun.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling modifyRun.');
            }
            // verify required parameter 'modifyRunRequest' is not null or undefined
            if (modifyRunRequest === null || modifyRunRequest === undefined) {
                throw new RequiredError('modifyRunRequest','Required parameter modifyRunRequest was null or undefined when calling modifyRun.');
            }
            const localVarPath = `/threads/{thread_id}/runs/{run_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof modifyRunRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(modifyRunRequest != null ? modifyRunRequest : {}) : (((modifyRunRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a thread.
         * @throws {RequiredError}
         */
        modifyThread(threadId: string, modifyThreadRequest: ModifyThreadRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling modifyThread.');
            }
            // verify required parameter 'modifyThreadRequest' is not null or undefined
            if (modifyThreadRequest === null || modifyThreadRequest === undefined) {
                throw new RequiredError('modifyThreadRequest','Required parameter modifyThreadRequest was null or undefined when calling modifyThread.');
            }
            const localVarPath = `/threads/{thread_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof modifyThreadRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(modifyThreadRequest != null ? modifyThreadRequest : {}) : (((modifyThreadRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they\'re all completed. All outputs must be submitted in a single request. 
         * @throws {RequiredError}
         */
        submitToolOuputsToRun(threadId: string, runId: string, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'threadId' is not null or undefined
            if (threadId === null || threadId === undefined) {
                throw new RequiredError('threadId','Required parameter threadId was null or undefined when calling submitToolOuputsToRun.');
            }
            // verify required parameter 'runId' is not null or undefined
            if (runId === null || runId === undefined) {
                throw new RequiredError('runId','Required parameter runId was null or undefined when calling submitToolOuputsToRun.');
            }
            // verify required parameter 'submitToolOutputsRunRequest' is not null or undefined
            if (submitToolOutputsRunRequest === null || submitToolOutputsRunRequest === undefined) {
                throw new RequiredError('submitToolOutputsRunRequest','Required parameter submitToolOutputsRunRequest was null or undefined when calling submitToolOuputsToRun.');
            }
            const localVarPath = `/threads/{thread_id}/runs/{run_id}/submit_tool_outputs`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof submitToolOutputsRunRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(submitToolOutputsRunRequest != null ? submitToolOutputsRunRequest : {}) : (((submitToolOutputsRunRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type AssistantsApiType = { 
    cancelRun(threadId: string, runId: string, options?: RequestOptions): Promise<RunObject>,

    createAssistant(createAssistantRequest: CreateAssistantRequest, options?: RequestOptions): Promise<AssistantObject>,

    createAssistantFile(assistantId: string, createAssistantFileRequest: CreateAssistantFileRequest, options?: RequestOptions): Promise<AssistantFileObject>,

    createMessage(threadId: string, createMessageRequest: CreateMessageRequest, options?: RequestOptions): Promise<MessageObject>,

    createRun(threadId: string, createRunRequest: CreateRunRequest, options?: RequestOptions): Promise<RunObject>,

    createThread(createThreadRequest?: CreateThreadRequest, options?: RequestOptions): Promise<ThreadObject>,

    createThreadAndRun(createThreadAndRunRequest: CreateThreadAndRunRequest, options?: RequestOptions): Promise<RunObject>,

    deleteAssistant(assistantId: string, options?: RequestOptions): Promise<DeleteAssistantResponse>,

    deleteAssistantFile(assistantId: string, fileId: string, options?: RequestOptions): Promise<DeleteAssistantFileResponse>,

    deleteThread(threadId: string, options?: RequestOptions): Promise<DeleteThreadResponse>,

    getAssistant(assistantId: string, options?: RequestOptions): Promise<AssistantObject>,

    getAssistantFile(assistantId: string, fileId: string, options?: RequestOptions): Promise<AssistantFileObject>,

    getMessage(threadId: string, messageId: string, options?: RequestOptions): Promise<MessageObject>,

    getMessageFile(threadId: string, messageId: string, fileId: string, options?: RequestOptions): Promise<MessageFileObject>,

    getRun(threadId: string, runId: string, options?: RequestOptions): Promise<RunObject>,

    getRunStep(threadId: string, runId: string, stepId: string, options?: RequestOptions): Promise<RunStepObject>,

    getThread(threadId: string, options?: RequestOptions): Promise<ThreadObject>,

    listAssistantFiles(assistantId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions): Promise<ListAssistantFilesResponse>,

    listAssistants(limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions): Promise<ListAssistantsResponse>,

    listMessageFiles(threadId: string, messageId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions): Promise<ListMessageFilesResponse>,

    listMessages(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, runId?: string, options?: RequestOptions): Promise<ListMessagesResponse>,

    listRunSteps(threadId: string, runId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions): Promise<ListRunStepsResponse>,

    listRuns(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions): Promise<ListRunsResponse>,

    modifyAssistant(assistantId: string, modifyAssistantRequest: ModifyAssistantRequest, options?: RequestOptions): Promise<AssistantObject>,

    modifyMessage(threadId: string, messageId: string, modifyMessageRequest: ModifyMessageRequest, options?: RequestOptions): Promise<MessageObject>,

    modifyRun(threadId: string, runId: string, modifyRunRequest: ModifyRunRequest, options?: RequestOptions): Promise<RunObject>,

    modifyThread(threadId: string, modifyThreadRequest: ModifyThreadRequest, options?: RequestOptions): Promise<ThreadObject>,

    submitToolOuputsToRun(threadId: string, runId: string, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest, options?: RequestOptions): Promise<RunObject>,
}

/**
 * AssistantsApi - factory function to inject configuration 
 * @export
 */
export const AssistantsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): AssistantsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Cancels a run that is `in_progress`.
         * @throws {RequiredError}
         */
        cancelRun(threadId: string, runId: string, options?: RequestOptions = {}): Promise<RunObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).cancelRun(threadId, runId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create an assistant with a model and instructions.
         * @throws {RequiredError}
         */
        createAssistant(createAssistantRequest: CreateAssistantRequest, options?: RequestOptions = {}): Promise<AssistantObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).createAssistant(createAssistantRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants).
         * @throws {RequiredError}
         */
        createAssistantFile(assistantId: string, createAssistantFileRequest: CreateAssistantFileRequest, options?: RequestOptions = {}): Promise<AssistantFileObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).createAssistantFile(assistantId, createAssistantFileRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create a message.
         * @throws {RequiredError}
         */
        createMessage(threadId: string, createMessageRequest: CreateMessageRequest, options?: RequestOptions = {}): Promise<MessageObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).createMessage(threadId, createMessageRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create a run.
         * @throws {RequiredError}
         */
        createRun(threadId: string, createRunRequest: CreateRunRequest, options?: RequestOptions = {}): Promise<RunObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).createRun(threadId, createRunRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create a thread.
         * @throws {RequiredError}
         */
        createThread(createThreadRequest?: CreateThreadRequest, options?: RequestOptions = {}): Promise<ThreadObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).createThread(createThreadRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create a thread and run it in one request.
         * @throws {RequiredError}
         */
        createThreadAndRun(createThreadAndRunRequest: CreateThreadAndRunRequest, options?: RequestOptions = {}): Promise<RunObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).createThreadAndRun(createThreadAndRunRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete an assistant.
         * @throws {RequiredError}
         */
        deleteAssistant(assistantId: string, options?: RequestOptions = {}): Promise<DeleteAssistantResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).deleteAssistant(assistantId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete an assistant file.
         * @throws {RequiredError}
         */
        deleteAssistantFile(assistantId: string, fileId: string, options?: RequestOptions = {}): Promise<DeleteAssistantFileResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).deleteAssistantFile(assistantId, fileId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete a thread.
         * @throws {RequiredError}
         */
        deleteThread(threadId: string, options?: RequestOptions = {}): Promise<DeleteThreadResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).deleteThread(threadId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves an assistant.
         * @throws {RequiredError}
         */
        getAssistant(assistantId: string, options?: RequestOptions = {}): Promise<AssistantObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).getAssistant(assistantId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves an AssistantFile.
         * @throws {RequiredError}
         */
        getAssistantFile(assistantId: string, fileId: string, options?: RequestOptions = {}): Promise<AssistantFileObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).getAssistantFile(assistantId, fileId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve a message.
         * @throws {RequiredError}
         */
        getMessage(threadId: string, messageId: string, options?: RequestOptions = {}): Promise<MessageObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).getMessage(threadId, messageId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a message file.
         * @throws {RequiredError}
         */
        getMessageFile(threadId: string, messageId: string, fileId: string, options?: RequestOptions = {}): Promise<MessageFileObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).getMessageFile(threadId, messageId, fileId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a run.
         * @throws {RequiredError}
         */
        getRun(threadId: string, runId: string, options?: RequestOptions = {}): Promise<RunObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).getRun(threadId, runId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a run step.
         * @throws {RequiredError}
         */
        getRunStep(threadId: string, runId: string, stepId: string, options?: RequestOptions = {}): Promise<RunStepObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).getRunStep(threadId, runId, stepId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a thread.
         * @throws {RequiredError}
         */
        getThread(threadId: string, options?: RequestOptions = {}): Promise<ThreadObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).getThread(threadId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of assistant files.
         * @throws {RequiredError}
         */
        listAssistantFiles(assistantId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions = {}): Promise<ListAssistantFilesResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).listAssistantFiles(assistantId, limit, order, after, before, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of assistants.
         * @throws {RequiredError}
         */
        listAssistants(limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions = {}): Promise<ListAssistantsResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).listAssistants(limit, order, after, before, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of message files.
         * @throws {RequiredError}
         */
        listMessageFiles(threadId: string, messageId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions = {}): Promise<ListMessageFilesResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).listMessageFiles(threadId, messageId, limit, order, after, before, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of messages for a given thread.
         * @throws {RequiredError}
         */
        listMessages(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, runId?: string, options?: RequestOptions = {}): Promise<ListMessagesResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).listMessages(threadId, limit, order, after, before, runId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of run steps belonging to a run.
         * @throws {RequiredError}
         */
        listRunSteps(threadId: string, runId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions = {}): Promise<ListRunStepsResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).listRunSteps(threadId, runId, limit, order, after, before, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of runs belonging to a thread.
         * @throws {RequiredError}
         */
        listRuns(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, options?: RequestOptions = {}): Promise<ListRunsResponse> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).listRuns(threadId, limit, order, after, before, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Modifies an assistant.
         * @throws {RequiredError}
         */
        modifyAssistant(assistantId: string, modifyAssistantRequest: ModifyAssistantRequest, options?: RequestOptions = {}): Promise<AssistantObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).modifyAssistant(assistantId, modifyAssistantRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Modifies a message.
         * @throws {RequiredError}
         */
        modifyMessage(threadId: string, messageId: string, modifyMessageRequest: ModifyMessageRequest, options?: RequestOptions = {}): Promise<MessageObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).modifyMessage(threadId, messageId, modifyMessageRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Modifies a run.
         * @throws {RequiredError}
         */
        modifyRun(threadId: string, runId: string, modifyRunRequest: ModifyRunRequest, options?: RequestOptions = {}): Promise<RunObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).modifyRun(threadId, runId, modifyRunRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Modifies a thread.
         * @throws {RequiredError}
         */
        modifyThread(threadId: string, modifyThreadRequest: ModifyThreadRequest, options?: RequestOptions = {}): Promise<ThreadObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).modifyThread(threadId, modifyThreadRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they\'re all completed. All outputs must be submitted in a single request. 
         * @throws {RequiredError}
         */
        submitToolOuputsToRun(threadId: string, runId: string, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest, options?: RequestOptions = {}): Promise<RunObject> {
            const localVarFetchArgs = AssistantsApiFetchParamCreator(configuration).submitToolOuputsToRun(threadId, runId, submitToolOutputsRunRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * AudioApi - fetch parameter creator
 * @export
 */
export const AudioApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generates audio from the input text.
         * @throws {RequiredError}
         */
        createSpeech(createSpeechRequest: CreateSpeechRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createSpeechRequest' is not null or undefined
            if (createSpeechRequest === null || createSpeechRequest === undefined) {
                throw new RequiredError('createSpeechRequest','Required parameter createSpeechRequest was null or undefined when calling createSpeech.');
            }
            const localVarPath = `/audio/speech`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createSpeechRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createSpeechRequest != null ? createSpeechRequest : {}) : (((createSpeechRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transcribes audio into the input language.
         * @throws {RequiredError}
         */
        createTranscription(file: File, model: CreateTranscriptionRequestModel, language?: string, prompt?: string, responseFormat?: string, temperature?: number, timestampGranularities?: Array<string>, options: RequestOptions): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling createTranscription.');
            }
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError('model','Required parameter model was null or undefined when calling createTranscription.');
            }
            const localVarPath = `/audio/transcriptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication ApiKeyAuth required

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (model !== undefined) {
                localVarFormParams.set('model', ((model:any):string));
            }

            if (language !== undefined) {
                localVarFormParams.set('language', ((language:any):string));
            }

            if (prompt !== undefined) {
                localVarFormParams.set('prompt', ((prompt:any):string));
            }

            if (responseFormat !== undefined) {
                localVarFormParams.set('response_format', ((responseFormat:any):string));
            }

            if (temperature !== undefined) {
                localVarFormParams.set('temperature', ((temperature:any):string));
            }

            if (timestampGranularities) {
                    localVarFormParams.set('timestamp_granularities[]', timestampGranularities.join(COLLECTION_FORMATS["csv"]));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Translates audio into English.
         * @throws {RequiredError}
         */
        createTranslation(file: File, model: CreateTranscriptionRequestModel, prompt?: string, responseFormat?: string, temperature?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling createTranslation.');
            }
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError('model','Required parameter model was null or undefined when calling createTranslation.');
            }
            const localVarPath = `/audio/translations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication ApiKeyAuth required

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (model !== undefined) {
                localVarFormParams.set('model', ((model:any):string));
            }

            if (prompt !== undefined) {
                localVarFormParams.set('prompt', ((prompt:any):string));
            }

            if (responseFormat !== undefined) {
                localVarFormParams.set('response_format', ((responseFormat:any):string));
            }

            if (temperature !== undefined) {
                localVarFormParams.set('temperature', ((temperature:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type AudioApiType = { 
    createSpeech(createSpeechRequest: CreateSpeechRequest, options?: RequestOptions): Promise<File>,

    createTranscription(file: File, model: CreateTranscriptionRequestModel, language?: string, prompt?: string, responseFormat?: string, temperature?: number, timestampGranularities?: Array<string>, options?: RequestOptions): Promise<CreateTranscription200Response>,

    createTranslation(file: File, model: CreateTranscriptionRequestModel, prompt?: string, responseFormat?: string, temperature?: number, options?: RequestOptions): Promise<CreateTranslation200Response>,
}

/**
 * AudioApi - factory function to inject configuration 
 * @export
 */
export const AudioApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): AudioApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Generates audio from the input text.
         * @throws {RequiredError}
         */
        createSpeech(createSpeechRequest: CreateSpeechRequest, options?: RequestOptions = {}): Promise<File> {
            const localVarFetchArgs = AudioApiFetchParamCreator(configuration).createSpeech(createSpeechRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Transcribes audio into the input language.
         * @throws {RequiredError}
         */
        createTranscription(file: File, model: CreateTranscriptionRequestModel, language?: string, prompt?: string, responseFormat?: string, temperature?: number, timestampGranularities?: Array<string>, options?: RequestOptions = {}): Promise<CreateTranscription200Response> {
            const localVarFetchArgs = AudioApiFetchParamCreator(configuration).createTranscription(file, model, language, prompt, responseFormat, temperature, timestampGranularities, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Translates audio into English.
         * @throws {RequiredError}
         */
        createTranslation(file: File, model: CreateTranscriptionRequestModel, prompt?: string, responseFormat?: string, temperature?: number, options?: RequestOptions = {}): Promise<CreateTranslation200Response> {
            const localVarFetchArgs = AudioApiFetchParamCreator(configuration).createTranslation(file, model, prompt, responseFormat, temperature, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ChatApi - fetch parameter creator
 * @export
 */
export const ChatApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a model response for the given chat conversation.
         * @throws {RequiredError}
         */
        createChatCompletion(createChatCompletionRequest: CreateChatCompletionRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createChatCompletionRequest' is not null or undefined
            if (createChatCompletionRequest === null || createChatCompletionRequest === undefined) {
                throw new RequiredError('createChatCompletionRequest','Required parameter createChatCompletionRequest was null or undefined when calling createChatCompletion.');
            }
            const localVarPath = `/chat/completions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createChatCompletionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createChatCompletionRequest != null ? createChatCompletionRequest : {}) : (((createChatCompletionRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ChatApiType = { 
    createChatCompletion(createChatCompletionRequest: CreateChatCompletionRequest, options?: RequestOptions): Promise<CreateChatCompletionResponse>,
}

/**
 * ChatApi - factory function to inject configuration 
 * @export
 */
export const ChatApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ChatApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Creates a model response for the given chat conversation.
         * @throws {RequiredError}
         */
        createChatCompletion(createChatCompletionRequest: CreateChatCompletionRequest, options?: RequestOptions = {}): Promise<CreateChatCompletionResponse> {
            const localVarFetchArgs = ChatApiFetchParamCreator(configuration).createChatCompletion(createChatCompletionRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CompletionsApi - fetch parameter creator
 * @export
 */
export const CompletionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a completion for the provided prompt and parameters.
         * @throws {RequiredError}
         */
        createCompletion(createCompletionRequest: CreateCompletionRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createCompletionRequest' is not null or undefined
            if (createCompletionRequest === null || createCompletionRequest === undefined) {
                throw new RequiredError('createCompletionRequest','Required parameter createCompletionRequest was null or undefined when calling createCompletion.');
            }
            const localVarPath = `/completions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createCompletionRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createCompletionRequest != null ? createCompletionRequest : {}) : (((createCompletionRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CompletionsApiType = { 
    createCompletion(createCompletionRequest: CreateCompletionRequest, options?: RequestOptions): Promise<CreateCompletionResponse>,
}

/**
 * CompletionsApi - factory function to inject configuration 
 * @export
 */
export const CompletionsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CompletionsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Creates a completion for the provided prompt and parameters.
         * @throws {RequiredError}
         */
        createCompletion(createCompletionRequest: CreateCompletionRequest, options?: RequestOptions = {}): Promise<CreateCompletionResponse> {
            const localVarFetchArgs = CompletionsApiFetchParamCreator(configuration).createCompletion(createCompletionRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * EmbeddingsApi - fetch parameter creator
 * @export
 */
export const EmbeddingsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an embedding vector representing the input text.
         * @throws {RequiredError}
         */
        createEmbedding(createEmbeddingRequest: CreateEmbeddingRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createEmbeddingRequest' is not null or undefined
            if (createEmbeddingRequest === null || createEmbeddingRequest === undefined) {
                throw new RequiredError('createEmbeddingRequest','Required parameter createEmbeddingRequest was null or undefined when calling createEmbedding.');
            }
            const localVarPath = `/embeddings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createEmbeddingRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createEmbeddingRequest != null ? createEmbeddingRequest : {}) : (((createEmbeddingRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type EmbeddingsApiType = { 
    createEmbedding(createEmbeddingRequest: CreateEmbeddingRequest, options?: RequestOptions): Promise<CreateEmbeddingResponse>,
}

/**
 * EmbeddingsApi - factory function to inject configuration 
 * @export
 */
export const EmbeddingsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): EmbeddingsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Creates an embedding vector representing the input text.
         * @throws {RequiredError}
         */
        createEmbedding(createEmbeddingRequest: CreateEmbeddingRequest, options?: RequestOptions = {}): Promise<CreateEmbeddingResponse> {
            const localVarFetchArgs = EmbeddingsApiFetchParamCreator(configuration).createEmbedding(createEmbeddingRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * FilesApi - fetch parameter creator
 * @export
 */
export const FilesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload a file that can be used across various endpoints. The size of all the files uploaded by one organization can be up to 100 GB.  The size of individual files can be a maximum of 512 MB or 2 million tokens for Assistants. See the [Assistants Tools guide](/docs/assistants/tools) to learn more about the types of files supported. The Fine-tuning API only supports `.jsonl` files.  Please [contact us](https://help.openai.com/) if you need to increase these storage limits. 
         * @throws {RequiredError}
         */
        createFile(file: File, purpose: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling createFile.');
            }
            // verify required parameter 'purpose' is not null or undefined
            if (purpose === null || purpose === undefined) {
                throw new RequiredError('purpose','Required parameter purpose was null or undefined when calling createFile.');
            }
            const localVarPath = `/files`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication ApiKeyAuth required

            if (file !== undefined) {
                localVarFormParams.set('file', ((file:any):string));
            }

            if (purpose !== undefined) {
                localVarFormParams.set('purpose', ((purpose:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a file.
         * @throws {RequiredError}
         */
        deleteFile(fileId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling deleteFile.');
            }
            const localVarPath = `/files/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the contents of the specified file.
         * @throws {RequiredError}
         */
        downloadFile(fileId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling downloadFile.');
            }
            const localVarPath = `/files/{file_id}/content`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of files that belong to the user\'s organization.
         * @throws {RequiredError}
         */
        listFiles(purpose?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/files`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (purpose !== undefined) {
                localVarQueryParameter['purpose'] = ((purpose:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns information about a specific file.
         * @throws {RequiredError}
         */
        retrieveFile(fileId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling retrieveFile.');
            }
            const localVarPath = `/files/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type FilesApiType = { 
    createFile(file: File, purpose: string, options?: RequestOptions): Promise<OpenAIFile>,

    deleteFile(fileId: string, options?: RequestOptions): Promise<DeleteFileResponse>,

    downloadFile(fileId: string, options?: RequestOptions): Promise<string>,

    listFiles(purpose?: string, options?: RequestOptions): Promise<ListFilesResponse>,

    retrieveFile(fileId: string, options?: RequestOptions): Promise<OpenAIFile>,
}

/**
 * FilesApi - factory function to inject configuration 
 * @export
 */
export const FilesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): FilesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Upload a file that can be used across various endpoints. The size of all the files uploaded by one organization can be up to 100 GB.  The size of individual files can be a maximum of 512 MB or 2 million tokens for Assistants. See the [Assistants Tools guide](/docs/assistants/tools) to learn more about the types of files supported. The Fine-tuning API only supports `.jsonl` files.  Please [contact us](https://help.openai.com/) if you need to increase these storage limits. 
         * @throws {RequiredError}
         */
        createFile(file: File, purpose: string, options?: RequestOptions = {}): Promise<OpenAIFile> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).createFile(file, purpose, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete a file.
         * @throws {RequiredError}
         */
        deleteFile(fileId: string, options?: RequestOptions = {}): Promise<DeleteFileResponse> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).deleteFile(fileId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns the contents of the specified file.
         * @throws {RequiredError}
         */
        downloadFile(fileId: string, options?: RequestOptions = {}): Promise<string> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).downloadFile(fileId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns a list of files that belong to the user\'s organization.
         * @throws {RequiredError}
         */
        listFiles(purpose?: string, options?: RequestOptions = {}): Promise<ListFilesResponse> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).listFiles(purpose, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Returns information about a specific file.
         * @throws {RequiredError}
         */
        retrieveFile(fileId: string, options?: RequestOptions = {}): Promise<OpenAIFile> {
            const localVarFetchArgs = FilesApiFetchParamCreator(configuration).retrieveFile(fileId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * FineTuningApi - fetch parameter creator
 * @export
 */
export const FineTuningApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Immediately cancel a fine-tune job. 
         * @throws {RequiredError}
         */
        cancelFineTuningJob(fineTuningJobId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'fineTuningJobId' is not null or undefined
            if (fineTuningJobId === null || fineTuningJobId === undefined) {
                throw new RequiredError('fineTuningJobId','Required parameter fineTuningJobId was null or undefined when calling cancelFineTuningJob.');
            }
            const localVarPath = `/fine_tuning/jobs/{fine_tuning_job_id}/cancel`
                .replace(`{${"fine_tuning_job_id"}}`, encodeURIComponent(String(fineTuningJobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a fine-tuning job which begins the process of creating a new model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
         * @throws {RequiredError}
         */
        createFineTuningJob(createFineTuningJobRequest: CreateFineTuningJobRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createFineTuningJobRequest' is not null or undefined
            if (createFineTuningJobRequest === null || createFineTuningJobRequest === undefined) {
                throw new RequiredError('createFineTuningJobRequest','Required parameter createFineTuningJobRequest was null or undefined when calling createFineTuningJob.');
            }
            const localVarPath = `/fine_tuning/jobs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createFineTuningJobRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createFineTuningJobRequest != null ? createFineTuningJobRequest : {}) : (((createFineTuningJobRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get status updates for a fine-tuning job. 
         * @throws {RequiredError}
         */
        listFineTuningEvents(fineTuningJobId: string, after?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'fineTuningJobId' is not null or undefined
            if (fineTuningJobId === null || fineTuningJobId === undefined) {
                throw new RequiredError('fineTuningJobId','Required parameter fineTuningJobId was null or undefined when calling listFineTuningEvents.');
            }
            const localVarPath = `/fine_tuning/jobs/{fine_tuning_job_id}/events`
                .replace(`{${"fine_tuning_job_id"}}`, encodeURIComponent(String(fineTuningJobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List checkpoints for a fine-tuning job. 
         * @throws {RequiredError}
         */
        listFineTuningJobCheckpoints(fineTuningJobId: string, after?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'fineTuningJobId' is not null or undefined
            if (fineTuningJobId === null || fineTuningJobId === undefined) {
                throw new RequiredError('fineTuningJobId','Required parameter fineTuningJobId was null or undefined when calling listFineTuningJobCheckpoints.');
            }
            const localVarPath = `/fine_tuning/jobs/{fine_tuning_job_id}/checkpoints`
                .replace(`{${"fine_tuning_job_id"}}`, encodeURIComponent(String(fineTuningJobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List your organization\'s fine-tuning jobs 
         * @throws {RequiredError}
         */
        listPaginatedFineTuningJobs(after?: string, limit?: number, options: RequestOptions): FetchArgs {
            const localVarPath = `/fine_tuning/jobs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            if (after !== undefined) {
                localVarQueryParameter['after'] = ((after:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get info about a fine-tuning job.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
         * @throws {RequiredError}
         */
        retrieveFineTuningJob(fineTuningJobId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'fineTuningJobId' is not null or undefined
            if (fineTuningJobId === null || fineTuningJobId === undefined) {
                throw new RequiredError('fineTuningJobId','Required parameter fineTuningJobId was null or undefined when calling retrieveFineTuningJob.');
            }
            const localVarPath = `/fine_tuning/jobs/{fine_tuning_job_id}`
                .replace(`{${"fine_tuning_job_id"}}`, encodeURIComponent(String(fineTuningJobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type FineTuningApiType = { 
    cancelFineTuningJob(fineTuningJobId: string, options?: RequestOptions): Promise<FineTuningJob>,

    createFineTuningJob(createFineTuningJobRequest: CreateFineTuningJobRequest, options?: RequestOptions): Promise<FineTuningJob>,

    listFineTuningEvents(fineTuningJobId: string, after?: string, limit?: number, options?: RequestOptions): Promise<ListFineTuningJobEventsResponse>,

    listFineTuningJobCheckpoints(fineTuningJobId: string, after?: string, limit?: number, options?: RequestOptions): Promise<ListFineTuningJobCheckpointsResponse>,

    listPaginatedFineTuningJobs(after?: string, limit?: number, options?: RequestOptions): Promise<ListPaginatedFineTuningJobsResponse>,

    retrieveFineTuningJob(fineTuningJobId: string, options?: RequestOptions): Promise<FineTuningJob>,
}

/**
 * FineTuningApi - factory function to inject configuration 
 * @export
 */
export const FineTuningApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): FineTuningApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Immediately cancel a fine-tune job. 
         * @throws {RequiredError}
         */
        cancelFineTuningJob(fineTuningJobId: string, options?: RequestOptions = {}): Promise<FineTuningJob> {
            const localVarFetchArgs = FineTuningApiFetchParamCreator(configuration).cancelFineTuningJob(fineTuningJobId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Creates a fine-tuning job which begins the process of creating a new model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
         * @throws {RequiredError}
         */
        createFineTuningJob(createFineTuningJobRequest: CreateFineTuningJobRequest, options?: RequestOptions = {}): Promise<FineTuningJob> {
            const localVarFetchArgs = FineTuningApiFetchParamCreator(configuration).createFineTuningJob(createFineTuningJobRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get status updates for a fine-tuning job. 
         * @throws {RequiredError}
         */
        listFineTuningEvents(fineTuningJobId: string, after?: string, limit?: number, options?: RequestOptions = {}): Promise<ListFineTuningJobEventsResponse> {
            const localVarFetchArgs = FineTuningApiFetchParamCreator(configuration).listFineTuningEvents(fineTuningJobId, after, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List checkpoints for a fine-tuning job. 
         * @throws {RequiredError}
         */
        listFineTuningJobCheckpoints(fineTuningJobId: string, after?: string, limit?: number, options?: RequestOptions = {}): Promise<ListFineTuningJobCheckpointsResponse> {
            const localVarFetchArgs = FineTuningApiFetchParamCreator(configuration).listFineTuningJobCheckpoints(fineTuningJobId, after, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List your organization\'s fine-tuning jobs 
         * @throws {RequiredError}
         */
        listPaginatedFineTuningJobs(after?: string, limit?: number, options?: RequestOptions = {}): Promise<ListPaginatedFineTuningJobsResponse> {
            const localVarFetchArgs = FineTuningApiFetchParamCreator(configuration).listPaginatedFineTuningJobs(after, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get info about a fine-tuning job.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
         * @throws {RequiredError}
         */
        retrieveFineTuningJob(fineTuningJobId: string, options?: RequestOptions = {}): Promise<FineTuningJob> {
            const localVarFetchArgs = FineTuningApiFetchParamCreator(configuration).retrieveFineTuningJob(fineTuningJobId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ImagesApi - fetch parameter creator
 * @export
 */
export const ImagesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an image given a prompt.
         * @throws {RequiredError}
         */
        createImage(createImageRequest: CreateImageRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createImageRequest' is not null or undefined
            if (createImageRequest === null || createImageRequest === undefined) {
                throw new RequiredError('createImageRequest','Required parameter createImageRequest was null or undefined when calling createImage.');
            }
            const localVarPath = `/images/generations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createImageRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createImageRequest != null ? createImageRequest : {}) : (((createImageRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @throws {RequiredError}
         */
        createImageEdit(image: File, prompt: string, mask?: File, model?: CreateImageEditRequestModel, n?: number, size?: string, responseFormat?: string, user?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling createImageEdit.');
            }
            // verify required parameter 'prompt' is not null or undefined
            if (prompt === null || prompt === undefined) {
                throw new RequiredError('prompt','Required parameter prompt was null or undefined when calling createImageEdit.');
            }
            const localVarPath = `/images/edits`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication ApiKeyAuth required

            if (image !== undefined) {
                localVarFormParams.set('image', ((image:any):string));
            }

            if (prompt !== undefined) {
                localVarFormParams.set('prompt', ((prompt:any):string));
            }

            if (mask !== undefined) {
                localVarFormParams.set('mask', ((mask:any):string));
            }

            if (model !== undefined) {
                localVarFormParams.set('model', ((model:any):string));
            }

            if (n !== undefined) {
                localVarFormParams.set('n', ((n:any):string));
            }

            if (size !== undefined) {
                localVarFormParams.set('size', ((size:any):string));
            }

            if (responseFormat !== undefined) {
                localVarFormParams.set('response_format', ((responseFormat:any):string));
            }

            if (user !== undefined) {
                localVarFormParams.set('user', ((user:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a variation of a given image.
         * @throws {RequiredError}
         */
        createImageVariation(image: File, model?: CreateImageEditRequestModel, n?: number, responseFormat?: string, size?: string, user?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling createImageVariation.');
            }
            const localVarPath = `/images/variations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();

            // authentication ApiKeyAuth required

            if (image !== undefined) {
                localVarFormParams.set('image', ((image:any):string));
            }

            if (model !== undefined) {
                localVarFormParams.set('model', ((model:any):string));
            }

            if (n !== undefined) {
                localVarFormParams.set('n', ((n:any):string));
            }

            if (responseFormat !== undefined) {
                localVarFormParams.set('response_format', ((responseFormat:any):string));
            }

            if (size !== undefined) {
                localVarFormParams.set('size', ((size:any):string));
            }

            if (user !== undefined) {
                localVarFormParams.set('user', ((user:any):string));
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ImagesApiType = { 
    createImage(createImageRequest: CreateImageRequest, options?: RequestOptions): Promise<ImagesResponse>,

    createImageEdit(image: File, prompt: string, mask?: File, model?: CreateImageEditRequestModel, n?: number, size?: string, responseFormat?: string, user?: string, options?: RequestOptions): Promise<ImagesResponse>,

    createImageVariation(image: File, model?: CreateImageEditRequestModel, n?: number, responseFormat?: string, size?: string, user?: string, options?: RequestOptions): Promise<ImagesResponse>,
}

/**
 * ImagesApi - factory function to inject configuration 
 * @export
 */
export const ImagesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ImagesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Creates an image given a prompt.
         * @throws {RequiredError}
         */
        createImage(createImageRequest: CreateImageRequest, options?: RequestOptions = {}): Promise<ImagesResponse> {
            const localVarFetchArgs = ImagesApiFetchParamCreator(configuration).createImage(createImageRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @throws {RequiredError}
         */
        createImageEdit(image: File, prompt: string, mask?: File, model?: CreateImageEditRequestModel, n?: number, size?: string, responseFormat?: string, user?: string, options?: RequestOptions = {}): Promise<ImagesResponse> {
            const localVarFetchArgs = ImagesApiFetchParamCreator(configuration).createImageEdit(image, prompt, mask, model, n, size, responseFormat, user, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Creates a variation of a given image.
         * @throws {RequiredError}
         */
        createImageVariation(image: File, model?: CreateImageEditRequestModel, n?: number, responseFormat?: string, size?: string, user?: string, options?: RequestOptions = {}): Promise<ImagesResponse> {
            const localVarFetchArgs = ImagesApiFetchParamCreator(configuration).createImageVariation(image, model, n, responseFormat, size, user, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ModelsApi - fetch parameter creator
 * @export
 */
export const ModelsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization to delete a model.
         * @throws {RequiredError}
         */
        deleteModel(model: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError('model','Required parameter model was null or undefined when calling deleteModel.');
            }
            const localVarPath = `/models/{model}`
                .replace(`{${"model"}}`, encodeURIComponent(String(model)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @throws {RequiredError}
         */
        listModels(options: RequestOptions): FetchArgs {
            const localVarPath = `/models`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @throws {RequiredError}
         */
        retrieveModel(model: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'model' is not null or undefined
            if (model === null || model === undefined) {
                throw new RequiredError('model','Required parameter model was null or undefined when calling retrieveModel.');
            }
            const localVarPath = `/models/{model}`
                .replace(`{${"model"}}`, encodeURIComponent(String(model)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ModelsApiType = { 
    deleteModel(model: string, options?: RequestOptions): Promise<DeleteModelResponse>,

    listModels(options?: RequestOptions): Promise<ListModelsResponse>,

    retrieveModel(model: string, options?: RequestOptions): Promise<Model>,
}

/**
 * ModelsApi - factory function to inject configuration 
 * @export
 */
export const ModelsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ModelsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization to delete a model.
         * @throws {RequiredError}
         */
        deleteModel(model: string, options?: RequestOptions = {}): Promise<DeleteModelResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).deleteModel(model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @throws {RequiredError}
         */
        listModels(options?: RequestOptions = {}): Promise<ListModelsResponse> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).listModels(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @throws {RequiredError}
         */
        retrieveModel(model: string, options?: RequestOptions = {}): Promise<Model> {
            const localVarFetchArgs = ModelsApiFetchParamCreator(configuration).retrieveModel(model, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ModerationsApi - fetch parameter creator
 * @export
 */
export const ModerationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Classifies if text is potentially harmful.
         * @throws {RequiredError}
         */
        createModeration(createModerationRequest: CreateModerationRequest, options: RequestOptions): FetchArgs {
            // verify required parameter 'createModerationRequest' is not null or undefined
            if (createModerationRequest === null || createModerationRequest === undefined) {
                throw new RequiredError('createModerationRequest','Required parameter createModerationRequest was null or undefined when calling createModeration.');
            }
            const localVarPath = `/moderations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKeyAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof createModerationRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(createModerationRequest != null ? createModerationRequest : {}) : (((createModerationRequest:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ModerationsApiType = { 
    createModeration(createModerationRequest: CreateModerationRequest, options?: RequestOptions): Promise<CreateModerationResponse>,
}

/**
 * ModerationsApi - factory function to inject configuration 
 * @export
 */
export const ModerationsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ModerationsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Classifies if text is potentially harmful.
         * @throws {RequiredError}
         */
        createModeration(createModerationRequest: CreateModerationRequest, options?: RequestOptions = {}): Promise<CreateModerationResponse> {
            const localVarFetchArgs = ModerationsApiFetchParamCreator(configuration).createModeration(createModerationRequest, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    AssistantsApi: AssistantsApiType,

    AudioApi: AudioApiType,

    ChatApi: ChatApiType,

    CompletionsApi: CompletionsApiType,

    EmbeddingsApi: EmbeddingsApiType,

    FilesApi: FilesApiType,

    FineTuningApi: FineTuningApiType,

    ImagesApi: ImagesApiType,

    ModelsApi: ModelsApiType,

    ModerationsApi: ModerationsApiType,
 }
