/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.AssistantObject
import org.openapitools.client.models.CreateAssistantRequest
import org.openapitools.client.models.CreateMessageRequest
import org.openapitools.client.models.CreateRunRequest
import org.openapitools.client.models.CreateThreadAndRunRequest
import org.openapitools.client.models.CreateThreadRequest
import org.openapitools.client.models.DeleteAssistantResponse
import org.openapitools.client.models.DeleteMessageResponse
import org.openapitools.client.models.DeleteThreadResponse
import org.openapitools.client.models.ListAssistantsResponse
import org.openapitools.client.models.ListMessagesResponse
import org.openapitools.client.models.ListRunStepsResponse
import org.openapitools.client.models.ListRunsResponse
import org.openapitools.client.models.MessageObject
import org.openapitools.client.models.ModifyAssistantRequest
import org.openapitools.client.models.ModifyMessageRequest
import org.openapitools.client.models.ModifyRunRequest
import org.openapitools.client.models.ModifyThreadRequest
import org.openapitools.client.models.RunObject
import org.openapitools.client.models.RunStepObject
import org.openapitools.client.models.SubmitToolOutputsRunRequest
import org.openapitools.client.models.ThreadObject

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class AssistantsApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.openai.com/v1")
        }
    }

    /**
     * POST /threads/{thread_id}/runs/{run_id}/cancel
     * Cancels a run that is &#x60;in_progress&#x60;.
     * 
     * @param threadId The ID of the thread to which this run belongs.
     * @param runId The ID of the run to cancel.
     * @return RunObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cancelRun(threadId: kotlin.String, runId: kotlin.String) : RunObject {
        val localVarResponse = cancelRunWithHttpInfo(threadId = threadId, runId = runId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RunObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /threads/{thread_id}/runs/{run_id}/cancel
     * Cancels a run that is &#x60;in_progress&#x60;.
     * 
     * @param threadId The ID of the thread to which this run belongs.
     * @param runId The ID of the run to cancel.
     * @return ApiResponse<RunObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cancelRunWithHttpInfo(threadId: kotlin.String, runId: kotlin.String) : ApiResponse<RunObject?> {
        val localVariableConfig = cancelRunRequestConfig(threadId = threadId, runId = runId)

        return request<Unit, RunObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cancelRun
     *
     * @param threadId The ID of the thread to which this run belongs.
     * @param runId The ID of the run to cancel.
     * @return RequestConfig
     */
    fun cancelRunRequestConfig(threadId: kotlin.String, runId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/threads/{thread_id}/runs/{run_id}/cancel".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())).replace("{"+"run_id"+"}", encodeURIComponent(runId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /assistants
     * Create an assistant with a model and instructions.
     * 
     * @param createAssistantRequest 
     * @return AssistantObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createAssistant(createAssistantRequest: CreateAssistantRequest) : AssistantObject {
        val localVarResponse = createAssistantWithHttpInfo(createAssistantRequest = createAssistantRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssistantObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /assistants
     * Create an assistant with a model and instructions.
     * 
     * @param createAssistantRequest 
     * @return ApiResponse<AssistantObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createAssistantWithHttpInfo(createAssistantRequest: CreateAssistantRequest) : ApiResponse<AssistantObject?> {
        val localVariableConfig = createAssistantRequestConfig(createAssistantRequest = createAssistantRequest)

        return request<CreateAssistantRequest, AssistantObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createAssistant
     *
     * @param createAssistantRequest 
     * @return RequestConfig
     */
    fun createAssistantRequestConfig(createAssistantRequest: CreateAssistantRequest) : RequestConfig<CreateAssistantRequest> {
        val localVariableBody = createAssistantRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/assistants",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /threads/{thread_id}/messages
     * Create a message.
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) to create a message for.
     * @param createMessageRequest 
     * @return MessageObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createMessage(threadId: kotlin.String, createMessageRequest: CreateMessageRequest) : MessageObject {
        val localVarResponse = createMessageWithHttpInfo(threadId = threadId, createMessageRequest = createMessageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MessageObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /threads/{thread_id}/messages
     * Create a message.
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) to create a message for.
     * @param createMessageRequest 
     * @return ApiResponse<MessageObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createMessageWithHttpInfo(threadId: kotlin.String, createMessageRequest: CreateMessageRequest) : ApiResponse<MessageObject?> {
        val localVariableConfig = createMessageRequestConfig(threadId = threadId, createMessageRequest = createMessageRequest)

        return request<CreateMessageRequest, MessageObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createMessage
     *
     * @param threadId The ID of the [thread](/docs/api-reference/threads) to create a message for.
     * @param createMessageRequest 
     * @return RequestConfig
     */
    fun createMessageRequestConfig(threadId: kotlin.String, createMessageRequest: CreateMessageRequest) : RequestConfig<CreateMessageRequest> {
        val localVariableBody = createMessageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/threads/{thread_id}/messages".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter include
     */
     enum class IncludeCreateRun(val value: kotlin.String) {
         @Json(name = "step_details.tool_calls[*].file_search.results[*].content") step_detailsPeriodTool_callsLeft_Square_BracketStarRight_Square_BracketPeriodFile_searchPeriodResultsLeft_Square_BracketStarRight_Square_BracketPeriodContent("step_details.tool_calls[*].file_search.results[*].content");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * POST /threads/{thread_id}/runs
     * Create a run.
     * 
     * @param threadId The ID of the thread to run.
     * @param createRunRequest 
     * @param include A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.  (optional)
     * @return RunObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createRun(threadId: kotlin.String, createRunRequest: CreateRunRequest, include: kotlin.collections.List<IncludeCreateRun>? = null) : RunObject {
        val localVarResponse = createRunWithHttpInfo(threadId = threadId, createRunRequest = createRunRequest, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RunObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /threads/{thread_id}/runs
     * Create a run.
     * 
     * @param threadId The ID of the thread to run.
     * @param createRunRequest 
     * @param include A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.  (optional)
     * @return ApiResponse<RunObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createRunWithHttpInfo(threadId: kotlin.String, createRunRequest: CreateRunRequest, include: kotlin.collections.List<IncludeCreateRun>?) : ApiResponse<RunObject?> {
        val localVariableConfig = createRunRequestConfig(threadId = threadId, createRunRequest = createRunRequest, include = include)

        return request<CreateRunRequest, RunObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createRun
     *
     * @param threadId The ID of the thread to run.
     * @param createRunRequest 
     * @param include A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.  (optional)
     * @return RequestConfig
     */
    fun createRunRequestConfig(threadId: kotlin.String, createRunRequest: CreateRunRequest, include: kotlin.collections.List<IncludeCreateRun>?) : RequestConfig<CreateRunRequest> {
        val localVariableBody = createRunRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (include != null) {
                    put("include[]", toMultiValue(include.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/threads/{thread_id}/runs".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /threads
     * Create a thread.
     * 
     * @param createThreadRequest  (optional)
     * @return ThreadObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createThread(createThreadRequest: CreateThreadRequest? = null) : ThreadObject {
        val localVarResponse = createThreadWithHttpInfo(createThreadRequest = createThreadRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ThreadObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /threads
     * Create a thread.
     * 
     * @param createThreadRequest  (optional)
     * @return ApiResponse<ThreadObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createThreadWithHttpInfo(createThreadRequest: CreateThreadRequest?) : ApiResponse<ThreadObject?> {
        val localVariableConfig = createThreadRequestConfig(createThreadRequest = createThreadRequest)

        return request<CreateThreadRequest, ThreadObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createThread
     *
     * @param createThreadRequest  (optional)
     * @return RequestConfig
     */
    fun createThreadRequestConfig(createThreadRequest: CreateThreadRequest?) : RequestConfig<CreateThreadRequest> {
        val localVariableBody = createThreadRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/threads",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /threads/runs
     * Create a thread and run it in one request.
     * 
     * @param createThreadAndRunRequest 
     * @return RunObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createThreadAndRun(createThreadAndRunRequest: CreateThreadAndRunRequest) : RunObject {
        val localVarResponse = createThreadAndRunWithHttpInfo(createThreadAndRunRequest = createThreadAndRunRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RunObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /threads/runs
     * Create a thread and run it in one request.
     * 
     * @param createThreadAndRunRequest 
     * @return ApiResponse<RunObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createThreadAndRunWithHttpInfo(createThreadAndRunRequest: CreateThreadAndRunRequest) : ApiResponse<RunObject?> {
        val localVariableConfig = createThreadAndRunRequestConfig(createThreadAndRunRequest = createThreadAndRunRequest)

        return request<CreateThreadAndRunRequest, RunObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createThreadAndRun
     *
     * @param createThreadAndRunRequest 
     * @return RequestConfig
     */
    fun createThreadAndRunRequestConfig(createThreadAndRunRequest: CreateThreadAndRunRequest) : RequestConfig<CreateThreadAndRunRequest> {
        val localVariableBody = createThreadAndRunRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/threads/runs",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * DELETE /assistants/{assistant_id}
     * Delete an assistant.
     * 
     * @param assistantId The ID of the assistant to delete.
     * @return DeleteAssistantResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteAssistant(assistantId: kotlin.String) : DeleteAssistantResponse {
        val localVarResponse = deleteAssistantWithHttpInfo(assistantId = assistantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteAssistantResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /assistants/{assistant_id}
     * Delete an assistant.
     * 
     * @param assistantId The ID of the assistant to delete.
     * @return ApiResponse<DeleteAssistantResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteAssistantWithHttpInfo(assistantId: kotlin.String) : ApiResponse<DeleteAssistantResponse?> {
        val localVariableConfig = deleteAssistantRequestConfig(assistantId = assistantId)

        return request<Unit, DeleteAssistantResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteAssistant
     *
     * @param assistantId The ID of the assistant to delete.
     * @return RequestConfig
     */
    fun deleteAssistantRequestConfig(assistantId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/assistants/{assistant_id}".replace("{"+"assistant_id"+"}", encodeURIComponent(assistantId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * DELETE /threads/{thread_id}/messages/{message_id}
     * Deletes a message.
     * 
     * @param threadId The ID of the thread to which this message belongs.
     * @param messageId The ID of the message to delete.
     * @return DeleteMessageResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteMessage(threadId: kotlin.String, messageId: kotlin.String) : DeleteMessageResponse {
        val localVarResponse = deleteMessageWithHttpInfo(threadId = threadId, messageId = messageId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteMessageResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /threads/{thread_id}/messages/{message_id}
     * Deletes a message.
     * 
     * @param threadId The ID of the thread to which this message belongs.
     * @param messageId The ID of the message to delete.
     * @return ApiResponse<DeleteMessageResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteMessageWithHttpInfo(threadId: kotlin.String, messageId: kotlin.String) : ApiResponse<DeleteMessageResponse?> {
        val localVariableConfig = deleteMessageRequestConfig(threadId = threadId, messageId = messageId)

        return request<Unit, DeleteMessageResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteMessage
     *
     * @param threadId The ID of the thread to which this message belongs.
     * @param messageId The ID of the message to delete.
     * @return RequestConfig
     */
    fun deleteMessageRequestConfig(threadId: kotlin.String, messageId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/threads/{thread_id}/messages/{message_id}".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())).replace("{"+"message_id"+"}", encodeURIComponent(messageId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * DELETE /threads/{thread_id}
     * Delete a thread.
     * 
     * @param threadId The ID of the thread to delete.
     * @return DeleteThreadResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteThread(threadId: kotlin.String) : DeleteThreadResponse {
        val localVarResponse = deleteThreadWithHttpInfo(threadId = threadId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteThreadResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /threads/{thread_id}
     * Delete a thread.
     * 
     * @param threadId The ID of the thread to delete.
     * @return ApiResponse<DeleteThreadResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteThreadWithHttpInfo(threadId: kotlin.String) : ApiResponse<DeleteThreadResponse?> {
        val localVariableConfig = deleteThreadRequestConfig(threadId = threadId)

        return request<Unit, DeleteThreadResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteThread
     *
     * @param threadId The ID of the thread to delete.
     * @return RequestConfig
     */
    fun deleteThreadRequestConfig(threadId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/threads/{thread_id}".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /assistants/{assistant_id}
     * Retrieves an assistant.
     * 
     * @param assistantId The ID of the assistant to retrieve.
     * @return AssistantObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAssistant(assistantId: kotlin.String) : AssistantObject {
        val localVarResponse = getAssistantWithHttpInfo(assistantId = assistantId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssistantObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /assistants/{assistant_id}
     * Retrieves an assistant.
     * 
     * @param assistantId The ID of the assistant to retrieve.
     * @return ApiResponse<AssistantObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAssistantWithHttpInfo(assistantId: kotlin.String) : ApiResponse<AssistantObject?> {
        val localVariableConfig = getAssistantRequestConfig(assistantId = assistantId)

        return request<Unit, AssistantObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAssistant
     *
     * @param assistantId The ID of the assistant to retrieve.
     * @return RequestConfig
     */
    fun getAssistantRequestConfig(assistantId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/assistants/{assistant_id}".replace("{"+"assistant_id"+"}", encodeURIComponent(assistantId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /threads/{thread_id}/messages/{message_id}
     * Retrieve a message.
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this message belongs.
     * @param messageId The ID of the message to retrieve.
     * @return MessageObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMessage(threadId: kotlin.String, messageId: kotlin.String) : MessageObject {
        val localVarResponse = getMessageWithHttpInfo(threadId = threadId, messageId = messageId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MessageObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /threads/{thread_id}/messages/{message_id}
     * Retrieve a message.
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this message belongs.
     * @param messageId The ID of the message to retrieve.
     * @return ApiResponse<MessageObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMessageWithHttpInfo(threadId: kotlin.String, messageId: kotlin.String) : ApiResponse<MessageObject?> {
        val localVariableConfig = getMessageRequestConfig(threadId = threadId, messageId = messageId)

        return request<Unit, MessageObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMessage
     *
     * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this message belongs.
     * @param messageId The ID of the message to retrieve.
     * @return RequestConfig
     */
    fun getMessageRequestConfig(threadId: kotlin.String, messageId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/threads/{thread_id}/messages/{message_id}".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())).replace("{"+"message_id"+"}", encodeURIComponent(messageId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /threads/{thread_id}/runs/{run_id}
     * Retrieves a run.
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run.
     * @param runId The ID of the run to retrieve.
     * @return RunObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRun(threadId: kotlin.String, runId: kotlin.String) : RunObject {
        val localVarResponse = getRunWithHttpInfo(threadId = threadId, runId = runId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RunObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /threads/{thread_id}/runs/{run_id}
     * Retrieves a run.
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run.
     * @param runId The ID of the run to retrieve.
     * @return ApiResponse<RunObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRunWithHttpInfo(threadId: kotlin.String, runId: kotlin.String) : ApiResponse<RunObject?> {
        val localVariableConfig = getRunRequestConfig(threadId = threadId, runId = runId)

        return request<Unit, RunObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRun
     *
     * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run.
     * @param runId The ID of the run to retrieve.
     * @return RequestConfig
     */
    fun getRunRequestConfig(threadId: kotlin.String, runId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/threads/{thread_id}/runs/{run_id}".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())).replace("{"+"run_id"+"}", encodeURIComponent(runId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter include
     */
     enum class IncludeGetRunStep(val value: kotlin.String) {
         @Json(name = "step_details.tool_calls[*].file_search.results[*].content") step_detailsPeriodTool_callsLeft_Square_BracketStarRight_Square_BracketPeriodFile_searchPeriodResultsLeft_Square_BracketStarRight_Square_BracketPeriodContent("step_details.tool_calls[*].file_search.results[*].content");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /threads/{thread_id}/runs/{run_id}/steps/{step_id}
     * Retrieves a run step.
     * 
     * @param threadId The ID of the thread to which the run and run step belongs.
     * @param runId The ID of the run to which the run step belongs.
     * @param stepId The ID of the run step to retrieve.
     * @param include A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.  (optional)
     * @return RunStepObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRunStep(threadId: kotlin.String, runId: kotlin.String, stepId: kotlin.String, include: kotlin.collections.List<IncludeGetRunStep>? = null) : RunStepObject {
        val localVarResponse = getRunStepWithHttpInfo(threadId = threadId, runId = runId, stepId = stepId, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RunStepObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /threads/{thread_id}/runs/{run_id}/steps/{step_id}
     * Retrieves a run step.
     * 
     * @param threadId The ID of the thread to which the run and run step belongs.
     * @param runId The ID of the run to which the run step belongs.
     * @param stepId The ID of the run step to retrieve.
     * @param include A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.  (optional)
     * @return ApiResponse<RunStepObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRunStepWithHttpInfo(threadId: kotlin.String, runId: kotlin.String, stepId: kotlin.String, include: kotlin.collections.List<IncludeGetRunStep>?) : ApiResponse<RunStepObject?> {
        val localVariableConfig = getRunStepRequestConfig(threadId = threadId, runId = runId, stepId = stepId, include = include)

        return request<Unit, RunStepObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRunStep
     *
     * @param threadId The ID of the thread to which the run and run step belongs.
     * @param runId The ID of the run to which the run step belongs.
     * @param stepId The ID of the run step to retrieve.
     * @param include A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.  (optional)
     * @return RequestConfig
     */
    fun getRunStepRequestConfig(threadId: kotlin.String, runId: kotlin.String, stepId: kotlin.String, include: kotlin.collections.List<IncludeGetRunStep>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (include != null) {
                    put("include[]", toMultiValue(include.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/threads/{thread_id}/runs/{run_id}/steps/{step_id}".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())).replace("{"+"run_id"+"}", encodeURIComponent(runId.toString())).replace("{"+"step_id"+"}", encodeURIComponent(stepId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /threads/{thread_id}
     * Retrieves a thread.
     * 
     * @param threadId The ID of the thread to retrieve.
     * @return ThreadObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getThread(threadId: kotlin.String) : ThreadObject {
        val localVarResponse = getThreadWithHttpInfo(threadId = threadId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ThreadObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /threads/{thread_id}
     * Retrieves a thread.
     * 
     * @param threadId The ID of the thread to retrieve.
     * @return ApiResponse<ThreadObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getThreadWithHttpInfo(threadId: kotlin.String) : ApiResponse<ThreadObject?> {
        val localVariableConfig = getThreadRequestConfig(threadId = threadId)

        return request<Unit, ThreadObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getThread
     *
     * @param threadId The ID of the thread to retrieve.
     * @return RequestConfig
     */
    fun getThreadRequestConfig(threadId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/threads/{thread_id}".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderListAssistants(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /assistants
     * Returns a list of assistants.
     * 
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @return ListAssistantsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listAssistants(limit: kotlin.Int? = 20, order: OrderListAssistants? = OrderListAssistants.desc, after: kotlin.String? = null, before: kotlin.String? = null) : ListAssistantsResponse {
        val localVarResponse = listAssistantsWithHttpInfo(limit = limit, order = order, after = after, before = before)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListAssistantsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /assistants
     * Returns a list of assistants.
     * 
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @return ApiResponse<ListAssistantsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listAssistantsWithHttpInfo(limit: kotlin.Int?, order: OrderListAssistants?, after: kotlin.String?, before: kotlin.String?) : ApiResponse<ListAssistantsResponse?> {
        val localVariableConfig = listAssistantsRequestConfig(limit = limit, order = order, after = after, before = before)

        return request<Unit, ListAssistantsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listAssistants
     *
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @return RequestConfig
     */
    fun listAssistantsRequestConfig(limit: kotlin.Int?, order: OrderListAssistants?, after: kotlin.String?, before: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/assistants",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderListMessages(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /threads/{thread_id}/messages
     * Returns a list of messages for a given thread.
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) the messages belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @param runId Filter messages by the run ID that generated them.  (optional)
     * @return ListMessagesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listMessages(threadId: kotlin.String, limit: kotlin.Int? = 20, order: OrderListMessages? = OrderListMessages.desc, after: kotlin.String? = null, before: kotlin.String? = null, runId: kotlin.String? = null) : ListMessagesResponse {
        val localVarResponse = listMessagesWithHttpInfo(threadId = threadId, limit = limit, order = order, after = after, before = before, runId = runId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListMessagesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /threads/{thread_id}/messages
     * Returns a list of messages for a given thread.
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) the messages belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @param runId Filter messages by the run ID that generated them.  (optional)
     * @return ApiResponse<ListMessagesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listMessagesWithHttpInfo(threadId: kotlin.String, limit: kotlin.Int?, order: OrderListMessages?, after: kotlin.String?, before: kotlin.String?, runId: kotlin.String?) : ApiResponse<ListMessagesResponse?> {
        val localVariableConfig = listMessagesRequestConfig(threadId = threadId, limit = limit, order = order, after = after, before = before, runId = runId)

        return request<Unit, ListMessagesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listMessages
     *
     * @param threadId The ID of the [thread](/docs/api-reference/threads) the messages belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @param runId Filter messages by the run ID that generated them.  (optional)
     * @return RequestConfig
     */
    fun listMessagesRequestConfig(threadId: kotlin.String, limit: kotlin.Int?, order: OrderListMessages?, after: kotlin.String?, before: kotlin.String?, runId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
                if (runId != null) {
                    put("run_id", listOf(runId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/threads/{thread_id}/messages".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderListRunSteps(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter include
     */
     enum class IncludeListRunSteps(val value: kotlin.String) {
         @Json(name = "step_details.tool_calls[*].file_search.results[*].content") step_detailsPeriodTool_callsLeft_Square_BracketStarRight_Square_BracketPeriodFile_searchPeriodResultsLeft_Square_BracketStarRight_Square_BracketPeriodContent("step_details.tool_calls[*].file_search.results[*].content");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /threads/{thread_id}/runs/{run_id}/steps
     * Returns a list of run steps belonging to a run.
     * 
     * @param threadId The ID of the thread the run and run steps belong to.
     * @param runId The ID of the run the run steps belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @param include A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.  (optional)
     * @return ListRunStepsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listRunSteps(threadId: kotlin.String, runId: kotlin.String, limit: kotlin.Int? = 20, order: OrderListRunSteps? = OrderListRunSteps.desc, after: kotlin.String? = null, before: kotlin.String? = null, include: kotlin.collections.List<IncludeListRunSteps>? = null) : ListRunStepsResponse {
        val localVarResponse = listRunStepsWithHttpInfo(threadId = threadId, runId = runId, limit = limit, order = order, after = after, before = before, include = include)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListRunStepsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /threads/{thread_id}/runs/{run_id}/steps
     * Returns a list of run steps belonging to a run.
     * 
     * @param threadId The ID of the thread the run and run steps belong to.
     * @param runId The ID of the run the run steps belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @param include A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.  (optional)
     * @return ApiResponse<ListRunStepsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listRunStepsWithHttpInfo(threadId: kotlin.String, runId: kotlin.String, limit: kotlin.Int?, order: OrderListRunSteps?, after: kotlin.String?, before: kotlin.String?, include: kotlin.collections.List<IncludeListRunSteps>?) : ApiResponse<ListRunStepsResponse?> {
        val localVariableConfig = listRunStepsRequestConfig(threadId = threadId, runId = runId, limit = limit, order = order, after = after, before = before, include = include)

        return request<Unit, ListRunStepsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listRunSteps
     *
     * @param threadId The ID of the thread the run and run steps belong to.
     * @param runId The ID of the run the run steps belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @param include A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.  (optional)
     * @return RequestConfig
     */
    fun listRunStepsRequestConfig(threadId: kotlin.String, runId: kotlin.String, limit: kotlin.Int?, order: OrderListRunSteps?, after: kotlin.String?, before: kotlin.String?, include: kotlin.collections.List<IncludeListRunSteps>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
                if (include != null) {
                    put("include[]", toMultiValue(include.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/threads/{thread_id}/runs/{run_id}/steps".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())).replace("{"+"run_id"+"}", encodeURIComponent(runId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderListRuns(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /threads/{thread_id}/runs
     * Returns a list of runs belonging to a thread.
     * 
     * @param threadId The ID of the thread the run belongs to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @return ListRunsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listRuns(threadId: kotlin.String, limit: kotlin.Int? = 20, order: OrderListRuns? = OrderListRuns.desc, after: kotlin.String? = null, before: kotlin.String? = null) : ListRunsResponse {
        val localVarResponse = listRunsWithHttpInfo(threadId = threadId, limit = limit, order = order, after = after, before = before)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListRunsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /threads/{thread_id}/runs
     * Returns a list of runs belonging to a thread.
     * 
     * @param threadId The ID of the thread the run belongs to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @return ApiResponse<ListRunsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listRunsWithHttpInfo(threadId: kotlin.String, limit: kotlin.Int?, order: OrderListRuns?, after: kotlin.String?, before: kotlin.String?) : ApiResponse<ListRunsResponse?> {
        val localVariableConfig = listRunsRequestConfig(threadId = threadId, limit = limit, order = order, after = after, before = before)

        return request<Unit, ListRunsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listRuns
     *
     * @param threadId The ID of the thread the run belongs to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @return RequestConfig
     */
    fun listRunsRequestConfig(threadId: kotlin.String, limit: kotlin.Int?, order: OrderListRuns?, after: kotlin.String?, before: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/threads/{thread_id}/runs".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /assistants/{assistant_id}
     * Modifies an assistant.
     * 
     * @param assistantId The ID of the assistant to modify.
     * @param modifyAssistantRequest 
     * @return AssistantObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun modifyAssistant(assistantId: kotlin.String, modifyAssistantRequest: ModifyAssistantRequest) : AssistantObject {
        val localVarResponse = modifyAssistantWithHttpInfo(assistantId = assistantId, modifyAssistantRequest = modifyAssistantRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AssistantObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /assistants/{assistant_id}
     * Modifies an assistant.
     * 
     * @param assistantId The ID of the assistant to modify.
     * @param modifyAssistantRequest 
     * @return ApiResponse<AssistantObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun modifyAssistantWithHttpInfo(assistantId: kotlin.String, modifyAssistantRequest: ModifyAssistantRequest) : ApiResponse<AssistantObject?> {
        val localVariableConfig = modifyAssistantRequestConfig(assistantId = assistantId, modifyAssistantRequest = modifyAssistantRequest)

        return request<ModifyAssistantRequest, AssistantObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation modifyAssistant
     *
     * @param assistantId The ID of the assistant to modify.
     * @param modifyAssistantRequest 
     * @return RequestConfig
     */
    fun modifyAssistantRequestConfig(assistantId: kotlin.String, modifyAssistantRequest: ModifyAssistantRequest) : RequestConfig<ModifyAssistantRequest> {
        val localVariableBody = modifyAssistantRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/assistants/{assistant_id}".replace("{"+"assistant_id"+"}", encodeURIComponent(assistantId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /threads/{thread_id}/messages/{message_id}
     * Modifies a message.
     * 
     * @param threadId The ID of the thread to which this message belongs.
     * @param messageId The ID of the message to modify.
     * @param modifyMessageRequest 
     * @return MessageObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun modifyMessage(threadId: kotlin.String, messageId: kotlin.String, modifyMessageRequest: ModifyMessageRequest) : MessageObject {
        val localVarResponse = modifyMessageWithHttpInfo(threadId = threadId, messageId = messageId, modifyMessageRequest = modifyMessageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MessageObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /threads/{thread_id}/messages/{message_id}
     * Modifies a message.
     * 
     * @param threadId The ID of the thread to which this message belongs.
     * @param messageId The ID of the message to modify.
     * @param modifyMessageRequest 
     * @return ApiResponse<MessageObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun modifyMessageWithHttpInfo(threadId: kotlin.String, messageId: kotlin.String, modifyMessageRequest: ModifyMessageRequest) : ApiResponse<MessageObject?> {
        val localVariableConfig = modifyMessageRequestConfig(threadId = threadId, messageId = messageId, modifyMessageRequest = modifyMessageRequest)

        return request<ModifyMessageRequest, MessageObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation modifyMessage
     *
     * @param threadId The ID of the thread to which this message belongs.
     * @param messageId The ID of the message to modify.
     * @param modifyMessageRequest 
     * @return RequestConfig
     */
    fun modifyMessageRequestConfig(threadId: kotlin.String, messageId: kotlin.String, modifyMessageRequest: ModifyMessageRequest) : RequestConfig<ModifyMessageRequest> {
        val localVariableBody = modifyMessageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/threads/{thread_id}/messages/{message_id}".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())).replace("{"+"message_id"+"}", encodeURIComponent(messageId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /threads/{thread_id}/runs/{run_id}
     * Modifies a run.
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run.
     * @param runId The ID of the run to modify.
     * @param modifyRunRequest 
     * @return RunObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun modifyRun(threadId: kotlin.String, runId: kotlin.String, modifyRunRequest: ModifyRunRequest) : RunObject {
        val localVarResponse = modifyRunWithHttpInfo(threadId = threadId, runId = runId, modifyRunRequest = modifyRunRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RunObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /threads/{thread_id}/runs/{run_id}
     * Modifies a run.
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run.
     * @param runId The ID of the run to modify.
     * @param modifyRunRequest 
     * @return ApiResponse<RunObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun modifyRunWithHttpInfo(threadId: kotlin.String, runId: kotlin.String, modifyRunRequest: ModifyRunRequest) : ApiResponse<RunObject?> {
        val localVariableConfig = modifyRunRequestConfig(threadId = threadId, runId = runId, modifyRunRequest = modifyRunRequest)

        return request<ModifyRunRequest, RunObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation modifyRun
     *
     * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run.
     * @param runId The ID of the run to modify.
     * @param modifyRunRequest 
     * @return RequestConfig
     */
    fun modifyRunRequestConfig(threadId: kotlin.String, runId: kotlin.String, modifyRunRequest: ModifyRunRequest) : RequestConfig<ModifyRunRequest> {
        val localVariableBody = modifyRunRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/threads/{thread_id}/runs/{run_id}".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())).replace("{"+"run_id"+"}", encodeURIComponent(runId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /threads/{thread_id}
     * Modifies a thread.
     * 
     * @param threadId The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified.
     * @param modifyThreadRequest 
     * @return ThreadObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun modifyThread(threadId: kotlin.String, modifyThreadRequest: ModifyThreadRequest) : ThreadObject {
        val localVarResponse = modifyThreadWithHttpInfo(threadId = threadId, modifyThreadRequest = modifyThreadRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ThreadObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /threads/{thread_id}
     * Modifies a thread.
     * 
     * @param threadId The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified.
     * @param modifyThreadRequest 
     * @return ApiResponse<ThreadObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun modifyThreadWithHttpInfo(threadId: kotlin.String, modifyThreadRequest: ModifyThreadRequest) : ApiResponse<ThreadObject?> {
        val localVariableConfig = modifyThreadRequestConfig(threadId = threadId, modifyThreadRequest = modifyThreadRequest)

        return request<ModifyThreadRequest, ThreadObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation modifyThread
     *
     * @param threadId The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified.
     * @param modifyThreadRequest 
     * @return RequestConfig
     */
    fun modifyThreadRequestConfig(threadId: kotlin.String, modifyThreadRequest: ModifyThreadRequest) : RequestConfig<ModifyThreadRequest> {
        val localVariableBody = modifyThreadRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/threads/{thread_id}".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /threads/{thread_id}/runs/{run_id}/submit_tool_outputs
     * When a run has the &#x60;status: \&quot;requires_action\&quot;&#x60; and &#x60;required_action.type&#x60; is &#x60;submit_tool_outputs&#x60;, this endpoint can be used to submit the outputs from the tool calls once they&#39;re all completed. All outputs must be submitted in a single request. 
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this run belongs.
     * @param runId The ID of the run that requires the tool output submission.
     * @param submitToolOutputsRunRequest 
     * @return RunObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun submitToolOuputsToRun(threadId: kotlin.String, runId: kotlin.String, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest) : RunObject {
        val localVarResponse = submitToolOuputsToRunWithHttpInfo(threadId = threadId, runId = runId, submitToolOutputsRunRequest = submitToolOutputsRunRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RunObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /threads/{thread_id}/runs/{run_id}/submit_tool_outputs
     * When a run has the &#x60;status: \&quot;requires_action\&quot;&#x60; and &#x60;required_action.type&#x60; is &#x60;submit_tool_outputs&#x60;, this endpoint can be used to submit the outputs from the tool calls once they&#39;re all completed. All outputs must be submitted in a single request. 
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this run belongs.
     * @param runId The ID of the run that requires the tool output submission.
     * @param submitToolOutputsRunRequest 
     * @return ApiResponse<RunObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun submitToolOuputsToRunWithHttpInfo(threadId: kotlin.String, runId: kotlin.String, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest) : ApiResponse<RunObject?> {
        val localVariableConfig = submitToolOuputsToRunRequestConfig(threadId = threadId, runId = runId, submitToolOutputsRunRequest = submitToolOutputsRunRequest)

        return request<SubmitToolOutputsRunRequest, RunObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation submitToolOuputsToRun
     *
     * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this run belongs.
     * @param runId The ID of the run that requires the tool output submission.
     * @param submitToolOutputsRunRequest 
     * @return RequestConfig
     */
    fun submitToolOuputsToRunRequestConfig(threadId: kotlin.String, runId: kotlin.String, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest) : RequestConfig<SubmitToolOutputsRunRequest> {
        val localVariableBody = submitToolOutputsRunRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/threads/{thread_id}/runs/{run_id}/submit_tool_outputs".replace("{"+"thread_id"+"}", encodeURIComponent(threadId.toString())).replace("{"+"run_id"+"}", encodeURIComponent(runId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
