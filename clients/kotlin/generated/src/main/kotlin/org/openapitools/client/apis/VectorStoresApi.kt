/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.CreateVectorStoreFileBatchRequest
import org.openapitools.client.models.CreateVectorStoreFileRequest
import org.openapitools.client.models.CreateVectorStoreRequest
import org.openapitools.client.models.DeleteVectorStoreFileResponse
import org.openapitools.client.models.DeleteVectorStoreResponse
import org.openapitools.client.models.ListVectorStoreFilesResponse
import org.openapitools.client.models.ListVectorStoresResponse
import org.openapitools.client.models.UpdateVectorStoreRequest
import org.openapitools.client.models.VectorStoreFileBatchObject
import org.openapitools.client.models.VectorStoreFileObject
import org.openapitools.client.models.VectorStoreObject

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

open class VectorStoresApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.openai.com/v1")
        }
    }

    /**
     * POST /vector_stores/{vector_store_id}/file_batches/{batch_id}/cancel
     * Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
     * 
     * @param vectorStoreId The ID of the vector store that the file batch belongs to.
     * @param batchId The ID of the file batch to cancel.
     * @return VectorStoreFileBatchObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun cancelVectorStoreFileBatch(vectorStoreId: kotlin.String, batchId: kotlin.String) : VectorStoreFileBatchObject {
        val localVarResponse = cancelVectorStoreFileBatchWithHttpInfo(vectorStoreId = vectorStoreId, batchId = batchId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VectorStoreFileBatchObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /vector_stores/{vector_store_id}/file_batches/{batch_id}/cancel
     * Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
     * 
     * @param vectorStoreId The ID of the vector store that the file batch belongs to.
     * @param batchId The ID of the file batch to cancel.
     * @return ApiResponse<VectorStoreFileBatchObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun cancelVectorStoreFileBatchWithHttpInfo(vectorStoreId: kotlin.String, batchId: kotlin.String) : ApiResponse<VectorStoreFileBatchObject?> {
        val localVariableConfig = cancelVectorStoreFileBatchRequestConfig(vectorStoreId = vectorStoreId, batchId = batchId)

        return request<Unit, VectorStoreFileBatchObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cancelVectorStoreFileBatch
     *
     * @param vectorStoreId The ID of the vector store that the file batch belongs to.
     * @param batchId The ID of the file batch to cancel.
     * @return RequestConfig
     */
    fun cancelVectorStoreFileBatchRequestConfig(vectorStoreId: kotlin.String, batchId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/vector_stores/{vector_store_id}/file_batches/{batch_id}/cancel".replace("{"+"vector_store_id"+"}", encodeURIComponent(vectorStoreId.toString())).replace("{"+"batch_id"+"}", encodeURIComponent(batchId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /vector_stores
     * Create a vector store.
     * 
     * @param createVectorStoreRequest 
     * @return VectorStoreObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createVectorStore(createVectorStoreRequest: CreateVectorStoreRequest) : VectorStoreObject {
        val localVarResponse = createVectorStoreWithHttpInfo(createVectorStoreRequest = createVectorStoreRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VectorStoreObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /vector_stores
     * Create a vector store.
     * 
     * @param createVectorStoreRequest 
     * @return ApiResponse<VectorStoreObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createVectorStoreWithHttpInfo(createVectorStoreRequest: CreateVectorStoreRequest) : ApiResponse<VectorStoreObject?> {
        val localVariableConfig = createVectorStoreRequestConfig(createVectorStoreRequest = createVectorStoreRequest)

        return request<CreateVectorStoreRequest, VectorStoreObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createVectorStore
     *
     * @param createVectorStoreRequest 
     * @return RequestConfig
     */
    fun createVectorStoreRequestConfig(createVectorStoreRequest: CreateVectorStoreRequest) : RequestConfig<CreateVectorStoreRequest> {
        val localVariableBody = createVectorStoreRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/vector_stores",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /vector_stores/{vector_store_id}/files
     * Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
     * 
     * @param vectorStoreId The ID of the vector store for which to create a File. 
     * @param createVectorStoreFileRequest 
     * @return VectorStoreFileObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createVectorStoreFile(vectorStoreId: kotlin.String, createVectorStoreFileRequest: CreateVectorStoreFileRequest) : VectorStoreFileObject {
        val localVarResponse = createVectorStoreFileWithHttpInfo(vectorStoreId = vectorStoreId, createVectorStoreFileRequest = createVectorStoreFileRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VectorStoreFileObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /vector_stores/{vector_store_id}/files
     * Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
     * 
     * @param vectorStoreId The ID of the vector store for which to create a File. 
     * @param createVectorStoreFileRequest 
     * @return ApiResponse<VectorStoreFileObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createVectorStoreFileWithHttpInfo(vectorStoreId: kotlin.String, createVectorStoreFileRequest: CreateVectorStoreFileRequest) : ApiResponse<VectorStoreFileObject?> {
        val localVariableConfig = createVectorStoreFileRequestConfig(vectorStoreId = vectorStoreId, createVectorStoreFileRequest = createVectorStoreFileRequest)

        return request<CreateVectorStoreFileRequest, VectorStoreFileObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createVectorStoreFile
     *
     * @param vectorStoreId The ID of the vector store for which to create a File. 
     * @param createVectorStoreFileRequest 
     * @return RequestConfig
     */
    fun createVectorStoreFileRequestConfig(vectorStoreId: kotlin.String, createVectorStoreFileRequest: CreateVectorStoreFileRequest) : RequestConfig<CreateVectorStoreFileRequest> {
        val localVariableBody = createVectorStoreFileRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/vector_stores/{vector_store_id}/files".replace("{"+"vector_store_id"+"}", encodeURIComponent(vectorStoreId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /vector_stores/{vector_store_id}/file_batches
     * Create a vector store file batch.
     * 
     * @param vectorStoreId The ID of the vector store for which to create a File Batch. 
     * @param createVectorStoreFileBatchRequest 
     * @return VectorStoreFileBatchObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createVectorStoreFileBatch(vectorStoreId: kotlin.String, createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest) : VectorStoreFileBatchObject {
        val localVarResponse = createVectorStoreFileBatchWithHttpInfo(vectorStoreId = vectorStoreId, createVectorStoreFileBatchRequest = createVectorStoreFileBatchRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VectorStoreFileBatchObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /vector_stores/{vector_store_id}/file_batches
     * Create a vector store file batch.
     * 
     * @param vectorStoreId The ID of the vector store for which to create a File Batch. 
     * @param createVectorStoreFileBatchRequest 
     * @return ApiResponse<VectorStoreFileBatchObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createVectorStoreFileBatchWithHttpInfo(vectorStoreId: kotlin.String, createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest) : ApiResponse<VectorStoreFileBatchObject?> {
        val localVariableConfig = createVectorStoreFileBatchRequestConfig(vectorStoreId = vectorStoreId, createVectorStoreFileBatchRequest = createVectorStoreFileBatchRequest)

        return request<CreateVectorStoreFileBatchRequest, VectorStoreFileBatchObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createVectorStoreFileBatch
     *
     * @param vectorStoreId The ID of the vector store for which to create a File Batch. 
     * @param createVectorStoreFileBatchRequest 
     * @return RequestConfig
     */
    fun createVectorStoreFileBatchRequestConfig(vectorStoreId: kotlin.String, createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest) : RequestConfig<CreateVectorStoreFileBatchRequest> {
        val localVariableBody = createVectorStoreFileBatchRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/vector_stores/{vector_store_id}/file_batches".replace("{"+"vector_store_id"+"}", encodeURIComponent(vectorStoreId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * DELETE /vector_stores/{vector_store_id}
     * Delete a vector store.
     * 
     * @param vectorStoreId The ID of the vector store to delete.
     * @return DeleteVectorStoreResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteVectorStore(vectorStoreId: kotlin.String) : DeleteVectorStoreResponse {
        val localVarResponse = deleteVectorStoreWithHttpInfo(vectorStoreId = vectorStoreId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteVectorStoreResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /vector_stores/{vector_store_id}
     * Delete a vector store.
     * 
     * @param vectorStoreId The ID of the vector store to delete.
     * @return ApiResponse<DeleteVectorStoreResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteVectorStoreWithHttpInfo(vectorStoreId: kotlin.String) : ApiResponse<DeleteVectorStoreResponse?> {
        val localVariableConfig = deleteVectorStoreRequestConfig(vectorStoreId = vectorStoreId)

        return request<Unit, DeleteVectorStoreResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteVectorStore
     *
     * @param vectorStoreId The ID of the vector store to delete.
     * @return RequestConfig
     */
    fun deleteVectorStoreRequestConfig(vectorStoreId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/vector_stores/{vector_store_id}".replace("{"+"vector_store_id"+"}", encodeURIComponent(vectorStoreId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * DELETE /vector_stores/{vector_store_id}/files/{file_id}
     * Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
     * 
     * @param vectorStoreId The ID of the vector store that the file belongs to.
     * @param fileId The ID of the file to delete.
     * @return DeleteVectorStoreFileResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteVectorStoreFile(vectorStoreId: kotlin.String, fileId: kotlin.String) : DeleteVectorStoreFileResponse {
        val localVarResponse = deleteVectorStoreFileWithHttpInfo(vectorStoreId = vectorStoreId, fileId = fileId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteVectorStoreFileResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /vector_stores/{vector_store_id}/files/{file_id}
     * Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
     * 
     * @param vectorStoreId The ID of the vector store that the file belongs to.
     * @param fileId The ID of the file to delete.
     * @return ApiResponse<DeleteVectorStoreFileResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteVectorStoreFileWithHttpInfo(vectorStoreId: kotlin.String, fileId: kotlin.String) : ApiResponse<DeleteVectorStoreFileResponse?> {
        val localVariableConfig = deleteVectorStoreFileRequestConfig(vectorStoreId = vectorStoreId, fileId = fileId)

        return request<Unit, DeleteVectorStoreFileResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteVectorStoreFile
     *
     * @param vectorStoreId The ID of the vector store that the file belongs to.
     * @param fileId The ID of the file to delete.
     * @return RequestConfig
     */
    fun deleteVectorStoreFileRequestConfig(vectorStoreId: kotlin.String, fileId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/vector_stores/{vector_store_id}/files/{file_id}".replace("{"+"vector_store_id"+"}", encodeURIComponent(vectorStoreId.toString())).replace("{"+"file_id"+"}", encodeURIComponent(fileId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /vector_stores/{vector_store_id}
     * Retrieves a vector store.
     * 
     * @param vectorStoreId The ID of the vector store to retrieve.
     * @return VectorStoreObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getVectorStore(vectorStoreId: kotlin.String) : VectorStoreObject {
        val localVarResponse = getVectorStoreWithHttpInfo(vectorStoreId = vectorStoreId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VectorStoreObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /vector_stores/{vector_store_id}
     * Retrieves a vector store.
     * 
     * @param vectorStoreId The ID of the vector store to retrieve.
     * @return ApiResponse<VectorStoreObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getVectorStoreWithHttpInfo(vectorStoreId: kotlin.String) : ApiResponse<VectorStoreObject?> {
        val localVariableConfig = getVectorStoreRequestConfig(vectorStoreId = vectorStoreId)

        return request<Unit, VectorStoreObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getVectorStore
     *
     * @param vectorStoreId The ID of the vector store to retrieve.
     * @return RequestConfig
     */
    fun getVectorStoreRequestConfig(vectorStoreId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/vector_stores/{vector_store_id}".replace("{"+"vector_store_id"+"}", encodeURIComponent(vectorStoreId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /vector_stores/{vector_store_id}/files/{file_id}
     * Retrieves a vector store file.
     * 
     * @param vectorStoreId The ID of the vector store that the file belongs to.
     * @param fileId The ID of the file being retrieved.
     * @return VectorStoreFileObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getVectorStoreFile(vectorStoreId: kotlin.String, fileId: kotlin.String) : VectorStoreFileObject {
        val localVarResponse = getVectorStoreFileWithHttpInfo(vectorStoreId = vectorStoreId, fileId = fileId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VectorStoreFileObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /vector_stores/{vector_store_id}/files/{file_id}
     * Retrieves a vector store file.
     * 
     * @param vectorStoreId The ID of the vector store that the file belongs to.
     * @param fileId The ID of the file being retrieved.
     * @return ApiResponse<VectorStoreFileObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getVectorStoreFileWithHttpInfo(vectorStoreId: kotlin.String, fileId: kotlin.String) : ApiResponse<VectorStoreFileObject?> {
        val localVariableConfig = getVectorStoreFileRequestConfig(vectorStoreId = vectorStoreId, fileId = fileId)

        return request<Unit, VectorStoreFileObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getVectorStoreFile
     *
     * @param vectorStoreId The ID of the vector store that the file belongs to.
     * @param fileId The ID of the file being retrieved.
     * @return RequestConfig
     */
    fun getVectorStoreFileRequestConfig(vectorStoreId: kotlin.String, fileId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/vector_stores/{vector_store_id}/files/{file_id}".replace("{"+"vector_store_id"+"}", encodeURIComponent(vectorStoreId.toString())).replace("{"+"file_id"+"}", encodeURIComponent(fileId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /vector_stores/{vector_store_id}/file_batches/{batch_id}
     * Retrieves a vector store file batch.
     * 
     * @param vectorStoreId The ID of the vector store that the file batch belongs to.
     * @param batchId The ID of the file batch being retrieved.
     * @return VectorStoreFileBatchObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getVectorStoreFileBatch(vectorStoreId: kotlin.String, batchId: kotlin.String) : VectorStoreFileBatchObject {
        val localVarResponse = getVectorStoreFileBatchWithHttpInfo(vectorStoreId = vectorStoreId, batchId = batchId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VectorStoreFileBatchObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /vector_stores/{vector_store_id}/file_batches/{batch_id}
     * Retrieves a vector store file batch.
     * 
     * @param vectorStoreId The ID of the vector store that the file batch belongs to.
     * @param batchId The ID of the file batch being retrieved.
     * @return ApiResponse<VectorStoreFileBatchObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getVectorStoreFileBatchWithHttpInfo(vectorStoreId: kotlin.String, batchId: kotlin.String) : ApiResponse<VectorStoreFileBatchObject?> {
        val localVariableConfig = getVectorStoreFileBatchRequestConfig(vectorStoreId = vectorStoreId, batchId = batchId)

        return request<Unit, VectorStoreFileBatchObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getVectorStoreFileBatch
     *
     * @param vectorStoreId The ID of the vector store that the file batch belongs to.
     * @param batchId The ID of the file batch being retrieved.
     * @return RequestConfig
     */
    fun getVectorStoreFileBatchRequestConfig(vectorStoreId: kotlin.String, batchId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/vector_stores/{vector_store_id}/file_batches/{batch_id}".replace("{"+"vector_store_id"+"}", encodeURIComponent(vectorStoreId.toString())).replace("{"+"batch_id"+"}", encodeURIComponent(batchId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderListFilesInVectorStoreBatch(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter filter
     */
     enum class FilterListFilesInVectorStoreBatch(val value: kotlin.String) {
         @Json(name = "in_progress") in_progress("in_progress"),
         @Json(name = "completed") completed("completed"),
         @Json(name = "failed") failed("failed"),
         @Json(name = "cancelled") cancelled("cancelled");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /vector_stores/{vector_store_id}/file_batches/{batch_id}/files
     * Returns a list of vector store files in a batch.
     * 
     * @param vectorStoreId The ID of the vector store that the files belong to.
     * @param batchId The ID of the file batch that the files belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @param filter Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;. (optional)
     * @return ListVectorStoreFilesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listFilesInVectorStoreBatch(vectorStoreId: kotlin.String, batchId: kotlin.String, limit: kotlin.Int? = 20, order: OrderListFilesInVectorStoreBatch? = OrderListFilesInVectorStoreBatch.desc, after: kotlin.String? = null, before: kotlin.String? = null, filter: FilterListFilesInVectorStoreBatch? = null) : ListVectorStoreFilesResponse {
        val localVarResponse = listFilesInVectorStoreBatchWithHttpInfo(vectorStoreId = vectorStoreId, batchId = batchId, limit = limit, order = order, after = after, before = before, filter = filter)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListVectorStoreFilesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /vector_stores/{vector_store_id}/file_batches/{batch_id}/files
     * Returns a list of vector store files in a batch.
     * 
     * @param vectorStoreId The ID of the vector store that the files belong to.
     * @param batchId The ID of the file batch that the files belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @param filter Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;. (optional)
     * @return ApiResponse<ListVectorStoreFilesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listFilesInVectorStoreBatchWithHttpInfo(vectorStoreId: kotlin.String, batchId: kotlin.String, limit: kotlin.Int?, order: OrderListFilesInVectorStoreBatch?, after: kotlin.String?, before: kotlin.String?, filter: FilterListFilesInVectorStoreBatch?) : ApiResponse<ListVectorStoreFilesResponse?> {
        val localVariableConfig = listFilesInVectorStoreBatchRequestConfig(vectorStoreId = vectorStoreId, batchId = batchId, limit = limit, order = order, after = after, before = before, filter = filter)

        return request<Unit, ListVectorStoreFilesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listFilesInVectorStoreBatch
     *
     * @param vectorStoreId The ID of the vector store that the files belong to.
     * @param batchId The ID of the file batch that the files belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @param filter Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;. (optional)
     * @return RequestConfig
     */
    fun listFilesInVectorStoreBatchRequestConfig(vectorStoreId: kotlin.String, batchId: kotlin.String, limit: kotlin.Int?, order: OrderListFilesInVectorStoreBatch?, after: kotlin.String?, before: kotlin.String?, filter: FilterListFilesInVectorStoreBatch?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
                if (filter != null) {
                    put("filter", listOf(filter.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/vector_stores/{vector_store_id}/file_batches/{batch_id}/files".replace("{"+"vector_store_id"+"}", encodeURIComponent(vectorStoreId.toString())).replace("{"+"batch_id"+"}", encodeURIComponent(batchId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderListVectorStoreFiles(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter filter
     */
     enum class FilterListVectorStoreFiles(val value: kotlin.String) {
         @Json(name = "in_progress") in_progress("in_progress"),
         @Json(name = "completed") completed("completed"),
         @Json(name = "failed") failed("failed"),
         @Json(name = "cancelled") cancelled("cancelled");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /vector_stores/{vector_store_id}/files
     * Returns a list of vector store files.
     * 
     * @param vectorStoreId The ID of the vector store that the files belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @param filter Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;. (optional)
     * @return ListVectorStoreFilesResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listVectorStoreFiles(vectorStoreId: kotlin.String, limit: kotlin.Int? = 20, order: OrderListVectorStoreFiles? = OrderListVectorStoreFiles.desc, after: kotlin.String? = null, before: kotlin.String? = null, filter: FilterListVectorStoreFiles? = null) : ListVectorStoreFilesResponse {
        val localVarResponse = listVectorStoreFilesWithHttpInfo(vectorStoreId = vectorStoreId, limit = limit, order = order, after = after, before = before, filter = filter)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListVectorStoreFilesResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /vector_stores/{vector_store_id}/files
     * Returns a list of vector store files.
     * 
     * @param vectorStoreId The ID of the vector store that the files belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @param filter Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;. (optional)
     * @return ApiResponse<ListVectorStoreFilesResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listVectorStoreFilesWithHttpInfo(vectorStoreId: kotlin.String, limit: kotlin.Int?, order: OrderListVectorStoreFiles?, after: kotlin.String?, before: kotlin.String?, filter: FilterListVectorStoreFiles?) : ApiResponse<ListVectorStoreFilesResponse?> {
        val localVariableConfig = listVectorStoreFilesRequestConfig(vectorStoreId = vectorStoreId, limit = limit, order = order, after = after, before = before, filter = filter)

        return request<Unit, ListVectorStoreFilesResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listVectorStoreFiles
     *
     * @param vectorStoreId The ID of the vector store that the files belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @param filter Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;. (optional)
     * @return RequestConfig
     */
    fun listVectorStoreFilesRequestConfig(vectorStoreId: kotlin.String, limit: kotlin.Int?, order: OrderListVectorStoreFiles?, after: kotlin.String?, before: kotlin.String?, filter: FilterListVectorStoreFiles?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
                if (filter != null) {
                    put("filter", listOf(filter.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/vector_stores/{vector_store_id}/files".replace("{"+"vector_store_id"+"}", encodeURIComponent(vectorStoreId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderListVectorStores(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /vector_stores
     * Returns a list of vector stores.
     * 
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @return ListVectorStoresResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listVectorStores(limit: kotlin.Int? = 20, order: OrderListVectorStores? = OrderListVectorStores.desc, after: kotlin.String? = null, before: kotlin.String? = null) : ListVectorStoresResponse {
        val localVarResponse = listVectorStoresWithHttpInfo(limit = limit, order = order, after = after, before = before)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListVectorStoresResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /vector_stores
     * Returns a list of vector stores.
     * 
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @return ApiResponse<ListVectorStoresResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listVectorStoresWithHttpInfo(limit: kotlin.Int?, order: OrderListVectorStores?, after: kotlin.String?, before: kotlin.String?) : ApiResponse<ListVectorStoresResponse?> {
        val localVariableConfig = listVectorStoresRequestConfig(limit = limit, order = order, after = after, before = before)

        return request<Unit, ListVectorStoresResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listVectorStores
     *
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to Order.desc)
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
     * @return RequestConfig
     */
    fun listVectorStoresRequestConfig(limit: kotlin.Int?, order: OrderListVectorStores?, after: kotlin.String?, before: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (after != null) {
                    put("after", listOf(after.toString()))
                }
                if (before != null) {
                    put("before", listOf(before.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/vector_stores",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /vector_stores/{vector_store_id}
     * Modifies a vector store.
     * 
     * @param vectorStoreId The ID of the vector store to modify.
     * @param updateVectorStoreRequest 
     * @return VectorStoreObject
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun modifyVectorStore(vectorStoreId: kotlin.String, updateVectorStoreRequest: UpdateVectorStoreRequest) : VectorStoreObject {
        val localVarResponse = modifyVectorStoreWithHttpInfo(vectorStoreId = vectorStoreId, updateVectorStoreRequest = updateVectorStoreRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VectorStoreObject
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /vector_stores/{vector_store_id}
     * Modifies a vector store.
     * 
     * @param vectorStoreId The ID of the vector store to modify.
     * @param updateVectorStoreRequest 
     * @return ApiResponse<VectorStoreObject?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun modifyVectorStoreWithHttpInfo(vectorStoreId: kotlin.String, updateVectorStoreRequest: UpdateVectorStoreRequest) : ApiResponse<VectorStoreObject?> {
        val localVariableConfig = modifyVectorStoreRequestConfig(vectorStoreId = vectorStoreId, updateVectorStoreRequest = updateVectorStoreRequest)

        return request<UpdateVectorStoreRequest, VectorStoreObject>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation modifyVectorStore
     *
     * @param vectorStoreId The ID of the vector store to modify.
     * @param updateVectorStoreRequest 
     * @return RequestConfig
     */
    fun modifyVectorStoreRequestConfig(vectorStoreId: kotlin.String, updateVectorStoreRequest: UpdateVectorStoreRequest) : RequestConfig<UpdateVectorStoreRequest> {
        val localVariableBody = updateVectorStoreRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/vector_stores/{vector_store_id}".replace("{"+"vector_store_id"+"}", encodeURIComponent(vectorStoreId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
