/**
* OpenAI API
* APIs for sampling from and fine-tuning language models
*
* The version of the OpenAPI document: 2.0.0
* Contact: blah+oapicf@cliffano.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package org.openapitools.database.models

import org.ktorm.dsl.*
import org.ktorm.schema.*
import org.ktorm.database.Database
import .*


/**
 * 
 * @param model 
 * @param instruction The instruction that tells the model how to edit the prompt.
 * @param input The input text to use as a starting point for the edit.
 * @param n How many edits to generate for the input and instruction.
 * @param temperature What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or `top_p` but not both. 
 * @param topP An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or `temperature` but not both. 
 */
object CreateEditRequests : BaseTable<CreateEditRequest>("CreateEditRequest") {
    val model = long("model")
    val instruction = text("instruction") /* The instruction that tells the model how to edit the prompt. */
    val input = text("input") /* null */ /* The input text to use as a starting point for the edit. */
    val n = int("n") /* null */ /* How many edits to generate for the input and instruction. */
    val temperature = decimal("temperature") /* null */ /* What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or `top_p` but not both.  */
    val topP = decimal("top_p") /* null */ /* An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or `temperature` but not both.  */

    /**
     * Create an entity of type CreateEditRequest from the model
     */
    override fun doCreateEntity(row: QueryRowSet, withReferences: Boolean) = CreateEditRequest(
        model = CreateEditRequestModels.createEntity(row, withReferences) /* CreateEditRequestModel */,
        instruction = row[instruction] ?: "" /* kotlin.String */ /* The instruction that tells the model how to edit the prompt. */,
        input = row[input] ?: "" /* kotlin.String? */ /* The input text to use as a starting point for the edit. */,
        n = row[n] ?: 1 /* kotlin.Int? */ /* How many edits to generate for the input and instruction. */,
        temperature = row[temperature] ?: 1 /* java.math.BigDecimal? */ /* What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or `top_p` but not both.  */,
        topP = row[topP] ?: 1 /* java.math.BigDecimal? */ /* An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or `temperature` but not both.  */
    )

    /**
    * Assign all the columns from the entity of type CreateEditRequest to the DML expression.
    *
    * Usage:
    *
    * ```kotlin
    * let entity = CreateEditRequest()
    * database.update(CreateEditRequests, {
    *     assignFrom(entity)
    * })
    * ```
    * @return the builder with the columns for the update or insert.
    */
    fun AssignmentsBuilder.assignFrom(entity: CreateEditRequest) {
        this.apply {
            set(CreateEditRequests.model, entity.model)
            set(CreateEditRequests.instruction, entity.instruction)
            set(CreateEditRequests.input, entity.input)
            set(CreateEditRequests.n, entity.n)
            set(CreateEditRequests.temperature, entity.temperature)
            set(CreateEditRequests.topP, entity.topP)
        }
    }

}


