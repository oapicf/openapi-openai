#
# OpenAI API
# 
# The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
# The version of the OpenAPI document: 2.0.0
# Contact: blah+oapicf@cliffano.com
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_assistant_file_object
import ../models/model_assistant_object
import ../models/model_create_assistant_file_request
import ../models/model_create_assistant_request
import ../models/model_create_message_request
import ../models/model_create_run_request
import ../models/model_create_thread_and_run_request
import ../models/model_create_thread_request
import ../models/model_delete_assistant_file_response
import ../models/model_delete_assistant_response
import ../models/model_delete_thread_response
import ../models/model_list_assistant_files_response
import ../models/model_list_assistants_response
import ../models/model_list_message_files_response
import ../models/model_list_messages_response
import ../models/model_list_run_steps_response
import ../models/model_list_runs_response
import ../models/model_message_file_object
import ../models/model_message_object
import ../models/model_modify_assistant_request
import ../models/model_modify_message_request
import ../models/model_modify_run_request
import ../models/model_modify_thread_request
import ../models/model_run_object
import ../models/model_run_step_object
import ../models/model_submit_tool_outputs_run_request
import ../models/model_thread_object

const basepath = "https://api.openai.com/v1"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      when name(stripGenericParams(T.typedesc).typedesc) == name(Table):
        (some(json.to(parseJson(response.body), T.typedesc)), response)
      else:
        (some(marshal.to[T](response.body)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc cancelRun*(httpClient: HttpClient, threadId: string, runId: string): (Option[RunObject], Response) =
  ## Cancels a run that is `in_progress`.

  let response = httpClient.post(basepath & fmt"/threads/{thread_id}/runs/{run_id}/cancel")
  constructResult[RunObject](response)


proc createAssistant*(httpClient: HttpClient, createAssistantRequest: CreateAssistantRequest): (Option[AssistantObject], Response) =
  ## Create an assistant with a model and instructions.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & "/assistants", $(%createAssistantRequest))
  constructResult[AssistantObject](response)


proc createAssistantFile*(httpClient: HttpClient, assistantId: string, createAssistantFileRequest: CreateAssistantFileRequest): (Option[AssistantFileObject], Response) =
  ## Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants).
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/assistants/{assistant_id}/files", $(%createAssistantFileRequest))
  constructResult[AssistantFileObject](response)


proc createMessage*(httpClient: HttpClient, threadId: string, createMessageRequest: CreateMessageRequest): (Option[MessageObject], Response) =
  ## Create a message.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/threads/{thread_id}/messages", $(%createMessageRequest))
  constructResult[MessageObject](response)


proc createRun*(httpClient: HttpClient, threadId: string, createRunRequest: CreateRunRequest): (Option[RunObject], Response) =
  ## Create a run.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/threads/{thread_id}/runs", $(%createRunRequest))
  constructResult[RunObject](response)


proc createThread*(httpClient: HttpClient, createThreadRequest: CreateThreadRequest): (Option[ThreadObject], Response) =
  ## Create a thread.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & "/threads", $(%createThreadRequest))
  constructResult[ThreadObject](response)


proc createThreadAndRun*(httpClient: HttpClient, createThreadAndRunRequest: CreateThreadAndRunRequest): (Option[RunObject], Response) =
  ## Create a thread and run it in one request.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & "/threads/runs", $(%createThreadAndRunRequest))
  constructResult[RunObject](response)


proc deleteAssistant*(httpClient: HttpClient, assistantId: string): (Option[DeleteAssistantResponse], Response) =
  ## Delete an assistant.

  let response = httpClient.delete(basepath & fmt"/assistants/{assistant_id}")
  constructResult[DeleteAssistantResponse](response)


proc deleteAssistantFile*(httpClient: HttpClient, assistantId: string, fileId: string): (Option[DeleteAssistantFileResponse], Response) =
  ## Delete an assistant file.

  let response = httpClient.delete(basepath & fmt"/assistants/{assistant_id}/files/{file_id}")
  constructResult[DeleteAssistantFileResponse](response)


proc deleteThread*(httpClient: HttpClient, threadId: string): (Option[DeleteThreadResponse], Response) =
  ## Delete a thread.

  let response = httpClient.delete(basepath & fmt"/threads/{thread_id}")
  constructResult[DeleteThreadResponse](response)


proc getAssistant*(httpClient: HttpClient, assistantId: string): (Option[AssistantObject], Response) =
  ## Retrieves an assistant.

  let response = httpClient.get(basepath & fmt"/assistants/{assistant_id}")
  constructResult[AssistantObject](response)


proc getAssistantFile*(httpClient: HttpClient, assistantId: string, fileId: string): (Option[AssistantFileObject], Response) =
  ## Retrieves an AssistantFile.

  let response = httpClient.get(basepath & fmt"/assistants/{assistant_id}/files/{file_id}")
  constructResult[AssistantFileObject](response)


proc getMessage*(httpClient: HttpClient, threadId: string, messageId: string): (Option[MessageObject], Response) =
  ## Retrieve a message.

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}/messages/{message_id}")
  constructResult[MessageObject](response)


proc getMessageFile*(httpClient: HttpClient, threadId: string, messageId: string, fileId: string): (Option[MessageFileObject], Response) =
  ## Retrieves a message file.

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}/messages/{message_id}/files/{file_id}")
  constructResult[MessageFileObject](response)


proc getRun*(httpClient: HttpClient, threadId: string, runId: string): (Option[RunObject], Response) =
  ## Retrieves a run.

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}/runs/{run_id}")
  constructResult[RunObject](response)


proc getRunStep*(httpClient: HttpClient, threadId: string, runId: string, stepId: string): (Option[RunStepObject], Response) =
  ## Retrieves a run step.

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}/runs/{run_id}/steps/{step_id}")
  constructResult[RunStepObject](response)


proc getThread*(httpClient: HttpClient, threadId: string): (Option[ThreadObject], Response) =
  ## Retrieves a thread.

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}")
  constructResult[ThreadObject](response)


proc listAssistantFiles*(httpClient: HttpClient, assistantId: string, limit: int, order: string, after: string, before: string): (Option[ListAssistantFilesResponse], Response) =
  ## Returns a list of assistant files.
  let query_for_api_call = encodeQuery([
    ("limit", $limit), # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
    ("order", $order), # Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
    ("after", $after), # A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
    ("before", $before), # A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
  ])

  let response = httpClient.get(basepath & fmt"/assistants/{assistant_id}/files" & "?" & query_for_api_call)
  constructResult[ListAssistantFilesResponse](response)


proc listAssistants*(httpClient: HttpClient, limit: int, order: string, after: string, before: string): (Option[ListAssistantsResponse], Response) =
  ## Returns a list of assistants.
  let query_for_api_call = encodeQuery([
    ("limit", $limit), # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
    ("order", $order), # Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
    ("after", $after), # A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
    ("before", $before), # A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
  ])

  let response = httpClient.get(basepath & "/assistants" & "?" & query_for_api_call)
  constructResult[ListAssistantsResponse](response)


proc listMessageFiles*(httpClient: HttpClient, threadId: string, messageId: string, limit: int, order: string, after: string, before: string): (Option[ListMessageFilesResponse], Response) =
  ## Returns a list of message files.
  let query_for_api_call = encodeQuery([
    ("limit", $limit), # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
    ("order", $order), # Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
    ("after", $after), # A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
    ("before", $before), # A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
  ])

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}/messages/{message_id}/files" & "?" & query_for_api_call)
  constructResult[ListMessageFilesResponse](response)


proc listMessages*(httpClient: HttpClient, threadId: string, limit: int, order: string, after: string, before: string, runId: string): (Option[ListMessagesResponse], Response) =
  ## Returns a list of messages for a given thread.
  let query_for_api_call = encodeQuery([
    ("limit", $limit), # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
    ("order", $order), # Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
    ("after", $after), # A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
    ("before", $before), # A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
    ("run_id", $runId), # Filter messages by the run ID that generated them. 
  ])

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}/messages" & "?" & query_for_api_call)
  constructResult[ListMessagesResponse](response)


proc listRunSteps*(httpClient: HttpClient, threadId: string, runId: string, limit: int, order: string, after: string, before: string): (Option[ListRunStepsResponse], Response) =
  ## Returns a list of run steps belonging to a run.
  let query_for_api_call = encodeQuery([
    ("limit", $limit), # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
    ("order", $order), # Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
    ("after", $after), # A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
    ("before", $before), # A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
  ])

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}/runs/{run_id}/steps" & "?" & query_for_api_call)
  constructResult[ListRunStepsResponse](response)


proc listRuns*(httpClient: HttpClient, threadId: string, limit: int, order: string, after: string, before: string): (Option[ListRunsResponse], Response) =
  ## Returns a list of runs belonging to a thread.
  let query_for_api_call = encodeQuery([
    ("limit", $limit), # A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
    ("order", $order), # Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
    ("after", $after), # A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
    ("before", $before), # A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
  ])

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}/runs" & "?" & query_for_api_call)
  constructResult[ListRunsResponse](response)


proc modifyAssistant*(httpClient: HttpClient, assistantId: string, modifyAssistantRequest: ModifyAssistantRequest): (Option[AssistantObject], Response) =
  ## Modifies an assistant.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/assistants/{assistant_id}", $(%modifyAssistantRequest))
  constructResult[AssistantObject](response)


proc modifyMessage*(httpClient: HttpClient, threadId: string, messageId: string, modifyMessageRequest: ModifyMessageRequest): (Option[MessageObject], Response) =
  ## Modifies a message.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/threads/{thread_id}/messages/{message_id}", $(%modifyMessageRequest))
  constructResult[MessageObject](response)


proc modifyRun*(httpClient: HttpClient, threadId: string, runId: string, modifyRunRequest: ModifyRunRequest): (Option[RunObject], Response) =
  ## Modifies a run.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/threads/{thread_id}/runs/{run_id}", $(%modifyRunRequest))
  constructResult[RunObject](response)


proc modifyThread*(httpClient: HttpClient, threadId: string, modifyThreadRequest: ModifyThreadRequest): (Option[ThreadObject], Response) =
  ## Modifies a thread.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/threads/{thread_id}", $(%modifyThreadRequest))
  constructResult[ThreadObject](response)


proc submitToolOuputsToRun*(httpClient: HttpClient, threadId: string, runId: string, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest): (Option[RunObject], Response) =
  ## When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they're all completed. All outputs must be submitted in a single request. 
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/threads/{thread_id}/runs/{run_id}/submit_tool_outputs", $(%submitToolOutputsRunRequest))
  constructResult[RunObject](response)

