#
# OpenAI API
# 
# The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
# The version of the OpenAPI document: 2.3.0
# Contact: blah+oapicf@cliffano.com
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_assistant_object
import ../models/model_create_assistant_request
import ../models/model_create_message_request
import ../models/model_create_run_request
import ../models/model_create_thread_and_run_request
import ../models/model_create_thread_request
import ../models/model_delete_assistant_response
import ../models/model_delete_message_response
import ../models/model_delete_thread_response
import ../models/model_list_assistants_response
import ../models/model_list_messages_response
import ../models/model_list_run_steps_response
import ../models/model_list_runs_response
import ../models/model_message_object
import ../models/model_modify_assistant_request
import ../models/model_modify_message_request
import ../models/model_modify_run_request
import ../models/model_modify_thread_request
import ../models/model_run_object
import ../models/model_run_step_object
import ../models/model_submit_tool_outputs_run_request
import ../models/model_thread_object

const basepath = "https://api.openai.com/v1"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      (some(to(parseJson(response.body), T)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc cancelRun*(httpClient: HttpClient, threadId: string, runId: string): (Option[RunObject], Response) =
  ## Cancels a run that is `in_progress`.

  let response = httpClient.post(basepath & fmt"/threads/{thread_id}/runs/{run_id}/cancel")
  constructResult[RunObject](response)


proc createAssistant*(httpClient: HttpClient, createAssistantRequest: CreateAssistantRequest): (Option[AssistantObject], Response) =
  ## Create an assistant with a model and instructions.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & "/assistants", $(%createAssistantRequest))
  constructResult[AssistantObject](response)


proc createMessage*(httpClient: HttpClient, threadId: string, createMessageRequest: CreateMessageRequest): (Option[MessageObject], Response) =
  ## Create a message.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/threads/{thread_id}/messages", $(%createMessageRequest))
  constructResult[MessageObject](response)


proc createRun*(httpClient: HttpClient, threadId: string, createRunRequest: CreateRunRequest, `include`: seq[`Include`]): (Option[RunObject], Response) =
  ## Create a run.
  httpClient.headers["Content-Type"] = "application/json"
  var query_params_list: seq[(string, string)] = @[]
  if `include`.len > 0:
    query_params_list.add(("include[]", $`include`.join(",")))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.post(basepath & fmt"/threads/{thread_id}/runs" & "?" & url_encoded_query_params, $(%createRunRequest))
  constructResult[RunObject](response)


proc createThread*(httpClient: HttpClient, createThreadRequest: CreateThreadRequest): (Option[ThreadObject], Response) =
  ## Create a thread.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & "/threads", $(%createThreadRequest))
  constructResult[ThreadObject](response)


proc createThreadAndRun*(httpClient: HttpClient, createThreadAndRunRequest: CreateThreadAndRunRequest): (Option[RunObject], Response) =
  ## Create a thread and run it in one request.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & "/threads/runs", $(%createThreadAndRunRequest))
  constructResult[RunObject](response)


proc deleteAssistant*(httpClient: HttpClient, assistantId: string): (Option[DeleteAssistantResponse], Response) =
  ## Delete an assistant.

  let response = httpClient.delete(basepath & fmt"/assistants/{assistant_id}")
  constructResult[DeleteAssistantResponse](response)


proc deleteMessage*(httpClient: HttpClient, threadId: string, messageId: string): (Option[DeleteMessageResponse], Response) =
  ## Deletes a message.

  let response = httpClient.delete(basepath & fmt"/threads/{thread_id}/messages/{message_id}")
  constructResult[DeleteMessageResponse](response)


proc deleteThread*(httpClient: HttpClient, threadId: string): (Option[DeleteThreadResponse], Response) =
  ## Delete a thread.

  let response = httpClient.delete(basepath & fmt"/threads/{thread_id}")
  constructResult[DeleteThreadResponse](response)


proc getAssistant*(httpClient: HttpClient, assistantId: string): (Option[AssistantObject], Response) =
  ## Retrieves an assistant.

  let response = httpClient.get(basepath & fmt"/assistants/{assistant_id}")
  constructResult[AssistantObject](response)


proc getMessage*(httpClient: HttpClient, threadId: string, messageId: string): (Option[MessageObject], Response) =
  ## Retrieve a message.

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}/messages/{message_id}")
  constructResult[MessageObject](response)


proc getRun*(httpClient: HttpClient, threadId: string, runId: string): (Option[RunObject], Response) =
  ## Retrieves a run.

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}/runs/{run_id}")
  constructResult[RunObject](response)


proc getRunStep*(httpClient: HttpClient, threadId: string, runId: string, stepId: string, `include`: seq[`Include`]): (Option[RunStepObject], Response) =
  ## Retrieves a run step.
  var query_params_list: seq[(string, string)] = @[]
  if `include`.len > 0:
    query_params_list.add(("include[]", $`include`.join(",")))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}/runs/{run_id}/steps/{step_id}" & "?" & url_encoded_query_params)
  constructResult[RunStepObject](response)


proc getThread*(httpClient: HttpClient, threadId: string): (Option[ThreadObject], Response) =
  ## Retrieves a thread.

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}")
  constructResult[ThreadObject](response)


proc listAssistants*(httpClient: HttpClient, limit: int, order: string, after: string, before: string): (Option[ListAssistantsResponse], Response) =
  ## Returns a list of assistants.
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $order != "":
    query_params_list.add(("order", $order))
  if $after != "":
    query_params_list.add(("after", $after))
  if $before != "":
    query_params_list.add(("before", $before))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/assistants" & "?" & url_encoded_query_params)
  constructResult[ListAssistantsResponse](response)


proc listMessages*(httpClient: HttpClient, threadId: string, limit: int, order: string, after: string, before: string, runId: string): (Option[ListMessagesResponse], Response) =
  ## Returns a list of messages for a given thread.
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $order != "":
    query_params_list.add(("order", $order))
  if $after != "":
    query_params_list.add(("after", $after))
  if $before != "":
    query_params_list.add(("before", $before))
  if $runId != "":
    query_params_list.add(("run_id", $runId))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}/messages" & "?" & url_encoded_query_params)
  constructResult[ListMessagesResponse](response)


proc listRunSteps*(httpClient: HttpClient, threadId: string, runId: string, limit: int, order: string, after: string, before: string, `include`: seq[`Include`]): (Option[ListRunStepsResponse], Response) =
  ## Returns a list of run steps belonging to a run.
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $order != "":
    query_params_list.add(("order", $order))
  if $after != "":
    query_params_list.add(("after", $after))
  if $before != "":
    query_params_list.add(("before", $before))
  if `include`.len > 0:
    query_params_list.add(("include[]", $`include`.join(",")))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}/runs/{run_id}/steps" & "?" & url_encoded_query_params)
  constructResult[ListRunStepsResponse](response)


proc listRuns*(httpClient: HttpClient, threadId: string, limit: int, order: string, after: string, before: string): (Option[ListRunsResponse], Response) =
  ## Returns a list of runs belonging to a thread.
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $order != "":
    query_params_list.add(("order", $order))
  if $after != "":
    query_params_list.add(("after", $after))
  if $before != "":
    query_params_list.add(("before", $before))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/threads/{thread_id}/runs" & "?" & url_encoded_query_params)
  constructResult[ListRunsResponse](response)


proc modifyAssistant*(httpClient: HttpClient, assistantId: string, modifyAssistantRequest: ModifyAssistantRequest): (Option[AssistantObject], Response) =
  ## Modifies an assistant.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/assistants/{assistant_id}", $(%modifyAssistantRequest))
  constructResult[AssistantObject](response)


proc modifyMessage*(httpClient: HttpClient, threadId: string, messageId: string, modifyMessageRequest: ModifyMessageRequest): (Option[MessageObject], Response) =
  ## Modifies a message.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/threads/{thread_id}/messages/{message_id}", $(%modifyMessageRequest))
  constructResult[MessageObject](response)


proc modifyRun*(httpClient: HttpClient, threadId: string, runId: string, modifyRunRequest: ModifyRunRequest): (Option[RunObject], Response) =
  ## Modifies a run.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/threads/{thread_id}/runs/{run_id}", $(%modifyRunRequest))
  constructResult[RunObject](response)


proc modifyThread*(httpClient: HttpClient, threadId: string, modifyThreadRequest: ModifyThreadRequest): (Option[ThreadObject], Response) =
  ## Modifies a thread.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/threads/{thread_id}", $(%modifyThreadRequest))
  constructResult[ThreadObject](response)


proc submitToolOuputsToRun*(httpClient: HttpClient, threadId: string, runId: string, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest): (Option[RunObject], Response) =
  ## When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they're all completed. All outputs must be submitted in a single request. 
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/threads/{thread_id}/runs/{run_id}/submit_tool_outputs", $(%submitToolOutputsRunRequest))
  constructResult[RunObject](response)

