#
# OpenAI API
# 
# The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
# The version of the OpenAPI document: 2.3.0
# Contact: blah+oapicf@cliffano.com
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_usage_response

const basepath = "https://api.openai.com/v1"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      (some(to(parseJson(response.body), T)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc usageAudioSpeeches*(httpClient: HttpClient, startTime: int, endTime: int, bucketWidth: string, projectIds: seq[string], userIds: seq[string], apiKeyIds: seq[string], models: seq[string], groupBy: seq[GroupBy], limit: int, page: string): (Option[UsageResponse], Response) =
  ## Get audio speeches usage details for the organization.
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("start_time", $startTime))
  if $endTime != "":
    query_params_list.add(("end_time", $endTime))
  if $bucketWidth != "":
    query_params_list.add(("bucket_width", $bucketWidth))
  if projectIds.len > 0:
    query_params_list.add(("project_ids", $projectIds.join(",")))
  if userIds.len > 0:
    query_params_list.add(("user_ids", $userIds.join(",")))
  if apiKeyIds.len > 0:
    query_params_list.add(("api_key_ids", $apiKeyIds.join(",")))
  if models.len > 0:
    query_params_list.add(("models", $models.join(",")))
  if groupBy.len > 0:
    query_params_list.add(("group_by", $groupBy.join(",")))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $page != "":
    query_params_list.add(("page", $page))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/organization/usage/audio_speeches" & "?" & url_encoded_query_params)
  constructResult[UsageResponse](response)


proc usageAudioTranscriptions*(httpClient: HttpClient, startTime: int, endTime: int, bucketWidth: string, projectIds: seq[string], userIds: seq[string], apiKeyIds: seq[string], models: seq[string], groupBy: seq[GroupBy], limit: int, page: string): (Option[UsageResponse], Response) =
  ## Get audio transcriptions usage details for the organization.
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("start_time", $startTime))
  if $endTime != "":
    query_params_list.add(("end_time", $endTime))
  if $bucketWidth != "":
    query_params_list.add(("bucket_width", $bucketWidth))
  if projectIds.len > 0:
    query_params_list.add(("project_ids", $projectIds.join(",")))
  if userIds.len > 0:
    query_params_list.add(("user_ids", $userIds.join(",")))
  if apiKeyIds.len > 0:
    query_params_list.add(("api_key_ids", $apiKeyIds.join(",")))
  if models.len > 0:
    query_params_list.add(("models", $models.join(",")))
  if groupBy.len > 0:
    query_params_list.add(("group_by", $groupBy.join(",")))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $page != "":
    query_params_list.add(("page", $page))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/organization/usage/audio_transcriptions" & "?" & url_encoded_query_params)
  constructResult[UsageResponse](response)


proc usageCodeInterpreterSessions*(httpClient: HttpClient, startTime: int, endTime: int, bucketWidth: string, projectIds: seq[string], groupBy: seq[GroupBy], limit: int, page: string): (Option[UsageResponse], Response) =
  ## Get code interpreter sessions usage details for the organization.
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("start_time", $startTime))
  if $endTime != "":
    query_params_list.add(("end_time", $endTime))
  if $bucketWidth != "":
    query_params_list.add(("bucket_width", $bucketWidth))
  if projectIds.len > 0:
    query_params_list.add(("project_ids", $projectIds.join(",")))
  if groupBy.len > 0:
    query_params_list.add(("group_by", $groupBy.join(",")))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $page != "":
    query_params_list.add(("page", $page))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/organization/usage/code_interpreter_sessions" & "?" & url_encoded_query_params)
  constructResult[UsageResponse](response)


proc usageCompletions*(httpClient: HttpClient, startTime: int, endTime: int, bucketWidth: string, projectIds: seq[string], userIds: seq[string], apiKeyIds: seq[string], models: seq[string], batch: bool, groupBy: seq[GroupBy], limit: int, page: string): (Option[UsageResponse], Response) =
  ## Get completions usage details for the organization.
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("start_time", $startTime))
  if $endTime != "":
    query_params_list.add(("end_time", $endTime))
  if $bucketWidth != "":
    query_params_list.add(("bucket_width", $bucketWidth))
  if projectIds.len > 0:
    query_params_list.add(("project_ids", $projectIds.join(",")))
  if userIds.len > 0:
    query_params_list.add(("user_ids", $userIds.join(",")))
  if apiKeyIds.len > 0:
    query_params_list.add(("api_key_ids", $apiKeyIds.join(",")))
  if models.len > 0:
    query_params_list.add(("models", $models.join(",")))
  if $batch != "":
    query_params_list.add(("batch", $batch))
  if groupBy.len > 0:
    query_params_list.add(("group_by", $groupBy.join(",")))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $page != "":
    query_params_list.add(("page", $page))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/organization/usage/completions" & "?" & url_encoded_query_params)
  constructResult[UsageResponse](response)


proc usageCosts*(httpClient: HttpClient, startTime: int, endTime: int, bucketWidth: string, projectIds: seq[string], groupBy: seq[GroupBy], limit: int, page: string): (Option[UsageResponse], Response) =
  ## Get costs details for the organization.
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("start_time", $startTime))
  if $endTime != "":
    query_params_list.add(("end_time", $endTime))
  if $bucketWidth != "":
    query_params_list.add(("bucket_width", $bucketWidth))
  if projectIds.len > 0:
    query_params_list.add(("project_ids", $projectIds.join(",")))
  if groupBy.len > 0:
    query_params_list.add(("group_by", $groupBy.join(",")))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $page != "":
    query_params_list.add(("page", $page))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/organization/costs" & "?" & url_encoded_query_params)
  constructResult[UsageResponse](response)


proc usageEmbeddings*(httpClient: HttpClient, startTime: int, endTime: int, bucketWidth: string, projectIds: seq[string], userIds: seq[string], apiKeyIds: seq[string], models: seq[string], groupBy: seq[GroupBy], limit: int, page: string): (Option[UsageResponse], Response) =
  ## Get embeddings usage details for the organization.
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("start_time", $startTime))
  if $endTime != "":
    query_params_list.add(("end_time", $endTime))
  if $bucketWidth != "":
    query_params_list.add(("bucket_width", $bucketWidth))
  if projectIds.len > 0:
    query_params_list.add(("project_ids", $projectIds.join(",")))
  if userIds.len > 0:
    query_params_list.add(("user_ids", $userIds.join(",")))
  if apiKeyIds.len > 0:
    query_params_list.add(("api_key_ids", $apiKeyIds.join(",")))
  if models.len > 0:
    query_params_list.add(("models", $models.join(",")))
  if groupBy.len > 0:
    query_params_list.add(("group_by", $groupBy.join(",")))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $page != "":
    query_params_list.add(("page", $page))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/organization/usage/embeddings" & "?" & url_encoded_query_params)
  constructResult[UsageResponse](response)


proc usageImages*(httpClient: HttpClient, startTime: int, endTime: int, bucketWidth: string, sources: seq[Sources], sizes: seq[Sizes], projectIds: seq[string], userIds: seq[string], apiKeyIds: seq[string], models: seq[string], groupBy: seq[GroupBy], limit: int, page: string): (Option[UsageResponse], Response) =
  ## Get images usage details for the organization.
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("start_time", $startTime))
  if $endTime != "":
    query_params_list.add(("end_time", $endTime))
  if $bucketWidth != "":
    query_params_list.add(("bucket_width", $bucketWidth))
  if sources.len > 0:
    query_params_list.add(("sources", $sources.join(",")))
  if sizes.len > 0:
    query_params_list.add(("sizes", $sizes.join(",")))
  if projectIds.len > 0:
    query_params_list.add(("project_ids", $projectIds.join(",")))
  if userIds.len > 0:
    query_params_list.add(("user_ids", $userIds.join(",")))
  if apiKeyIds.len > 0:
    query_params_list.add(("api_key_ids", $apiKeyIds.join(",")))
  if models.len > 0:
    query_params_list.add(("models", $models.join(",")))
  if groupBy.len > 0:
    query_params_list.add(("group_by", $groupBy.join(",")))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $page != "":
    query_params_list.add(("page", $page))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/organization/usage/images" & "?" & url_encoded_query_params)
  constructResult[UsageResponse](response)


proc usageModerations*(httpClient: HttpClient, startTime: int, endTime: int, bucketWidth: string, projectIds: seq[string], userIds: seq[string], apiKeyIds: seq[string], models: seq[string], groupBy: seq[GroupBy], limit: int, page: string): (Option[UsageResponse], Response) =
  ## Get moderations usage details for the organization.
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("start_time", $startTime))
  if $endTime != "":
    query_params_list.add(("end_time", $endTime))
  if $bucketWidth != "":
    query_params_list.add(("bucket_width", $bucketWidth))
  if projectIds.len > 0:
    query_params_list.add(("project_ids", $projectIds.join(",")))
  if userIds.len > 0:
    query_params_list.add(("user_ids", $userIds.join(",")))
  if apiKeyIds.len > 0:
    query_params_list.add(("api_key_ids", $apiKeyIds.join(",")))
  if models.len > 0:
    query_params_list.add(("models", $models.join(",")))
  if groupBy.len > 0:
    query_params_list.add(("group_by", $groupBy.join(",")))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $page != "":
    query_params_list.add(("page", $page))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/organization/usage/moderations" & "?" & url_encoded_query_params)
  constructResult[UsageResponse](response)


proc usageVectorStores*(httpClient: HttpClient, startTime: int, endTime: int, bucketWidth: string, projectIds: seq[string], groupBy: seq[GroupBy], limit: int, page: string): (Option[UsageResponse], Response) =
  ## Get vector stores usage details for the organization.
  var query_params_list: seq[(string, string)] = @[]
  query_params_list.add(("start_time", $startTime))
  if $endTime != "":
    query_params_list.add(("end_time", $endTime))
  if $bucketWidth != "":
    query_params_list.add(("bucket_width", $bucketWidth))
  if projectIds.len > 0:
    query_params_list.add(("project_ids", $projectIds.join(",")))
  if groupBy.len > 0:
    query_params_list.add(("group_by", $groupBy.join(",")))
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $page != "":
    query_params_list.add(("page", $page))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/organization/usage/vector_stores" & "?" & url_encoded_query_params)
  constructResult[UsageResponse](response)

