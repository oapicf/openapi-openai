#
# OpenAI API
# 
# The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
# The version of the OpenAPI document: 2.3.0
# Contact: blah+oapicf@cliffano.com
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_create_vector_store_file_batch_request
import ../models/model_create_vector_store_file_request
import ../models/model_create_vector_store_request
import ../models/model_delete_vector_store_file_response
import ../models/model_delete_vector_store_response
import ../models/model_list_vector_store_files_response
import ../models/model_list_vector_stores_response
import ../models/model_update_vector_store_request
import ../models/model_vector_store_file_batch_object
import ../models/model_vector_store_file_object
import ../models/model_vector_store_object

const basepath = "https://api.openai.com/v1"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      (some(to(parseJson(response.body), T)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc cancelVectorStoreFileBatch*(httpClient: HttpClient, vectorStoreId: string, batchId: string): (Option[VectorStoreFileBatchObject], Response) =
  ## Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.

  let response = httpClient.post(basepath & fmt"/vector_stores/{vector_store_id}/file_batches/{batch_id}/cancel")
  constructResult[VectorStoreFileBatchObject](response)


proc createVectorStore*(httpClient: HttpClient, createVectorStoreRequest: CreateVectorStoreRequest): (Option[VectorStoreObject], Response) =
  ## Create a vector store.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & "/vector_stores", $(%createVectorStoreRequest))
  constructResult[VectorStoreObject](response)


proc createVectorStoreFile*(httpClient: HttpClient, vectorStoreId: string, createVectorStoreFileRequest: CreateVectorStoreFileRequest): (Option[VectorStoreFileObject], Response) =
  ## Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/vector_stores/{vector_store_id}/files", $(%createVectorStoreFileRequest))
  constructResult[VectorStoreFileObject](response)


proc createVectorStoreFileBatch*(httpClient: HttpClient, vectorStoreId: string, createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest): (Option[VectorStoreFileBatchObject], Response) =
  ## Create a vector store file batch.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/vector_stores/{vector_store_id}/file_batches", $(%createVectorStoreFileBatchRequest))
  constructResult[VectorStoreFileBatchObject](response)


proc deleteVectorStore*(httpClient: HttpClient, vectorStoreId: string): (Option[DeleteVectorStoreResponse], Response) =
  ## Delete a vector store.

  let response = httpClient.delete(basepath & fmt"/vector_stores/{vector_store_id}")
  constructResult[DeleteVectorStoreResponse](response)


proc deleteVectorStoreFile*(httpClient: HttpClient, vectorStoreId: string, fileId: string): (Option[DeleteVectorStoreFileResponse], Response) =
  ## Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.

  let response = httpClient.delete(basepath & fmt"/vector_stores/{vector_store_id}/files/{file_id}")
  constructResult[DeleteVectorStoreFileResponse](response)


proc getVectorStore*(httpClient: HttpClient, vectorStoreId: string): (Option[VectorStoreObject], Response) =
  ## Retrieves a vector store.

  let response = httpClient.get(basepath & fmt"/vector_stores/{vector_store_id}")
  constructResult[VectorStoreObject](response)


proc getVectorStoreFile*(httpClient: HttpClient, vectorStoreId: string, fileId: string): (Option[VectorStoreFileObject], Response) =
  ## Retrieves a vector store file.

  let response = httpClient.get(basepath & fmt"/vector_stores/{vector_store_id}/files/{file_id}")
  constructResult[VectorStoreFileObject](response)


proc getVectorStoreFileBatch*(httpClient: HttpClient, vectorStoreId: string, batchId: string): (Option[VectorStoreFileBatchObject], Response) =
  ## Retrieves a vector store file batch.

  let response = httpClient.get(basepath & fmt"/vector_stores/{vector_store_id}/file_batches/{batch_id}")
  constructResult[VectorStoreFileBatchObject](response)


proc listFilesInVectorStoreBatch*(httpClient: HttpClient, vectorStoreId: string, batchId: string, limit: int, order: string, after: string, before: string, filter: string): (Option[ListVectorStoreFilesResponse], Response) =
  ## Returns a list of vector store files in a batch.
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $order != "":
    query_params_list.add(("order", $order))
  if $after != "":
    query_params_list.add(("after", $after))
  if $before != "":
    query_params_list.add(("before", $before))
  if $filter != "":
    query_params_list.add(("filter", $filter))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/vector_stores/{vector_store_id}/file_batches/{batch_id}/files" & "?" & url_encoded_query_params)
  constructResult[ListVectorStoreFilesResponse](response)


proc listVectorStoreFiles*(httpClient: HttpClient, vectorStoreId: string, limit: int, order: string, after: string, before: string, filter: string): (Option[ListVectorStoreFilesResponse], Response) =
  ## Returns a list of vector store files.
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $order != "":
    query_params_list.add(("order", $order))
  if $after != "":
    query_params_list.add(("after", $after))
  if $before != "":
    query_params_list.add(("before", $before))
  if $filter != "":
    query_params_list.add(("filter", $filter))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & fmt"/vector_stores/{vector_store_id}/files" & "?" & url_encoded_query_params)
  constructResult[ListVectorStoreFilesResponse](response)


proc listVectorStores*(httpClient: HttpClient, limit: int, order: string, after: string, before: string): (Option[ListVectorStoresResponse], Response) =
  ## Returns a list of vector stores.
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $order != "":
    query_params_list.add(("order", $order))
  if $after != "":
    query_params_list.add(("after", $after))
  if $before != "":
    query_params_list.add(("before", $before))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/vector_stores" & "?" & url_encoded_query_params)
  constructResult[ListVectorStoresResponse](response)


proc modifyVectorStore*(httpClient: HttpClient, vectorStoreId: string, updateVectorStoreRequest: UpdateVectorStoreRequest): (Option[VectorStoreObject], Response) =
  ## Modifies a vector store.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/vector_stores/{vector_store_id}", $(%updateVectorStoreRequest))
  constructResult[VectorStoreObject](response)

