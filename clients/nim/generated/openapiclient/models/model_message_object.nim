#
# OpenAI API
# 
# The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
# The version of the OpenAPI document: 2.3.0
# Contact: blah+oapicf@cliffano.com
# Generated by: https://openapi-generator.tech
#

import json
import tables
import marshal
import options

import model_create_message_request_attachments_inner
import model_message_object_content_inner
import model_message_object_incomplete_details
import model_object

type `Object`* {.pure.} = enum
  ThreadMessage

type Status* {.pure.} = enum
  InProgress
  Incomplete
  Completed

type Role* {.pure.} = enum
  User
  Assistant

type MessageObject* = object
  ## Represents a message within a [thread](/docs/api-reference/threads).
  id*: string ## The identifier, which can be referenced in API endpoints.
  `object`*: `Object` ## The object type, which is always `thread.message`.
  createdAt*: int ## The Unix timestamp (in seconds) for when the message was created.
  threadId*: string ## The [thread](/docs/api-reference/threads) ID that this message belongs to.
  status*: Status ## The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
  incompleteDetails*: Option[MessageObject_incomplete_details]
  completedAt*: Option[int] ## The Unix timestamp (in seconds) for when the message was completed.
  incompleteAt*: Option[int] ## The Unix timestamp (in seconds) for when the message was marked as incomplete.
  role*: Role ## The entity that produced the message. One of `user` or `assistant`.
  content*: seq[MessageObject_content_inner] ## The content of the message in array of text and/or images.
  assistantId*: Option[string] ## If applicable, the ID of the [assistant](/docs/api-reference/assistants) that authored this message.
  runId*: Option[string] ## The ID of the [run](/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints.
  attachments*: Option[seq[CreateMessageRequest_attachments_inner]] ## A list of files attached to the message, and the tools they were added to.
  metadata*: Option[JsonNode] ## Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 

func `%`*(v: `Object`): JsonNode =
  result = case v:
    of `Object`.ThreadMessage: %"thread.message"
func `$`*(v: `Object`): string =
  result = case v:
    of `Object`.ThreadMessage: $("thread.message")

proc to*(node: JsonNode, T: typedesc[`Object`]): `Object` =
  if node.kind != JString:
    raise newException(ValueError, "Expected string for enum `Object`, got " & $node.kind)
  let strVal = node.getStr()
  case strVal:
  of $("thread.message"):
    return `Object`.ThreadMessage
  else:
    raise newException(ValueError, "Invalid enum value for `Object`: " & strVal)

func `%`*(v: Status): JsonNode =
  result = case v:
    of Status.InProgress: %"in_progress"
    of Status.Incomplete: %"incomplete"
    of Status.Completed: %"completed"
func `$`*(v: Status): string =
  result = case v:
    of Status.InProgress: $("in_progress")
    of Status.Incomplete: $("incomplete")
    of Status.Completed: $("completed")

proc to*(node: JsonNode, T: typedesc[Status]): Status =
  if node.kind != JString:
    raise newException(ValueError, "Expected string for enum Status, got " & $node.kind)
  let strVal = node.getStr()
  case strVal:
  of $("in_progress"):
    return Status.InProgress
  of $("incomplete"):
    return Status.Incomplete
  of $("completed"):
    return Status.Completed
  else:
    raise newException(ValueError, "Invalid enum value for Status: " & strVal)

func `%`*(v: Role): JsonNode =
  result = case v:
    of Role.User: %"user"
    of Role.Assistant: %"assistant"
func `$`*(v: Role): string =
  result = case v:
    of Role.User: $("user")
    of Role.Assistant: $("assistant")

proc to*(node: JsonNode, T: typedesc[Role]): Role =
  if node.kind != JString:
    raise newException(ValueError, "Expected string for enum Role, got " & $node.kind)
  let strVal = node.getStr()
  case strVal:
  of $("user"):
    return Role.User
  of $("assistant"):
    return Role.Assistant
  else:
    raise newException(ValueError, "Invalid enum value for Role: " & strVal)


# Custom JSON deserialization for MessageObject with custom field names
proc to*(node: JsonNode, T: typedesc[MessageObject]): MessageObject =
  result = MessageObject()
  if node.kind == JObject:
    if node.hasKey("id"):
      result.id = to(node["id"], string)
    if node.hasKey("object"):
      result.`object` = to(node["object"], `Object`)
    if node.hasKey("created_at"):
      result.createdAt = to(node["created_at"], int)
    if node.hasKey("thread_id"):
      result.threadId = to(node["thread_id"], string)
    if node.hasKey("status"):
      result.status = to(node["status"], Status)
    if node.hasKey("incomplete_details") and node["incomplete_details"].kind != JNull:
      result.incompleteDetails = some(to(node["incomplete_details"], typeof(result.incompleteDetails.get())))
    if node.hasKey("completed_at") and node["completed_at"].kind != JNull:
      result.completedAt = some(to(node["completed_at"], typeof(result.completedAt.get())))
    if node.hasKey("incomplete_at") and node["incomplete_at"].kind != JNull:
      result.incompleteAt = some(to(node["incomplete_at"], typeof(result.incompleteAt.get())))
    if node.hasKey("role"):
      result.role = to(node["role"], Role)
    if node.hasKey("content"):
      result.content = to(node["content"], seq[MessageObject_content_inner])
    if node.hasKey("assistant_id") and node["assistant_id"].kind != JNull:
      result.assistantId = some(to(node["assistant_id"], typeof(result.assistantId.get())))
    if node.hasKey("run_id") and node["run_id"].kind != JNull:
      result.runId = some(to(node["run_id"], typeof(result.runId.get())))
    if node.hasKey("attachments") and node["attachments"].kind != JNull:
      result.attachments = some(to(node["attachments"], typeof(result.attachments.get())))
    if node.hasKey("metadata") and node["metadata"].kind != JNull:
      result.metadata = some(to(node["metadata"], typeof(result.metadata.get())))

# Custom JSON serialization for MessageObject with custom field names
proc `%`*(obj: MessageObject): JsonNode =
  result = newJObject()
  result["id"] = %obj.id
  result["object"] = %obj.`object`
  result["created_at"] = %obj.createdAt
  result["thread_id"] = %obj.threadId
  result["status"] = %obj.status
  if obj.incompleteDetails.isSome():
    result["incomplete_details"] = %obj.incompleteDetails.get()
  if obj.completedAt.isSome():
    result["completed_at"] = %obj.completedAt.get()
  if obj.incompleteAt.isSome():
    result["incomplete_at"] = %obj.incompleteAt.get()
  result["role"] = %obj.role
  result["content"] = %obj.content
  if obj.assistantId.isSome():
    result["assistant_id"] = %obj.assistantId.get()
  if obj.runId.isSome():
    result["run_id"] = %obj.runId.get()
  if obj.attachments.isSome():
    result["attachments"] = %obj.attachments.get()
  if obj.metadata.isSome():
    result["metadata"] = %obj.metadata.get()

