<?php

/**
 * UsageController
 * PHP version 8.1.1
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */

/**
 * OpenAI API
 *
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 *
 */

/**
 * NOTE: This class is auto generated by the openapi generator program.
 * https://github.com/openapitools/openapi-generator
 * Do not edit the class manually.
 */

namespace OpenAPI\Server\Controller;

use \Exception;
use JMS\Serializer\Exception\RuntimeException as SerializerRuntimeException;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\HttpException;
use Symfony\Component\Validator\Constraints as Assert;
use OpenAPI\Server\Api\UsageApiInterface;
use OpenAPI\Server\Model\UsageResponse;

/**
 * UsageController Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */
class UsageController extends Controller
{

    /**
     * Operation usageAudioSpeeches
     *
     * Get audio speeches usage details for the organization.
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function usageAudioSpeechesAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKeyAuth' required
        // HTTP bearer authentication required
        $securityApiKeyAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $startTime = $request->query->get('startTime');
        $endTime = $request->query->get('endTime');
        $bucketWidth = $request->query->get('bucketWidth', '1d');
        $projectIds = $request->query->get('projectIds');
        $userIds = $request->query->get('userIds');
        $apiKeyIds = $request->query->get('apiKeyIds');
        $models = $request->query->get('models');
        $groupBy = $request->query->get('groupBy');
        $limit = $request->query->get('limit');
        $page = $request->query->get('page');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $startTime = $this->deserialize($startTime, 'int', 'string');
            $endTime = $this->deserialize($endTime, 'int', 'string');
            $bucketWidth = $this->deserialize($bucketWidth, 'string', 'string');
            $projectIds = $this->deserialize($projectIds, 'array<multi,string>', 'string');
            $userIds = $this->deserialize($userIds, 'array<multi,string>', 'string');
            $apiKeyIds = $this->deserialize($apiKeyIds, 'array<multi,string>', 'string');
            $models = $this->deserialize($models, 'array<multi,string>', 'string');
            $groupBy = $this->deserialize($groupBy, 'array<multi,string>', 'string');
            $limit = $this->deserialize($limit, 'int', 'string');
            $page = $this->deserialize($page, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($startTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($endTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ '1m', '1h', '1d' ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($bucketWidth, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($projectIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($userIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($apiKeyIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($models, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Choice([ 'project_id', 'user_id', 'api_key_id', 'model' ])
        ]);
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($groupBy, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($limit, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($page, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKeyAuth'
            $handler->setApiKeyAuth($securityApiKeyAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->usageAudioSpeeches($startTime, $endTime, $bucketWidth, $projectIds, $userIds, $apiKeyIds, $models, $groupBy, $limit, $page, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Usage data retrieved successfully.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation usageAudioTranscriptions
     *
     * Get audio transcriptions usage details for the organization.
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function usageAudioTranscriptionsAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKeyAuth' required
        // HTTP bearer authentication required
        $securityApiKeyAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $startTime = $request->query->get('startTime');
        $endTime = $request->query->get('endTime');
        $bucketWidth = $request->query->get('bucketWidth', '1d');
        $projectIds = $request->query->get('projectIds');
        $userIds = $request->query->get('userIds');
        $apiKeyIds = $request->query->get('apiKeyIds');
        $models = $request->query->get('models');
        $groupBy = $request->query->get('groupBy');
        $limit = $request->query->get('limit');
        $page = $request->query->get('page');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $startTime = $this->deserialize($startTime, 'int', 'string');
            $endTime = $this->deserialize($endTime, 'int', 'string');
            $bucketWidth = $this->deserialize($bucketWidth, 'string', 'string');
            $projectIds = $this->deserialize($projectIds, 'array<multi,string>', 'string');
            $userIds = $this->deserialize($userIds, 'array<multi,string>', 'string');
            $apiKeyIds = $this->deserialize($apiKeyIds, 'array<multi,string>', 'string');
            $models = $this->deserialize($models, 'array<multi,string>', 'string');
            $groupBy = $this->deserialize($groupBy, 'array<multi,string>', 'string');
            $limit = $this->deserialize($limit, 'int', 'string');
            $page = $this->deserialize($page, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($startTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($endTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ '1m', '1h', '1d' ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($bucketWidth, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($projectIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($userIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($apiKeyIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($models, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Choice([ 'project_id', 'user_id', 'api_key_id', 'model' ])
        ]);
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($groupBy, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($limit, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($page, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKeyAuth'
            $handler->setApiKeyAuth($securityApiKeyAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->usageAudioTranscriptions($startTime, $endTime, $bucketWidth, $projectIds, $userIds, $apiKeyIds, $models, $groupBy, $limit, $page, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Usage data retrieved successfully.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation usageCodeInterpreterSessions
     *
     * Get code interpreter sessions usage details for the organization.
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function usageCodeInterpreterSessionsAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKeyAuth' required
        // HTTP bearer authentication required
        $securityApiKeyAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $startTime = $request->query->get('startTime');
        $endTime = $request->query->get('endTime');
        $bucketWidth = $request->query->get('bucketWidth', '1d');
        $projectIds = $request->query->get('projectIds');
        $groupBy = $request->query->get('groupBy');
        $limit = $request->query->get('limit');
        $page = $request->query->get('page');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $startTime = $this->deserialize($startTime, 'int', 'string');
            $endTime = $this->deserialize($endTime, 'int', 'string');
            $bucketWidth = $this->deserialize($bucketWidth, 'string', 'string');
            $projectIds = $this->deserialize($projectIds, 'array<multi,string>', 'string');
            $groupBy = $this->deserialize($groupBy, 'array<multi,string>', 'string');
            $limit = $this->deserialize($limit, 'int', 'string');
            $page = $this->deserialize($page, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($startTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($endTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ '1m', '1h', '1d' ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($bucketWidth, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($projectIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Choice([ 'project_id' ])
        ]);
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($groupBy, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($limit, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($page, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKeyAuth'
            $handler->setApiKeyAuth($securityApiKeyAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->usageCodeInterpreterSessions($startTime, $endTime, $bucketWidth, $projectIds, $groupBy, $limit, $page, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Usage data retrieved successfully.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation usageCompletions
     *
     * Get completions usage details for the organization.
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function usageCompletionsAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKeyAuth' required
        // HTTP bearer authentication required
        $securityApiKeyAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $startTime = $request->query->get('startTime');
        $endTime = $request->query->get('endTime');
        $bucketWidth = $request->query->get('bucketWidth', '1d');
        $projectIds = $request->query->get('projectIds');
        $userIds = $request->query->get('userIds');
        $apiKeyIds = $request->query->get('apiKeyIds');
        $models = $request->query->get('models');
        $batch = $request->query->get('batch');
        $groupBy = $request->query->get('groupBy');
        $limit = $request->query->get('limit');
        $page = $request->query->get('page');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $startTime = $this->deserialize($startTime, 'int', 'string');
            $endTime = $this->deserialize($endTime, 'int', 'string');
            $bucketWidth = $this->deserialize($bucketWidth, 'string', 'string');
            $projectIds = $this->deserialize($projectIds, 'array<multi,string>', 'string');
            $userIds = $this->deserialize($userIds, 'array<multi,string>', 'string');
            $apiKeyIds = $this->deserialize($apiKeyIds, 'array<multi,string>', 'string');
            $models = $this->deserialize($models, 'array<multi,string>', 'string');
            $batch = $this->deserialize($batch, 'bool', 'string');
            $groupBy = $this->deserialize($groupBy, 'array<multi,string>', 'string');
            $limit = $this->deserialize($limit, 'int', 'string');
            $page = $this->deserialize($page, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($startTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($endTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ '1m', '1h', '1d' ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($bucketWidth, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($projectIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($userIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($apiKeyIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($models, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($batch, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Choice([ 'project_id', 'user_id', 'api_key_id', 'model', 'batch' ])
        ]);
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($groupBy, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($limit, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($page, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKeyAuth'
            $handler->setApiKeyAuth($securityApiKeyAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->usageCompletions($startTime, $endTime, $bucketWidth, $projectIds, $userIds, $apiKeyIds, $models, $batch, $groupBy, $limit, $page, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Usage data retrieved successfully.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation usageCosts
     *
     * Get costs details for the organization.
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function usageCostsAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKeyAuth' required
        // HTTP bearer authentication required
        $securityApiKeyAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $startTime = $request->query->get('startTime');
        $endTime = $request->query->get('endTime');
        $bucketWidth = $request->query->get('bucketWidth', '1d');
        $projectIds = $request->query->get('projectIds');
        $groupBy = $request->query->get('groupBy');
        $limit = $request->query->get('limit', 7);
        $page = $request->query->get('page');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $startTime = $this->deserialize($startTime, 'int', 'string');
            $endTime = $this->deserialize($endTime, 'int', 'string');
            $bucketWidth = $this->deserialize($bucketWidth, 'string', 'string');
            $projectIds = $this->deserialize($projectIds, 'array<multi,string>', 'string');
            $groupBy = $this->deserialize($groupBy, 'array<multi,string>', 'string');
            $limit = $this->deserialize($limit, 'int', 'string');
            $page = $this->deserialize($page, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($startTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($endTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ '1d' ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($bucketWidth, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($projectIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Choice([ 'project_id', 'line_item' ])
        ]);
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($groupBy, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($limit, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($page, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKeyAuth'
            $handler->setApiKeyAuth($securityApiKeyAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->usageCosts($startTime, $endTime, $bucketWidth, $projectIds, $groupBy, $limit, $page, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Costs data retrieved successfully.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation usageEmbeddings
     *
     * Get embeddings usage details for the organization.
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function usageEmbeddingsAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKeyAuth' required
        // HTTP bearer authentication required
        $securityApiKeyAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $startTime = $request->query->get('startTime');
        $endTime = $request->query->get('endTime');
        $bucketWidth = $request->query->get('bucketWidth', '1d');
        $projectIds = $request->query->get('projectIds');
        $userIds = $request->query->get('userIds');
        $apiKeyIds = $request->query->get('apiKeyIds');
        $models = $request->query->get('models');
        $groupBy = $request->query->get('groupBy');
        $limit = $request->query->get('limit');
        $page = $request->query->get('page');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $startTime = $this->deserialize($startTime, 'int', 'string');
            $endTime = $this->deserialize($endTime, 'int', 'string');
            $bucketWidth = $this->deserialize($bucketWidth, 'string', 'string');
            $projectIds = $this->deserialize($projectIds, 'array<multi,string>', 'string');
            $userIds = $this->deserialize($userIds, 'array<multi,string>', 'string');
            $apiKeyIds = $this->deserialize($apiKeyIds, 'array<multi,string>', 'string');
            $models = $this->deserialize($models, 'array<multi,string>', 'string');
            $groupBy = $this->deserialize($groupBy, 'array<multi,string>', 'string');
            $limit = $this->deserialize($limit, 'int', 'string');
            $page = $this->deserialize($page, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($startTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($endTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ '1m', '1h', '1d' ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($bucketWidth, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($projectIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($userIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($apiKeyIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($models, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Choice([ 'project_id', 'user_id', 'api_key_id', 'model' ])
        ]);
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($groupBy, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($limit, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($page, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKeyAuth'
            $handler->setApiKeyAuth($securityApiKeyAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->usageEmbeddings($startTime, $endTime, $bucketWidth, $projectIds, $userIds, $apiKeyIds, $models, $groupBy, $limit, $page, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Usage data retrieved successfully.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation usageImages
     *
     * Get images usage details for the organization.
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function usageImagesAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKeyAuth' required
        // HTTP bearer authentication required
        $securityApiKeyAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $startTime = $request->query->get('startTime');
        $endTime = $request->query->get('endTime');
        $bucketWidth = $request->query->get('bucketWidth', '1d');
        $sources = $request->query->get('sources');
        $sizes = $request->query->get('sizes');
        $projectIds = $request->query->get('projectIds');
        $userIds = $request->query->get('userIds');
        $apiKeyIds = $request->query->get('apiKeyIds');
        $models = $request->query->get('models');
        $groupBy = $request->query->get('groupBy');
        $limit = $request->query->get('limit');
        $page = $request->query->get('page');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $startTime = $this->deserialize($startTime, 'int', 'string');
            $endTime = $this->deserialize($endTime, 'int', 'string');
            $bucketWidth = $this->deserialize($bucketWidth, 'string', 'string');
            $sources = $this->deserialize($sources, 'array<multi,string>', 'string');
            $sizes = $this->deserialize($sizes, 'array<multi,string>', 'string');
            $projectIds = $this->deserialize($projectIds, 'array<multi,string>', 'string');
            $userIds = $this->deserialize($userIds, 'array<multi,string>', 'string');
            $apiKeyIds = $this->deserialize($apiKeyIds, 'array<multi,string>', 'string');
            $models = $this->deserialize($models, 'array<multi,string>', 'string');
            $groupBy = $this->deserialize($groupBy, 'array<multi,string>', 'string');
            $limit = $this->deserialize($limit, 'int', 'string');
            $page = $this->deserialize($page, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($startTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($endTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ '1m', '1h', '1d' ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($bucketWidth, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Choice([ 'image.generation', 'image.edit', 'image.variation' ])
        ]);
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($sources, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Choice([ '256x256', '512x512', '1024x1024', '1792x1792', '1024x1792' ])
        ]);
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($sizes, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($projectIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($userIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($apiKeyIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($models, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Choice([ 'project_id', 'user_id', 'api_key_id', 'model', 'size', 'source' ])
        ]);
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($groupBy, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($limit, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($page, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKeyAuth'
            $handler->setApiKeyAuth($securityApiKeyAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->usageImages($startTime, $endTime, $bucketWidth, $sources, $sizes, $projectIds, $userIds, $apiKeyIds, $models, $groupBy, $limit, $page, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Usage data retrieved successfully.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation usageModerations
     *
     * Get moderations usage details for the organization.
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function usageModerationsAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKeyAuth' required
        // HTTP bearer authentication required
        $securityApiKeyAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $startTime = $request->query->get('startTime');
        $endTime = $request->query->get('endTime');
        $bucketWidth = $request->query->get('bucketWidth', '1d');
        $projectIds = $request->query->get('projectIds');
        $userIds = $request->query->get('userIds');
        $apiKeyIds = $request->query->get('apiKeyIds');
        $models = $request->query->get('models');
        $groupBy = $request->query->get('groupBy');
        $limit = $request->query->get('limit');
        $page = $request->query->get('page');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $startTime = $this->deserialize($startTime, 'int', 'string');
            $endTime = $this->deserialize($endTime, 'int', 'string');
            $bucketWidth = $this->deserialize($bucketWidth, 'string', 'string');
            $projectIds = $this->deserialize($projectIds, 'array<multi,string>', 'string');
            $userIds = $this->deserialize($userIds, 'array<multi,string>', 'string');
            $apiKeyIds = $this->deserialize($apiKeyIds, 'array<multi,string>', 'string');
            $models = $this->deserialize($models, 'array<multi,string>', 'string');
            $groupBy = $this->deserialize($groupBy, 'array<multi,string>', 'string');
            $limit = $this->deserialize($limit, 'int', 'string');
            $page = $this->deserialize($page, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($startTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($endTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ '1m', '1h', '1d' ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($bucketWidth, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($projectIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($userIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($apiKeyIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($models, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Choice([ 'project_id', 'user_id', 'api_key_id', 'model' ])
        ]);
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($groupBy, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($limit, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($page, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKeyAuth'
            $handler->setApiKeyAuth($securityApiKeyAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->usageModerations($startTime, $endTime, $bucketWidth, $projectIds, $userIds, $apiKeyIds, $models, $groupBy, $limit, $page, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Usage data retrieved successfully.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation usageVectorStores
     *
     * Get vector stores usage details for the organization.
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function usageVectorStoresAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKeyAuth' required
        // HTTP bearer authentication required
        $securityApiKeyAuth = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $startTime = $request->query->get('startTime');
        $endTime = $request->query->get('endTime');
        $bucketWidth = $request->query->get('bucketWidth', '1d');
        $projectIds = $request->query->get('projectIds');
        $groupBy = $request->query->get('groupBy');
        $limit = $request->query->get('limit');
        $page = $request->query->get('page');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $startTime = $this->deserialize($startTime, 'int', 'string');
            $endTime = $this->deserialize($endTime, 'int', 'string');
            $bucketWidth = $this->deserialize($bucketWidth, 'string', 'string');
            $projectIds = $this->deserialize($projectIds, 'array<multi,string>', 'string');
            $groupBy = $this->deserialize($groupBy, 'array<multi,string>', 'string');
            $limit = $this->deserialize($limit, 'int', 'string');
            $page = $this->deserialize($page, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($startTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($endTime, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ '1m', '1h', '1d' ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($bucketWidth, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($projectIds, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Choice([ 'project_id' ])
        ]);
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($groupBy, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($limit, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($page, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKeyAuth'
            $handler->setApiKeyAuth($securityApiKeyAuth);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->usageVectorStores($startTime, $endTime, $bucketWidth, $projectIds, $groupBy, $limit, $page, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Usage data retrieved successfully.',
                default => '',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Returns the handler for this API controller.
     * @return UsageApiInterface
     */
    public function getApiHandler()
    {
        return $this->apiServer->getApiHandler('usage');
    }
}
