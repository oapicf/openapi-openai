<?php
/**
 * Batch
 *
 * PHP version 8.1.1
 *
 * @category Class
 * @package  OpenAPI\Server\Model
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */

/**
 * OpenAI API
 *
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 *
 */

/**
 * NOTE: This class is auto generated by the openapi generator program.
 * https://github.com/openapitools/openapi-generator
 * Do not edit the class manually.
 */

namespace OpenAPI\Server\Model;

use Symfony\Component\Validator\Constraints as Assert;
use JMS\Serializer\Annotation\Type;
use JMS\Serializer\Annotation\Accessor;
use JMS\Serializer\Annotation\SerializedName;

/**
 * Class representing the Batch model.
 *
 * @package OpenAPI\Server\Model
 * @author  OpenAPI Generator team
 */

class Batch 
{
        /**
     * @var string|null
     * @SerializedName("id")
     * @Type("string")
    */
    #[Assert\NotNull]
    #[Assert\Type("string")]
    protected ?string $id = null;

    /**
     * The object type, which is always &#x60;batch&#x60;.
     *
     * @var string|null
     * @SerializedName("object")
     * @Type("string")
    */
    #[Assert\NotNull]
    #[Assert\Choice(['batch'])]
    #[Assert\Type("string")]
    protected ?string $object = null;

    /**
     * The OpenAI API endpoint used by the batch.
     *
     * @var string|null
     * @SerializedName("endpoint")
     * @Type("string")
    */
    #[Assert\NotNull]
    #[Assert\Type("string")]
    protected ?string $endpoint = null;

    /**
     * @var BatchErrors|null
     * @SerializedName("errors")
     * @Type("OpenAPI\Server\Model\BatchErrors")
    */
    #[Assert\Type("OpenAPI\Server\Model\BatchErrors")]
    protected ?BatchErrors $errors = null;

    /**
     * The ID of the input file for the batch.
     *
     * @var string|null
     * @SerializedName("input_file_id")
     * @Type("string")
    */
    #[Assert\NotNull]
    #[Assert\Type("string")]
    protected ?string $inputFileId = null;

    /**
     * The time frame within which the batch should be processed.
     *
     * @var string|null
     * @SerializedName("completion_window")
     * @Type("string")
    */
    #[Assert\NotNull]
    #[Assert\Type("string")]
    protected ?string $completionWindow = null;

    /**
     * The current status of the batch.
     *
     * @var string|null
     * @SerializedName("status")
     * @Type("string")
    */
    #[Assert\NotNull]
    #[Assert\Choice(['validating', 'failed', 'in_progress', 'finalizing', 'completed', 'expired', 'cancelling', 'cancelled'])]
    #[Assert\Type("string")]
    protected ?string $status = null;

    /**
     * The ID of the file containing the outputs of successfully executed requests.
     *
     * @var string|null
     * @SerializedName("output_file_id")
     * @Type("string")
    */
    #[Assert\Type("string")]
    protected ?string $outputFileId = null;

    /**
     * The ID of the file containing the outputs of requests with errors.
     *
     * @var string|null
     * @SerializedName("error_file_id")
     * @Type("string")
    */
    #[Assert\Type("string")]
    protected ?string $errorFileId = null;

    /**
     * The Unix timestamp (in seconds) for when the batch was created.
     *
     * @var int|null
     * @SerializedName("created_at")
     * @Type("int")
    */
    #[Assert\NotNull]
    #[Assert\Type("int")]
    protected ?int $createdAt = null;

    /**
     * The Unix timestamp (in seconds) for when the batch started processing.
     *
     * @var int|null
     * @SerializedName("in_progress_at")
     * @Type("int")
    */
    #[Assert\Type("int")]
    protected ?int $inProgressAt = null;

    /**
     * The Unix timestamp (in seconds) for when the batch will expire.
     *
     * @var int|null
     * @SerializedName("expires_at")
     * @Type("int")
    */
    #[Assert\Type("int")]
    protected ?int $expiresAt = null;

    /**
     * The Unix timestamp (in seconds) for when the batch started finalizing.
     *
     * @var int|null
     * @SerializedName("finalizing_at")
     * @Type("int")
    */
    #[Assert\Type("int")]
    protected ?int $finalizingAt = null;

    /**
     * The Unix timestamp (in seconds) for when the batch was completed.
     *
     * @var int|null
     * @SerializedName("completed_at")
     * @Type("int")
    */
    #[Assert\Type("int")]
    protected ?int $completedAt = null;

    /**
     * The Unix timestamp (in seconds) for when the batch failed.
     *
     * @var int|null
     * @SerializedName("failed_at")
     * @Type("int")
    */
    #[Assert\Type("int")]
    protected ?int $failedAt = null;

    /**
     * The Unix timestamp (in seconds) for when the batch expired.
     *
     * @var int|null
     * @SerializedName("expired_at")
     * @Type("int")
    */
    #[Assert\Type("int")]
    protected ?int $expiredAt = null;

    /**
     * The Unix timestamp (in seconds) for when the batch started cancelling.
     *
     * @var int|null
     * @SerializedName("cancelling_at")
     * @Type("int")
    */
    #[Assert\Type("int")]
    protected ?int $cancellingAt = null;

    /**
     * The Unix timestamp (in seconds) for when the batch was cancelled.
     *
     * @var int|null
     * @SerializedName("cancelled_at")
     * @Type("int")
    */
    #[Assert\Type("int")]
    protected ?int $cancelledAt = null;

    /**
     * @var BatchRequestCounts|null
     * @SerializedName("request_counts")
     * @Type("OpenAPI\Server\Model\BatchRequestCounts")
    */
    #[Assert\Type("OpenAPI\Server\Model\BatchRequestCounts")]
    protected ?BatchRequestCounts $requestCounts = null;

    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
     *
     * @var array|null
     * @SerializedName("metadata")
     * @Type("array")
    */
    #[Assert\Type("array")]
    protected ?array $metadata = null;

    /**
     * Constructor
     * @param array|null $data Associated array of property values initializing the model
     */
    public function __construct(?array $data = null)
    {
        if (is_array($data)) {
            $this->id = array_key_exists('id', $data) ? $data['id'] : $this->id;
            $this->object = array_key_exists('object', $data) ? $data['object'] : $this->object;
            $this->endpoint = array_key_exists('endpoint', $data) ? $data['endpoint'] : $this->endpoint;
            $this->errors = array_key_exists('errors', $data) ? $data['errors'] : $this->errors;
            $this->inputFileId = array_key_exists('inputFileId', $data) ? $data['inputFileId'] : $this->inputFileId;
            $this->completionWindow = array_key_exists('completionWindow', $data) ? $data['completionWindow'] : $this->completionWindow;
            $this->status = array_key_exists('status', $data) ? $data['status'] : $this->status;
            $this->outputFileId = array_key_exists('outputFileId', $data) ? $data['outputFileId'] : $this->outputFileId;
            $this->errorFileId = array_key_exists('errorFileId', $data) ? $data['errorFileId'] : $this->errorFileId;
            $this->createdAt = array_key_exists('createdAt', $data) ? $data['createdAt'] : $this->createdAt;
            $this->inProgressAt = array_key_exists('inProgressAt', $data) ? $data['inProgressAt'] : $this->inProgressAt;
            $this->expiresAt = array_key_exists('expiresAt', $data) ? $data['expiresAt'] : $this->expiresAt;
            $this->finalizingAt = array_key_exists('finalizingAt', $data) ? $data['finalizingAt'] : $this->finalizingAt;
            $this->completedAt = array_key_exists('completedAt', $data) ? $data['completedAt'] : $this->completedAt;
            $this->failedAt = array_key_exists('failedAt', $data) ? $data['failedAt'] : $this->failedAt;
            $this->expiredAt = array_key_exists('expiredAt', $data) ? $data['expiredAt'] : $this->expiredAt;
            $this->cancellingAt = array_key_exists('cancellingAt', $data) ? $data['cancellingAt'] : $this->cancellingAt;
            $this->cancelledAt = array_key_exists('cancelledAt', $data) ? $data['cancelledAt'] : $this->cancelledAt;
            $this->requestCounts = array_key_exists('requestCounts', $data) ? $data['requestCounts'] : $this->requestCounts;
            $this->metadata = array_key_exists('metadata', $data) ? $data['metadata'] : $this->metadata;
        }
    }

    /**
     * Gets id.
     *
     * @return string|null
     */
    public function getId(): ?string
    {
        return $this->id;
    }

    /**
    * Sets id.
    *
    * @param string|null $id
    *
    * @return $this
    */
    public function setId(?string $id): self
    {
        $this->id = $id;

        return $this;
    }




    /**
     * Gets object.
     *
     * @return string|null
     */
    public function getObject(): ?string
    {
        return $this->object;
    }

    /**
    * Sets object.
    *
    * @param string|null $object  The object type, which is always `batch`.
    *
    * @return $this
    */
    public function setObject(?string $object): self
    {
        $this->object = $object;

        return $this;
    }




    /**
     * Gets endpoint.
     *
     * @return string|null
     */
    public function getEndpoint(): ?string
    {
        return $this->endpoint;
    }

    /**
    * Sets endpoint.
    *
    * @param string|null $endpoint  The OpenAI API endpoint used by the batch.
    *
    * @return $this
    */
    public function setEndpoint(?string $endpoint): self
    {
        $this->endpoint = $endpoint;

        return $this;
    }




    /**
     * Gets errors.
     *
     * @return BatchErrors|null
     */
    public function getErrors(): ?BatchErrors
    {
        return $this->errors;
    }

    /**
    * Sets errors.
    *
    * @param BatchErrors|null $errors
    *
    * @return $this
    */
    public function setErrors(?BatchErrors $errors = null): self
    {
        $this->errors = $errors;

        return $this;
    }




    /**
     * Gets inputFileId.
     *
     * @return string|null
     */
    public function getInputFileId(): ?string
    {
        return $this->inputFileId;
    }

    /**
    * Sets inputFileId.
    *
    * @param string|null $inputFileId  The ID of the input file for the batch.
    *
    * @return $this
    */
    public function setInputFileId(?string $inputFileId): self
    {
        $this->inputFileId = $inputFileId;

        return $this;
    }




    /**
     * Gets completionWindow.
     *
     * @return string|null
     */
    public function getCompletionWindow(): ?string
    {
        return $this->completionWindow;
    }

    /**
    * Sets completionWindow.
    *
    * @param string|null $completionWindow  The time frame within which the batch should be processed.
    *
    * @return $this
    */
    public function setCompletionWindow(?string $completionWindow): self
    {
        $this->completionWindow = $completionWindow;

        return $this;
    }




    /**
     * Gets status.
     *
     * @return string|null
     */
    public function getStatus(): ?string
    {
        return $this->status;
    }

    /**
    * Sets status.
    *
    * @param string|null $status  The current status of the batch.
    *
    * @return $this
    */
    public function setStatus(?string $status): self
    {
        $this->status = $status;

        return $this;
    }




    /**
     * Gets outputFileId.
     *
     * @return string|null
     */
    public function getOutputFileId(): ?string
    {
        return $this->outputFileId;
    }

    /**
    * Sets outputFileId.
    *
    * @param string|null $outputFileId  The ID of the file containing the outputs of successfully executed requests.
    *
    * @return $this
    */
    public function setOutputFileId(?string $outputFileId = null): self
    {
        $this->outputFileId = $outputFileId;

        return $this;
    }




    /**
     * Gets errorFileId.
     *
     * @return string|null
     */
    public function getErrorFileId(): ?string
    {
        return $this->errorFileId;
    }

    /**
    * Sets errorFileId.
    *
    * @param string|null $errorFileId  The ID of the file containing the outputs of requests with errors.
    *
    * @return $this
    */
    public function setErrorFileId(?string $errorFileId = null): self
    {
        $this->errorFileId = $errorFileId;

        return $this;
    }




    /**
     * Gets createdAt.
     *
     * @return int|null
     */
    public function getCreatedAt(): ?int
    {
        return $this->createdAt;
    }

    /**
    * Sets createdAt.
    *
    * @param int|null $createdAt  The Unix timestamp (in seconds) for when the batch was created.
    *
    * @return $this
    */
    public function setCreatedAt(?int $createdAt): self
    {
        $this->createdAt = $createdAt;

        return $this;
    }




    /**
     * Gets inProgressAt.
     *
     * @return int|null
     */
    public function getInProgressAt(): ?int
    {
        return $this->inProgressAt;
    }

    /**
    * Sets inProgressAt.
    *
    * @param int|null $inProgressAt  The Unix timestamp (in seconds) for when the batch started processing.
    *
    * @return $this
    */
    public function setInProgressAt(?int $inProgressAt = null): self
    {
        $this->inProgressAt = $inProgressAt;

        return $this;
    }




    /**
     * Gets expiresAt.
     *
     * @return int|null
     */
    public function getExpiresAt(): ?int
    {
        return $this->expiresAt;
    }

    /**
    * Sets expiresAt.
    *
    * @param int|null $expiresAt  The Unix timestamp (in seconds) for when the batch will expire.
    *
    * @return $this
    */
    public function setExpiresAt(?int $expiresAt = null): self
    {
        $this->expiresAt = $expiresAt;

        return $this;
    }




    /**
     * Gets finalizingAt.
     *
     * @return int|null
     */
    public function getFinalizingAt(): ?int
    {
        return $this->finalizingAt;
    }

    /**
    * Sets finalizingAt.
    *
    * @param int|null $finalizingAt  The Unix timestamp (in seconds) for when the batch started finalizing.
    *
    * @return $this
    */
    public function setFinalizingAt(?int $finalizingAt = null): self
    {
        $this->finalizingAt = $finalizingAt;

        return $this;
    }




    /**
     * Gets completedAt.
     *
     * @return int|null
     */
    public function getCompletedAt(): ?int
    {
        return $this->completedAt;
    }

    /**
    * Sets completedAt.
    *
    * @param int|null $completedAt  The Unix timestamp (in seconds) for when the batch was completed.
    *
    * @return $this
    */
    public function setCompletedAt(?int $completedAt = null): self
    {
        $this->completedAt = $completedAt;

        return $this;
    }




    /**
     * Gets failedAt.
     *
     * @return int|null
     */
    public function getFailedAt(): ?int
    {
        return $this->failedAt;
    }

    /**
    * Sets failedAt.
    *
    * @param int|null $failedAt  The Unix timestamp (in seconds) for when the batch failed.
    *
    * @return $this
    */
    public function setFailedAt(?int $failedAt = null): self
    {
        $this->failedAt = $failedAt;

        return $this;
    }




    /**
     * Gets expiredAt.
     *
     * @return int|null
     */
    public function getExpiredAt(): ?int
    {
        return $this->expiredAt;
    }

    /**
    * Sets expiredAt.
    *
    * @param int|null $expiredAt  The Unix timestamp (in seconds) for when the batch expired.
    *
    * @return $this
    */
    public function setExpiredAt(?int $expiredAt = null): self
    {
        $this->expiredAt = $expiredAt;

        return $this;
    }




    /**
     * Gets cancellingAt.
     *
     * @return int|null
     */
    public function getCancellingAt(): ?int
    {
        return $this->cancellingAt;
    }

    /**
    * Sets cancellingAt.
    *
    * @param int|null $cancellingAt  The Unix timestamp (in seconds) for when the batch started cancelling.
    *
    * @return $this
    */
    public function setCancellingAt(?int $cancellingAt = null): self
    {
        $this->cancellingAt = $cancellingAt;

        return $this;
    }




    /**
     * Gets cancelledAt.
     *
     * @return int|null
     */
    public function getCancelledAt(): ?int
    {
        return $this->cancelledAt;
    }

    /**
    * Sets cancelledAt.
    *
    * @param int|null $cancelledAt  The Unix timestamp (in seconds) for when the batch was cancelled.
    *
    * @return $this
    */
    public function setCancelledAt(?int $cancelledAt = null): self
    {
        $this->cancelledAt = $cancelledAt;

        return $this;
    }




    /**
     * Gets requestCounts.
     *
     * @return BatchRequestCounts|null
     */
    public function getRequestCounts(): ?BatchRequestCounts
    {
        return $this->requestCounts;
    }

    /**
    * Sets requestCounts.
    *
    * @param BatchRequestCounts|null $requestCounts
    *
    * @return $this
    */
    public function setRequestCounts(?BatchRequestCounts $requestCounts = null): self
    {
        $this->requestCounts = $requestCounts;

        return $this;
    }




    /**
     * Gets metadata.
     *
     * @return array|null
     */
    public function getMetadata(): ?array
    {
        return $this->metadata;
    }

    /**
    * Sets metadata.
    *
    * @param array|null $metadata  Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
    *
    * @return $this
    */
    public function setMetadata(?array $metadata = null): self
    {
        $this->metadata = $metadata;

        return $this;
    }



}


