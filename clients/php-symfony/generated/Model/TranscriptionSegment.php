<?php
/**
 * TranscriptionSegment
 *
 * PHP version 8.1.1
 *
 * @category Class
 * @package  OpenAPI\Server\Model
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */

/**
 * OpenAI API
 *
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: blah+oapicf@cliffano.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 *
 */

/**
 * NOTE: This class is auto generated by the openapi generator program.
 * https://github.com/openapitools/openapi-generator
 * Do not edit the class manually.
 */

namespace OpenAPI\Server\Model;

use Symfony\Component\Validator\Constraints as Assert;
use JMS\Serializer\Annotation\Type;
use JMS\Serializer\Annotation\Accessor;
use JMS\Serializer\Annotation\SerializedName;

/**
 * Class representing the TranscriptionSegment model.
 *
 * @package OpenAPI\Server\Model
 * @author  OpenAPI Generator team
 */

class TranscriptionSegment 
{
        /**
     * Unique identifier of the segment.
     *
     * @var int|null
     * @SerializedName("id")
     * @Type("int")
    */
    #[Assert\NotNull]
    #[Assert\Type("int")]
    protected ?int $id = null;

    /**
     * Seek offset of the segment.
     *
     * @var int|null
     * @SerializedName("seek")
     * @Type("int")
    */
    #[Assert\NotNull]
    #[Assert\Type("int")]
    protected ?int $seek = null;

    /**
     * Start time of the segment in seconds.
     *
     * @var float|null
     * @SerializedName("start")
     * @Type("float")
    */
    #[Assert\NotNull]
    #[Assert\Type("float")]
    protected ?float $start = null;

    /**
     * End time of the segment in seconds.
     *
     * @var float|null
     * @SerializedName("end")
     * @Type("float")
    */
    #[Assert\NotNull]
    #[Assert\Type("float")]
    protected ?float $end = null;

    /**
     * Text content of the segment.
     *
     * @var string|null
     * @SerializedName("text")
     * @Type("string")
    */
    #[Assert\NotNull]
    #[Assert\Type("string")]
    protected ?string $text = null;

    /**
     * Array of token IDs for the text content.
     *
     * @var int[]|null
     * @SerializedName("tokens")
     * @Type("array<int>")
    */
    #[Assert\NotNull]
    #[Assert\All([
        new Assert\Type("int"),
    ])]
    protected ?array $tokens = null;

    /**
     * Temperature parameter used for generating the segment.
     *
     * @var float|null
     * @SerializedName("temperature")
     * @Type("float")
    */
    #[Assert\NotNull]
    #[Assert\Type("float")]
    protected ?float $temperature = null;

    /**
     * Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.
     *
     * @var float|null
     * @SerializedName("avg_logprob")
     * @Type("float")
    */
    #[Assert\NotNull]
    #[Assert\Type("float")]
    protected ?float $avgLogprob = null;

    /**
     * Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.
     *
     * @var float|null
     * @SerializedName("compression_ratio")
     * @Type("float")
    */
    #[Assert\NotNull]
    #[Assert\Type("float")]
    protected ?float $compressionRatio = null;

    /**
     * Probability of no speech in the segment. If the value is higher than 1.0 and the &#x60;avg_logprob&#x60; is below -1, consider this segment silent.
     *
     * @var float|null
     * @SerializedName("no_speech_prob")
     * @Type("float")
    */
    #[Assert\NotNull]
    #[Assert\Type("float")]
    protected ?float $noSpeechProb = null;

    /**
     * Constructor
     * @param array|null $data Associated array of property values initializing the model
     */
    public function __construct(?array $data = null)
    {
        if (is_array($data)) {
            $this->id = array_key_exists('id', $data) ? $data['id'] : $this->id;
            $this->seek = array_key_exists('seek', $data) ? $data['seek'] : $this->seek;
            $this->start = array_key_exists('start', $data) ? $data['start'] : $this->start;
            $this->end = array_key_exists('end', $data) ? $data['end'] : $this->end;
            $this->text = array_key_exists('text', $data) ? $data['text'] : $this->text;
            $this->tokens = array_key_exists('tokens', $data) ? $data['tokens'] : $this->tokens;
            $this->temperature = array_key_exists('temperature', $data) ? $data['temperature'] : $this->temperature;
            $this->avgLogprob = array_key_exists('avgLogprob', $data) ? $data['avgLogprob'] : $this->avgLogprob;
            $this->compressionRatio = array_key_exists('compressionRatio', $data) ? $data['compressionRatio'] : $this->compressionRatio;
            $this->noSpeechProb = array_key_exists('noSpeechProb', $data) ? $data['noSpeechProb'] : $this->noSpeechProb;
        }
    }

    /**
     * Gets id.
     *
     * @return int|null
     */
    public function getId(): ?int
    {
        return $this->id;
    }

    /**
    * Sets id.
    *
    * @param int|null $id  Unique identifier of the segment.
    *
    * @return $this
    */
    public function setId(?int $id): self
    {
        $this->id = $id;

        return $this;
    }




    /**
     * Gets seek.
     *
     * @return int|null
     */
    public function getSeek(): ?int
    {
        return $this->seek;
    }

    /**
    * Sets seek.
    *
    * @param int|null $seek  Seek offset of the segment.
    *
    * @return $this
    */
    public function setSeek(?int $seek): self
    {
        $this->seek = $seek;

        return $this;
    }




    /**
     * Gets start.
     *
     * @return float|null
     */
    public function getStart(): ?float
    {
        return $this->start;
    }

    /**
    * Sets start.
    *
    * @param float|null $start  Start time of the segment in seconds.
    *
    * @return $this
    */
    public function setStart(?float $start): self
    {
        $this->start = $start;

        return $this;
    }




    /**
     * Gets end.
     *
     * @return float|null
     */
    public function getEnd(): ?float
    {
        return $this->end;
    }

    /**
    * Sets end.
    *
    * @param float|null $end  End time of the segment in seconds.
    *
    * @return $this
    */
    public function setEnd(?float $end): self
    {
        $this->end = $end;

        return $this;
    }




    /**
     * Gets text.
     *
     * @return string|null
     */
    public function getText(): ?string
    {
        return $this->text;
    }

    /**
    * Sets text.
    *
    * @param string|null $text  Text content of the segment.
    *
    * @return $this
    */
    public function setText(?string $text): self
    {
        $this->text = $text;

        return $this;
    }




    /**
     * Gets tokens.
     *
     * @return int[]|null
     */
    public function getTokens(): ?array
    {
        return $this->tokens;
    }

    /**
    * Sets tokens.
    *
    * @param int[]|null $tokens  Array of token IDs for the text content.
    *
    * @return $this
    */
    public function setTokens(?array $tokens): self
    {
        $this->tokens = $tokens;

        return $this;
    }




    /**
     * Gets temperature.
     *
     * @return float|null
     */
    public function getTemperature(): ?float
    {
        return $this->temperature;
    }

    /**
    * Sets temperature.
    *
    * @param float|null $temperature  Temperature parameter used for generating the segment.
    *
    * @return $this
    */
    public function setTemperature(?float $temperature): self
    {
        $this->temperature = $temperature;

        return $this;
    }




    /**
     * Gets avgLogprob.
     *
     * @return float|null
     */
    public function getAvgLogprob(): ?float
    {
        return $this->avgLogprob;
    }

    /**
    * Sets avgLogprob.
    *
    * @param float|null $avgLogprob  Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.
    *
    * @return $this
    */
    public function setAvgLogprob(?float $avgLogprob): self
    {
        $this->avgLogprob = $avgLogprob;

        return $this;
    }




    /**
     * Gets compressionRatio.
     *
     * @return float|null
     */
    public function getCompressionRatio(): ?float
    {
        return $this->compressionRatio;
    }

    /**
    * Sets compressionRatio.
    *
    * @param float|null $compressionRatio  Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.
    *
    * @return $this
    */
    public function setCompressionRatio(?float $compressionRatio): self
    {
        $this->compressionRatio = $compressionRatio;

        return $this;
    }




    /**
     * Gets noSpeechProb.
     *
     * @return float|null
     */
    public function getNoSpeechProb(): ?float
    {
        return $this->noSpeechProb;
    }

    /**
    * Sets noSpeechProb.
    *
    * @param float|null $noSpeechProb  Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent.
    *
    * @return $this
    */
    public function setNoSpeechProb(?float $noSpeechProb): self
    {
        $this->noSpeechProb = $noSpeechProb;

        return $this;
    }



}


