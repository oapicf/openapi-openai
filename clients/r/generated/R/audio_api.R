#' OpenAI API
#'
#' The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
#'
#' The version of the OpenAPI document: 2.0.0
#' Contact: blah+oapicf@cliffano.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Audio operations
#' @description AudioApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  CreateSpeech  ####################
#'
#' library(openapi)
#' var_create_speech_request <- CreateSpeechRequest$new(CreateSpeechRequest_model$new(), "input_example", "alloy", "mp3", 123) # CreateSpeechRequest | 
#'
#' #Generates audio from the input text.
#' api_instance <- AudioApi$new()
#'
#' # Configure HTTP bearer authorization: ApiKeyAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateSpeech(var_create_speech_requestdata_file = "result.txt")
#' result <- api_instance$CreateSpeech(var_create_speech_request)
#' dput(result)
#'
#'
#' ####################  CreateTranscription  ####################
#'
#' library(openapi)
#' var_file <- File.new('/path/to/file') # data.frame | The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. 
#' var_model <- CreateTranscriptionRequest_model$new() # CreateTranscriptionRequestModel | 
#' var_language <- "language_example" # character | The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.  (Optional)
#' var_prompt <- "prompt_example" # character | An optional text to guide the model's style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.  (Optional)
#' var_response_format <- "json" # character | The format of the transcript output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.  (Optional)
#' var_temperature <- 0 # numeric | The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.  (Optional)
#' var_timestamp_granularities <- c("word") # array[character] | The timestamp granularities to populate for this transcription. `response_format` must be set `verbose_json` to use timestamp granularities. Either or both of these options are supported: `word`, or `segment`. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency.  (Optional)
#'
#' #Transcribes audio into the input language.
#' api_instance <- AudioApi$new()
#'
#' # Configure HTTP bearer authorization: ApiKeyAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateTranscription(var_file, var_model, language = var_language, prompt = var_prompt, response_format = var_response_format, temperature = var_temperature, timestamp_granularities = var_timestamp_granularitiesdata_file = "result.txt")
#' result <- api_instance$CreateTranscription(var_file, var_model, language = var_language, prompt = var_prompt, response_format = var_response_format, temperature = var_temperature, timestamp_granularities = var_timestamp_granularities)
#' dput(result)
#'
#'
#' ####################  CreateTranslation  ####################
#'
#' library(openapi)
#' var_file <- File.new('/path/to/file') # data.frame | The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. 
#' var_model <- CreateTranscriptionRequest_model$new() # CreateTranscriptionRequestModel | 
#' var_prompt <- "prompt_example" # character | An optional text to guide the model's style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.  (Optional)
#' var_response_format <- "json" # character | The format of the transcript output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.  (Optional)
#' var_temperature <- 0 # numeric | The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.  (Optional)
#'
#' #Translates audio into English.
#' api_instance <- AudioApi$new()
#'
#' # Configure HTTP bearer authorization: ApiKeyAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateTranslation(var_file, var_model, prompt = var_prompt, response_format = var_response_format, temperature = var_temperaturedata_file = "result.txt")
#' result <- api_instance$CreateTranslation(var_file, var_model, prompt = var_prompt, response_format = var_response_format, temperature = var_temperature)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
AudioApi <- R6::R6Class(
  "AudioApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new AudioApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Generates audio from the input text.
    #'
    #' @param create_speech_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return data.frame
    CreateSpeech = function(create_speech_request, data_file = NULL, ...) {
      local_var_response <- self$CreateSpeechWithHttpInfo(create_speech_request, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Generates audio from the input text.
    #'
    #' @param create_speech_request 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (data.frame) with additional information such as HTTP status code, headers
    CreateSpeechWithHttpInfo = function(create_speech_request, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`create_speech_request`)) {
        stop("Missing required parameter `create_speech_request`.")
      }

      if (!missing(`create_speech_request`) && is.null(`create_speech_request`)) {
        stop("Invalid value for `create_speech_request` when calling AudioApi$CreateSpeech, `create_speech_request` is not nullable")
      }

      if (!is.null(`create_speech_request`)) {
        local_var_body <- `create_speech_request`$toJSONString()
      } else {
        local_var_body <- NULL
      }

      local_var_url_path <- "/audio/speech"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/octet-stream")

      # The Content-Type representation header
      local_var_content_types <- list("application/json")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "data.frame"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Transcribes audio into the input language.
    #'
    #' @param file The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. 
    #' @param model 
    #' @param language (optional) The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency. 
    #' @param prompt (optional) An optional text to guide the model's style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language. 
    #' @param response_format (optional) The format of the transcript output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.  (default value: "json")
    #' @param temperature (optional) The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.  (default value: 0)
    #' @param timestamp_granularities (optional) The timestamp granularities to populate for this transcription. `response_format` must be set `verbose_json` to use timestamp granularities. Either or both of these options are supported: `word`, or `segment`. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency. 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return CreateTranscription200Response
    CreateTranscription = function(file, model, language = NULL, prompt = NULL, response_format = "json", temperature = 0, timestamp_granularities = NULL, data_file = NULL, ...) {
      local_var_response <- self$CreateTranscriptionWithHttpInfo(file, model, language, prompt, response_format, temperature, timestamp_granularities, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Transcribes audio into the input language.
    #'
    #' @param file The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. 
    #' @param model 
    #' @param language (optional) The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency. 
    #' @param prompt (optional) An optional text to guide the model's style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language. 
    #' @param response_format (optional) The format of the transcript output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.  (default value: "json")
    #' @param temperature (optional) The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.  (default value: 0)
    #' @param timestamp_granularities (optional) The timestamp granularities to populate for this transcription. `response_format` must be set `verbose_json` to use timestamp granularities. Either or both of these options are supported: `word`, or `segment`. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency. 
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (CreateTranscription200Response) with additional information such as HTTP status code, headers
    CreateTranscriptionWithHttpInfo = function(file, model, language = NULL, prompt = NULL, response_format = "json", temperature = 0, timestamp_granularities = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`file`)) {
        stop("Missing required parameter `file`.")
      }

      if (missing(`model`)) {
        stop("Missing required parameter `model`.")
      }

      if (!missing(`file`) && is.null(`file`)) {
        stop("Invalid value for `file` when calling AudioApi$CreateTranscription, `file` is not nullable")
      }

      if (!missing(`model`) && is.null(`model`)) {
        stop("Invalid value for `model` when calling AudioApi$CreateTranscription, `model` is not nullable")
      }

      if (!missing(`language`) && is.null(`language`)) {
        stop("Invalid value for `language` when calling AudioApi$CreateTranscription, `language` is not nullable")
      }

      if (!missing(`prompt`) && is.null(`prompt`)) {
        stop("Invalid value for `prompt` when calling AudioApi$CreateTranscription, `prompt` is not nullable")
      }

      if (!missing(`response_format`) && is.null(`response_format`)) {
        stop("Invalid value for `response_format` when calling AudioApi$CreateTranscription, `response_format` is not nullable")
      }

      if (!missing(`temperature`) && is.null(`temperature`)) {
        stop("Invalid value for `temperature` when calling AudioApi$CreateTranscription, `temperature` is not nullable")
      }

      if (!missing(`timestamp_granularities`) && is.null(`timestamp_granularities`)) {
        stop("Invalid value for `timestamp_granularities` when calling AudioApi$CreateTranscription, `timestamp_granularities` is not nullable")
      }

      file_params["file"] <- httr::upload_file(`file`)
      form_params["model"] <- `model`
      form_params["language"] <- `language`
      form_params["prompt"] <- `prompt`
      form_params["response_format"] <- `response_format`
      form_params["temperature"] <- `temperature`
      form_params["timestamp_granularities[]"] <- `timestamp_granularities`
      local_var_url_path <- "/audio/transcriptions"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list("multipart/form-data")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "CreateTranscription200Response"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Translates audio into English.
    #'
    #' @param file The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. 
    #' @param model 
    #' @param prompt (optional) An optional text to guide the model's style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English. 
    #' @param response_format (optional) The format of the transcript output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.  (default value: "json")
    #' @param temperature (optional) The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.  (default value: 0)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return CreateTranslation200Response
    CreateTranslation = function(file, model, prompt = NULL, response_format = "json", temperature = 0, data_file = NULL, ...) {
      local_var_response <- self$CreateTranslationWithHttpInfo(file, model, prompt, response_format, temperature, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Translates audio into English.
    #'
    #' @param file The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. 
    #' @param model 
    #' @param prompt (optional) An optional text to guide the model's style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English. 
    #' @param response_format (optional) The format of the transcript output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.  (default value: "json")
    #' @param temperature (optional) The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.  (default value: 0)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (CreateTranslation200Response) with additional information such as HTTP status code, headers
    CreateTranslationWithHttpInfo = function(file, model, prompt = NULL, response_format = "json", temperature = 0, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`file`)) {
        stop("Missing required parameter `file`.")
      }

      if (missing(`model`)) {
        stop("Missing required parameter `model`.")
      }

      if (!missing(`file`) && is.null(`file`)) {
        stop("Invalid value for `file` when calling AudioApi$CreateTranslation, `file` is not nullable")
      }

      if (!missing(`model`) && is.null(`model`)) {
        stop("Invalid value for `model` when calling AudioApi$CreateTranslation, `model` is not nullable")
      }

      if (!missing(`prompt`) && is.null(`prompt`)) {
        stop("Invalid value for `prompt` when calling AudioApi$CreateTranslation, `prompt` is not nullable")
      }

      if (!missing(`response_format`) && is.null(`response_format`)) {
        stop("Invalid value for `response_format` when calling AudioApi$CreateTranslation, `response_format` is not nullable")
      }

      if (!missing(`temperature`) && is.null(`temperature`)) {
        stop("Invalid value for `temperature` when calling AudioApi$CreateTranslation, `temperature` is not nullable")
      }

      file_params["file"] <- httr::upload_file(`file`)
      form_params["model"] <- `model`
      form_params["prompt"] <- `prompt`
      form_params["response_format"] <- `response_format`
      form_params["temperature"] <- `temperature`
      local_var_url_path <- "/audio/translations"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list("multipart/form-data")

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "CreateTranslation200Response"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
