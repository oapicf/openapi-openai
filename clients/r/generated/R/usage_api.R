#' OpenAI API
#'
#' The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
#'
#' The version of the OpenAPI document: 2.3.0
#' Contact: blah+oapicf@cliffano.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Usage operations
#' @description UsageApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  UsageAudioSpeeches  ####################
#'
#' library(openapi)
#' var_start_time <- 56 # integer | Start time (Unix seconds) of the query time range, inclusive.
#' var_end_time <- 56 # integer | End time (Unix seconds) of the query time range, exclusive. (Optional)
#' var_bucket_width <- "1d" # character | Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (Optional)
#' var_project_ids <- c("inner_example") # array[character] | Return only usage for these projects. (Optional)
#' var_user_ids <- c("inner_example") # array[character] | Return only usage for these users. (Optional)
#' var_api_key_ids <- c("inner_example") # array[character] | Return only usage for these API keys. (Optional)
#' var_models <- c("inner_example") # array[character] | Return only usage for these models. (Optional)
#' var_group_by <- c("project_id") # array[character] | Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them. (Optional)
#' var_limit <- 56 # integer | Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440  (Optional)
#' var_page <- "page_example" # character | A cursor for use in pagination. Corresponding to the `next_page` field from the previous response. (Optional)
#'
#' #Get audio speeches usage details for the organization.
#' api_instance <- UsageApi$new()
#'
#' # Configure HTTP bearer authorization: ApiKeyAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UsageAudioSpeeches(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, user_ids = var_user_ids, api_key_ids = var_api_key_ids, models = var_models, group_by = var_group_by, limit = var_limit, page = var_pagedata_file = "result.txt")
#' result <- api_instance$UsageAudioSpeeches(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, user_ids = var_user_ids, api_key_ids = var_api_key_ids, models = var_models, group_by = var_group_by, limit = var_limit, page = var_page)
#' dput(result)
#'
#'
#' ####################  UsageAudioTranscriptions  ####################
#'
#' library(openapi)
#' var_start_time <- 56 # integer | Start time (Unix seconds) of the query time range, inclusive.
#' var_end_time <- 56 # integer | End time (Unix seconds) of the query time range, exclusive. (Optional)
#' var_bucket_width <- "1d" # character | Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (Optional)
#' var_project_ids <- c("inner_example") # array[character] | Return only usage for these projects. (Optional)
#' var_user_ids <- c("inner_example") # array[character] | Return only usage for these users. (Optional)
#' var_api_key_ids <- c("inner_example") # array[character] | Return only usage for these API keys. (Optional)
#' var_models <- c("inner_example") # array[character] | Return only usage for these models. (Optional)
#' var_group_by <- c("project_id") # array[character] | Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them. (Optional)
#' var_limit <- 56 # integer | Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440  (Optional)
#' var_page <- "page_example" # character | A cursor for use in pagination. Corresponding to the `next_page` field from the previous response. (Optional)
#'
#' #Get audio transcriptions usage details for the organization.
#' api_instance <- UsageApi$new()
#'
#' # Configure HTTP bearer authorization: ApiKeyAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UsageAudioTranscriptions(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, user_ids = var_user_ids, api_key_ids = var_api_key_ids, models = var_models, group_by = var_group_by, limit = var_limit, page = var_pagedata_file = "result.txt")
#' result <- api_instance$UsageAudioTranscriptions(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, user_ids = var_user_ids, api_key_ids = var_api_key_ids, models = var_models, group_by = var_group_by, limit = var_limit, page = var_page)
#' dput(result)
#'
#'
#' ####################  UsageCodeInterpreterSessions  ####################
#'
#' library(openapi)
#' var_start_time <- 56 # integer | Start time (Unix seconds) of the query time range, inclusive.
#' var_end_time <- 56 # integer | End time (Unix seconds) of the query time range, exclusive. (Optional)
#' var_bucket_width <- "1d" # character | Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (Optional)
#' var_project_ids <- c("inner_example") # array[character] | Return only usage for these projects. (Optional)
#' var_group_by <- c("project_id") # array[character] | Group the usage data by the specified fields. Support fields include `project_id`. (Optional)
#' var_limit <- 56 # integer | Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440  (Optional)
#' var_page <- "page_example" # character | A cursor for use in pagination. Corresponding to the `next_page` field from the previous response. (Optional)
#'
#' #Get code interpreter sessions usage details for the organization.
#' api_instance <- UsageApi$new()
#'
#' # Configure HTTP bearer authorization: ApiKeyAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UsageCodeInterpreterSessions(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, group_by = var_group_by, limit = var_limit, page = var_pagedata_file = "result.txt")
#' result <- api_instance$UsageCodeInterpreterSessions(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, group_by = var_group_by, limit = var_limit, page = var_page)
#' dput(result)
#'
#'
#' ####################  UsageCompletions  ####################
#'
#' library(openapi)
#' var_start_time <- 56 # integer | Start time (Unix seconds) of the query time range, inclusive.
#' var_end_time <- 56 # integer | End time (Unix seconds) of the query time range, exclusive. (Optional)
#' var_bucket_width <- "1d" # character | Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (Optional)
#' var_project_ids <- c("inner_example") # array[character] | Return only usage for these projects. (Optional)
#' var_user_ids <- c("inner_example") # array[character] | Return only usage for these users. (Optional)
#' var_api_key_ids <- c("inner_example") # array[character] | Return only usage for these API keys. (Optional)
#' var_models <- c("inner_example") # array[character] | Return only usage for these models. (Optional)
#' var_batch <- "batch_example" # character | If `true`, return batch jobs only. If `false`, return non-batch jobs only. By default, return both.  (Optional)
#' var_group_by <- c("project_id") # array[character] | Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model`, `batch` or any combination of them. (Optional)
#' var_limit <- 56 # integer | Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440  (Optional)
#' var_page <- "page_example" # character | A cursor for use in pagination. Corresponding to the `next_page` field from the previous response. (Optional)
#'
#' #Get completions usage details for the organization.
#' api_instance <- UsageApi$new()
#'
#' # Configure HTTP bearer authorization: ApiKeyAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UsageCompletions(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, user_ids = var_user_ids, api_key_ids = var_api_key_ids, models = var_models, batch = var_batch, group_by = var_group_by, limit = var_limit, page = var_pagedata_file = "result.txt")
#' result <- api_instance$UsageCompletions(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, user_ids = var_user_ids, api_key_ids = var_api_key_ids, models = var_models, batch = var_batch, group_by = var_group_by, limit = var_limit, page = var_page)
#' dput(result)
#'
#'
#' ####################  UsageCosts  ####################
#'
#' library(openapi)
#' var_start_time <- 56 # integer | Start time (Unix seconds) of the query time range, inclusive.
#' var_end_time <- 56 # integer | End time (Unix seconds) of the query time range, exclusive. (Optional)
#' var_bucket_width <- "1d" # character | Width of each time bucket in response. Currently only `1d` is supported, default to `1d`. (Optional)
#' var_project_ids <- c("inner_example") # array[character] | Return only costs for these projects. (Optional)
#' var_group_by <- c("project_id") # array[character] | Group the costs by the specified fields. Support fields include `project_id`, `line_item` and any combination of them. (Optional)
#' var_limit <- 7 # integer | A limit on the number of buckets to be returned. Limit can range between 1 and 180, and the default is 7.  (Optional)
#' var_page <- "page_example" # character | A cursor for use in pagination. Corresponding to the `next_page` field from the previous response. (Optional)
#'
#' #Get costs details for the organization.
#' api_instance <- UsageApi$new()
#'
#' # Configure HTTP bearer authorization: ApiKeyAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UsageCosts(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, group_by = var_group_by, limit = var_limit, page = var_pagedata_file = "result.txt")
#' result <- api_instance$UsageCosts(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, group_by = var_group_by, limit = var_limit, page = var_page)
#' dput(result)
#'
#'
#' ####################  UsageEmbeddings  ####################
#'
#' library(openapi)
#' var_start_time <- 56 # integer | Start time (Unix seconds) of the query time range, inclusive.
#' var_end_time <- 56 # integer | End time (Unix seconds) of the query time range, exclusive. (Optional)
#' var_bucket_width <- "1d" # character | Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (Optional)
#' var_project_ids <- c("inner_example") # array[character] | Return only usage for these projects. (Optional)
#' var_user_ids <- c("inner_example") # array[character] | Return only usage for these users. (Optional)
#' var_api_key_ids <- c("inner_example") # array[character] | Return only usage for these API keys. (Optional)
#' var_models <- c("inner_example") # array[character] | Return only usage for these models. (Optional)
#' var_group_by <- c("project_id") # array[character] | Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them. (Optional)
#' var_limit <- 56 # integer | Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440  (Optional)
#' var_page <- "page_example" # character | A cursor for use in pagination. Corresponding to the `next_page` field from the previous response. (Optional)
#'
#' #Get embeddings usage details for the organization.
#' api_instance <- UsageApi$new()
#'
#' # Configure HTTP bearer authorization: ApiKeyAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UsageEmbeddings(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, user_ids = var_user_ids, api_key_ids = var_api_key_ids, models = var_models, group_by = var_group_by, limit = var_limit, page = var_pagedata_file = "result.txt")
#' result <- api_instance$UsageEmbeddings(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, user_ids = var_user_ids, api_key_ids = var_api_key_ids, models = var_models, group_by = var_group_by, limit = var_limit, page = var_page)
#' dput(result)
#'
#'
#' ####################  UsageImages  ####################
#'
#' library(openapi)
#' var_start_time <- 56 # integer | Start time (Unix seconds) of the query time range, inclusive.
#' var_end_time <- 56 # integer | End time (Unix seconds) of the query time range, exclusive. (Optional)
#' var_bucket_width <- "1d" # character | Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (Optional)
#' var_sources <- c("image.generation") # array[character] | Return only usages for these sources. Possible values are `image.generation`, `image.edit`, `image.variation` or any combination of them. (Optional)
#' var_sizes <- c("256x256") # array[character] | Return only usages for these image sizes. Possible values are `256x256`, `512x512`, `1024x1024`, `1792x1792`, `1024x1792` or any combination of them. (Optional)
#' var_project_ids <- c("inner_example") # array[character] | Return only usage for these projects. (Optional)
#' var_user_ids <- c("inner_example") # array[character] | Return only usage for these users. (Optional)
#' var_api_key_ids <- c("inner_example") # array[character] | Return only usage for these API keys. (Optional)
#' var_models <- c("inner_example") # array[character] | Return only usage for these models. (Optional)
#' var_group_by <- c("project_id") # array[character] | Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model`, `size`, `source` or any combination of them. (Optional)
#' var_limit <- 56 # integer | Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440  (Optional)
#' var_page <- "page_example" # character | A cursor for use in pagination. Corresponding to the `next_page` field from the previous response. (Optional)
#'
#' #Get images usage details for the organization.
#' api_instance <- UsageApi$new()
#'
#' # Configure HTTP bearer authorization: ApiKeyAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UsageImages(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, sources = var_sources, sizes = var_sizes, project_ids = var_project_ids, user_ids = var_user_ids, api_key_ids = var_api_key_ids, models = var_models, group_by = var_group_by, limit = var_limit, page = var_pagedata_file = "result.txt")
#' result <- api_instance$UsageImages(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, sources = var_sources, sizes = var_sizes, project_ids = var_project_ids, user_ids = var_user_ids, api_key_ids = var_api_key_ids, models = var_models, group_by = var_group_by, limit = var_limit, page = var_page)
#' dput(result)
#'
#'
#' ####################  UsageModerations  ####################
#'
#' library(openapi)
#' var_start_time <- 56 # integer | Start time (Unix seconds) of the query time range, inclusive.
#' var_end_time <- 56 # integer | End time (Unix seconds) of the query time range, exclusive. (Optional)
#' var_bucket_width <- "1d" # character | Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (Optional)
#' var_project_ids <- c("inner_example") # array[character] | Return only usage for these projects. (Optional)
#' var_user_ids <- c("inner_example") # array[character] | Return only usage for these users. (Optional)
#' var_api_key_ids <- c("inner_example") # array[character] | Return only usage for these API keys. (Optional)
#' var_models <- c("inner_example") # array[character] | Return only usage for these models. (Optional)
#' var_group_by <- c("project_id") # array[character] | Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them. (Optional)
#' var_limit <- 56 # integer | Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440  (Optional)
#' var_page <- "page_example" # character | A cursor for use in pagination. Corresponding to the `next_page` field from the previous response. (Optional)
#'
#' #Get moderations usage details for the organization.
#' api_instance <- UsageApi$new()
#'
#' # Configure HTTP bearer authorization: ApiKeyAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UsageModerations(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, user_ids = var_user_ids, api_key_ids = var_api_key_ids, models = var_models, group_by = var_group_by, limit = var_limit, page = var_pagedata_file = "result.txt")
#' result <- api_instance$UsageModerations(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, user_ids = var_user_ids, api_key_ids = var_api_key_ids, models = var_models, group_by = var_group_by, limit = var_limit, page = var_page)
#' dput(result)
#'
#'
#' ####################  UsageVectorStores  ####################
#'
#' library(openapi)
#' var_start_time <- 56 # integer | Start time (Unix seconds) of the query time range, inclusive.
#' var_end_time <- 56 # integer | End time (Unix seconds) of the query time range, exclusive. (Optional)
#' var_bucket_width <- "1d" # character | Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (Optional)
#' var_project_ids <- c("inner_example") # array[character] | Return only usage for these projects. (Optional)
#' var_group_by <- c("project_id") # array[character] | Group the usage data by the specified fields. Support fields include `project_id`. (Optional)
#' var_limit <- 56 # integer | Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440  (Optional)
#' var_page <- "page_example" # character | A cursor for use in pagination. Corresponding to the `next_page` field from the previous response. (Optional)
#'
#' #Get vector stores usage details for the organization.
#' api_instance <- UsageApi$new()
#'
#' # Configure HTTP bearer authorization: ApiKeyAuth
#' api_instance$api_client$bearer_token <- Sys.getenv("BEARER_TOKEN")
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UsageVectorStores(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, group_by = var_group_by, limit = var_limit, page = var_pagedata_file = "result.txt")
#' result <- api_instance$UsageVectorStores(var_start_time, end_time = var_end_time, bucket_width = var_bucket_width, project_ids = var_project_ids, group_by = var_group_by, limit = var_limit, page = var_page)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
UsageApi <- R6::R6Class(
  "UsageApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new UsageApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Get audio speeches usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param user_ids (optional) Return only usage for these users.
    #' @param api_key_ids (optional) Return only usage for these API keys.
    #' @param models (optional) Return only usage for these models.
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return UsageResponse
    UsageAudioSpeeches = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, user_ids = NULL, api_key_ids = NULL, models = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      local_var_response <- self$UsageAudioSpeechesWithHttpInfo(start_time, end_time, bucket_width, project_ids, user_ids, api_key_ids, models, group_by, limit, page, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get audio speeches usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param user_ids (optional) Return only usage for these users.
    #' @param api_key_ids (optional) Return only usage for these API keys.
    #' @param models (optional) Return only usage for these models.
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (UsageResponse) with additional information such as HTTP status code, headers
    UsageAudioSpeechesWithHttpInfo = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, user_ids = NULL, api_key_ids = NULL, models = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`start_time`)) {
        stop("Missing required parameter `start_time`.")
      }

      if (!missing(`start_time`) && is.null(`start_time`)) {
        stop("Invalid value for `start_time` when calling UsageApi$UsageAudioSpeeches, `start_time` is not nullable")
      }

      if (!missing(`end_time`) && is.null(`end_time`)) {
        stop("Invalid value for `end_time` when calling UsageApi$UsageAudioSpeeches, `end_time` is not nullable")
      }

      if (!missing(`bucket_width`) && is.null(`bucket_width`)) {
        stop("Invalid value for `bucket_width` when calling UsageApi$UsageAudioSpeeches, `bucket_width` is not nullable")
      }

      if (!missing(`project_ids`) && is.null(`project_ids`)) {
        stop("Invalid value for `project_ids` when calling UsageApi$UsageAudioSpeeches, `project_ids` is not nullable")
      }

      if (!missing(`user_ids`) && is.null(`user_ids`)) {
        stop("Invalid value for `user_ids` when calling UsageApi$UsageAudioSpeeches, `user_ids` is not nullable")
      }

      if (!missing(`api_key_ids`) && is.null(`api_key_ids`)) {
        stop("Invalid value for `api_key_ids` when calling UsageApi$UsageAudioSpeeches, `api_key_ids` is not nullable")
      }

      if (!missing(`models`) && is.null(`models`)) {
        stop("Invalid value for `models` when calling UsageApi$UsageAudioSpeeches, `models` is not nullable")
      }

      if (!missing(`group_by`) && is.null(`group_by`)) {
        stop("Invalid value for `group_by` when calling UsageApi$UsageAudioSpeeches, `group_by` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling UsageApi$UsageAudioSpeeches, `limit` is not nullable")
      }

      if (!missing(`page`) && is.null(`page`)) {
        stop("Invalid value for `page` when calling UsageApi$UsageAudioSpeeches, `page` is not nullable")
      }

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      if (!is.null(`bucket_width`) && !(`bucket_width` %in% c("1m", "1h", "1d"))) {
        stop("Invalid value for bucket_width when calling UsageApi$UsageAudioSpeeches. Must be [1m, 1h, 1d].")
      }
      query_params[["bucket_width"]] <- `bucket_width`

      # explore
      for (query_item in `project_ids`) {
        query_params[["project_ids"]] <- c(query_params[["project_ids"]], list(`project_ids` = query_item))
      }

      # explore
      for (query_item in `user_ids`) {
        query_params[["user_ids"]] <- c(query_params[["user_ids"]], list(`user_ids` = query_item))
      }

      # explore
      for (query_item in `api_key_ids`) {
        query_params[["api_key_ids"]] <- c(query_params[["api_key_ids"]], list(`api_key_ids` = query_item))
      }

      # explore
      for (query_item in `models`) {
        query_params[["models"]] <- c(query_params[["models"]], list(`models` = query_item))
      }

      # explore
      for (query_item in `group_by`) {
        # validate enum values
        if (!is.null(query_item) && !(query_item %in% c("project_id", "user_id", "api_key_id", "model"))) {
          stop("Invalid value for group_by when calling UsageApi$UsageAudioSpeeches. Must be [project_id, user_id, api_key_id, model].")
        }
        query_params[["group_by"]] <- c(query_params[["group_by"]], list(`group_by` = query_item))
      }

      query_params[["limit"]] <- `limit`

      query_params[["page"]] <- `page`

      local_var_url_path <- "/organization/usage/audio_speeches"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "UsageResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get audio transcriptions usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param user_ids (optional) Return only usage for these users.
    #' @param api_key_ids (optional) Return only usage for these API keys.
    #' @param models (optional) Return only usage for these models.
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return UsageResponse
    UsageAudioTranscriptions = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, user_ids = NULL, api_key_ids = NULL, models = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      local_var_response <- self$UsageAudioTranscriptionsWithHttpInfo(start_time, end_time, bucket_width, project_ids, user_ids, api_key_ids, models, group_by, limit, page, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get audio transcriptions usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param user_ids (optional) Return only usage for these users.
    #' @param api_key_ids (optional) Return only usage for these API keys.
    #' @param models (optional) Return only usage for these models.
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (UsageResponse) with additional information such as HTTP status code, headers
    UsageAudioTranscriptionsWithHttpInfo = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, user_ids = NULL, api_key_ids = NULL, models = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`start_time`)) {
        stop("Missing required parameter `start_time`.")
      }

      if (!missing(`start_time`) && is.null(`start_time`)) {
        stop("Invalid value for `start_time` when calling UsageApi$UsageAudioTranscriptions, `start_time` is not nullable")
      }

      if (!missing(`end_time`) && is.null(`end_time`)) {
        stop("Invalid value for `end_time` when calling UsageApi$UsageAudioTranscriptions, `end_time` is not nullable")
      }

      if (!missing(`bucket_width`) && is.null(`bucket_width`)) {
        stop("Invalid value for `bucket_width` when calling UsageApi$UsageAudioTranscriptions, `bucket_width` is not nullable")
      }

      if (!missing(`project_ids`) && is.null(`project_ids`)) {
        stop("Invalid value for `project_ids` when calling UsageApi$UsageAudioTranscriptions, `project_ids` is not nullable")
      }

      if (!missing(`user_ids`) && is.null(`user_ids`)) {
        stop("Invalid value for `user_ids` when calling UsageApi$UsageAudioTranscriptions, `user_ids` is not nullable")
      }

      if (!missing(`api_key_ids`) && is.null(`api_key_ids`)) {
        stop("Invalid value for `api_key_ids` when calling UsageApi$UsageAudioTranscriptions, `api_key_ids` is not nullable")
      }

      if (!missing(`models`) && is.null(`models`)) {
        stop("Invalid value for `models` when calling UsageApi$UsageAudioTranscriptions, `models` is not nullable")
      }

      if (!missing(`group_by`) && is.null(`group_by`)) {
        stop("Invalid value for `group_by` when calling UsageApi$UsageAudioTranscriptions, `group_by` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling UsageApi$UsageAudioTranscriptions, `limit` is not nullable")
      }

      if (!missing(`page`) && is.null(`page`)) {
        stop("Invalid value for `page` when calling UsageApi$UsageAudioTranscriptions, `page` is not nullable")
      }

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      if (!is.null(`bucket_width`) && !(`bucket_width` %in% c("1m", "1h", "1d"))) {
        stop("Invalid value for bucket_width when calling UsageApi$UsageAudioTranscriptions. Must be [1m, 1h, 1d].")
      }
      query_params[["bucket_width"]] <- `bucket_width`

      # explore
      for (query_item in `project_ids`) {
        query_params[["project_ids"]] <- c(query_params[["project_ids"]], list(`project_ids` = query_item))
      }

      # explore
      for (query_item in `user_ids`) {
        query_params[["user_ids"]] <- c(query_params[["user_ids"]], list(`user_ids` = query_item))
      }

      # explore
      for (query_item in `api_key_ids`) {
        query_params[["api_key_ids"]] <- c(query_params[["api_key_ids"]], list(`api_key_ids` = query_item))
      }

      # explore
      for (query_item in `models`) {
        query_params[["models"]] <- c(query_params[["models"]], list(`models` = query_item))
      }

      # explore
      for (query_item in `group_by`) {
        # validate enum values
        if (!is.null(query_item) && !(query_item %in% c("project_id", "user_id", "api_key_id", "model"))) {
          stop("Invalid value for group_by when calling UsageApi$UsageAudioTranscriptions. Must be [project_id, user_id, api_key_id, model].")
        }
        query_params[["group_by"]] <- c(query_params[["group_by"]], list(`group_by` = query_item))
      }

      query_params[["limit"]] <- `limit`

      query_params[["page"]] <- `page`

      local_var_url_path <- "/organization/usage/audio_transcriptions"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "UsageResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get code interpreter sessions usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return UsageResponse
    UsageCodeInterpreterSessions = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      local_var_response <- self$UsageCodeInterpreterSessionsWithHttpInfo(start_time, end_time, bucket_width, project_ids, group_by, limit, page, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get code interpreter sessions usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (UsageResponse) with additional information such as HTTP status code, headers
    UsageCodeInterpreterSessionsWithHttpInfo = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`start_time`)) {
        stop("Missing required parameter `start_time`.")
      }

      if (!missing(`start_time`) && is.null(`start_time`)) {
        stop("Invalid value for `start_time` when calling UsageApi$UsageCodeInterpreterSessions, `start_time` is not nullable")
      }

      if (!missing(`end_time`) && is.null(`end_time`)) {
        stop("Invalid value for `end_time` when calling UsageApi$UsageCodeInterpreterSessions, `end_time` is not nullable")
      }

      if (!missing(`bucket_width`) && is.null(`bucket_width`)) {
        stop("Invalid value for `bucket_width` when calling UsageApi$UsageCodeInterpreterSessions, `bucket_width` is not nullable")
      }

      if (!missing(`project_ids`) && is.null(`project_ids`)) {
        stop("Invalid value for `project_ids` when calling UsageApi$UsageCodeInterpreterSessions, `project_ids` is not nullable")
      }

      if (!missing(`group_by`) && is.null(`group_by`)) {
        stop("Invalid value for `group_by` when calling UsageApi$UsageCodeInterpreterSessions, `group_by` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling UsageApi$UsageCodeInterpreterSessions, `limit` is not nullable")
      }

      if (!missing(`page`) && is.null(`page`)) {
        stop("Invalid value for `page` when calling UsageApi$UsageCodeInterpreterSessions, `page` is not nullable")
      }

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      if (!is.null(`bucket_width`) && !(`bucket_width` %in% c("1m", "1h", "1d"))) {
        stop("Invalid value for bucket_width when calling UsageApi$UsageCodeInterpreterSessions. Must be [1m, 1h, 1d].")
      }
      query_params[["bucket_width"]] <- `bucket_width`

      # explore
      for (query_item in `project_ids`) {
        query_params[["project_ids"]] <- c(query_params[["project_ids"]], list(`project_ids` = query_item))
      }

      # explore
      for (query_item in `group_by`) {
        # validate enum values
        if (!is.null(query_item) && !(query_item %in% c("project_id"))) {
          stop("Invalid value for group_by when calling UsageApi$UsageCodeInterpreterSessions. Must be [project_id].")
        }
        query_params[["group_by"]] <- c(query_params[["group_by"]], list(`group_by` = query_item))
      }

      query_params[["limit"]] <- `limit`

      query_params[["page"]] <- `page`

      local_var_url_path <- "/organization/usage/code_interpreter_sessions"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "UsageResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get completions usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param user_ids (optional) Return only usage for these users.
    #' @param api_key_ids (optional) Return only usage for these API keys.
    #' @param models (optional) Return only usage for these models.
    #' @param batch (optional) If `true`, return batch jobs only. If `false`, return non-batch jobs only. By default, return both. 
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model`, `batch` or any combination of them.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return UsageResponse
    UsageCompletions = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, user_ids = NULL, api_key_ids = NULL, models = NULL, batch = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      local_var_response <- self$UsageCompletionsWithHttpInfo(start_time, end_time, bucket_width, project_ids, user_ids, api_key_ids, models, batch, group_by, limit, page, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get completions usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param user_ids (optional) Return only usage for these users.
    #' @param api_key_ids (optional) Return only usage for these API keys.
    #' @param models (optional) Return only usage for these models.
    #' @param batch (optional) If `true`, return batch jobs only. If `false`, return non-batch jobs only. By default, return both. 
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model`, `batch` or any combination of them.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (UsageResponse) with additional information such as HTTP status code, headers
    UsageCompletionsWithHttpInfo = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, user_ids = NULL, api_key_ids = NULL, models = NULL, batch = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`start_time`)) {
        stop("Missing required parameter `start_time`.")
      }

      if (!missing(`start_time`) && is.null(`start_time`)) {
        stop("Invalid value for `start_time` when calling UsageApi$UsageCompletions, `start_time` is not nullable")
      }

      if (!missing(`end_time`) && is.null(`end_time`)) {
        stop("Invalid value for `end_time` when calling UsageApi$UsageCompletions, `end_time` is not nullable")
      }

      if (!missing(`bucket_width`) && is.null(`bucket_width`)) {
        stop("Invalid value for `bucket_width` when calling UsageApi$UsageCompletions, `bucket_width` is not nullable")
      }

      if (!missing(`project_ids`) && is.null(`project_ids`)) {
        stop("Invalid value for `project_ids` when calling UsageApi$UsageCompletions, `project_ids` is not nullable")
      }

      if (!missing(`user_ids`) && is.null(`user_ids`)) {
        stop("Invalid value for `user_ids` when calling UsageApi$UsageCompletions, `user_ids` is not nullable")
      }

      if (!missing(`api_key_ids`) && is.null(`api_key_ids`)) {
        stop("Invalid value for `api_key_ids` when calling UsageApi$UsageCompletions, `api_key_ids` is not nullable")
      }

      if (!missing(`models`) && is.null(`models`)) {
        stop("Invalid value for `models` when calling UsageApi$UsageCompletions, `models` is not nullable")
      }

      if (!missing(`batch`) && is.null(`batch`)) {
        stop("Invalid value for `batch` when calling UsageApi$UsageCompletions, `batch` is not nullable")
      }

      if (!missing(`group_by`) && is.null(`group_by`)) {
        stop("Invalid value for `group_by` when calling UsageApi$UsageCompletions, `group_by` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling UsageApi$UsageCompletions, `limit` is not nullable")
      }

      if (!missing(`page`) && is.null(`page`)) {
        stop("Invalid value for `page` when calling UsageApi$UsageCompletions, `page` is not nullable")
      }

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      if (!is.null(`bucket_width`) && !(`bucket_width` %in% c("1m", "1h", "1d"))) {
        stop("Invalid value for bucket_width when calling UsageApi$UsageCompletions. Must be [1m, 1h, 1d].")
      }
      query_params[["bucket_width"]] <- `bucket_width`

      # explore
      for (query_item in `project_ids`) {
        query_params[["project_ids"]] <- c(query_params[["project_ids"]], list(`project_ids` = query_item))
      }

      # explore
      for (query_item in `user_ids`) {
        query_params[["user_ids"]] <- c(query_params[["user_ids"]], list(`user_ids` = query_item))
      }

      # explore
      for (query_item in `api_key_ids`) {
        query_params[["api_key_ids"]] <- c(query_params[["api_key_ids"]], list(`api_key_ids` = query_item))
      }

      # explore
      for (query_item in `models`) {
        query_params[["models"]] <- c(query_params[["models"]], list(`models` = query_item))
      }

      query_params[["batch"]] <- `batch`

      # explore
      for (query_item in `group_by`) {
        # validate enum values
        if (!is.null(query_item) && !(query_item %in% c("project_id", "user_id", "api_key_id", "model", "batch"))) {
          stop("Invalid value for group_by when calling UsageApi$UsageCompletions. Must be [project_id, user_id, api_key_id, model, batch].")
        }
        query_params[["group_by"]] <- c(query_params[["group_by"]], list(`group_by` = query_item))
      }

      query_params[["limit"]] <- `limit`

      query_params[["page"]] <- `page`

      local_var_url_path <- "/organization/usage/completions"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "UsageResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get costs details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently only `1d` is supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only costs for these projects.
    #' @param group_by (optional) Group the costs by the specified fields. Support fields include `project_id`, `line_item` and any combination of them.
    #' @param limit (optional) A limit on the number of buckets to be returned. Limit can range between 1 and 180, and the default is 7.  (default value: 7)
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return UsageResponse
    UsageCosts = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, group_by = NULL, limit = 7, page = NULL, data_file = NULL, ...) {
      local_var_response <- self$UsageCostsWithHttpInfo(start_time, end_time, bucket_width, project_ids, group_by, limit, page, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get costs details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently only `1d` is supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only costs for these projects.
    #' @param group_by (optional) Group the costs by the specified fields. Support fields include `project_id`, `line_item` and any combination of them.
    #' @param limit (optional) A limit on the number of buckets to be returned. Limit can range between 1 and 180, and the default is 7.  (default value: 7)
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (UsageResponse) with additional information such as HTTP status code, headers
    UsageCostsWithHttpInfo = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, group_by = NULL, limit = 7, page = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`start_time`)) {
        stop("Missing required parameter `start_time`.")
      }

      if (!missing(`start_time`) && is.null(`start_time`)) {
        stop("Invalid value for `start_time` when calling UsageApi$UsageCosts, `start_time` is not nullable")
      }

      if (!missing(`end_time`) && is.null(`end_time`)) {
        stop("Invalid value for `end_time` when calling UsageApi$UsageCosts, `end_time` is not nullable")
      }

      if (!missing(`bucket_width`) && is.null(`bucket_width`)) {
        stop("Invalid value for `bucket_width` when calling UsageApi$UsageCosts, `bucket_width` is not nullable")
      }

      if (!missing(`project_ids`) && is.null(`project_ids`)) {
        stop("Invalid value for `project_ids` when calling UsageApi$UsageCosts, `project_ids` is not nullable")
      }

      if (!missing(`group_by`) && is.null(`group_by`)) {
        stop("Invalid value for `group_by` when calling UsageApi$UsageCosts, `group_by` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling UsageApi$UsageCosts, `limit` is not nullable")
      }

      if (!missing(`page`) && is.null(`page`)) {
        stop("Invalid value for `page` when calling UsageApi$UsageCosts, `page` is not nullable")
      }

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      if (!is.null(`bucket_width`) && !(`bucket_width` %in% c("1d"))) {
        stop("Invalid value for bucket_width when calling UsageApi$UsageCosts. Must be [1d].")
      }
      query_params[["bucket_width"]] <- `bucket_width`

      # explore
      for (query_item in `project_ids`) {
        query_params[["project_ids"]] <- c(query_params[["project_ids"]], list(`project_ids` = query_item))
      }

      # explore
      for (query_item in `group_by`) {
        # validate enum values
        if (!is.null(query_item) && !(query_item %in% c("project_id", "line_item"))) {
          stop("Invalid value for group_by when calling UsageApi$UsageCosts. Must be [project_id, line_item].")
        }
        query_params[["group_by"]] <- c(query_params[["group_by"]], list(`group_by` = query_item))
      }

      query_params[["limit"]] <- `limit`

      query_params[["page"]] <- `page`

      local_var_url_path <- "/organization/costs"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "UsageResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get embeddings usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param user_ids (optional) Return only usage for these users.
    #' @param api_key_ids (optional) Return only usage for these API keys.
    #' @param models (optional) Return only usage for these models.
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return UsageResponse
    UsageEmbeddings = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, user_ids = NULL, api_key_ids = NULL, models = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      local_var_response <- self$UsageEmbeddingsWithHttpInfo(start_time, end_time, bucket_width, project_ids, user_ids, api_key_ids, models, group_by, limit, page, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get embeddings usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param user_ids (optional) Return only usage for these users.
    #' @param api_key_ids (optional) Return only usage for these API keys.
    #' @param models (optional) Return only usage for these models.
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (UsageResponse) with additional information such as HTTP status code, headers
    UsageEmbeddingsWithHttpInfo = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, user_ids = NULL, api_key_ids = NULL, models = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`start_time`)) {
        stop("Missing required parameter `start_time`.")
      }

      if (!missing(`start_time`) && is.null(`start_time`)) {
        stop("Invalid value for `start_time` when calling UsageApi$UsageEmbeddings, `start_time` is not nullable")
      }

      if (!missing(`end_time`) && is.null(`end_time`)) {
        stop("Invalid value for `end_time` when calling UsageApi$UsageEmbeddings, `end_time` is not nullable")
      }

      if (!missing(`bucket_width`) && is.null(`bucket_width`)) {
        stop("Invalid value for `bucket_width` when calling UsageApi$UsageEmbeddings, `bucket_width` is not nullable")
      }

      if (!missing(`project_ids`) && is.null(`project_ids`)) {
        stop("Invalid value for `project_ids` when calling UsageApi$UsageEmbeddings, `project_ids` is not nullable")
      }

      if (!missing(`user_ids`) && is.null(`user_ids`)) {
        stop("Invalid value for `user_ids` when calling UsageApi$UsageEmbeddings, `user_ids` is not nullable")
      }

      if (!missing(`api_key_ids`) && is.null(`api_key_ids`)) {
        stop("Invalid value for `api_key_ids` when calling UsageApi$UsageEmbeddings, `api_key_ids` is not nullable")
      }

      if (!missing(`models`) && is.null(`models`)) {
        stop("Invalid value for `models` when calling UsageApi$UsageEmbeddings, `models` is not nullable")
      }

      if (!missing(`group_by`) && is.null(`group_by`)) {
        stop("Invalid value for `group_by` when calling UsageApi$UsageEmbeddings, `group_by` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling UsageApi$UsageEmbeddings, `limit` is not nullable")
      }

      if (!missing(`page`) && is.null(`page`)) {
        stop("Invalid value for `page` when calling UsageApi$UsageEmbeddings, `page` is not nullable")
      }

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      if (!is.null(`bucket_width`) && !(`bucket_width` %in% c("1m", "1h", "1d"))) {
        stop("Invalid value for bucket_width when calling UsageApi$UsageEmbeddings. Must be [1m, 1h, 1d].")
      }
      query_params[["bucket_width"]] <- `bucket_width`

      # explore
      for (query_item in `project_ids`) {
        query_params[["project_ids"]] <- c(query_params[["project_ids"]], list(`project_ids` = query_item))
      }

      # explore
      for (query_item in `user_ids`) {
        query_params[["user_ids"]] <- c(query_params[["user_ids"]], list(`user_ids` = query_item))
      }

      # explore
      for (query_item in `api_key_ids`) {
        query_params[["api_key_ids"]] <- c(query_params[["api_key_ids"]], list(`api_key_ids` = query_item))
      }

      # explore
      for (query_item in `models`) {
        query_params[["models"]] <- c(query_params[["models"]], list(`models` = query_item))
      }

      # explore
      for (query_item in `group_by`) {
        # validate enum values
        if (!is.null(query_item) && !(query_item %in% c("project_id", "user_id", "api_key_id", "model"))) {
          stop("Invalid value for group_by when calling UsageApi$UsageEmbeddings. Must be [project_id, user_id, api_key_id, model].")
        }
        query_params[["group_by"]] <- c(query_params[["group_by"]], list(`group_by` = query_item))
      }

      query_params[["limit"]] <- `limit`

      query_params[["page"]] <- `page`

      local_var_url_path <- "/organization/usage/embeddings"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "UsageResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get images usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param sources (optional) Return only usages for these sources. Possible values are `image.generation`, `image.edit`, `image.variation` or any combination of them.
    #' @param sizes (optional) Return only usages for these image sizes. Possible values are `256x256`, `512x512`, `1024x1024`, `1792x1792`, `1024x1792` or any combination of them.
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param user_ids (optional) Return only usage for these users.
    #' @param api_key_ids (optional) Return only usage for these API keys.
    #' @param models (optional) Return only usage for these models.
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model`, `size`, `source` or any combination of them.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return UsageResponse
    UsageImages = function(start_time, end_time = NULL, bucket_width = "1d", sources = NULL, sizes = NULL, project_ids = NULL, user_ids = NULL, api_key_ids = NULL, models = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      local_var_response <- self$UsageImagesWithHttpInfo(start_time, end_time, bucket_width, sources, sizes, project_ids, user_ids, api_key_ids, models, group_by, limit, page, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get images usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param sources (optional) Return only usages for these sources. Possible values are `image.generation`, `image.edit`, `image.variation` or any combination of them.
    #' @param sizes (optional) Return only usages for these image sizes. Possible values are `256x256`, `512x512`, `1024x1024`, `1792x1792`, `1024x1792` or any combination of them.
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param user_ids (optional) Return only usage for these users.
    #' @param api_key_ids (optional) Return only usage for these API keys.
    #' @param models (optional) Return only usage for these models.
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model`, `size`, `source` or any combination of them.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (UsageResponse) with additional information such as HTTP status code, headers
    UsageImagesWithHttpInfo = function(start_time, end_time = NULL, bucket_width = "1d", sources = NULL, sizes = NULL, project_ids = NULL, user_ids = NULL, api_key_ids = NULL, models = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`start_time`)) {
        stop("Missing required parameter `start_time`.")
      }

      if (!missing(`start_time`) && is.null(`start_time`)) {
        stop("Invalid value for `start_time` when calling UsageApi$UsageImages, `start_time` is not nullable")
      }

      if (!missing(`end_time`) && is.null(`end_time`)) {
        stop("Invalid value for `end_time` when calling UsageApi$UsageImages, `end_time` is not nullable")
      }

      if (!missing(`bucket_width`) && is.null(`bucket_width`)) {
        stop("Invalid value for `bucket_width` when calling UsageApi$UsageImages, `bucket_width` is not nullable")
      }

      if (!missing(`sources`) && is.null(`sources`)) {
        stop("Invalid value for `sources` when calling UsageApi$UsageImages, `sources` is not nullable")
      }

      if (!missing(`sizes`) && is.null(`sizes`)) {
        stop("Invalid value for `sizes` when calling UsageApi$UsageImages, `sizes` is not nullable")
      }

      if (!missing(`project_ids`) && is.null(`project_ids`)) {
        stop("Invalid value for `project_ids` when calling UsageApi$UsageImages, `project_ids` is not nullable")
      }

      if (!missing(`user_ids`) && is.null(`user_ids`)) {
        stop("Invalid value for `user_ids` when calling UsageApi$UsageImages, `user_ids` is not nullable")
      }

      if (!missing(`api_key_ids`) && is.null(`api_key_ids`)) {
        stop("Invalid value for `api_key_ids` when calling UsageApi$UsageImages, `api_key_ids` is not nullable")
      }

      if (!missing(`models`) && is.null(`models`)) {
        stop("Invalid value for `models` when calling UsageApi$UsageImages, `models` is not nullable")
      }

      if (!missing(`group_by`) && is.null(`group_by`)) {
        stop("Invalid value for `group_by` when calling UsageApi$UsageImages, `group_by` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling UsageApi$UsageImages, `limit` is not nullable")
      }

      if (!missing(`page`) && is.null(`page`)) {
        stop("Invalid value for `page` when calling UsageApi$UsageImages, `page` is not nullable")
      }

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      if (!is.null(`bucket_width`) && !(`bucket_width` %in% c("1m", "1h", "1d"))) {
        stop("Invalid value for bucket_width when calling UsageApi$UsageImages. Must be [1m, 1h, 1d].")
      }
      query_params[["bucket_width"]] <- `bucket_width`

      # explore
      for (query_item in `sources`) {
        # validate enum values
        if (!is.null(query_item) && !(query_item %in% c("image.generation", "image.edit", "image.variation"))) {
          stop("Invalid value for sources when calling UsageApi$UsageImages. Must be [image.generation, image.edit, image.variation].")
        }
        query_params[["sources"]] <- c(query_params[["sources"]], list(`sources` = query_item))
      }

      # explore
      for (query_item in `sizes`) {
        # validate enum values
        if (!is.null(query_item) && !(query_item %in% c("256x256", "512x512", "1024x1024", "1792x1792", "1024x1792"))) {
          stop("Invalid value for sizes when calling UsageApi$UsageImages. Must be [256x256, 512x512, 1024x1024, 1792x1792, 1024x1792].")
        }
        query_params[["sizes"]] <- c(query_params[["sizes"]], list(`sizes` = query_item))
      }

      # explore
      for (query_item in `project_ids`) {
        query_params[["project_ids"]] <- c(query_params[["project_ids"]], list(`project_ids` = query_item))
      }

      # explore
      for (query_item in `user_ids`) {
        query_params[["user_ids"]] <- c(query_params[["user_ids"]], list(`user_ids` = query_item))
      }

      # explore
      for (query_item in `api_key_ids`) {
        query_params[["api_key_ids"]] <- c(query_params[["api_key_ids"]], list(`api_key_ids` = query_item))
      }

      # explore
      for (query_item in `models`) {
        query_params[["models"]] <- c(query_params[["models"]], list(`models` = query_item))
      }

      # explore
      for (query_item in `group_by`) {
        # validate enum values
        if (!is.null(query_item) && !(query_item %in% c("project_id", "user_id", "api_key_id", "model", "size", "source"))) {
          stop("Invalid value for group_by when calling UsageApi$UsageImages. Must be [project_id, user_id, api_key_id, model, size, source].")
        }
        query_params[["group_by"]] <- c(query_params[["group_by"]], list(`group_by` = query_item))
      }

      query_params[["limit"]] <- `limit`

      query_params[["page"]] <- `page`

      local_var_url_path <- "/organization/usage/images"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "UsageResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get moderations usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param user_ids (optional) Return only usage for these users.
    #' @param api_key_ids (optional) Return only usage for these API keys.
    #' @param models (optional) Return only usage for these models.
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return UsageResponse
    UsageModerations = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, user_ids = NULL, api_key_ids = NULL, models = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      local_var_response <- self$UsageModerationsWithHttpInfo(start_time, end_time, bucket_width, project_ids, user_ids, api_key_ids, models, group_by, limit, page, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get moderations usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param user_ids (optional) Return only usage for these users.
    #' @param api_key_ids (optional) Return only usage for these API keys.
    #' @param models (optional) Return only usage for these models.
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (UsageResponse) with additional information such as HTTP status code, headers
    UsageModerationsWithHttpInfo = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, user_ids = NULL, api_key_ids = NULL, models = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`start_time`)) {
        stop("Missing required parameter `start_time`.")
      }

      if (!missing(`start_time`) && is.null(`start_time`)) {
        stop("Invalid value for `start_time` when calling UsageApi$UsageModerations, `start_time` is not nullable")
      }

      if (!missing(`end_time`) && is.null(`end_time`)) {
        stop("Invalid value for `end_time` when calling UsageApi$UsageModerations, `end_time` is not nullable")
      }

      if (!missing(`bucket_width`) && is.null(`bucket_width`)) {
        stop("Invalid value for `bucket_width` when calling UsageApi$UsageModerations, `bucket_width` is not nullable")
      }

      if (!missing(`project_ids`) && is.null(`project_ids`)) {
        stop("Invalid value for `project_ids` when calling UsageApi$UsageModerations, `project_ids` is not nullable")
      }

      if (!missing(`user_ids`) && is.null(`user_ids`)) {
        stop("Invalid value for `user_ids` when calling UsageApi$UsageModerations, `user_ids` is not nullable")
      }

      if (!missing(`api_key_ids`) && is.null(`api_key_ids`)) {
        stop("Invalid value for `api_key_ids` when calling UsageApi$UsageModerations, `api_key_ids` is not nullable")
      }

      if (!missing(`models`) && is.null(`models`)) {
        stop("Invalid value for `models` when calling UsageApi$UsageModerations, `models` is not nullable")
      }

      if (!missing(`group_by`) && is.null(`group_by`)) {
        stop("Invalid value for `group_by` when calling UsageApi$UsageModerations, `group_by` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling UsageApi$UsageModerations, `limit` is not nullable")
      }

      if (!missing(`page`) && is.null(`page`)) {
        stop("Invalid value for `page` when calling UsageApi$UsageModerations, `page` is not nullable")
      }

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      if (!is.null(`bucket_width`) && !(`bucket_width` %in% c("1m", "1h", "1d"))) {
        stop("Invalid value for bucket_width when calling UsageApi$UsageModerations. Must be [1m, 1h, 1d].")
      }
      query_params[["bucket_width"]] <- `bucket_width`

      # explore
      for (query_item in `project_ids`) {
        query_params[["project_ids"]] <- c(query_params[["project_ids"]], list(`project_ids` = query_item))
      }

      # explore
      for (query_item in `user_ids`) {
        query_params[["user_ids"]] <- c(query_params[["user_ids"]], list(`user_ids` = query_item))
      }

      # explore
      for (query_item in `api_key_ids`) {
        query_params[["api_key_ids"]] <- c(query_params[["api_key_ids"]], list(`api_key_ids` = query_item))
      }

      # explore
      for (query_item in `models`) {
        query_params[["models"]] <- c(query_params[["models"]], list(`models` = query_item))
      }

      # explore
      for (query_item in `group_by`) {
        # validate enum values
        if (!is.null(query_item) && !(query_item %in% c("project_id", "user_id", "api_key_id", "model"))) {
          stop("Invalid value for group_by when calling UsageApi$UsageModerations. Must be [project_id, user_id, api_key_id, model].")
        }
        query_params[["group_by"]] <- c(query_params[["group_by"]], list(`group_by` = query_item))
      }

      query_params[["limit"]] <- `limit`

      query_params[["page"]] <- `page`

      local_var_url_path <- "/organization/usage/moderations"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "UsageResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get vector stores usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return UsageResponse
    UsageVectorStores = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      local_var_response <- self$UsageVectorStoresWithHttpInfo(start_time, end_time, bucket_width, project_ids, group_by, limit, page, data_file = data_file, ...)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get vector stores usage details for the organization.
    #'
    #' @param start_time Start time (Unix seconds) of the query time range, inclusive.
    #' @param end_time (optional) End time (Unix seconds) of the query time range, exclusive.
    #' @param bucket_width (optional) Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`. (default value: "1d")
    #' @param project_ids (optional) Return only usage for these projects.
    #' @param group_by (optional) Group the usage data by the specified fields. Support fields include `project_id`.
    #' @param limit (optional) Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
    #' @param page (optional) A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #'
    #' @return API response (UsageResponse) with additional information such as HTTP status code, headers
    UsageVectorStoresWithHttpInfo = function(start_time, end_time = NULL, bucket_width = "1d", project_ids = NULL, group_by = NULL, limit = NULL, page = NULL, data_file = NULL, ...) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`start_time`)) {
        stop("Missing required parameter `start_time`.")
      }

      if (!missing(`start_time`) && is.null(`start_time`)) {
        stop("Invalid value for `start_time` when calling UsageApi$UsageVectorStores, `start_time` is not nullable")
      }

      if (!missing(`end_time`) && is.null(`end_time`)) {
        stop("Invalid value for `end_time` when calling UsageApi$UsageVectorStores, `end_time` is not nullable")
      }

      if (!missing(`bucket_width`) && is.null(`bucket_width`)) {
        stop("Invalid value for `bucket_width` when calling UsageApi$UsageVectorStores, `bucket_width` is not nullable")
      }

      if (!missing(`project_ids`) && is.null(`project_ids`)) {
        stop("Invalid value for `project_ids` when calling UsageApi$UsageVectorStores, `project_ids` is not nullable")
      }

      if (!missing(`group_by`) && is.null(`group_by`)) {
        stop("Invalid value for `group_by` when calling UsageApi$UsageVectorStores, `group_by` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling UsageApi$UsageVectorStores, `limit` is not nullable")
      }

      if (!missing(`page`) && is.null(`page`)) {
        stop("Invalid value for `page` when calling UsageApi$UsageVectorStores, `page` is not nullable")
      }

      query_params[["start_time"]] <- `start_time`

      query_params[["end_time"]] <- `end_time`

      if (!is.null(`bucket_width`) && !(`bucket_width` %in% c("1m", "1h", "1d"))) {
        stop("Invalid value for bucket_width when calling UsageApi$UsageVectorStores. Must be [1m, 1h, 1d].")
      }
      query_params[["bucket_width"]] <- `bucket_width`

      # explore
      for (query_item in `project_ids`) {
        query_params[["project_ids"]] <- c(query_params[["project_ids"]], list(`project_ids` = query_item))
      }

      # explore
      for (query_item in `group_by`) {
        # validate enum values
        if (!is.null(query_item) && !(query_item %in% c("project_id"))) {
          stop("Invalid value for group_by when calling UsageApi$UsageVectorStores. Must be [project_id].")
        }
        query_params[["group_by"]] <- c(query_params[["group_by"]], list(`group_by` = query_item))
      }

      query_params[["limit"]] <- `limit`

      query_params[["page"]] <- `page`

      local_var_url_path <- "/organization/usage/vector_stores"
      # Bearer token
      if (!is.null(self$api_client$bearer_token)) {
        header_params["Authorization"] <- paste("Bearer", self$api_client$bearer_token, sep = " ")
      }

      # The Accept request HTTP header
      local_var_accepts <- list("application/json")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "UsageResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(paste("Server returned ", local_var_resp$status_code, " response status code."), local_var_resp)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new("API client error", local_var_resp)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || local_var_resp$response == "") {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
