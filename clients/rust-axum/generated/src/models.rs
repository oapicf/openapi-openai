#![allow(unused_qualifications)]

use http::HeaderValue;
use validator::Validate;

#[cfg(feature = "server")]
use crate::header;
use crate::{models, types::*};

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CancelRunPathParams {
            /// The ID of the thread to which this run belongs.
                pub thread_id: String,
            /// The ID of the run to cancel.
                pub run_id: String,
    }


      
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CreateAssistantFilePathParams {
            /// The ID of the assistant for which to create a File. 
                pub assistant_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CreateMessagePathParams {
            /// The ID of the [thread](/docs/api-reference/threads) to create a message for.
                pub thread_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CreateRunPathParams {
            /// The ID of the thread to run.
                pub thread_id: String,
    }


      
      
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct DeleteAssistantPathParams {
            /// The ID of the assistant to delete.
                pub assistant_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct DeleteAssistantFilePathParams {
            /// The ID of the assistant that the file belongs to.
                pub assistant_id: String,
            /// The ID of the file to delete.
                pub file_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct DeleteThreadPathParams {
            /// The ID of the thread to delete.
                pub thread_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct GetAssistantPathParams {
            /// The ID of the assistant to retrieve.
                pub assistant_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct GetAssistantFilePathParams {
            /// The ID of the assistant who the file belongs to.
                pub assistant_id: String,
            /// The ID of the file we're getting.
                pub file_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct GetMessagePathParams {
            /// The ID of the [thread](/docs/api-reference/threads) to which this message belongs.
                pub thread_id: String,
            /// The ID of the message to retrieve.
                pub message_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct GetMessageFilePathParams {
            /// The ID of the thread to which the message and File belong.
                pub thread_id: String,
            /// The ID of the message the file belongs to.
                pub message_id: String,
            /// The ID of the file being retrieved.
                pub file_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct GetRunPathParams {
            /// The ID of the [thread](/docs/api-reference/threads) that was run.
                pub thread_id: String,
            /// The ID of the run to retrieve.
                pub run_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct GetRunStepPathParams {
            /// The ID of the thread to which the run and run step belongs.
                pub thread_id: String,
            /// The ID of the run to which the run step belongs.
                pub run_id: String,
            /// The ID of the run step to retrieve.
                pub step_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct GetThreadPathParams {
            /// The ID of the thread to retrieve.
                pub thread_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListAssistantFilesPathParams {
            /// The ID of the assistant the file belongs to.
                pub assistant_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListAssistantFilesQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
            /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub after: Option<String>,
            /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
                #[serde(rename = "before")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub before: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListAssistantsQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
            /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub after: Option<String>,
            /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
                #[serde(rename = "before")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub before: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListMessageFilesPathParams {
            /// The ID of the thread that the message and files belong to.
                pub thread_id: String,
            /// The ID of the message that the files belongs to.
                pub message_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListMessageFilesQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
            /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub after: Option<String>,
            /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
                #[serde(rename = "before")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub before: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListMessagesPathParams {
            /// The ID of the [thread](/docs/api-reference/threads) the messages belong to.
                pub thread_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListMessagesQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
            /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub after: Option<String>,
            /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
                #[serde(rename = "before")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub before: Option<String>,
            /// Filter messages by the run ID that generated them. 
                #[serde(rename = "run_id")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub run_id: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListRunStepsPathParams {
            /// The ID of the thread the run and run steps belong to.
                pub thread_id: String,
            /// The ID of the run the run steps belong to.
                pub run_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListRunStepsQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
            /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub after: Option<String>,
            /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
                #[serde(rename = "before")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub before: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListRunsPathParams {
            /// The ID of the thread the run belongs to.
                pub thread_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListRunsQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
            /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub order: Option<String>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub after: Option<String>,
            /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
                #[serde(rename = "before")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub before: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ModifyAssistantPathParams {
            /// The ID of the assistant to modify.
                pub assistant_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ModifyMessagePathParams {
            /// The ID of the thread to which this message belongs.
                pub thread_id: String,
            /// The ID of the message to modify.
                pub message_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ModifyRunPathParams {
            /// The ID of the [thread](/docs/api-reference/threads) that was run.
                pub thread_id: String,
            /// The ID of the run to modify.
                pub run_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ModifyThreadPathParams {
            /// The ID of the thread to modify. Only the `metadata` can be modified.
                pub thread_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct SubmitToolOuputsToRunPathParams {
            /// The ID of the [thread](/docs/api-reference/threads) to which this run belongs.
                pub thread_id: String,
            /// The ID of the run that requires the tool output submission.
                pub run_id: String,
    }


      
      
      
      
      
      
      
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct DeleteFilePathParams {
            /// The ID of the file to use for this request.
                pub file_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct DownloadFilePathParams {
            /// The ID of the file to use for this request.
                pub file_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListFilesQueryParams {
            /// Only return files with the given purpose.
                #[serde(rename = "purpose")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub purpose: Option<String>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct RetrieveFilePathParams {
            /// The ID of the file to use for this request.
                pub file_id: String,
    }


      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct CancelFineTuningJobPathParams {
            /// The ID of the fine-tuning job to cancel. 
                pub fine_tuning_job_id: String,
    }


      
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListFineTuningEventsPathParams {
            /// The ID of the fine-tuning job to get events for. 
                pub fine_tuning_job_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListFineTuningEventsQueryParams {
            /// Identifier for the last event from the previous pagination request.
                #[serde(rename = "after")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub after: Option<String>,
            /// Number of events to retrieve.
                #[serde(rename = "limit")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListFineTuningJobCheckpointsPathParams {
            /// The ID of the fine-tuning job to get checkpoints for. 
                pub fine_tuning_job_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListFineTuningJobCheckpointsQueryParams {
            /// Identifier for the last checkpoint ID from the previous pagination request.
                #[serde(rename = "after")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub after: Option<String>,
            /// Number of checkpoints to retrieve.
                #[serde(rename = "limit")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct ListPaginatedFineTuningJobsQueryParams {
            /// Identifier for the last job from the previous pagination request.
                #[serde(rename = "after")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub after: Option<String>,
            /// Number of fine-tuning jobs to retrieve.
                #[serde(rename = "limit")]
                #[serde(skip_serializing_if="Option::is_none")]
                pub limit: Option<i32>,
    }

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct RetrieveFineTuningJobPathParams {
            /// The ID of the fine-tuning job. 
                pub fine_tuning_job_id: String,
    }


      
      
      
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct DeleteModelPathParams {
            /// The model to delete
                pub model: String,
    }


      
      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct RetrieveModelPathParams {
            /// The ID of the model to use for this request
                pub model: String,
    }


      


/// A list of [Files](/docs/api-reference/files) attached to an `assistant`.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantFileObject {
/// The identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
    pub id: String,

/// The object type, which is always `assistant.file`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

/// The Unix timestamp (in seconds) for when the assistant file was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

/// The assistant ID that the file is attached to.
    #[serde(rename = "assistant_id")]
    pub assistant_id: String,

}


impl AssistantFileObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, created_at: i32, assistant_id: String, ) -> AssistantFileObject {
        AssistantFileObject {
            id,
            object,
            created_at,
            assistant_id,
        }
    }
}

/// Converts the AssistantFileObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantFileObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("assistant_id".to_string()),
            Some(self.assistant_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantFileObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantFileObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub created_at: Vec<i32>,
            pub assistant_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantFileObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "assistant_id" => intermediate_rep.assistant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantFileObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantFileObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in AssistantFileObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in AssistantFileObject".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in AssistantFileObject".to_string())?,
            assistant_id: intermediate_rep.assistant_id.into_iter().next().ok_or_else(|| "assistant_id missing in AssistantFileObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantFileObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantFileObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantFileObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AssistantFileObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantFileObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantFileObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AssistantFileObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Represents an `assistant` that can call the model and use tools.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantObject {
/// The identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
    pub id: String,

/// The object type, which is always `assistant`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

/// The Unix timestamp (in seconds) for when the assistant was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

/// The name of the assistant. The maximum length is 256 characters. 
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
        )]
    pub name: Nullable<String>,

/// The description of the assistant. The maximum length is 512 characters. 
    #[serde(rename = "description")]
    #[validate(
            length(max = 512),
        )]
    pub description: Nullable<String>,

/// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them. 
    #[serde(rename = "model")]
    pub model: String,

/// The system instructions that the assistant uses. The maximum length is 256,000 characters. 
    #[serde(rename = "instructions")]
    #[validate(
            length(max = 256000),
        )]
    pub instructions: Nullable<String>,

/// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`. 
    #[serde(rename = "tools")]
    #[validate(
            length(max = 128),
        )]
    pub tools: Vec<models::AssistantObjectToolsInner>,

/// A list of [file](/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. 
    #[serde(rename = "file_ids")]
    #[validate(
            length(max = 20),
        )]
    pub file_ids: Vec<String>,

/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
    #[serde(rename = "metadata")]
    pub metadata: crate::types::Object,

}


impl AssistantObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, created_at: i32, name: Nullable<String>, description: Nullable<String>, model: String, instructions: Nullable<String>, tools: Vec<models::AssistantObjectToolsInner>, file_ids: Vec<String>, metadata: crate::types::Object, ) -> AssistantObject {
        AssistantObject {
            id,
            object,
            created_at,
            name,
            description,
            model,
            instructions,
            tools,
            file_ids,
            metadata,
        }
    }
}

/// Converts the AssistantObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("name".to_string()),
            Some(self.name.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("description".to_string()),
            Some(self.description.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("model".to_string()),
            Some(self.model.to_string()),


            Some("instructions".to_string()),
            Some(self.instructions.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping tools in query parameter serialization


            Some("file_ids".to_string()),
            Some(self.file_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub created_at: Vec<i32>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub model: Vec<String>,
            pub instructions: Vec<String>,
            pub tools: Vec<Vec<models::AssistantObjectToolsInner>>,
            pub file_ids: Vec<Vec<String>>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AssistantObject".to_string()),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AssistantObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "instructions" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AssistantObject".to_string()),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in AssistantObject".to_string()),
                    "file_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in AssistantObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in AssistantObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in AssistantObject".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in AssistantObject".to_string())?,
            name: std::result::Result::Err("Nullable types not supported in AssistantObject".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in AssistantObject".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in AssistantObject".to_string())?,
            instructions: std::result::Result::Err("Nullable types not supported in AssistantObject".to_string())?,
            tools: intermediate_rep.tools.into_iter().next().ok_or_else(|| "tools missing in AssistantObject".to_string())?,
            file_ids: intermediate_rep.file_ids.into_iter().next().ok_or_else(|| "file_ids missing in AssistantObject".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next().ok_or_else(|| "metadata missing in AssistantObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AssistantObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AssistantObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - AssistantToolsCode
/// - AssistantToolsFunction
/// - AssistantToolsRetrieval
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AssistantObjectToolsInner(Box<serde_json::value::RawValue>);

impl validator::Validate for AssistantObjectToolsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantObjectToolsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantObjectToolsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for AssistantObjectToolsInner {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Represents an event emitted when streaming a Run.  Each event in a server-sent events stream has an `event` and `data` property:  ``` event: thread.created data: {\"id\": \"thread_123\", \"object\": \"thread\", ...} ```  We emit events whenever a new object is created, transitions to a new state, or is being streamed in parts (deltas). For example, we emit `thread.run.created` when a new run is created, `thread.run.completed` when a run completes, and so on. When an Assistant chooses to create a message during a run, we emit a `thread.message.created event`, a `thread.message.in_progress` event, many `thread.message.delta` events, and finally a `thread.message.completed` event.  We may add additional events over time, so we recommend handling unknown events gracefully in your code. See the [Assistants API quickstart](/docs/assistants/overview) to learn how to integrate the Assistants API with streaming. 


/// One of:
/// - DoneEvent
/// - ErrorEvent
/// - MessageStreamEvent
/// - RunStepStreamEvent
/// - RunStreamEvent
/// - ThreadStreamEvent
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AssistantStreamEvent(Box<serde_json::value::RawValue>);

impl validator::Validate for AssistantStreamEvent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantStreamEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantStreamEvent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for AssistantStreamEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantToolsCode {
/// The type of tool being defined: `code_interpreter`
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

}


impl AssistantToolsCode {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, ) -> AssistantToolsCode {
        AssistantToolsCode {
            r#type,
        }
    }
}

/// Converts the AssistantToolsCode value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantToolsCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantToolsCode value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantToolsCode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantToolsCode".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantToolsCode".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantToolsCode {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in AssistantToolsCode".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantToolsCode> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantToolsCode>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantToolsCode>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AssistantToolsCode - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantToolsCode> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantToolsCode as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AssistantToolsCode - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantToolsFunction {
/// The type of tool being defined: `function`
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "function")]
    pub function: models::FunctionObject,

}


impl AssistantToolsFunction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, function: models::FunctionObject, ) -> AssistantToolsFunction {
        AssistantToolsFunction {
            r#type,
            function,
        }
    }
}

/// Converts the AssistantToolsFunction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantToolsFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantToolsFunction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantToolsFunction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub function: Vec<models::FunctionObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantToolsFunction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::FunctionObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantToolsFunction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantToolsFunction {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in AssistantToolsFunction".to_string())?,
            function: intermediate_rep.function.into_iter().next().ok_or_else(|| "function missing in AssistantToolsFunction".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantToolsFunction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantToolsFunction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantToolsFunction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AssistantToolsFunction - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantToolsFunction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantToolsFunction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AssistantToolsFunction - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantToolsRetrieval {
/// The type of tool being defined: `retrieval`
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

}


impl AssistantToolsRetrieval {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, ) -> AssistantToolsRetrieval {
        AssistantToolsRetrieval {
            r#type,
        }
    }
}

/// Converts the AssistantToolsRetrieval value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantToolsRetrieval {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantToolsRetrieval value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantToolsRetrieval {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantToolsRetrieval".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantToolsRetrieval".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantToolsRetrieval {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in AssistantToolsRetrieval".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantToolsRetrieval> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantToolsRetrieval>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantToolsRetrieval>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AssistantToolsRetrieval - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantToolsRetrieval> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantToolsRetrieval as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AssistantToolsRetrieval - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Specifies a tool the model should use. Use to force the model to call a specific tool.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantsApiNamedToolChoice {
/// The type of the tool. If type is `function`, the function name must be set
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "function")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub function: Option<models::ChatCompletionNamedToolChoiceFunction>,

}


impl AssistantsApiNamedToolChoice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, ) -> AssistantsApiNamedToolChoice {
        AssistantsApiNamedToolChoice {
            r#type,
            function: None,
        }
    }
}

/// Converts the AssistantsApiNamedToolChoice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantsApiNamedToolChoice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantsApiNamedToolChoice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantsApiNamedToolChoice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub function: Vec<models::ChatCompletionNamedToolChoiceFunction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantsApiNamedToolChoice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::ChatCompletionNamedToolChoiceFunction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantsApiNamedToolChoice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantsApiNamedToolChoice {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in AssistantsApiNamedToolChoice".to_string())?,
            function: intermediate_rep.function.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantsApiNamedToolChoice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantsApiNamedToolChoice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantsApiNamedToolChoice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AssistantsApiNamedToolChoice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantsApiNamedToolChoice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantsApiNamedToolChoice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AssistantsApiNamedToolChoice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// An object describing the expected output of the model. If `json_object` only `function` type `tools` are allowed to be passed to the Run. If `text` the model can return text or any value needed. 



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantsApiResponseFormat {
/// Must be one of `text` or `json_object`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl AssistantsApiResponseFormat {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AssistantsApiResponseFormat {
        AssistantsApiResponseFormat {
            r#type: Some("text".to_string()),
        }
    }
}

/// Converts the AssistantsApiResponseFormat value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantsApiResponseFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantsApiResponseFormat value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantsApiResponseFormat {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantsApiResponseFormat".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantsApiResponseFormat".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantsApiResponseFormat {
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantsApiResponseFormat> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantsApiResponseFormat>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantsApiResponseFormat>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AssistantsApiResponseFormat - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantsApiResponseFormat> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantsApiResponseFormat as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AssistantsApiResponseFormat - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Specifies the format that the model must output. Compatible with [GPT-4 Turbo](/docs/models/gpt-4-and-gpt-4-turbo) and all GPT-3.5 Turbo models newer than `gpt-3.5-turbo-1106`.  Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which guarantees the message the model generates is valid JSON.  **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \"stuck\" request. Also note that the message content may be partially cut off if `finish_reason=\"length\"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length. 


/// One of:
/// - AssistantsApiResponseFormat
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AssistantsApiResponseFormatOption(Box<serde_json::value::RawValue>);

impl validator::Validate for AssistantsApiResponseFormatOption
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantsApiResponseFormatOption value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantsApiResponseFormatOption {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for AssistantsApiResponseFormatOption {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Controls which (if any) tool is called by the model. `none` means the model will not call any tools and instead generates a message. `auto` is the default value and means the model can pick between generating a message or calling a tool. Specifying a particular tool like `{\"type\": \"TOOL_TYPE\"}` or `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool. 


/// One of:
/// - AssistantsApiNamedToolChoice
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct AssistantsApiToolChoiceOption(Box<serde_json::value::RawValue>);

impl validator::Validate for AssistantsApiToolChoiceOption
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantsApiToolChoiceOption value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantsApiToolChoiceOption {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for AssistantsApiToolChoiceOption {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function. 



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionFunctionCallOption {
/// The name of the function to call.
    #[serde(rename = "name")]
    pub name: String,

}


impl ChatCompletionFunctionCallOption {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> ChatCompletionFunctionCallOption {
        ChatCompletionFunctionCallOption {
            name,
        }
    }
}

/// Converts the ChatCompletionFunctionCallOption value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionFunctionCallOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionFunctionCallOption value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionFunctionCallOption {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionFunctionCallOption".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionFunctionCallOption".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionFunctionCallOption {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ChatCompletionFunctionCallOption".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionFunctionCallOption> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionFunctionCallOption>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionFunctionCallOption>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionFunctionCallOption - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionFunctionCallOption> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionFunctionCallOption as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionFunctionCallOption - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionFunctions {
/// A description of what the function does, used by the model to choose when and how to call the function.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

/// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
    #[serde(rename = "name")]
    pub name: String,

/// The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/text-generation/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.   Omitting `parameters` defines a function with an empty parameter list.
    #[serde(rename = "parameters")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<std::collections::HashMap<String, crate::types::Object>>,

}


impl ChatCompletionFunctions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> ChatCompletionFunctions {
        ChatCompletionFunctions {
            description: None,
            name,
            parameters: None,
        }
    }
}

/// Converts the ChatCompletionFunctions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionFunctions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping parameters in query parameter serialization
            // Skipping parameters in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionFunctions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionFunctions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub name: Vec<String>,
            pub parameters: Vec<std::collections::HashMap<String, crate::types::Object>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionFunctions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "parameters" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatCompletionFunctions".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionFunctions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionFunctions {
            description: intermediate_rep.description.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ChatCompletionFunctions".to_string())?,
            parameters: intermediate_rep.parameters.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionFunctions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionFunctions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionFunctions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionFunctions - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionFunctions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionFunctions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionFunctions - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionMessageToolCall {
/// The ID of the tool call.
    #[serde(rename = "id")]
    pub id: String,

/// The type of the tool. Currently, only `function` is supported.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "function")]
    pub function: models::ChatCompletionMessageToolCallFunction,

}


impl ChatCompletionMessageToolCall {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, r#type: String, function: models::ChatCompletionMessageToolCallFunction, ) -> ChatCompletionMessageToolCall {
        ChatCompletionMessageToolCall {
            id,
            r#type,
            function,
        }
    }
}

/// Converts the ChatCompletionMessageToolCall value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionMessageToolCall {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionMessageToolCall value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionMessageToolCall {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r#type: Vec<String>,
            pub function: Vec<models::ChatCompletionMessageToolCallFunction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionMessageToolCall".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::ChatCompletionMessageToolCallFunction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionMessageToolCall".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionMessageToolCall {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ChatCompletionMessageToolCall".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in ChatCompletionMessageToolCall".to_string())?,
            function: intermediate_rep.function.into_iter().next().ok_or_else(|| "function missing in ChatCompletionMessageToolCall".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionMessageToolCall> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionMessageToolCall>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionMessageToolCall>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionMessageToolCall - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionMessageToolCall> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionMessageToolCall as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionMessageToolCall - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionMessageToolCallChunk {
    #[serde(rename = "index")]
    pub index: i32,

/// The ID of the tool call.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// The type of the tool. Currently, only `function` is supported.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

    #[serde(rename = "function")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub function: Option<models::ChatCompletionMessageToolCallChunkFunction>,

}


impl ChatCompletionMessageToolCallChunk {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, ) -> ChatCompletionMessageToolCallChunk {
        ChatCompletionMessageToolCallChunk {
            index,
            id: None,
            r#type: None,
            function: None,
        }
    }
}

/// Converts the ChatCompletionMessageToolCallChunk value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionMessageToolCallChunk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionMessageToolCallChunk value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionMessageToolCallChunk {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub id: Vec<String>,
            pub r#type: Vec<String>,
            pub function: Vec<models::ChatCompletionMessageToolCallChunkFunction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionMessageToolCallChunk".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::ChatCompletionMessageToolCallChunkFunction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionMessageToolCallChunk".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionMessageToolCallChunk {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in ChatCompletionMessageToolCallChunk".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next(),
            function: intermediate_rep.function.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionMessageToolCallChunk> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionMessageToolCallChunk>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionMessageToolCallChunk>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionMessageToolCallChunk - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionMessageToolCallChunk> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionMessageToolCallChunk as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionMessageToolCallChunk - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionMessageToolCallChunkFunction {
/// The name of the function to call.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
    #[serde(rename = "arguments")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub arguments: Option<String>,

}


impl ChatCompletionMessageToolCallChunkFunction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ChatCompletionMessageToolCallChunkFunction {
        ChatCompletionMessageToolCallChunkFunction {
            name: None,
            arguments: None,
        }
    }
}

/// Converts the ChatCompletionMessageToolCallChunkFunction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionMessageToolCallChunkFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.arguments.as_ref().map(|arguments| {
                [
                    "arguments".to_string(),
                    arguments.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionMessageToolCallChunkFunction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionMessageToolCallChunkFunction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub arguments: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionMessageToolCallChunkFunction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionMessageToolCallChunkFunction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionMessageToolCallChunkFunction {
            name: intermediate_rep.name.into_iter().next(),
            arguments: intermediate_rep.arguments.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionMessageToolCallChunkFunction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionMessageToolCallChunkFunction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionMessageToolCallChunkFunction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionMessageToolCallChunkFunction - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionMessageToolCallChunkFunction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionMessageToolCallChunkFunction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionMessageToolCallChunkFunction - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The function that the model called.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionMessageToolCallFunction {
/// The name of the function to call.
    #[serde(rename = "name")]
    pub name: String,

/// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
    #[serde(rename = "arguments")]
    pub arguments: String,

}


impl ChatCompletionMessageToolCallFunction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, arguments: String, ) -> ChatCompletionMessageToolCallFunction {
        ChatCompletionMessageToolCallFunction {
            name,
            arguments,
        }
    }
}

/// Converts the ChatCompletionMessageToolCallFunction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionMessageToolCallFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("arguments".to_string()),
            Some(self.arguments.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionMessageToolCallFunction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionMessageToolCallFunction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub arguments: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionMessageToolCallFunction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionMessageToolCallFunction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionMessageToolCallFunction {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ChatCompletionMessageToolCallFunction".to_string())?,
            arguments: intermediate_rep.arguments.into_iter().next().ok_or_else(|| "arguments missing in ChatCompletionMessageToolCallFunction".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionMessageToolCallFunction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionMessageToolCallFunction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionMessageToolCallFunction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionMessageToolCallFunction - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionMessageToolCallFunction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionMessageToolCallFunction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionMessageToolCallFunction - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Specifies a tool the model should use. Use to force the model to call a specific function.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionNamedToolChoice {
/// The type of the tool. Currently, only `function` is supported.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "function")]
    pub function: models::ChatCompletionNamedToolChoiceFunction,

}


impl ChatCompletionNamedToolChoice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, function: models::ChatCompletionNamedToolChoiceFunction, ) -> ChatCompletionNamedToolChoice {
        ChatCompletionNamedToolChoice {
            r#type,
            function,
        }
    }
}

/// Converts the ChatCompletionNamedToolChoice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionNamedToolChoice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionNamedToolChoice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionNamedToolChoice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub function: Vec<models::ChatCompletionNamedToolChoiceFunction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionNamedToolChoice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::ChatCompletionNamedToolChoiceFunction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionNamedToolChoice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionNamedToolChoice {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in ChatCompletionNamedToolChoice".to_string())?,
            function: intermediate_rep.function.into_iter().next().ok_or_else(|| "function missing in ChatCompletionNamedToolChoice".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionNamedToolChoice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionNamedToolChoice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionNamedToolChoice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionNamedToolChoice - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionNamedToolChoice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionNamedToolChoice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionNamedToolChoice - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionNamedToolChoiceFunction {
/// The name of the function to call.
    #[serde(rename = "name")]
    pub name: String,

}


impl ChatCompletionNamedToolChoiceFunction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> ChatCompletionNamedToolChoiceFunction {
        ChatCompletionNamedToolChoiceFunction {
            name,
        }
    }
}

/// Converts the ChatCompletionNamedToolChoiceFunction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionNamedToolChoiceFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionNamedToolChoiceFunction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionNamedToolChoiceFunction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionNamedToolChoiceFunction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionNamedToolChoiceFunction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionNamedToolChoiceFunction {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ChatCompletionNamedToolChoiceFunction".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionNamedToolChoiceFunction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionNamedToolChoiceFunction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionNamedToolChoiceFunction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionNamedToolChoiceFunction - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionNamedToolChoiceFunction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionNamedToolChoiceFunction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionNamedToolChoiceFunction - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestAssistantMessage {
/// The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified. 
    #[serde(rename = "content")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<Nullable<String>>,

/// The role of the messages author, in this case `assistant`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
    pub role: String,

/// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// The tool calls generated by the model, such as function calls.
    #[serde(rename = "tool_calls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_calls: Option<Vec<models::ChatCompletionMessageToolCall>>,

    #[serde(rename = "function_call")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub function_call: Option<models::ChatCompletionRequestAssistantMessageFunctionCall>,

}


impl ChatCompletionRequestAssistantMessage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(role: String, ) -> ChatCompletionRequestAssistantMessage {
        ChatCompletionRequestAssistantMessage {
            content: None,
            role,
            name: None,
            tool_calls: None,
            function_call: None,
        }
    }
}

/// Converts the ChatCompletionRequestAssistantMessage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestAssistantMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.content.as_ref().map(|content| {
                [
                    "content".to_string(),
                    content.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            Some("role".to_string()),
            Some(self.role.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping tool_calls in query parameter serialization

            // Skipping function_call in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestAssistantMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestAssistantMessage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content: Vec<String>,
            pub role: Vec<String>,
            pub name: Vec<String>,
            pub tool_calls: Vec<Vec<models::ChatCompletionMessageToolCall>>,
            pub function_call: Vec<models::ChatCompletionRequestAssistantMessageFunctionCall>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestAssistantMessage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "content" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ChatCompletionRequestAssistantMessage".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tool_calls" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatCompletionRequestAssistantMessage".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "function_call" => intermediate_rep.function_call.push(<models::ChatCompletionRequestAssistantMessageFunctionCall as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestAssistantMessage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestAssistantMessage {
            content: std::result::Result::Err("Nullable types not supported in ChatCompletionRequestAssistantMessage".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ChatCompletionRequestAssistantMessage".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            tool_calls: intermediate_rep.tool_calls.into_iter().next(),
            function_call: intermediate_rep.function_call.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestAssistantMessage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestAssistantMessage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestAssistantMessage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionRequestAssistantMessage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestAssistantMessage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestAssistantMessage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionRequestAssistantMessage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestAssistantMessageFunctionCall {
/// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
    #[serde(rename = "arguments")]
    pub arguments: String,

/// The name of the function to call.
    #[serde(rename = "name")]
    pub name: String,

}


impl ChatCompletionRequestAssistantMessageFunctionCall {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(arguments: String, name: String, ) -> ChatCompletionRequestAssistantMessageFunctionCall {
        ChatCompletionRequestAssistantMessageFunctionCall {
            arguments,
            name,
        }
    }
}

/// Converts the ChatCompletionRequestAssistantMessageFunctionCall value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestAssistantMessageFunctionCall {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("arguments".to_string()),
            Some(self.arguments.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestAssistantMessageFunctionCall value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestAssistantMessageFunctionCall {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub arguments: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestAssistantMessageFunctionCall".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestAssistantMessageFunctionCall".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestAssistantMessageFunctionCall {
            arguments: intermediate_rep.arguments.into_iter().next().ok_or_else(|| "arguments missing in ChatCompletionRequestAssistantMessageFunctionCall".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ChatCompletionRequestAssistantMessageFunctionCall".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestAssistantMessageFunctionCall> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestAssistantMessageFunctionCall>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestAssistantMessageFunctionCall>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionRequestAssistantMessageFunctionCall - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestAssistantMessageFunctionCall> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestAssistantMessageFunctionCall as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionRequestAssistantMessageFunctionCall - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestFunctionMessage {
/// The role of the messages author, in this case `function`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
    pub role: String,

/// The contents of the function message.
    #[serde(rename = "content")]
    pub content: Nullable<String>,

/// The name of the function to call.
    #[serde(rename = "name")]
    pub name: String,

}


impl ChatCompletionRequestFunctionMessage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(role: String, content: Nullable<String>, name: String, ) -> ChatCompletionRequestFunctionMessage {
        ChatCompletionRequestFunctionMessage {
            role,
            content,
            name,
        }
    }
}

/// Converts the ChatCompletionRequestFunctionMessage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestFunctionMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("role".to_string()),
            Some(self.role.to_string()),


            Some("content".to_string()),
            Some(self.content.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestFunctionMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestFunctionMessage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role: Vec<String>,
            pub content: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestFunctionMessage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "content" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ChatCompletionRequestFunctionMessage".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestFunctionMessage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestFunctionMessage {
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ChatCompletionRequestFunctionMessage".to_string())?,
            content: std::result::Result::Err("Nullable types not supported in ChatCompletionRequestFunctionMessage".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ChatCompletionRequestFunctionMessage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestFunctionMessage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestFunctionMessage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestFunctionMessage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionRequestFunctionMessage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestFunctionMessage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestFunctionMessage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionRequestFunctionMessage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - ChatCompletionRequestAssistantMessage
/// - ChatCompletionRequestFunctionMessage
/// - ChatCompletionRequestSystemMessage
/// - ChatCompletionRequestToolMessage
/// - ChatCompletionRequestUserMessage
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ChatCompletionRequestMessage(Box<serde_json::value::RawValue>);

impl validator::Validate for ChatCompletionRequestMessage
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestMessage {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for ChatCompletionRequestMessage {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}







/// One of:
/// - ChatCompletionRequestMessageContentPartImage
/// - ChatCompletionRequestMessageContentPartText
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ChatCompletionRequestMessageContentPart(Box<serde_json::value::RawValue>);

impl validator::Validate for ChatCompletionRequestMessageContentPart
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestMessageContentPart value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestMessageContentPart {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for ChatCompletionRequestMessageContentPart {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestMessageContentPartImage {
/// The type of the content part.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "image_url")]
    pub image_url: models::ChatCompletionRequestMessageContentPartImageImageUrl,

}


impl ChatCompletionRequestMessageContentPartImage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, image_url: models::ChatCompletionRequestMessageContentPartImageImageUrl, ) -> ChatCompletionRequestMessageContentPartImage {
        ChatCompletionRequestMessageContentPartImage {
            r#type,
            image_url,
        }
    }
}

/// Converts the ChatCompletionRequestMessageContentPartImage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestMessageContentPartImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping image_url in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestMessageContentPartImage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestMessageContentPartImage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub image_url: Vec<models::ChatCompletionRequestMessageContentPartImageImageUrl>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestMessageContentPartImage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_url" => intermediate_rep.image_url.push(<models::ChatCompletionRequestMessageContentPartImageImageUrl as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestMessageContentPartImage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestMessageContentPartImage {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in ChatCompletionRequestMessageContentPartImage".to_string())?,
            image_url: intermediate_rep.image_url.into_iter().next().ok_or_else(|| "image_url missing in ChatCompletionRequestMessageContentPartImage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionRequestMessageContentPartImage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestMessageContentPartImage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionRequestMessageContentPartImage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestMessageContentPartImageImageUrl {
/// Either a URL of the image or the base64 encoded image data.
    #[serde(rename = "url")]
    pub url: String,

/// Specifies the detail level of the image. Learn more in the [Vision guide](/docs/guides/vision/low-or-high-fidelity-image-understanding).
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "detail")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub detail: Option<String>,

}


impl ChatCompletionRequestMessageContentPartImageImageUrl {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(url: String, ) -> ChatCompletionRequestMessageContentPartImageImageUrl {
        ChatCompletionRequestMessageContentPartImageImageUrl {
            url,
            detail: Some("auto".to_string()),
        }
    }
}

/// Converts the ChatCompletionRequestMessageContentPartImageImageUrl value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestMessageContentPartImageImageUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("url".to_string()),
            Some(self.url.to_string()),


            self.detail.as_ref().map(|detail| {
                [
                    "detail".to_string(),
                    detail.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestMessageContentPartImageImageUrl value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestMessageContentPartImageImageUrl {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
            pub detail: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestMessageContentPartImageImageUrl".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "detail" => intermediate_rep.detail.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestMessageContentPartImageImageUrl".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestMessageContentPartImageImageUrl {
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in ChatCompletionRequestMessageContentPartImageImageUrl".to_string())?,
            detail: intermediate_rep.detail.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImageImageUrl> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImageImageUrl>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImageImageUrl>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionRequestMessageContentPartImageImageUrl - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImageImageUrl> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestMessageContentPartImageImageUrl as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionRequestMessageContentPartImageImageUrl - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestMessageContentPartText {
/// The type of the content part.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

/// The text content.
    #[serde(rename = "text")]
    pub text: String,

}


impl ChatCompletionRequestMessageContentPartText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, text: String, ) -> ChatCompletionRequestMessageContentPartText {
        ChatCompletionRequestMessageContentPartText {
            r#type,
            text,
        }
    }
}

/// Converts the ChatCompletionRequestMessageContentPartText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestMessageContentPartText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestMessageContentPartText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestMessageContentPartText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub text: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestMessageContentPartText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestMessageContentPartText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestMessageContentPartText {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in ChatCompletionRequestMessageContentPartText".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in ChatCompletionRequestMessageContentPartText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestMessageContentPartText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestMessageContentPartText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestMessageContentPartText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionRequestMessageContentPartText - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestMessageContentPartText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestMessageContentPartText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionRequestMessageContentPartText - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestSystemMessage {
/// The contents of the system message.
    #[serde(rename = "content")]
    pub content: String,

/// The role of the messages author, in this case `system`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
    pub role: String,

/// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl ChatCompletionRequestSystemMessage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(content: String, role: String, ) -> ChatCompletionRequestSystemMessage {
        ChatCompletionRequestSystemMessage {
            content,
            role,
            name: None,
        }
    }
}

/// Converts the ChatCompletionRequestSystemMessage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestSystemMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("content".to_string()),
            Some(self.content.to_string()),


            Some("role".to_string()),
            Some(self.role.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestSystemMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestSystemMessage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content: Vec<String>,
            pub role: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestSystemMessage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "content" => intermediate_rep.content.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestSystemMessage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestSystemMessage {
            content: intermediate_rep.content.into_iter().next().ok_or_else(|| "content missing in ChatCompletionRequestSystemMessage".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ChatCompletionRequestSystemMessage".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestSystemMessage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestSystemMessage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestSystemMessage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionRequestSystemMessage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestSystemMessage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestSystemMessage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionRequestSystemMessage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestToolMessage {
/// The role of the messages author, in this case `tool`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
    pub role: String,

/// The contents of the tool message.
    #[serde(rename = "content")]
    pub content: String,

/// Tool call that this message is responding to.
    #[serde(rename = "tool_call_id")]
    pub tool_call_id: String,

}


impl ChatCompletionRequestToolMessage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(role: String, content: String, tool_call_id: String, ) -> ChatCompletionRequestToolMessage {
        ChatCompletionRequestToolMessage {
            role,
            content,
            tool_call_id,
        }
    }
}

/// Converts the ChatCompletionRequestToolMessage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestToolMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("role".to_string()),
            Some(self.role.to_string()),


            Some("content".to_string()),
            Some(self.content.to_string()),


            Some("tool_call_id".to_string()),
            Some(self.tool_call_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestToolMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestToolMessage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role: Vec<String>,
            pub content: Vec<String>,
            pub tool_call_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestToolMessage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content" => intermediate_rep.content.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tool_call_id" => intermediate_rep.tool_call_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestToolMessage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestToolMessage {
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ChatCompletionRequestToolMessage".to_string())?,
            content: intermediate_rep.content.into_iter().next().ok_or_else(|| "content missing in ChatCompletionRequestToolMessage".to_string())?,
            tool_call_id: intermediate_rep.tool_call_id.into_iter().next().ok_or_else(|| "tool_call_id missing in ChatCompletionRequestToolMessage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestToolMessage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestToolMessage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestToolMessage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionRequestToolMessage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestToolMessage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestToolMessage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionRequestToolMessage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestUserMessage {
    #[serde(rename = "content")]
    pub content: models::ChatCompletionRequestUserMessageContent,

/// The role of the messages author, in this case `user`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
    pub role: String,

/// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl ChatCompletionRequestUserMessage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(content: models::ChatCompletionRequestUserMessageContent, role: String, ) -> ChatCompletionRequestUserMessage {
        ChatCompletionRequestUserMessage {
            content,
            role,
            name: None,
        }
    }
}

/// Converts the ChatCompletionRequestUserMessage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestUserMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping content in query parameter serialization


            Some("role".to_string()),
            Some(self.role.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestUserMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestUserMessage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content: Vec<models::ChatCompletionRequestUserMessageContent>,
            pub role: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestUserMessage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "content" => intermediate_rep.content.push(<models::ChatCompletionRequestUserMessageContent as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestUserMessage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestUserMessage {
            content: intermediate_rep.content.into_iter().next().ok_or_else(|| "content missing in ChatCompletionRequestUserMessage".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ChatCompletionRequestUserMessage".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestUserMessage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestUserMessage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestUserMessage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionRequestUserMessage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestUserMessage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestUserMessage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionRequestUserMessage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The contents of the user message. 


/// One of:
/// - String
/// - Vec<models::ChatCompletionRequestMessageContentPart>
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ChatCompletionRequestUserMessageContent(Box<serde_json::value::RawValue>);

impl validator::Validate for ChatCompletionRequestUserMessageContent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestUserMessageContent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestUserMessageContent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for ChatCompletionRequestUserMessageContent {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// A chat completion message generated by the model.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionResponseMessage {
/// The contents of the message.
    #[serde(rename = "content")]
    pub content: Nullable<String>,

/// The tool calls generated by the model, such as function calls.
    #[serde(rename = "tool_calls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_calls: Option<Vec<models::ChatCompletionMessageToolCall>>,

/// The role of the author of this message.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
    pub role: String,

    #[serde(rename = "function_call")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub function_call: Option<models::ChatCompletionRequestAssistantMessageFunctionCall>,

}


impl ChatCompletionResponseMessage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(content: Nullable<String>, role: String, ) -> ChatCompletionResponseMessage {
        ChatCompletionResponseMessage {
            content,
            tool_calls: None,
            role,
            function_call: None,
        }
    }
}

/// Converts the ChatCompletionResponseMessage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionResponseMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("content".to_string()),
            Some(self.content.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping tool_calls in query parameter serialization


            Some("role".to_string()),
            Some(self.role.to_string()),

            // Skipping function_call in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionResponseMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionResponseMessage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content: Vec<String>,
            pub tool_calls: Vec<Vec<models::ChatCompletionMessageToolCall>>,
            pub role: Vec<String>,
            pub function_call: Vec<models::ChatCompletionRequestAssistantMessageFunctionCall>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionResponseMessage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "content" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ChatCompletionResponseMessage".to_string()),
                    "tool_calls" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatCompletionResponseMessage".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function_call" => intermediate_rep.function_call.push(<models::ChatCompletionRequestAssistantMessageFunctionCall as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionResponseMessage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionResponseMessage {
            content: std::result::Result::Err("Nullable types not supported in ChatCompletionResponseMessage".to_string())?,
            tool_calls: intermediate_rep.tool_calls.into_iter().next(),
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ChatCompletionResponseMessage".to_string())?,
            function_call: intermediate_rep.function_call.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionResponseMessage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionResponseMessage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionResponseMessage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionResponseMessage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionResponseMessage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionResponseMessage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionResponseMessage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The role of the author of a message
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ChatCompletionRole {
    #[serde(rename = "system")]
    System,
    #[serde(rename = "user")]
    User,
    #[serde(rename = "assistant")]
    Assistant,
    #[serde(rename = "tool")]
    Tool,
    #[serde(rename = "function")]
    Function,
}

impl std::fmt::Display for ChatCompletionRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ChatCompletionRole::System => write!(f, "system"),
            ChatCompletionRole::User => write!(f, "user"),
            ChatCompletionRole::Assistant => write!(f, "assistant"),
            ChatCompletionRole::Tool => write!(f, "tool"),
            ChatCompletionRole::Function => write!(f, "function"),
        }
    }
}

impl std::str::FromStr for ChatCompletionRole {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "system" => std::result::Result::Ok(ChatCompletionRole::System),
            "user" => std::result::Result::Ok(ChatCompletionRole::User),
            "assistant" => std::result::Result::Ok(ChatCompletionRole::Assistant),
            "tool" => std::result::Result::Ok(ChatCompletionRole::Tool),
            "function" => std::result::Result::Ok(ChatCompletionRole::Function),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}


/// A chat completion delta generated by streamed model responses.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionStreamResponseDelta {
/// The contents of the chunk message.
    #[serde(rename = "content")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<Nullable<String>>,

    #[serde(rename = "function_call")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub function_call: Option<models::ChatCompletionStreamResponseDeltaFunctionCall>,

    #[serde(rename = "tool_calls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_calls: Option<Vec<models::ChatCompletionMessageToolCallChunk>>,

/// The role of the author of this message.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,

}


impl ChatCompletionStreamResponseDelta {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ChatCompletionStreamResponseDelta {
        ChatCompletionStreamResponseDelta {
            content: None,
            function_call: None,
            tool_calls: None,
            role: None,
        }
    }
}

/// Converts the ChatCompletionStreamResponseDelta value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionStreamResponseDelta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.content.as_ref().map(|content| {
                [
                    "content".to_string(),
                    content.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping function_call in query parameter serialization

            // Skipping tool_calls in query parameter serialization


            self.role.as_ref().map(|role| {
                [
                    "role".to_string(),
                    role.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionStreamResponseDelta value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionStreamResponseDelta {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content: Vec<String>,
            pub function_call: Vec<models::ChatCompletionStreamResponseDeltaFunctionCall>,
            pub tool_calls: Vec<Vec<models::ChatCompletionMessageToolCallChunk>>,
            pub role: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionStreamResponseDelta".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "content" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ChatCompletionStreamResponseDelta".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "function_call" => intermediate_rep.function_call.push(<models::ChatCompletionStreamResponseDeltaFunctionCall as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tool_calls" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatCompletionStreamResponseDelta".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionStreamResponseDelta".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionStreamResponseDelta {
            content: std::result::Result::Err("Nullable types not supported in ChatCompletionStreamResponseDelta".to_string())?,
            function_call: intermediate_rep.function_call.into_iter().next(),
            tool_calls: intermediate_rep.tool_calls.into_iter().next(),
            role: intermediate_rep.role.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionStreamResponseDelta> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionStreamResponseDelta>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionStreamResponseDelta>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionStreamResponseDelta - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionStreamResponseDelta> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionStreamResponseDelta as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionStreamResponseDelta - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionStreamResponseDeltaFunctionCall {
/// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
    #[serde(rename = "arguments")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub arguments: Option<String>,

/// The name of the function to call.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}


impl ChatCompletionStreamResponseDeltaFunctionCall {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ChatCompletionStreamResponseDeltaFunctionCall {
        ChatCompletionStreamResponseDeltaFunctionCall {
            arguments: None,
            name: None,
        }
    }
}

/// Converts the ChatCompletionStreamResponseDeltaFunctionCall value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionStreamResponseDeltaFunctionCall {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.arguments.as_ref().map(|arguments| {
                [
                    "arguments".to_string(),
                    arguments.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionStreamResponseDeltaFunctionCall value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionStreamResponseDeltaFunctionCall {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub arguments: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionStreamResponseDeltaFunctionCall".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionStreamResponseDeltaFunctionCall".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionStreamResponseDeltaFunctionCall {
            arguments: intermediate_rep.arguments.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionStreamResponseDeltaFunctionCall> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionStreamResponseDeltaFunctionCall>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionStreamResponseDeltaFunctionCall>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionStreamResponseDeltaFunctionCall - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionStreamResponseDeltaFunctionCall> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionStreamResponseDeltaFunctionCall as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionStreamResponseDeltaFunctionCall - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionTokenLogprob {
/// The token.
    #[serde(rename = "token")]
    pub token: String,

/// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
    #[serde(rename = "logprob")]
    pub logprob: f64,

/// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
    #[serde(rename = "bytes")]
    pub bytes: Nullable<Vec<i32>>,

/// List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
    #[serde(rename = "top_logprobs")]
    pub top_logprobs: Vec<models::ChatCompletionTokenLogprobTopLogprobsInner>,

}


impl ChatCompletionTokenLogprob {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(token: String, logprob: f64, bytes: Nullable<Vec<i32>>, top_logprobs: Vec<models::ChatCompletionTokenLogprobTopLogprobsInner>, ) -> ChatCompletionTokenLogprob {
        ChatCompletionTokenLogprob {
            token,
            logprob,
            bytes,
            top_logprobs,
        }
    }
}

/// Converts the ChatCompletionTokenLogprob value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionTokenLogprob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("token".to_string()),
            Some(self.token.to_string()),


            Some("logprob".to_string()),
            Some(self.logprob.to_string()),


            Some("bytes".to_string()),
            Some(self.bytes.as_ref().map_or(vec!["null".to_string()], |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","))),

            // Skipping top_logprobs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionTokenLogprob value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionTokenLogprob {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub token: Vec<String>,
            pub logprob: Vec<f64>,
            pub bytes: Vec<Vec<i32>>,
            pub top_logprobs: Vec<Vec<models::ChatCompletionTokenLogprobTopLogprobsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionTokenLogprob".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "token" => intermediate_rep.token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "logprob" => intermediate_rep.logprob.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "bytes" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatCompletionTokenLogprob".to_string()),
                    "top_logprobs" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatCompletionTokenLogprob".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionTokenLogprob".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionTokenLogprob {
            token: intermediate_rep.token.into_iter().next().ok_or_else(|| "token missing in ChatCompletionTokenLogprob".to_string())?,
            logprob: intermediate_rep.logprob.into_iter().next().ok_or_else(|| "logprob missing in ChatCompletionTokenLogprob".to_string())?,
            bytes: std::result::Result::Err("Nullable types not supported in ChatCompletionTokenLogprob".to_string())?,
            top_logprobs: intermediate_rep.top_logprobs.into_iter().next().ok_or_else(|| "top_logprobs missing in ChatCompletionTokenLogprob".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionTokenLogprob> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionTokenLogprob>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionTokenLogprob>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionTokenLogprob - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionTokenLogprob> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionTokenLogprob as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionTokenLogprob - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionTokenLogprobTopLogprobsInner {
/// The token.
    #[serde(rename = "token")]
    pub token: String,

/// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
    #[serde(rename = "logprob")]
    pub logprob: f64,

/// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
    #[serde(rename = "bytes")]
    pub bytes: Nullable<Vec<i32>>,

}


impl ChatCompletionTokenLogprobTopLogprobsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(token: String, logprob: f64, bytes: Nullable<Vec<i32>>, ) -> ChatCompletionTokenLogprobTopLogprobsInner {
        ChatCompletionTokenLogprobTopLogprobsInner {
            token,
            logprob,
            bytes,
        }
    }
}

/// Converts the ChatCompletionTokenLogprobTopLogprobsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionTokenLogprobTopLogprobsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("token".to_string()),
            Some(self.token.to_string()),


            Some("logprob".to_string()),
            Some(self.logprob.to_string()),


            Some("bytes".to_string()),
            Some(self.bytes.as_ref().map_or(vec!["null".to_string()], |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","))),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionTokenLogprobTopLogprobsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionTokenLogprobTopLogprobsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub token: Vec<String>,
            pub logprob: Vec<f64>,
            pub bytes: Vec<Vec<i32>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionTokenLogprobTopLogprobsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "token" => intermediate_rep.token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "logprob" => intermediate_rep.logprob.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "bytes" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatCompletionTokenLogprobTopLogprobsInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionTokenLogprobTopLogprobsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionTokenLogprobTopLogprobsInner {
            token: intermediate_rep.token.into_iter().next().ok_or_else(|| "token missing in ChatCompletionTokenLogprobTopLogprobsInner".to_string())?,
            logprob: intermediate_rep.logprob.into_iter().next().ok_or_else(|| "logprob missing in ChatCompletionTokenLogprobTopLogprobsInner".to_string())?,
            bytes: std::result::Result::Err("Nullable types not supported in ChatCompletionTokenLogprobTopLogprobsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionTokenLogprobTopLogprobsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionTokenLogprobTopLogprobsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionTokenLogprobTopLogprobsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionTokenLogprobTopLogprobsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionTokenLogprobTopLogprobsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionTokenLogprobTopLogprobsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionTokenLogprobTopLogprobsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionTool {
/// The type of the tool. Currently, only `function` is supported.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "function")]
    pub function: models::FunctionObject,

}


impl ChatCompletionTool {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, function: models::FunctionObject, ) -> ChatCompletionTool {
        ChatCompletionTool {
            r#type,
            function,
        }
    }
}

/// Converts the ChatCompletionTool value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionTool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionTool value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionTool {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub function: Vec<models::FunctionObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionTool".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::FunctionObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionTool".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionTool {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in ChatCompletionTool".to_string())?,
            function: intermediate_rep.function.into_iter().next().ok_or_else(|| "function missing in ChatCompletionTool".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionTool> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionTool>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionTool>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ChatCompletionTool - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionTool> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionTool as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ChatCompletionTool - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Controls which (if any) function is called by the model. `none` means the model will not call a function and instead generates a message. `auto` means the model can pick between generating a message or calling a function. Specifying a particular function via `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that function.  `none` is the default when no functions are present. `auto` is the default if functions are present. 


/// One of:
/// - ChatCompletionNamedToolChoice
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ChatCompletionToolChoiceOption(Box<serde_json::value::RawValue>);

impl validator::Validate for ChatCompletionToolChoiceOption
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionToolChoiceOption value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionToolChoiceOption {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for ChatCompletionToolChoiceOption {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Usage statistics for the completion request.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CompletionUsage {
/// Number of tokens in the generated completion.
    #[serde(rename = "completion_tokens")]
    pub completion_tokens: i32,

/// Number of tokens in the prompt.
    #[serde(rename = "prompt_tokens")]
    pub prompt_tokens: i32,

/// Total number of tokens used in the request (prompt + completion).
    #[serde(rename = "total_tokens")]
    pub total_tokens: i32,

}


impl CompletionUsage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(completion_tokens: i32, prompt_tokens: i32, total_tokens: i32, ) -> CompletionUsage {
        CompletionUsage {
            completion_tokens,
            prompt_tokens,
            total_tokens,
        }
    }
}

/// Converts the CompletionUsage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CompletionUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("completion_tokens".to_string()),
            Some(self.completion_tokens.to_string()),


            Some("prompt_tokens".to_string()),
            Some(self.prompt_tokens.to_string()),


            Some("total_tokens".to_string()),
            Some(self.total_tokens.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CompletionUsage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CompletionUsage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub completion_tokens: Vec<i32>,
            pub prompt_tokens: Vec<i32>,
            pub total_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CompletionUsage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "completion_tokens" => intermediate_rep.completion_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prompt_tokens" => intermediate_rep.prompt_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total_tokens" => intermediate_rep.total_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CompletionUsage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CompletionUsage {
            completion_tokens: intermediate_rep.completion_tokens.into_iter().next().ok_or_else(|| "completion_tokens missing in CompletionUsage".to_string())?,
            prompt_tokens: intermediate_rep.prompt_tokens.into_iter().next().ok_or_else(|| "prompt_tokens missing in CompletionUsage".to_string())?,
            total_tokens: intermediate_rep.total_tokens.into_iter().next().ok_or_else(|| "total_tokens missing in CompletionUsage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CompletionUsage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CompletionUsage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CompletionUsage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CompletionUsage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CompletionUsage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CompletionUsage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CompletionUsage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateAssistantFileRequest {
/// A [File](/docs/api-reference/files) ID (with `purpose=\"assistants\"`) that the assistant should use. Useful for tools like `retrieval` and `code_interpreter` that can access files.
    #[serde(rename = "file_id")]
    pub file_id: String,

}


impl CreateAssistantFileRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(file_id: String, ) -> CreateAssistantFileRequest {
        CreateAssistantFileRequest {
            file_id,
        }
    }
}

/// Converts the CreateAssistantFileRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateAssistantFileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("file_id".to_string()),
            Some(self.file_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateAssistantFileRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateAssistantFileRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateAssistantFileRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateAssistantFileRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateAssistantFileRequest {
            file_id: intermediate_rep.file_id.into_iter().next().ok_or_else(|| "file_id missing in CreateAssistantFileRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateAssistantFileRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateAssistantFileRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateAssistantFileRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateAssistantFileRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateAssistantFileRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateAssistantFileRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateAssistantFileRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateAssistantRequest {
    #[serde(rename = "model")]
    pub model: models::CreateAssistantRequestModel,

/// The name of the assistant. The maximum length is 256 characters. 
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

/// The description of the assistant. The maximum length is 512 characters. 
    #[serde(rename = "description")]
    #[validate(
            length(max = 512),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

/// The system instructions that the assistant uses. The maximum length is 256,000 characters. 
    #[serde(rename = "instructions")]
    #[validate(
            length(max = 256000),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instructions: Option<Nullable<String>>,

/// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`. 
    #[serde(rename = "tools")]
    #[validate(
            length(max = 128),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Vec<models::AssistantObjectToolsInner>>,

/// A list of [file](/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. 
    #[serde(rename = "file_ids")]
    #[validate(
            length(max = 20),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_ids: Option<Vec<String>>,

/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}


impl CreateAssistantRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(model: models::CreateAssistantRequestModel, ) -> CreateAssistantRequest {
        CreateAssistantRequest {
            model,
            name: None,
            description: None,
            instructions: None,
            tools: None,
            file_ids: None,
            metadata: None,
        }
    }
}

/// Converts the CreateAssistantRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateAssistantRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping model in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.instructions.as_ref().map(|instructions| {
                [
                    "instructions".to_string(),
                    instructions.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping tools in query parameter serialization


            self.file_ids.as_ref().map(|file_ids| {
                [
                    "file_ids".to_string(),
                    file_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateAssistantRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateAssistantRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub model: Vec<models::CreateAssistantRequestModel>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub instructions: Vec<String>,
            pub tools: Vec<Vec<models::AssistantObjectToolsInner>>,
            pub file_ids: Vec<Vec<String>>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateAssistantRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<models::CreateAssistantRequestModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateAssistantRequest".to_string()),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateAssistantRequest".to_string()),
                    "instructions" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateAssistantRequest".to_string()),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateAssistantRequest".to_string()),
                    "file_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateAssistantRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateAssistantRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateAssistantRequest {
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateAssistantRequest".to_string())?,
            name: std::result::Result::Err("Nullable types not supported in CreateAssistantRequest".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in CreateAssistantRequest".to_string())?,
            instructions: std::result::Result::Err("Nullable types not supported in CreateAssistantRequest".to_string())?,
            tools: intermediate_rep.tools.into_iter().next(),
            file_ids: intermediate_rep.file_ids.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateAssistantRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateAssistantRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateAssistantRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateAssistantRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateAssistantRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateAssistantRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateAssistantRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them. 

/// Any of:
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateAssistantRequestModel(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateAssistantRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateAssistantRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateAssistantRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateAssistantRequestModel {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}






/// Represents a chat completion response returned by model, based on the provided input.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionFunctionResponse {
/// A unique identifier for the chat completion.
    #[serde(rename = "id")]
    pub id: String,

/// A list of chat completion choices. Can be more than one if `n` is greater than 1.
    #[serde(rename = "choices")]
    pub choices: Vec<models::CreateChatCompletionFunctionResponseChoicesInner>,

/// The Unix timestamp (in seconds) of when the chat completion was created.
    #[serde(rename = "created")]
    pub created: i32,

/// The model used for the chat completion.
    #[serde(rename = "model")]
    pub model: String,

/// This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
    #[serde(rename = "system_fingerprint")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub system_fingerprint: Option<String>,

/// The object type, which is always `chat.completion`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "usage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub usage: Option<models::CompletionUsage>,

}


impl CreateChatCompletionFunctionResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, choices: Vec<models::CreateChatCompletionFunctionResponseChoicesInner>, created: i32, model: String, object: String, ) -> CreateChatCompletionFunctionResponse {
        CreateChatCompletionFunctionResponse {
            id,
            choices,
            created,
            model,
            system_fingerprint: None,
            object,
            usage: None,
        }
    }
}

/// Converts the CreateChatCompletionFunctionResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionFunctionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),

            // Skipping choices in query parameter serialization


            Some("created".to_string()),
            Some(self.created.to_string()),


            Some("model".to_string()),
            Some(self.model.to_string()),


            self.system_fingerprint.as_ref().map(|system_fingerprint| {
                [
                    "system_fingerprint".to_string(),
                    system_fingerprint.to_string(),
                ].join(",")
            }),


            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping usage in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionFunctionResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionFunctionResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub choices: Vec<Vec<models::CreateChatCompletionFunctionResponseChoicesInner>>,
            pub created: Vec<i32>,
            pub model: Vec<String>,
            pub system_fingerprint: Vec<String>,
            pub object: Vec<String>,
            pub usage: Vec<models::CompletionUsage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionFunctionResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "choices" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionFunctionResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "system_fingerprint" => intermediate_rep.system_fingerprint.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usage" => intermediate_rep.usage.push(<models::CompletionUsage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionFunctionResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionFunctionResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CreateChatCompletionFunctionResponse".to_string())?,
            choices: intermediate_rep.choices.into_iter().next().ok_or_else(|| "choices missing in CreateChatCompletionFunctionResponse".to_string())?,
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "created missing in CreateChatCompletionFunctionResponse".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateChatCompletionFunctionResponse".to_string())?,
            system_fingerprint: intermediate_rep.system_fingerprint.into_iter().next(),
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in CreateChatCompletionFunctionResponse".to_string())?,
            usage: intermediate_rep.usage.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionFunctionResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionFunctionResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionFunctionResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateChatCompletionFunctionResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionFunctionResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionFunctionResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateChatCompletionFunctionResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionFunctionResponseChoicesInner {
/// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, or `function_call` if the model called a function. 
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "finish_reason")]
    pub finish_reason: String,

/// The index of the choice in the list of choices.
    #[serde(rename = "index")]
    pub index: i32,

    #[serde(rename = "message")]
    pub message: models::ChatCompletionResponseMessage,

}


impl CreateChatCompletionFunctionResponseChoicesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(finish_reason: String, index: i32, message: models::ChatCompletionResponseMessage, ) -> CreateChatCompletionFunctionResponseChoicesInner {
        CreateChatCompletionFunctionResponseChoicesInner {
            finish_reason,
            index,
            message,
        }
    }
}

/// Converts the CreateChatCompletionFunctionResponseChoicesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionFunctionResponseChoicesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("finish_reason".to_string()),
            Some(self.finish_reason.to_string()),


            Some("index".to_string()),
            Some(self.index.to_string()),

            // Skipping message in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionFunctionResponseChoicesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionFunctionResponseChoicesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub finish_reason: Vec<String>,
            pub index: Vec<i32>,
            pub message: Vec<models::ChatCompletionResponseMessage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionFunctionResponseChoicesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "finish_reason" => intermediate_rep.finish_reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<models::ChatCompletionResponseMessage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionFunctionResponseChoicesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionFunctionResponseChoicesInner {
            finish_reason: intermediate_rep.finish_reason.into_iter().next().ok_or_else(|| "finish_reason missing in CreateChatCompletionFunctionResponseChoicesInner".to_string())?,
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in CreateChatCompletionFunctionResponseChoicesInner".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in CreateChatCompletionFunctionResponseChoicesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionFunctionResponseChoicesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionFunctionResponseChoicesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionFunctionResponseChoicesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateChatCompletionFunctionResponseChoicesInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionFunctionResponseChoicesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionFunctionResponseChoicesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateChatCompletionFunctionResponseChoicesInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionRequest {
/// A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
    #[serde(rename = "messages")]
    #[validate(
            length(min = 1),
        )]
    pub messages: Vec<models::ChatCompletionRequestMessage>,

    #[serde(rename = "model")]
    pub model: models::CreateChatCompletionRequestModel,

/// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.  [See more information about frequency and presence penalties.](/docs/guides/text-generation/parameter-details) 
    #[serde(rename = "frequency_penalty")]
    #[validate(
            range(min = -2, max = 2),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub frequency_penalty: Option<Nullable<f64>>,

/// Modify the likelihood of specified tokens appearing in the completion.  Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token. 
    #[serde(rename = "logit_bias")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logit_bias: Option<Nullable<std::collections::HashMap<String, i32>>>,

/// Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the `content` of `message`.
    #[serde(rename = "logprobs")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logprobs: Option<Nullable<bool>>,

/// An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. `logprobs` must be set to `true` if this parameter is used.
    #[serde(rename = "top_logprobs")]
    #[validate(
            range(min = 0, max = 20),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub top_logprobs: Option<Nullable<u8>>,

/// The maximum number of [tokens](/tokenizer) that can be generated in the chat completion.  The total length of input tokens and generated tokens is limited by the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. 
    #[serde(rename = "max_tokens")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_tokens: Option<Nullable<i32>>,

/// How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
    #[serde(rename = "n")]
    #[validate(
            range(min = 1, max = 128),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub n: Option<Nullable<u8>>,

/// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.  [See more information about frequency and presence penalties.](/docs/guides/text-generation/parameter-details) 
    #[serde(rename = "presence_penalty")]
    #[validate(
            range(min = -2, max = 2),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub presence_penalty: Option<Nullable<f64>>,

    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_format: Option<models::CreateChatCompletionRequestResponseFormat>,

/// This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result. Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend. 
    #[serde(rename = "seed")]
    #[validate(
            range(min = -9223372036854775808, max = 9223372036854775807),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seed: Option<Nullable<i64>>,

    #[serde(rename = "stop")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop: Option<models::CreateChatCompletionRequestStop>,

/// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions). 
    #[serde(rename = "stream")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stream: Option<Nullable<bool>>,

/// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or `top_p` but not both. 
    #[serde(rename = "temperature")]
    #[validate(
            range(min = 0, max = 2),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<Nullable<f64>>,

/// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or `temperature` but not both. 
    #[serde(rename = "top_p")]
    #[validate(
            range(min = 0, max = 1),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub top_p: Option<Nullable<f64>>,

/// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported. 
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Vec<models::ChatCompletionTool>>,

    #[serde(rename = "tool_choice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_choice: Option<models::ChatCompletionToolChoiceOption>,

/// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
    #[serde(rename = "user")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

    #[serde(rename = "function_call")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub function_call: Option<models::CreateChatCompletionRequestFunctionCall>,

/// Deprecated in favor of `tools`.  A list of functions the model may generate JSON inputs for. 
    #[serde(rename = "functions")]
    #[validate(
            length(min = 1, max = 128),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub functions: Option<Vec<models::ChatCompletionFunctions>>,

}


impl CreateChatCompletionRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(messages: Vec<models::ChatCompletionRequestMessage>, model: models::CreateChatCompletionRequestModel, ) -> CreateChatCompletionRequest {
        CreateChatCompletionRequest {
            messages,
            model,
            frequency_penalty: Some(Nullable::Present(0)),
            logit_bias: None,
            logprobs: Some(Nullable::Present(false)),
            top_logprobs: None,
            max_tokens: None,
            n: Some(Nullable::Present(1)),
            presence_penalty: Some(Nullable::Present(0)),
            response_format: None,
            seed: None,
            stop: None,
            stream: Some(Nullable::Present(false)),
            temperature: Some(Nullable::Present(1)),
            top_p: Some(Nullable::Present(1)),
            tools: None,
            tool_choice: None,
            user: None,
            function_call: None,
            functions: None,
        }
    }
}

/// Converts the CreateChatCompletionRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping messages in query parameter serialization

            // Skipping model in query parameter serialization


            self.frequency_penalty.as_ref().map(|frequency_penalty| {
                [
                    "frequency_penalty".to_string(),
                    frequency_penalty.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping logit_bias in query parameter serialization


            self.logprobs.as_ref().map(|logprobs| {
                [
                    "logprobs".to_string(),
                    logprobs.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.top_logprobs.as_ref().map(|top_logprobs| {
                [
                    "top_logprobs".to_string(),
                    top_logprobs.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.max_tokens.as_ref().map(|max_tokens| {
                [
                    "max_tokens".to_string(),
                    max_tokens.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.n.as_ref().map(|n| {
                [
                    "n".to_string(),
                    n.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.presence_penalty.as_ref().map(|presence_penalty| {
                [
                    "presence_penalty".to_string(),
                    presence_penalty.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping response_format in query parameter serialization


            self.seed.as_ref().map(|seed| {
                [
                    "seed".to_string(),
                    seed.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping stop in query parameter serialization


            self.stream.as_ref().map(|stream| {
                [
                    "stream".to_string(),
                    stream.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.top_p.as_ref().map(|top_p| {
                [
                    "top_p".to_string(),
                    top_p.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping tools in query parameter serialization

            // Skipping tool_choice in query parameter serialization


            self.user.as_ref().map(|user| {
                [
                    "user".to_string(),
                    user.to_string(),
                ].join(",")
            }),

            // Skipping function_call in query parameter serialization

            // Skipping functions in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub messages: Vec<Vec<models::ChatCompletionRequestMessage>>,
            pub model: Vec<models::CreateChatCompletionRequestModel>,
            pub frequency_penalty: Vec<f64>,
            pub logit_bias: Vec<std::collections::HashMap<String, i32>>,
            pub logprobs: Vec<bool>,
            pub top_logprobs: Vec<u8>,
            pub max_tokens: Vec<i32>,
            pub n: Vec<u8>,
            pub presence_penalty: Vec<f64>,
            pub response_format: Vec<models::CreateChatCompletionRequestResponseFormat>,
            pub seed: Vec<i64>,
            pub stop: Vec<models::CreateChatCompletionRequestStop>,
            pub stream: Vec<bool>,
            pub temperature: Vec<f64>,
            pub top_p: Vec<f64>,
            pub tools: Vec<Vec<models::ChatCompletionTool>>,
            pub tool_choice: Vec<models::ChatCompletionToolChoiceOption>,
            pub user: Vec<String>,
            pub function_call: Vec<models::CreateChatCompletionRequestFunctionCall>,
            pub functions: Vec<Vec<models::ChatCompletionFunctions>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "messages" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<models::CreateChatCompletionRequestModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "frequency_penalty" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "logit_bias" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "logprobs" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "top_logprobs" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "max_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "n" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "presence_penalty" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "response_format" => intermediate_rep.response_format.push(<models::CreateChatCompletionRequestResponseFormat as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "seed" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "stop" => intermediate_rep.stop.push(<models::CreateChatCompletionRequestStop as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "stream" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "temperature" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "top_p" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "tool_choice" => intermediate_rep.tool_choice.push(<models::ChatCompletionToolChoiceOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function_call" => intermediate_rep.function_call.push(<models::CreateChatCompletionRequestFunctionCall as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "functions" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionRequest {
            messages: intermediate_rep.messages.into_iter().next().ok_or_else(|| "messages missing in CreateChatCompletionRequest".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateChatCompletionRequest".to_string())?,
            frequency_penalty: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            logit_bias: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            logprobs: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            top_logprobs: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            max_tokens: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            n: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            presence_penalty: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            response_format: intermediate_rep.response_format.into_iter().next(),
            seed: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            stop: intermediate_rep.stop.into_iter().next(),
            stream: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            temperature: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            top_p: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            tools: intermediate_rep.tools.into_iter().next(),
            tool_choice: intermediate_rep.tool_choice.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
            function_call: intermediate_rep.function_call.into_iter().next(),
            functions: intermediate_rep.functions.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateChatCompletionRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateChatCompletionRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Deprecated in favor of `tool_choice`.  Controls which (if any) function is called by the model. `none` means the model will not call a function and instead generates a message. `auto` means the model can pick between generating a message or calling a function. Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function.  `none` is the default when no functions are present. `auto` is the default if functions are present. 


/// One of:
/// - ChatCompletionFunctionCallOption
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateChatCompletionRequestFunctionCall(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateChatCompletionRequestFunctionCall
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionRequestFunctionCall value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionRequestFunctionCall {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateChatCompletionRequestFunctionCall {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// ID of the model to use. See the [model endpoint compatibility](/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.

/// Any of:
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateChatCompletionRequestModel(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateChatCompletionRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateChatCompletionRequestModel {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}






/// An object specifying the format that the model must output. Compatible with [GPT-4 Turbo](/docs/models/gpt-4-and-gpt-4-turbo) and all GPT-3.5 Turbo models newer than `gpt-3.5-turbo-1106`.  Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which guarantees the message the model generates is valid JSON.  **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \"stuck\" request. Also note that the message content may be partially cut off if `finish_reason=\"length\"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length. 



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionRequestResponseFormat {
/// Must be one of `text` or `json_object`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

}


impl CreateChatCompletionRequestResponseFormat {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateChatCompletionRequestResponseFormat {
        CreateChatCompletionRequestResponseFormat {
            r#type: Some("text".to_string()),
        }
    }
}

/// Converts the CreateChatCompletionRequestResponseFormat value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionRequestResponseFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionRequestResponseFormat value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionRequestResponseFormat {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionRequestResponseFormat".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionRequestResponseFormat".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionRequestResponseFormat {
            r#type: intermediate_rep.r#type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionRequestResponseFormat> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionRequestResponseFormat>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionRequestResponseFormat>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateChatCompletionRequestResponseFormat - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionRequestResponseFormat> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionRequestResponseFormat as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateChatCompletionRequestResponseFormat - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Up to 4 sequences where the API will stop generating further tokens. 


/// One of:
/// - String
/// - Vec<String>
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateChatCompletionRequestStop(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateChatCompletionRequestStop
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionRequestStop value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionRequestStop {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateChatCompletionRequestStop {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Represents a chat completion response returned by model, based on the provided input.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionResponse {
/// A unique identifier for the chat completion.
    #[serde(rename = "id")]
    pub id: String,

/// A list of chat completion choices. Can be more than one if `n` is greater than 1.
    #[serde(rename = "choices")]
    pub choices: Vec<models::CreateChatCompletionResponseChoicesInner>,

/// The Unix timestamp (in seconds) of when the chat completion was created.
    #[serde(rename = "created")]
    pub created: i32,

/// The model used for the chat completion.
    #[serde(rename = "model")]
    pub model: String,

/// This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
    #[serde(rename = "system_fingerprint")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub system_fingerprint: Option<String>,

/// The object type, which is always `chat.completion`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "usage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub usage: Option<models::CompletionUsage>,

}


impl CreateChatCompletionResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, choices: Vec<models::CreateChatCompletionResponseChoicesInner>, created: i32, model: String, object: String, ) -> CreateChatCompletionResponse {
        CreateChatCompletionResponse {
            id,
            choices,
            created,
            model,
            system_fingerprint: None,
            object,
            usage: None,
        }
    }
}

/// Converts the CreateChatCompletionResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),

            // Skipping choices in query parameter serialization


            Some("created".to_string()),
            Some(self.created.to_string()),


            Some("model".to_string()),
            Some(self.model.to_string()),


            self.system_fingerprint.as_ref().map(|system_fingerprint| {
                [
                    "system_fingerprint".to_string(),
                    system_fingerprint.to_string(),
                ].join(",")
            }),


            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping usage in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub choices: Vec<Vec<models::CreateChatCompletionResponseChoicesInner>>,
            pub created: Vec<i32>,
            pub model: Vec<String>,
            pub system_fingerprint: Vec<String>,
            pub object: Vec<String>,
            pub usage: Vec<models::CompletionUsage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "choices" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "system_fingerprint" => intermediate_rep.system_fingerprint.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usage" => intermediate_rep.usage.push(<models::CompletionUsage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CreateChatCompletionResponse".to_string())?,
            choices: intermediate_rep.choices.into_iter().next().ok_or_else(|| "choices missing in CreateChatCompletionResponse".to_string())?,
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "created missing in CreateChatCompletionResponse".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateChatCompletionResponse".to_string())?,
            system_fingerprint: intermediate_rep.system_fingerprint.into_iter().next(),
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in CreateChatCompletionResponse".to_string())?,
            usage: intermediate_rep.usage.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateChatCompletionResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateChatCompletionResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionResponseChoicesInner {
/// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "finish_reason")]
    pub finish_reason: String,

/// The index of the choice in the list of choices.
    #[serde(rename = "index")]
    pub index: i32,

    #[serde(rename = "message")]
    pub message: models::ChatCompletionResponseMessage,

    #[serde(rename = "logprobs")]
    pub logprobs: Nullable<models::CreateChatCompletionResponseChoicesInnerLogprobs>,

}


impl CreateChatCompletionResponseChoicesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(finish_reason: String, index: i32, message: models::ChatCompletionResponseMessage, logprobs: Nullable<models::CreateChatCompletionResponseChoicesInnerLogprobs>, ) -> CreateChatCompletionResponseChoicesInner {
        CreateChatCompletionResponseChoicesInner {
            finish_reason,
            index,
            message,
            logprobs,
        }
    }
}

/// Converts the CreateChatCompletionResponseChoicesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionResponseChoicesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("finish_reason".to_string()),
            Some(self.finish_reason.to_string()),


            Some("index".to_string()),
            Some(self.index.to_string()),

            // Skipping message in query parameter serialization

            // Skipping logprobs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionResponseChoicesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionResponseChoicesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub finish_reason: Vec<String>,
            pub index: Vec<i32>,
            pub message: Vec<models::ChatCompletionResponseMessage>,
            pub logprobs: Vec<models::CreateChatCompletionResponseChoicesInnerLogprobs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionResponseChoicesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "finish_reason" => intermediate_rep.finish_reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<models::ChatCompletionResponseMessage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "logprobs" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionResponseChoicesInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionResponseChoicesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionResponseChoicesInner {
            finish_reason: intermediate_rep.finish_reason.into_iter().next().ok_or_else(|| "finish_reason missing in CreateChatCompletionResponseChoicesInner".to_string())?,
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in CreateChatCompletionResponseChoicesInner".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in CreateChatCompletionResponseChoicesInner".to_string())?,
            logprobs: std::result::Result::Err("Nullable types not supported in CreateChatCompletionResponseChoicesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionResponseChoicesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionResponseChoicesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionResponseChoicesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateChatCompletionResponseChoicesInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionResponseChoicesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionResponseChoicesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateChatCompletionResponseChoicesInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Log probability information for the choice.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionResponseChoicesInnerLogprobs {
/// A list of message content tokens with log probability information.
    #[serde(rename = "content")]
    pub content: Nullable<Vec<models::ChatCompletionTokenLogprob>>,

}


impl CreateChatCompletionResponseChoicesInnerLogprobs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(content: Nullable<Vec<models::ChatCompletionTokenLogprob>>, ) -> CreateChatCompletionResponseChoicesInnerLogprobs {
        CreateChatCompletionResponseChoicesInnerLogprobs {
            content,
        }
    }
}

/// Converts the CreateChatCompletionResponseChoicesInnerLogprobs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionResponseChoicesInnerLogprobs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping content in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionResponseChoicesInnerLogprobs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionResponseChoicesInnerLogprobs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content: Vec<Vec<models::ChatCompletionTokenLogprob>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionResponseChoicesInnerLogprobs".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "content" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionResponseChoicesInnerLogprobs".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionResponseChoicesInnerLogprobs".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionResponseChoicesInnerLogprobs {
            content: std::result::Result::Err("Nullable types not supported in CreateChatCompletionResponseChoicesInnerLogprobs".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionResponseChoicesInnerLogprobs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionResponseChoicesInnerLogprobs>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionResponseChoicesInnerLogprobs>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateChatCompletionResponseChoicesInnerLogprobs - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionResponseChoicesInnerLogprobs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionResponseChoicesInnerLogprobs as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateChatCompletionResponseChoicesInnerLogprobs - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Represents a streamed chunk of a chat completion response returned by model, based on the provided input.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionStreamResponse {
/// A unique identifier for the chat completion. Each chunk has the same ID.
    #[serde(rename = "id")]
    pub id: String,

/// A list of chat completion choices. Can be more than one if `n` is greater than 1.
    #[serde(rename = "choices")]
    pub choices: Vec<models::CreateChatCompletionStreamResponseChoicesInner>,

/// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
    #[serde(rename = "created")]
    pub created: i32,

/// The model to generate the completion.
    #[serde(rename = "model")]
    pub model: String,

/// This fingerprint represents the backend configuration that the model runs with. Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
    #[serde(rename = "system_fingerprint")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub system_fingerprint: Option<String>,

/// The object type, which is always `chat.completion.chunk`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

}


impl CreateChatCompletionStreamResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, choices: Vec<models::CreateChatCompletionStreamResponseChoicesInner>, created: i32, model: String, object: String, ) -> CreateChatCompletionStreamResponse {
        CreateChatCompletionStreamResponse {
            id,
            choices,
            created,
            model,
            system_fingerprint: None,
            object,
        }
    }
}

/// Converts the CreateChatCompletionStreamResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionStreamResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),

            // Skipping choices in query parameter serialization


            Some("created".to_string()),
            Some(self.created.to_string()),


            Some("model".to_string()),
            Some(self.model.to_string()),


            self.system_fingerprint.as_ref().map(|system_fingerprint| {
                [
                    "system_fingerprint".to_string(),
                    system_fingerprint.to_string(),
                ].join(",")
            }),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionStreamResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionStreamResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub choices: Vec<Vec<models::CreateChatCompletionStreamResponseChoicesInner>>,
            pub created: Vec<i32>,
            pub model: Vec<String>,
            pub system_fingerprint: Vec<String>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionStreamResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "choices" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionStreamResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "system_fingerprint" => intermediate_rep.system_fingerprint.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionStreamResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionStreamResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CreateChatCompletionStreamResponse".to_string())?,
            choices: intermediate_rep.choices.into_iter().next().ok_or_else(|| "choices missing in CreateChatCompletionStreamResponse".to_string())?,
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "created missing in CreateChatCompletionStreamResponse".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateChatCompletionStreamResponse".to_string())?,
            system_fingerprint: intermediate_rep.system_fingerprint.into_iter().next(),
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in CreateChatCompletionStreamResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionStreamResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionStreamResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionStreamResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateChatCompletionStreamResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionStreamResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionStreamResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateChatCompletionStreamResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionStreamResponseChoicesInner {
    #[serde(rename = "delta")]
    pub delta: models::ChatCompletionStreamResponseDelta,

    #[serde(rename = "logprobs")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logprobs: Option<Nullable<models::CreateChatCompletionResponseChoicesInnerLogprobs>>,

/// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "finish_reason")]
    pub finish_reason: Nullable<String>,

/// The index of the choice in the list of choices.
    #[serde(rename = "index")]
    pub index: i32,

}


impl CreateChatCompletionStreamResponseChoicesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(delta: models::ChatCompletionStreamResponseDelta, finish_reason: Nullable<String>, index: i32, ) -> CreateChatCompletionStreamResponseChoicesInner {
        CreateChatCompletionStreamResponseChoicesInner {
            delta,
            logprobs: None,
            finish_reason,
            index,
        }
    }
}

/// Converts the CreateChatCompletionStreamResponseChoicesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionStreamResponseChoicesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping delta in query parameter serialization

            // Skipping logprobs in query parameter serialization


            Some("finish_reason".to_string()),
            Some(self.finish_reason.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("index".to_string()),
            Some(self.index.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionStreamResponseChoicesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionStreamResponseChoicesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub delta: Vec<models::ChatCompletionStreamResponseDelta>,
            pub logprobs: Vec<models::CreateChatCompletionResponseChoicesInnerLogprobs>,
            pub finish_reason: Vec<String>,
            pub index: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionStreamResponseChoicesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "delta" => intermediate_rep.delta.push(<models::ChatCompletionStreamResponseDelta as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "logprobs" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionStreamResponseChoicesInner".to_string()),
                    "finish_reason" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionStreamResponseChoicesInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionStreamResponseChoicesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionStreamResponseChoicesInner {
            delta: intermediate_rep.delta.into_iter().next().ok_or_else(|| "delta missing in CreateChatCompletionStreamResponseChoicesInner".to_string())?,
            logprobs: std::result::Result::Err("Nullable types not supported in CreateChatCompletionStreamResponseChoicesInner".to_string())?,
            finish_reason: std::result::Result::Err("Nullable types not supported in CreateChatCompletionStreamResponseChoicesInner".to_string())?,
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in CreateChatCompletionStreamResponseChoicesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionStreamResponseChoicesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionStreamResponseChoicesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionStreamResponseChoicesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateChatCompletionStreamResponseChoicesInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionStreamResponseChoicesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionStreamResponseChoicesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateChatCompletionStreamResponseChoicesInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateCompletionRequest {
    #[serde(rename = "model")]
    pub model: models::CreateCompletionRequestModel,

    #[serde(rename = "prompt")]
    pub prompt: Nullable<models::CreateCompletionRequestPrompt>,

/// Generates `best_of` completions server-side and returns the \"best\" (the one with the highest log probability per token). Results cannot be streamed.  When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return – `best_of` must be greater than `n`.  **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`. 
    #[serde(rename = "best_of")]
    #[validate(
            range(min = 0, max = 20),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub best_of: Option<Nullable<u8>>,

/// Echo back the prompt in addition to the completion 
    #[serde(rename = "echo")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub echo: Option<Nullable<bool>>,

/// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.  [See more information about frequency and presence penalties.](/docs/guides/text-generation/parameter-details) 
    #[serde(rename = "frequency_penalty")]
    #[validate(
            range(min = -2, max = 2),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub frequency_penalty: Option<Nullable<f64>>,

/// Modify the likelihood of specified tokens appearing in the completion.  Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.  As an example, you can pass `{\"50256\": -100}` to prevent the <|endoftext|> token from being generated. 
    #[serde(rename = "logit_bias")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logit_bias: Option<Nullable<std::collections::HashMap<String, i32>>>,

/// Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.  The maximum value for `logprobs` is 5. 
    #[serde(rename = "logprobs")]
    #[validate(
            range(min = 0, max = 5),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logprobs: Option<Nullable<u8>>,

/// The maximum number of [tokens](/tokenizer) that can be generated in the completion.  The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. 
    #[serde(rename = "max_tokens")]
    #[validate(
            range(min = 0),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_tokens: Option<Nullable<u32>>,

/// How many completions to generate for each prompt.  **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`. 
    #[serde(rename = "n")]
    #[validate(
            range(min = 1, max = 128),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub n: Option<Nullable<u8>>,

/// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.  [See more information about frequency and presence penalties.](/docs/guides/text-generation/parameter-details) 
    #[serde(rename = "presence_penalty")]
    #[validate(
            range(min = -2, max = 2),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub presence_penalty: Option<Nullable<f64>>,

/// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.  Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend. 
    #[serde(rename = "seed")]
    #[validate(
            range(min = -9223372036854775808, max = 9223372036854775807),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seed: Option<Nullable<i64>>,

    #[serde(rename = "stop")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop: Option<Nullable<models::CreateCompletionRequestStop>>,

/// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions). 
    #[serde(rename = "stream")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stream: Option<Nullable<bool>>,

/// The suffix that comes after a completion of inserted text.  This parameter is only supported for `gpt-3.5-turbo-instruct`. 
    #[serde(rename = "suffix")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub suffix: Option<Nullable<String>>,

/// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or `top_p` but not both. 
    #[serde(rename = "temperature")]
    #[validate(
            range(min = 0, max = 2),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<Nullable<f64>>,

/// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or `temperature` but not both. 
    #[serde(rename = "top_p")]
    #[validate(
            range(min = 0, max = 1),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub top_p: Option<Nullable<f64>>,

/// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
    #[serde(rename = "user")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

}


impl CreateCompletionRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(model: models::CreateCompletionRequestModel, prompt: Nullable<models::CreateCompletionRequestPrompt>, ) -> CreateCompletionRequest {
        CreateCompletionRequest {
            model,
            prompt,
            best_of: Some(Nullable::Present(1)),
            echo: Some(Nullable::Present(false)),
            frequency_penalty: Some(Nullable::Present(0)),
            logit_bias: None,
            logprobs: None,
            max_tokens: Some(Nullable::Present(16)),
            n: Some(Nullable::Present(1)),
            presence_penalty: Some(Nullable::Present(0)),
            seed: None,
            stop: None,
            stream: Some(Nullable::Present(false)),
            suffix: None,
            temperature: Some(Nullable::Present(1)),
            top_p: Some(Nullable::Present(1)),
            user: None,
        }
    }
}

/// Converts the CreateCompletionRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateCompletionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping model in query parameter serialization

            // Skipping prompt in query parameter serialization


            self.best_of.as_ref().map(|best_of| {
                [
                    "best_of".to_string(),
                    best_of.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.echo.as_ref().map(|echo| {
                [
                    "echo".to_string(),
                    echo.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.frequency_penalty.as_ref().map(|frequency_penalty| {
                [
                    "frequency_penalty".to_string(),
                    frequency_penalty.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping logit_bias in query parameter serialization


            self.logprobs.as_ref().map(|logprobs| {
                [
                    "logprobs".to_string(),
                    logprobs.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.max_tokens.as_ref().map(|max_tokens| {
                [
                    "max_tokens".to_string(),
                    max_tokens.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.n.as_ref().map(|n| {
                [
                    "n".to_string(),
                    n.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.presence_penalty.as_ref().map(|presence_penalty| {
                [
                    "presence_penalty".to_string(),
                    presence_penalty.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.seed.as_ref().map(|seed| {
                [
                    "seed".to_string(),
                    seed.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping stop in query parameter serialization


            self.stream.as_ref().map(|stream| {
                [
                    "stream".to_string(),
                    stream.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.suffix.as_ref().map(|suffix| {
                [
                    "suffix".to_string(),
                    suffix.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.top_p.as_ref().map(|top_p| {
                [
                    "top_p".to_string(),
                    top_p.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "user".to_string(),
                    user.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateCompletionRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateCompletionRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub model: Vec<models::CreateCompletionRequestModel>,
            pub prompt: Vec<models::CreateCompletionRequestPrompt>,
            pub best_of: Vec<u8>,
            pub echo: Vec<bool>,
            pub frequency_penalty: Vec<f64>,
            pub logit_bias: Vec<std::collections::HashMap<String, i32>>,
            pub logprobs: Vec<u8>,
            pub max_tokens: Vec<u32>,
            pub n: Vec<u8>,
            pub presence_penalty: Vec<f64>,
            pub seed: Vec<i64>,
            pub stop: Vec<models::CreateCompletionRequestStop>,
            pub stream: Vec<bool>,
            pub suffix: Vec<String>,
            pub temperature: Vec<f64>,
            pub top_p: Vec<f64>,
            pub user: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateCompletionRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<models::CreateCompletionRequestModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "prompt" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "best_of" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "echo" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "frequency_penalty" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "logit_bias" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateCompletionRequest".to_string()),
                    "logprobs" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "max_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "n" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "presence_penalty" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "seed" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "stop" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "stream" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "suffix" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "temperature" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "top_p" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateCompletionRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateCompletionRequest {
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateCompletionRequest".to_string())?,
            prompt: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            best_of: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            echo: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            frequency_penalty: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            logit_bias: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            logprobs: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            max_tokens: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            n: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            presence_penalty: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            seed: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            stop: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            stream: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            suffix: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            temperature: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            top_p: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            user: intermediate_rep.user.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateCompletionRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateCompletionRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateCompletionRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateCompletionRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateCompletionRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateCompletionRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateCompletionRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them. 

/// Any of:
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateCompletionRequestModel(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateCompletionRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateCompletionRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateCompletionRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateCompletionRequestModel {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}






/// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.  Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document. 


/// One of:
/// - String
/// - Vec<String>
/// - Vec<Vec<i32>>
/// - Vec<i32>
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateCompletionRequestPrompt(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateCompletionRequestPrompt
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateCompletionRequestPrompt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateCompletionRequestPrompt {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateCompletionRequestPrompt {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence. 


/// One of:
/// - String
/// - Vec<String>
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateCompletionRequestStop(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateCompletionRequestStop
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateCompletionRequestStop value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateCompletionRequestStop {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateCompletionRequestStop {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape (unlike the chat endpoint). 



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateCompletionResponse {
/// A unique identifier for the completion.
    #[serde(rename = "id")]
    pub id: String,

/// The list of completion choices the model generated for the input prompt.
    #[serde(rename = "choices")]
    pub choices: Vec<models::CreateCompletionResponseChoicesInner>,

/// The Unix timestamp (in seconds) of when the completion was created.
    #[serde(rename = "created")]
    pub created: i32,

/// The model used for completion.
    #[serde(rename = "model")]
    pub model: String,

/// This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
    #[serde(rename = "system_fingerprint")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub system_fingerprint: Option<String>,

/// The object type, which is always \"text_completion\"
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "usage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub usage: Option<models::CompletionUsage>,

}


impl CreateCompletionResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, choices: Vec<models::CreateCompletionResponseChoicesInner>, created: i32, model: String, object: String, ) -> CreateCompletionResponse {
        CreateCompletionResponse {
            id,
            choices,
            created,
            model,
            system_fingerprint: None,
            object,
            usage: None,
        }
    }
}

/// Converts the CreateCompletionResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateCompletionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),

            // Skipping choices in query parameter serialization


            Some("created".to_string()),
            Some(self.created.to_string()),


            Some("model".to_string()),
            Some(self.model.to_string()),


            self.system_fingerprint.as_ref().map(|system_fingerprint| {
                [
                    "system_fingerprint".to_string(),
                    system_fingerprint.to_string(),
                ].join(",")
            }),


            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping usage in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateCompletionResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateCompletionResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub choices: Vec<Vec<models::CreateCompletionResponseChoicesInner>>,
            pub created: Vec<i32>,
            pub model: Vec<String>,
            pub system_fingerprint: Vec<String>,
            pub object: Vec<String>,
            pub usage: Vec<models::CompletionUsage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateCompletionResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "choices" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateCompletionResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "system_fingerprint" => intermediate_rep.system_fingerprint.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usage" => intermediate_rep.usage.push(<models::CompletionUsage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateCompletionResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateCompletionResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CreateCompletionResponse".to_string())?,
            choices: intermediate_rep.choices.into_iter().next().ok_or_else(|| "choices missing in CreateCompletionResponse".to_string())?,
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "created missing in CreateCompletionResponse".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateCompletionResponse".to_string())?,
            system_fingerprint: intermediate_rep.system_fingerprint.into_iter().next(),
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in CreateCompletionResponse".to_string())?,
            usage: intermediate_rep.usage.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateCompletionResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateCompletionResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateCompletionResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateCompletionResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateCompletionResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateCompletionResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateCompletionResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateCompletionResponseChoicesInner {
/// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, or `content_filter` if content was omitted due to a flag from our content filters. 
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "finish_reason")]
    pub finish_reason: String,

    #[serde(rename = "index")]
    pub index: i32,

    #[serde(rename = "logprobs")]
    pub logprobs: Nullable<models::CreateCompletionResponseChoicesInnerLogprobs>,

    #[serde(rename = "text")]
    pub text: String,

}


impl CreateCompletionResponseChoicesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(finish_reason: String, index: i32, logprobs: Nullable<models::CreateCompletionResponseChoicesInnerLogprobs>, text: String, ) -> CreateCompletionResponseChoicesInner {
        CreateCompletionResponseChoicesInner {
            finish_reason,
            index,
            logprobs,
            text,
        }
    }
}

/// Converts the CreateCompletionResponseChoicesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateCompletionResponseChoicesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("finish_reason".to_string()),
            Some(self.finish_reason.to_string()),


            Some("index".to_string()),
            Some(self.index.to_string()),

            // Skipping logprobs in query parameter serialization


            Some("text".to_string()),
            Some(self.text.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateCompletionResponseChoicesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateCompletionResponseChoicesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub finish_reason: Vec<String>,
            pub index: Vec<i32>,
            pub logprobs: Vec<models::CreateCompletionResponseChoicesInnerLogprobs>,
            pub text: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateCompletionResponseChoicesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "finish_reason" => intermediate_rep.finish_reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "logprobs" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionResponseChoicesInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateCompletionResponseChoicesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateCompletionResponseChoicesInner {
            finish_reason: intermediate_rep.finish_reason.into_iter().next().ok_or_else(|| "finish_reason missing in CreateCompletionResponseChoicesInner".to_string())?,
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in CreateCompletionResponseChoicesInner".to_string())?,
            logprobs: std::result::Result::Err("Nullable types not supported in CreateCompletionResponseChoicesInner".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in CreateCompletionResponseChoicesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateCompletionResponseChoicesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateCompletionResponseChoicesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateCompletionResponseChoicesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateCompletionResponseChoicesInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateCompletionResponseChoicesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateCompletionResponseChoicesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateCompletionResponseChoicesInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateCompletionResponseChoicesInnerLogprobs {
    #[serde(rename = "text_offset")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text_offset: Option<Vec<i32>>,

    #[serde(rename = "token_logprobs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_logprobs: Option<Vec<f64>>,

    #[serde(rename = "tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tokens: Option<Vec<String>>,

    #[serde(rename = "top_logprobs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub top_logprobs: Option<Vec<std::collections::HashMap<String, f64>>>,

}


impl CreateCompletionResponseChoicesInnerLogprobs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateCompletionResponseChoicesInnerLogprobs {
        CreateCompletionResponseChoicesInnerLogprobs {
            text_offset: None,
            token_logprobs: None,
            tokens: None,
            top_logprobs: None,
        }
    }
}

/// Converts the CreateCompletionResponseChoicesInnerLogprobs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateCompletionResponseChoicesInnerLogprobs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.text_offset.as_ref().map(|text_offset| {
                [
                    "text_offset".to_string(),
                    text_offset.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.token_logprobs.as_ref().map(|token_logprobs| {
                [
                    "token_logprobs".to_string(),
                    token_logprobs.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.tokens.as_ref().map(|tokens| {
                [
                    "tokens".to_string(),
                    tokens.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping top_logprobs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateCompletionResponseChoicesInnerLogprobs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateCompletionResponseChoicesInnerLogprobs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub text_offset: Vec<Vec<i32>>,
            pub token_logprobs: Vec<Vec<f64>>,
            pub tokens: Vec<Vec<String>>,
            pub top_logprobs: Vec<Vec<std::collections::HashMap<String, f64>>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateCompletionResponseChoicesInnerLogprobs".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "text_offset" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateCompletionResponseChoicesInnerLogprobs".to_string()),
                    "token_logprobs" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateCompletionResponseChoicesInnerLogprobs".to_string()),
                    "tokens" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateCompletionResponseChoicesInnerLogprobs".to_string()),
                    "top_logprobs" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateCompletionResponseChoicesInnerLogprobs".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateCompletionResponseChoicesInnerLogprobs".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateCompletionResponseChoicesInnerLogprobs {
            text_offset: intermediate_rep.text_offset.into_iter().next(),
            token_logprobs: intermediate_rep.token_logprobs.into_iter().next(),
            tokens: intermediate_rep.tokens.into_iter().next(),
            top_logprobs: intermediate_rep.top_logprobs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateCompletionResponseChoicesInnerLogprobs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateCompletionResponseChoicesInnerLogprobs>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateCompletionResponseChoicesInnerLogprobs>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateCompletionResponseChoicesInnerLogprobs - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateCompletionResponseChoicesInnerLogprobs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateCompletionResponseChoicesInnerLogprobs as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateCompletionResponseChoicesInnerLogprobs - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateEmbeddingRequest {
    #[serde(rename = "input")]
    pub input: models::CreateEmbeddingRequestInput,

    #[serde(rename = "model")]
    pub model: models::CreateEmbeddingRequestModel,

/// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "encoding_format")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub encoding_format: Option<String>,

/// The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models. 
    #[serde(rename = "dimensions")]
    #[validate(
            range(min = 1),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dimensions: Option<u32>,

/// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
    #[serde(rename = "user")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

}


impl CreateEmbeddingRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(input: models::CreateEmbeddingRequestInput, model: models::CreateEmbeddingRequestModel, ) -> CreateEmbeddingRequest {
        CreateEmbeddingRequest {
            input,
            model,
            encoding_format: Some("float".to_string()),
            dimensions: None,
            user: None,
        }
    }
}

/// Converts the CreateEmbeddingRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateEmbeddingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping input in query parameter serialization

            // Skipping model in query parameter serialization


            self.encoding_format.as_ref().map(|encoding_format| {
                [
                    "encoding_format".to_string(),
                    encoding_format.to_string(),
                ].join(",")
            }),


            self.dimensions.as_ref().map(|dimensions| {
                [
                    "dimensions".to_string(),
                    dimensions.to_string(),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "user".to_string(),
                    user.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateEmbeddingRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateEmbeddingRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub input: Vec<models::CreateEmbeddingRequestInput>,
            pub model: Vec<models::CreateEmbeddingRequestModel>,
            pub encoding_format: Vec<String>,
            pub dimensions: Vec<u32>,
            pub user: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateEmbeddingRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "input" => intermediate_rep.input.push(<models::CreateEmbeddingRequestInput as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<models::CreateEmbeddingRequestModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "encoding_format" => intermediate_rep.encoding_format.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dimensions" => intermediate_rep.dimensions.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateEmbeddingRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateEmbeddingRequest {
            input: intermediate_rep.input.into_iter().next().ok_or_else(|| "input missing in CreateEmbeddingRequest".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateEmbeddingRequest".to_string())?,
            encoding_format: intermediate_rep.encoding_format.into_iter().next(),
            dimensions: intermediate_rep.dimensions.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateEmbeddingRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateEmbeddingRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateEmbeddingRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateEmbeddingRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateEmbeddingRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateEmbeddingRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateEmbeddingRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. 


/// One of:
/// - String
/// - Vec<String>
/// - Vec<Vec<i32>>
/// - Vec<i32>
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateEmbeddingRequestInput(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateEmbeddingRequestInput
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateEmbeddingRequestInput value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateEmbeddingRequestInput {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateEmbeddingRequestInput {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them. 

/// Any of:
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateEmbeddingRequestModel(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateEmbeddingRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateEmbeddingRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateEmbeddingRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateEmbeddingRequestModel {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}









#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateEmbeddingResponse {
/// The list of embeddings generated by the model.
    #[serde(rename = "data")]
    pub data: Vec<models::Embedding>,

/// The name of the model used to generate the embedding.
    #[serde(rename = "model")]
    pub model: String,

/// The object type, which is always \"list\".
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "usage")]
    pub usage: models::CreateEmbeddingResponseUsage,

}


impl CreateEmbeddingResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(data: Vec<models::Embedding>, model: String, object: String, usage: models::CreateEmbeddingResponseUsage, ) -> CreateEmbeddingResponse {
        CreateEmbeddingResponse {
            data,
            model,
            object,
            usage,
        }
    }
}

/// Converts the CreateEmbeddingResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateEmbeddingResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization


            Some("model".to_string()),
            Some(self.model.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping usage in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateEmbeddingResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateEmbeddingResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<Vec<models::Embedding>>,
            pub model: Vec<String>,
            pub object: Vec<String>,
            pub usage: Vec<models::CreateEmbeddingResponseUsage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateEmbeddingResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateEmbeddingResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usage" => intermediate_rep.usage.push(<models::CreateEmbeddingResponseUsage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateEmbeddingResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateEmbeddingResponse {
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in CreateEmbeddingResponse".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateEmbeddingResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in CreateEmbeddingResponse".to_string())?,
            usage: intermediate_rep.usage.into_iter().next().ok_or_else(|| "usage missing in CreateEmbeddingResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateEmbeddingResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateEmbeddingResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateEmbeddingResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateEmbeddingResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateEmbeddingResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateEmbeddingResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateEmbeddingResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The usage information for the request.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateEmbeddingResponseUsage {
/// The number of tokens used by the prompt.
    #[serde(rename = "prompt_tokens")]
    pub prompt_tokens: i32,

/// The total number of tokens used by the request.
    #[serde(rename = "total_tokens")]
    pub total_tokens: i32,

}


impl CreateEmbeddingResponseUsage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(prompt_tokens: i32, total_tokens: i32, ) -> CreateEmbeddingResponseUsage {
        CreateEmbeddingResponseUsage {
            prompt_tokens,
            total_tokens,
        }
    }
}

/// Converts the CreateEmbeddingResponseUsage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateEmbeddingResponseUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("prompt_tokens".to_string()),
            Some(self.prompt_tokens.to_string()),


            Some("total_tokens".to_string()),
            Some(self.total_tokens.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateEmbeddingResponseUsage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateEmbeddingResponseUsage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub prompt_tokens: Vec<i32>,
            pub total_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateEmbeddingResponseUsage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "prompt_tokens" => intermediate_rep.prompt_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total_tokens" => intermediate_rep.total_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateEmbeddingResponseUsage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateEmbeddingResponseUsage {
            prompt_tokens: intermediate_rep.prompt_tokens.into_iter().next().ok_or_else(|| "prompt_tokens missing in CreateEmbeddingResponseUsage".to_string())?,
            total_tokens: intermediate_rep.total_tokens.into_iter().next().ok_or_else(|| "total_tokens missing in CreateEmbeddingResponseUsage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateEmbeddingResponseUsage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateEmbeddingResponseUsage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateEmbeddingResponseUsage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateEmbeddingResponseUsage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateEmbeddingResponseUsage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateEmbeddingResponseUsage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateEmbeddingResponseUsage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateFineTuningJobRequest {
    #[serde(rename = "model")]
    pub model: models::CreateFineTuningJobRequestModel,

/// The ID of an uploaded file that contains training data.  See [upload file](/docs/api-reference/files/upload) for how to upload a file.  Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.  See the [fine-tuning guide](/docs/guides/fine-tuning) for more details. 
    #[serde(rename = "training_file")]
    pub training_file: String,

    #[serde(rename = "hyperparameters")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hyperparameters: Option<models::CreateFineTuningJobRequestHyperparameters>,

/// A string of up to 18 characters that will be added to your fine-tuned model name.  For example, a `suffix` of \"custom-model-name\" would produce a model name like `ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel`. 
    #[serde(rename = "suffix")]
    #[validate(
            length(min = 1, max = 40),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub suffix: Option<Nullable<String>>,

/// The ID of an uploaded file that contains validation data.  If you provide this file, the data is used to generate validation metrics periodically during fine-tuning. These metrics can be viewed in the fine-tuning results file. The same data should not be present in both train and validation files.  Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.  See the [fine-tuning guide](/docs/guides/fine-tuning) for more details. 
    #[serde(rename = "validation_file")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub validation_file: Option<Nullable<String>>,

/// A list of integrations to enable for your fine-tuning job.
    #[serde(rename = "integrations")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub integrations: Option<Nullable<Vec<models::CreateFineTuningJobRequestIntegrationsInner>>>,

/// The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases. If a seed is not specified, one will be generated for you. 
    #[serde(rename = "seed")]
    #[validate(
            range(min = 0, max = 2147483647),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seed: Option<Nullable<u32>>,

}


impl CreateFineTuningJobRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(model: models::CreateFineTuningJobRequestModel, training_file: String, ) -> CreateFineTuningJobRequest {
        CreateFineTuningJobRequest {
            model,
            training_file,
            hyperparameters: None,
            suffix: None,
            validation_file: None,
            integrations: None,
            seed: None,
        }
    }
}

/// Converts the CreateFineTuningJobRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateFineTuningJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping model in query parameter serialization


            Some("training_file".to_string()),
            Some(self.training_file.to_string()),

            // Skipping hyperparameters in query parameter serialization


            self.suffix.as_ref().map(|suffix| {
                [
                    "suffix".to_string(),
                    suffix.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.validation_file.as_ref().map(|validation_file| {
                [
                    "validation_file".to_string(),
                    validation_file.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping integrations in query parameter serialization


            self.seed.as_ref().map(|seed| {
                [
                    "seed".to_string(),
                    seed.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub model: Vec<models::CreateFineTuningJobRequestModel>,
            pub training_file: Vec<String>,
            pub hyperparameters: Vec<models::CreateFineTuningJobRequestHyperparameters>,
            pub suffix: Vec<String>,
            pub validation_file: Vec<String>,
            pub integrations: Vec<Vec<models::CreateFineTuningJobRequestIntegrationsInner>>,
            pub seed: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateFineTuningJobRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<models::CreateFineTuningJobRequestModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "training_file" => intermediate_rep.training_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hyperparameters" => intermediate_rep.hyperparameters.push(<models::CreateFineTuningJobRequestHyperparameters as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "suffix" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateFineTuningJobRequest".to_string()),
                    "validation_file" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateFineTuningJobRequest".to_string()),
                    "integrations" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateFineTuningJobRequest".to_string()),
                    "seed" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateFineTuningJobRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateFineTuningJobRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateFineTuningJobRequest {
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateFineTuningJobRequest".to_string())?,
            training_file: intermediate_rep.training_file.into_iter().next().ok_or_else(|| "training_file missing in CreateFineTuningJobRequest".to_string())?,
            hyperparameters: intermediate_rep.hyperparameters.into_iter().next(),
            suffix: std::result::Result::Err("Nullable types not supported in CreateFineTuningJobRequest".to_string())?,
            validation_file: std::result::Result::Err("Nullable types not supported in CreateFineTuningJobRequest".to_string())?,
            integrations: std::result::Result::Err("Nullable types not supported in CreateFineTuningJobRequest".to_string())?,
            seed: std::result::Result::Err("Nullable types not supported in CreateFineTuningJobRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateFineTuningJobRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateFineTuningJobRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateFineTuningJobRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateFineTuningJobRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateFineTuningJobRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateFineTuningJobRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateFineTuningJobRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The hyperparameters used for the fine-tuning job.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateFineTuningJobRequestHyperparameters {
    #[serde(rename = "batch_size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub batch_size: Option<models::CreateFineTuningJobRequestHyperparametersBatchSize>,

    #[serde(rename = "learning_rate_multiplier")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub learning_rate_multiplier: Option<models::CreateFineTuningJobRequestHyperparametersLearningRateMultiplier>,

    #[serde(rename = "n_epochs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub n_epochs: Option<models::CreateFineTuningJobRequestHyperparametersNEpochs>,

}


impl CreateFineTuningJobRequestHyperparameters {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateFineTuningJobRequestHyperparameters {
        CreateFineTuningJobRequestHyperparameters {
            batch_size: None,
            learning_rate_multiplier: None,
            n_epochs: None,
        }
    }
}

/// Converts the CreateFineTuningJobRequestHyperparameters value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateFineTuningJobRequestHyperparameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping batch_size in query parameter serialization

            // Skipping learning_rate_multiplier in query parameter serialization

            // Skipping n_epochs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequestHyperparameters value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequestHyperparameters {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub batch_size: Vec<models::CreateFineTuningJobRequestHyperparametersBatchSize>,
            pub learning_rate_multiplier: Vec<models::CreateFineTuningJobRequestHyperparametersLearningRateMultiplier>,
            pub n_epochs: Vec<models::CreateFineTuningJobRequestHyperparametersNEpochs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateFineTuningJobRequestHyperparameters".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "batch_size" => intermediate_rep.batch_size.push(<models::CreateFineTuningJobRequestHyperparametersBatchSize as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "learning_rate_multiplier" => intermediate_rep.learning_rate_multiplier.push(<models::CreateFineTuningJobRequestHyperparametersLearningRateMultiplier as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n_epochs" => intermediate_rep.n_epochs.push(<models::CreateFineTuningJobRequestHyperparametersNEpochs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateFineTuningJobRequestHyperparameters".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateFineTuningJobRequestHyperparameters {
            batch_size: intermediate_rep.batch_size.into_iter().next(),
            learning_rate_multiplier: intermediate_rep.learning_rate_multiplier.into_iter().next(),
            n_epochs: intermediate_rep.n_epochs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateFineTuningJobRequestHyperparameters> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateFineTuningJobRequestHyperparameters>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateFineTuningJobRequestHyperparameters>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateFineTuningJobRequestHyperparameters - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateFineTuningJobRequestHyperparameters> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateFineTuningJobRequestHyperparameters as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateFineTuningJobRequestHyperparameters - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance. 


/// One of:
/// - String
/// - i32
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateFineTuningJobRequestHyperparametersBatchSize(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateFineTuningJobRequestHyperparametersBatchSize
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequestHyperparametersBatchSize value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequestHyperparametersBatchSize {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateFineTuningJobRequestHyperparametersBatchSize {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting. 


/// One of:
/// - String
/// - f64
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateFineTuningJobRequestHyperparametersLearningRateMultiplier(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateFineTuningJobRequestHyperparametersLearningRateMultiplier
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequestHyperparametersLearningRateMultiplier value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequestHyperparametersLearningRateMultiplier {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateFineTuningJobRequestHyperparametersLearningRateMultiplier {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset. 


/// One of:
/// - String
/// - i32
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateFineTuningJobRequestHyperparametersNEpochs(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateFineTuningJobRequestHyperparametersNEpochs
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequestHyperparametersNEpochs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequestHyperparametersNEpochs {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateFineTuningJobRequestHyperparametersNEpochs {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateFineTuningJobRequestIntegrationsInner {
    #[serde(rename = "type")]
    pub r#type: models::CreateFineTuningJobRequestIntegrationsInnerType,

    #[serde(rename = "wandb")]
    pub wandb: models::CreateFineTuningJobRequestIntegrationsInnerWandb,

}


impl CreateFineTuningJobRequestIntegrationsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: models::CreateFineTuningJobRequestIntegrationsInnerType, wandb: models::CreateFineTuningJobRequestIntegrationsInnerWandb, ) -> CreateFineTuningJobRequestIntegrationsInner {
        CreateFineTuningJobRequestIntegrationsInner {
            r#type,
            wandb,
        }
    }
}

/// Converts the CreateFineTuningJobRequestIntegrationsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateFineTuningJobRequestIntegrationsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping type in query parameter serialization

            // Skipping wandb in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequestIntegrationsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequestIntegrationsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<models::CreateFineTuningJobRequestIntegrationsInnerType>,
            pub wandb: Vec<models::CreateFineTuningJobRequestIntegrationsInnerWandb>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateFineTuningJobRequestIntegrationsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<models::CreateFineTuningJobRequestIntegrationsInnerType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "wandb" => intermediate_rep.wandb.push(<models::CreateFineTuningJobRequestIntegrationsInnerWandb as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateFineTuningJobRequestIntegrationsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateFineTuningJobRequestIntegrationsInner {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in CreateFineTuningJobRequestIntegrationsInner".to_string())?,
            wandb: intermediate_rep.wandb.into_iter().next().ok_or_else(|| "wandb missing in CreateFineTuningJobRequestIntegrationsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateFineTuningJobRequestIntegrationsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateFineTuningJobRequestIntegrationsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateFineTuningJobRequestIntegrationsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The type of integration to enable. Currently, only \"wandb\" (Weights and Biases) is supported. 


/// One of:
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateFineTuningJobRequestIntegrationsInnerType(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateFineTuningJobRequestIntegrationsInnerType
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequestIntegrationsInnerType value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequestIntegrationsInnerType {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateFineTuningJobRequestIntegrationsInnerType {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// The settings for your integration with Weights and Biases. This payload specifies the project that metrics will be sent to. Optionally, you can set an explicit display name for your run, add tags to your run, and set a default entity (team, username, etc) to be associated with your run. 



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateFineTuningJobRequestIntegrationsInnerWandb {
/// The name of the project that the new run will be created under. 
    #[serde(rename = "project")]
    pub project: String,

/// A display name to set for the run. If not set, we will use the Job ID as the name. 
    #[serde(rename = "name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

/// The entity to use for the run. This allows you to set the team or username of the WandB user that you would like associated with the run. If not set, the default entity for the registered WandB API key is used. 
    #[serde(rename = "entity")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub entity: Option<Nullable<String>>,

/// A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some default tags are generated by OpenAI: \"openai/finetune\", \"openai/{base-model}\", \"openai/{ftjob-abcdef}\". 
    #[serde(rename = "tags")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<Vec<String>>,

}


impl CreateFineTuningJobRequestIntegrationsInnerWandb {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(project: String, ) -> CreateFineTuningJobRequestIntegrationsInnerWandb {
        CreateFineTuningJobRequestIntegrationsInnerWandb {
            project,
            name: None,
            entity: None,
            tags: None,
        }
    }
}

/// Converts the CreateFineTuningJobRequestIntegrationsInnerWandb value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateFineTuningJobRequestIntegrationsInnerWandb {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("project".to_string()),
            Some(self.project.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.entity.as_ref().map(|entity| {
                [
                    "entity".to_string(),
                    entity.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.tags.as_ref().map(|tags| {
                [
                    "tags".to_string(),
                    tags.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequestIntegrationsInnerWandb value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequestIntegrationsInnerWandb {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub project: Vec<String>,
            pub name: Vec<String>,
            pub entity: Vec<String>,
            pub tags: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateFineTuningJobRequestIntegrationsInnerWandb".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "project" => intermediate_rep.project.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateFineTuningJobRequestIntegrationsInnerWandb".to_string()),
                    "entity" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateFineTuningJobRequestIntegrationsInnerWandb".to_string()),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateFineTuningJobRequestIntegrationsInnerWandb".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateFineTuningJobRequestIntegrationsInnerWandb".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateFineTuningJobRequestIntegrationsInnerWandb {
            project: intermediate_rep.project.into_iter().next().ok_or_else(|| "project missing in CreateFineTuningJobRequestIntegrationsInnerWandb".to_string())?,
            name: std::result::Result::Err("Nullable types not supported in CreateFineTuningJobRequestIntegrationsInnerWandb".to_string())?,
            entity: std::result::Result::Err("Nullable types not supported in CreateFineTuningJobRequestIntegrationsInnerWandb".to_string())?,
            tags: intermediate_rep.tags.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInnerWandb> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInnerWandb>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInnerWandb>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateFineTuningJobRequestIntegrationsInnerWandb - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInnerWandb> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateFineTuningJobRequestIntegrationsInnerWandb as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateFineTuningJobRequestIntegrationsInnerWandb - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The name of the model to fine-tune. You can select one of the [supported models](/docs/guides/fine-tuning/what-models-can-be-fine-tuned). 

/// Any of:
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateFineTuningJobRequestModel(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateFineTuningJobRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateFineTuningJobRequestModel {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}






/// The model to use for image generation. Only `dall-e-2` is supported at this time.

/// Any of:
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateImageEditRequestModel(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateImageEditRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateImageEditRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateImageEditRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateImageEditRequestModel {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}









#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateImageRequest {
/// A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
    #[serde(rename = "prompt")]
    pub prompt: String,

    #[serde(rename = "model")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<Nullable<models::CreateImageRequestModel>>,

/// The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
    #[serde(rename = "n")]
    #[validate(
            range(min = 1, max = 10),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub n: Option<Nullable<u8>>,

/// The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "quality")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quality: Option<String>,

/// The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "response_format")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_format: Option<Nullable<String>>,

/// The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "size")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<Nullable<String>>,

/// The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "style")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub style: Option<Nullable<String>>,

/// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
    #[serde(rename = "user")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

}


impl CreateImageRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(prompt: String, ) -> CreateImageRequest {
        CreateImageRequest {
            prompt,
            model: None,
            n: Some(Nullable::Present(1)),
            quality: Some("standard".to_string()),
            response_format: Some(Nullable::Present("url".to_string())),
            size: Some(Nullable::Present("1024x1024".to_string())),
            style: Some(Nullable::Present("vivid".to_string())),
            user: None,
        }
    }
}

/// Converts the CreateImageRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateImageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("prompt".to_string()),
            Some(self.prompt.to_string()),

            // Skipping model in query parameter serialization


            self.n.as_ref().map(|n| {
                [
                    "n".to_string(),
                    n.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.quality.as_ref().map(|quality| {
                [
                    "quality".to_string(),
                    quality.to_string(),
                ].join(",")
            }),


            self.response_format.as_ref().map(|response_format| {
                [
                    "response_format".to_string(),
                    response_format.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.style.as_ref().map(|style| {
                [
                    "style".to_string(),
                    style.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "user".to_string(),
                    user.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateImageRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateImageRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub prompt: Vec<String>,
            pub model: Vec<models::CreateImageRequestModel>,
            pub n: Vec<u8>,
            pub quality: Vec<String>,
            pub response_format: Vec<String>,
            pub size: Vec<String>,
            pub style: Vec<String>,
            pub user: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateImageRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "prompt" => intermediate_rep.prompt.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "model" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateImageRequest".to_string()),
                    "n" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateImageRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "quality" => intermediate_rep.quality.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "response_format" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateImageRequest".to_string()),
                    "size" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateImageRequest".to_string()),
                    "style" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateImageRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateImageRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateImageRequest {
            prompt: intermediate_rep.prompt.into_iter().next().ok_or_else(|| "prompt missing in CreateImageRequest".to_string())?,
            model: std::result::Result::Err("Nullable types not supported in CreateImageRequest".to_string())?,
            n: std::result::Result::Err("Nullable types not supported in CreateImageRequest".to_string())?,
            quality: intermediate_rep.quality.into_iter().next(),
            response_format: std::result::Result::Err("Nullable types not supported in CreateImageRequest".to_string())?,
            size: std::result::Result::Err("Nullable types not supported in CreateImageRequest".to_string())?,
            style: std::result::Result::Err("Nullable types not supported in CreateImageRequest".to_string())?,
            user: intermediate_rep.user.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateImageRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateImageRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateImageRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateImageRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateImageRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateImageRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateImageRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The model to use for image generation.

/// Any of:
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateImageRequestModel(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateImageRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateImageRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateImageRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateImageRequestModel {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}









#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateMessageRequest {
/// The role of the entity that is creating the message. Allowed values include: - `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages. - `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation. 
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
    pub role: String,

/// The content of the message.
    #[serde(rename = "content")]
    #[validate(
            length(min = 1, max = 256000),
        )]
    pub content: String,

/// A list of [File](/docs/api-reference/files) IDs that the message should use. There can be a maximum of 10 files attached to a message. Useful for tools like `retrieval` and `code_interpreter` that can access and use files.
    #[serde(rename = "file_ids")]
    #[validate(
            length(min = 1, max = 10),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_ids: Option<Vec<String>>,

/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}


impl CreateMessageRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(role: String, content: String, ) -> CreateMessageRequest {
        CreateMessageRequest {
            role,
            content,
            file_ids: None,
            metadata: None,
        }
    }
}

/// Converts the CreateMessageRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateMessageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("role".to_string()),
            Some(self.role.to_string()),


            Some("content".to_string()),
            Some(self.content.to_string()),


            self.file_ids.as_ref().map(|file_ids| {
                [
                    "file_ids".to_string(),
                    file_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateMessageRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateMessageRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role: Vec<String>,
            pub content: Vec<String>,
            pub file_ids: Vec<Vec<String>>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateMessageRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content" => intermediate_rep.content.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "file_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateMessageRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateMessageRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateMessageRequest {
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in CreateMessageRequest".to_string())?,
            content: intermediate_rep.content.into_iter().next().ok_or_else(|| "content missing in CreateMessageRequest".to_string())?,
            file_ids: intermediate_rep.file_ids.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateMessageRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateMessageRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateMessageRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateMessageRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateMessageRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateMessageRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateMessageRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateModerationRequest {
    #[serde(rename = "input")]
    pub input: models::CreateModerationRequestInput,

    #[serde(rename = "model")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<models::CreateModerationRequestModel>,

}


impl CreateModerationRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(input: models::CreateModerationRequestInput, ) -> CreateModerationRequest {
        CreateModerationRequest {
            input,
            model: None,
        }
    }
}

/// Converts the CreateModerationRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateModerationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping input in query parameter serialization

            // Skipping model in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub input: Vec<models::CreateModerationRequestInput>,
            pub model: Vec<models::CreateModerationRequestModel>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateModerationRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "input" => intermediate_rep.input.push(<models::CreateModerationRequestInput as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<models::CreateModerationRequestModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateModerationRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateModerationRequest {
            input: intermediate_rep.input.into_iter().next().ok_or_else(|| "input missing in CreateModerationRequest".to_string())?,
            model: intermediate_rep.model.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateModerationRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateModerationRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateModerationRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateModerationRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateModerationRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateModerationRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateModerationRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The input text to classify


/// One of:
/// - String
/// - Vec<String>
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateModerationRequestInput(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateModerationRequestInput
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationRequestInput value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationRequestInput {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateModerationRequestInput {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.  The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`. 

/// Any of:
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateModerationRequestModel(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateModerationRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateModerationRequestModel {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}






/// Represents if a given text input is potentially harmful.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateModerationResponse {
/// The unique identifier for the moderation request.
    #[serde(rename = "id")]
    pub id: String,

/// The model used to generate the moderation results.
    #[serde(rename = "model")]
    pub model: String,

/// A list of moderation objects.
    #[serde(rename = "results")]
    pub results: Vec<models::CreateModerationResponseResultsInner>,

}


impl CreateModerationResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, model: String, results: Vec<models::CreateModerationResponseResultsInner>, ) -> CreateModerationResponse {
        CreateModerationResponse {
            id,
            model,
            results,
        }
    }
}

/// Converts the CreateModerationResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateModerationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("model".to_string()),
            Some(self.model.to_string()),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub model: Vec<String>,
            pub results: Vec<Vec<models::CreateModerationResponseResultsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateModerationResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateModerationResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateModerationResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateModerationResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CreateModerationResponse".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateModerationResponse".to_string())?,
            results: intermediate_rep.results.into_iter().next().ok_or_else(|| "results missing in CreateModerationResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateModerationResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateModerationResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateModerationResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateModerationResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateModerationResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateModerationResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateModerationResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateModerationResponseResultsInner {
/// Whether any of the below categories are flagged.
    #[serde(rename = "flagged")]
    pub flagged: bool,

    #[serde(rename = "categories")]
    pub categories: models::CreateModerationResponseResultsInnerCategories,

    #[serde(rename = "category_scores")]
    pub category_scores: models::CreateModerationResponseResultsInnerCategoryScores,

}


impl CreateModerationResponseResultsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(flagged: bool, categories: models::CreateModerationResponseResultsInnerCategories, category_scores: models::CreateModerationResponseResultsInnerCategoryScores, ) -> CreateModerationResponseResultsInner {
        CreateModerationResponseResultsInner {
            flagged,
            categories,
            category_scores,
        }
    }
}

/// Converts the CreateModerationResponseResultsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateModerationResponseResultsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("flagged".to_string()),
            Some(self.flagged.to_string()),

            // Skipping categories in query parameter serialization

            // Skipping category_scores in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationResponseResultsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationResponseResultsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub flagged: Vec<bool>,
            pub categories: Vec<models::CreateModerationResponseResultsInnerCategories>,
            pub category_scores: Vec<models::CreateModerationResponseResultsInnerCategoryScores>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateModerationResponseResultsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "flagged" => intermediate_rep.flagged.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "categories" => intermediate_rep.categories.push(<models::CreateModerationResponseResultsInnerCategories as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "category_scores" => intermediate_rep.category_scores.push(<models::CreateModerationResponseResultsInnerCategoryScores as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateModerationResponseResultsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateModerationResponseResultsInner {
            flagged: intermediate_rep.flagged.into_iter().next().ok_or_else(|| "flagged missing in CreateModerationResponseResultsInner".to_string())?,
            categories: intermediate_rep.categories.into_iter().next().ok_or_else(|| "categories missing in CreateModerationResponseResultsInner".to_string())?,
            category_scores: intermediate_rep.category_scores.into_iter().next().ok_or_else(|| "category_scores missing in CreateModerationResponseResultsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateModerationResponseResultsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateModerationResponseResultsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateModerationResponseResultsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateModerationResponseResultsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateModerationResponseResultsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateModerationResponseResultsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateModerationResponseResultsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A list of the categories, and whether they are flagged or not.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateModerationResponseResultsInnerCategories {
/// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
    #[serde(rename = "hate")]
    pub hate: bool,

/// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
    #[serde(rename = "hate/threatening")]
    pub hate_slash_threatening: bool,

/// Content that expresses, incites, or promotes harassing language towards any target.
    #[serde(rename = "harassment")]
    pub harassment: bool,

/// Harassment content that also includes violence or serious harm towards any target.
    #[serde(rename = "harassment/threatening")]
    pub harassment_slash_threatening: bool,

/// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
    #[serde(rename = "self-harm")]
    pub self_harm: bool,

/// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
    #[serde(rename = "self-harm/intent")]
    pub self_harm_slash_intent: bool,

/// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
    #[serde(rename = "self-harm/instructions")]
    pub self_harm_slash_instructions: bool,

/// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
    #[serde(rename = "sexual")]
    pub sexual: bool,

/// Sexual content that includes an individual who is under 18 years old.
    #[serde(rename = "sexual/minors")]
    pub sexual_slash_minors: bool,

/// Content that depicts death, violence, or physical injury.
    #[serde(rename = "violence")]
    pub violence: bool,

/// Content that depicts death, violence, or physical injury in graphic detail.
    #[serde(rename = "violence/graphic")]
    pub violence_slash_graphic: bool,

}


impl CreateModerationResponseResultsInnerCategories {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(hate: bool, hate_slash_threatening: bool, harassment: bool, harassment_slash_threatening: bool, self_harm: bool, self_harm_slash_intent: bool, self_harm_slash_instructions: bool, sexual: bool, sexual_slash_minors: bool, violence: bool, violence_slash_graphic: bool, ) -> CreateModerationResponseResultsInnerCategories {
        CreateModerationResponseResultsInnerCategories {
            hate,
            hate_slash_threatening,
            harassment,
            harassment_slash_threatening,
            self_harm,
            self_harm_slash_intent,
            self_harm_slash_instructions,
            sexual,
            sexual_slash_minors,
            violence,
            violence_slash_graphic,
        }
    }
}

/// Converts the CreateModerationResponseResultsInnerCategories value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateModerationResponseResultsInnerCategories {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("hate".to_string()),
            Some(self.hate.to_string()),


            Some("hate/threatening".to_string()),
            Some(self.hate_slash_threatening.to_string()),


            Some("harassment".to_string()),
            Some(self.harassment.to_string()),


            Some("harassment/threatening".to_string()),
            Some(self.harassment_slash_threatening.to_string()),


            Some("self-harm".to_string()),
            Some(self.self_harm.to_string()),


            Some("self-harm/intent".to_string()),
            Some(self.self_harm_slash_intent.to_string()),


            Some("self-harm/instructions".to_string()),
            Some(self.self_harm_slash_instructions.to_string()),


            Some("sexual".to_string()),
            Some(self.sexual.to_string()),


            Some("sexual/minors".to_string()),
            Some(self.sexual_slash_minors.to_string()),


            Some("violence".to_string()),
            Some(self.violence.to_string()),


            Some("violence/graphic".to_string()),
            Some(self.violence_slash_graphic.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationResponseResultsInnerCategories value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationResponseResultsInnerCategories {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hate: Vec<bool>,
            pub hate_slash_threatening: Vec<bool>,
            pub harassment: Vec<bool>,
            pub harassment_slash_threatening: Vec<bool>,
            pub self_harm: Vec<bool>,
            pub self_harm_slash_intent: Vec<bool>,
            pub self_harm_slash_instructions: Vec<bool>,
            pub sexual: Vec<bool>,
            pub sexual_slash_minors: Vec<bool>,
            pub violence: Vec<bool>,
            pub violence_slash_graphic: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateModerationResponseResultsInnerCategories".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "hate" => intermediate_rep.hate.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hate/threatening" => intermediate_rep.hate_slash_threatening.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "harassment" => intermediate_rep.harassment.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "harassment/threatening" => intermediate_rep.harassment_slash_threatening.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "self-harm" => intermediate_rep.self_harm.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "self-harm/intent" => intermediate_rep.self_harm_slash_intent.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "self-harm/instructions" => intermediate_rep.self_harm_slash_instructions.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sexual" => intermediate_rep.sexual.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sexual/minors" => intermediate_rep.sexual_slash_minors.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "violence" => intermediate_rep.violence.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "violence/graphic" => intermediate_rep.violence_slash_graphic.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateModerationResponseResultsInnerCategories".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateModerationResponseResultsInnerCategories {
            hate: intermediate_rep.hate.into_iter().next().ok_or_else(|| "hate missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            hate_slash_threatening: intermediate_rep.hate_slash_threatening.into_iter().next().ok_or_else(|| "hate/threatening missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            harassment: intermediate_rep.harassment.into_iter().next().ok_or_else(|| "harassment missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            harassment_slash_threatening: intermediate_rep.harassment_slash_threatening.into_iter().next().ok_or_else(|| "harassment/threatening missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            self_harm: intermediate_rep.self_harm.into_iter().next().ok_or_else(|| "self-harm missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            self_harm_slash_intent: intermediate_rep.self_harm_slash_intent.into_iter().next().ok_or_else(|| "self-harm/intent missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            self_harm_slash_instructions: intermediate_rep.self_harm_slash_instructions.into_iter().next().ok_or_else(|| "self-harm/instructions missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            sexual: intermediate_rep.sexual.into_iter().next().ok_or_else(|| "sexual missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            sexual_slash_minors: intermediate_rep.sexual_slash_minors.into_iter().next().ok_or_else(|| "sexual/minors missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            violence: intermediate_rep.violence.into_iter().next().ok_or_else(|| "violence missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            violence_slash_graphic: intermediate_rep.violence_slash_graphic.into_iter().next().ok_or_else(|| "violence/graphic missing in CreateModerationResponseResultsInnerCategories".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateModerationResponseResultsInnerCategories> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateModerationResponseResultsInnerCategories>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateModerationResponseResultsInnerCategories>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateModerationResponseResultsInnerCategories - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateModerationResponseResultsInnerCategories> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateModerationResponseResultsInnerCategories as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateModerationResponseResultsInnerCategories - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A list of the categories along with their scores as predicted by model.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateModerationResponseResultsInnerCategoryScores {
/// The score for the category 'hate'.
    #[serde(rename = "hate")]
    pub hate: f64,

/// The score for the category 'hate/threatening'.
    #[serde(rename = "hate/threatening")]
    pub hate_slash_threatening: f64,

/// The score for the category 'harassment'.
    #[serde(rename = "harassment")]
    pub harassment: f64,

/// The score for the category 'harassment/threatening'.
    #[serde(rename = "harassment/threatening")]
    pub harassment_slash_threatening: f64,

/// The score for the category 'self-harm'.
    #[serde(rename = "self-harm")]
    pub self_harm: f64,

/// The score for the category 'self-harm/intent'.
    #[serde(rename = "self-harm/intent")]
    pub self_harm_slash_intent: f64,

/// The score for the category 'self-harm/instructions'.
    #[serde(rename = "self-harm/instructions")]
    pub self_harm_slash_instructions: f64,

/// The score for the category 'sexual'.
    #[serde(rename = "sexual")]
    pub sexual: f64,

/// The score for the category 'sexual/minors'.
    #[serde(rename = "sexual/minors")]
    pub sexual_slash_minors: f64,

/// The score for the category 'violence'.
    #[serde(rename = "violence")]
    pub violence: f64,

/// The score for the category 'violence/graphic'.
    #[serde(rename = "violence/graphic")]
    pub violence_slash_graphic: f64,

}


impl CreateModerationResponseResultsInnerCategoryScores {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(hate: f64, hate_slash_threatening: f64, harassment: f64, harassment_slash_threatening: f64, self_harm: f64, self_harm_slash_intent: f64, self_harm_slash_instructions: f64, sexual: f64, sexual_slash_minors: f64, violence: f64, violence_slash_graphic: f64, ) -> CreateModerationResponseResultsInnerCategoryScores {
        CreateModerationResponseResultsInnerCategoryScores {
            hate,
            hate_slash_threatening,
            harassment,
            harassment_slash_threatening,
            self_harm,
            self_harm_slash_intent,
            self_harm_slash_instructions,
            sexual,
            sexual_slash_minors,
            violence,
            violence_slash_graphic,
        }
    }
}

/// Converts the CreateModerationResponseResultsInnerCategoryScores value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateModerationResponseResultsInnerCategoryScores {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("hate".to_string()),
            Some(self.hate.to_string()),


            Some("hate/threatening".to_string()),
            Some(self.hate_slash_threatening.to_string()),


            Some("harassment".to_string()),
            Some(self.harassment.to_string()),


            Some("harassment/threatening".to_string()),
            Some(self.harassment_slash_threatening.to_string()),


            Some("self-harm".to_string()),
            Some(self.self_harm.to_string()),


            Some("self-harm/intent".to_string()),
            Some(self.self_harm_slash_intent.to_string()),


            Some("self-harm/instructions".to_string()),
            Some(self.self_harm_slash_instructions.to_string()),


            Some("sexual".to_string()),
            Some(self.sexual.to_string()),


            Some("sexual/minors".to_string()),
            Some(self.sexual_slash_minors.to_string()),


            Some("violence".to_string()),
            Some(self.violence.to_string()),


            Some("violence/graphic".to_string()),
            Some(self.violence_slash_graphic.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationResponseResultsInnerCategoryScores value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationResponseResultsInnerCategoryScores {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hate: Vec<f64>,
            pub hate_slash_threatening: Vec<f64>,
            pub harassment: Vec<f64>,
            pub harassment_slash_threatening: Vec<f64>,
            pub self_harm: Vec<f64>,
            pub self_harm_slash_intent: Vec<f64>,
            pub self_harm_slash_instructions: Vec<f64>,
            pub sexual: Vec<f64>,
            pub sexual_slash_minors: Vec<f64>,
            pub violence: Vec<f64>,
            pub violence_slash_graphic: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateModerationResponseResultsInnerCategoryScores".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "hate" => intermediate_rep.hate.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hate/threatening" => intermediate_rep.hate_slash_threatening.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "harassment" => intermediate_rep.harassment.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "harassment/threatening" => intermediate_rep.harassment_slash_threatening.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "self-harm" => intermediate_rep.self_harm.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "self-harm/intent" => intermediate_rep.self_harm_slash_intent.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "self-harm/instructions" => intermediate_rep.self_harm_slash_instructions.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sexual" => intermediate_rep.sexual.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sexual/minors" => intermediate_rep.sexual_slash_minors.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "violence" => intermediate_rep.violence.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "violence/graphic" => intermediate_rep.violence_slash_graphic.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateModerationResponseResultsInnerCategoryScores".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateModerationResponseResultsInnerCategoryScores {
            hate: intermediate_rep.hate.into_iter().next().ok_or_else(|| "hate missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            hate_slash_threatening: intermediate_rep.hate_slash_threatening.into_iter().next().ok_or_else(|| "hate/threatening missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            harassment: intermediate_rep.harassment.into_iter().next().ok_or_else(|| "harassment missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            harassment_slash_threatening: intermediate_rep.harassment_slash_threatening.into_iter().next().ok_or_else(|| "harassment/threatening missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            self_harm: intermediate_rep.self_harm.into_iter().next().ok_or_else(|| "self-harm missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            self_harm_slash_intent: intermediate_rep.self_harm_slash_intent.into_iter().next().ok_or_else(|| "self-harm/intent missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            self_harm_slash_instructions: intermediate_rep.self_harm_slash_instructions.into_iter().next().ok_or_else(|| "self-harm/instructions missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            sexual: intermediate_rep.sexual.into_iter().next().ok_or_else(|| "sexual missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            sexual_slash_minors: intermediate_rep.sexual_slash_minors.into_iter().next().ok_or_else(|| "sexual/minors missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            violence: intermediate_rep.violence.into_iter().next().ok_or_else(|| "violence missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            violence_slash_graphic: intermediate_rep.violence_slash_graphic.into_iter().next().ok_or_else(|| "violence/graphic missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateModerationResponseResultsInnerCategoryScores> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateModerationResponseResultsInnerCategoryScores>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateModerationResponseResultsInnerCategoryScores>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateModerationResponseResultsInnerCategoryScores - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateModerationResponseResultsInnerCategoryScores> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateModerationResponseResultsInnerCategoryScores as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateModerationResponseResultsInnerCategoryScores - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateRunRequest {
/// The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
    #[serde(rename = "assistant_id")]
    pub assistant_id: String,

    #[serde(rename = "model")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<Nullable<models::CreateRunRequestModel>>,

/// Overrides the [instructions](/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis.
    #[serde(rename = "instructions")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instructions: Option<Nullable<String>>,

/// Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.
    #[serde(rename = "additional_instructions")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_instructions: Option<Nullable<String>>,

/// Adds additional messages to the thread before creating the run.
    #[serde(rename = "additional_messages")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_messages: Option<Nullable<Vec<models::CreateMessageRequest>>>,

/// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
    #[serde(rename = "tools")]
    #[validate(
            length(max = 20),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Nullable<Vec<models::AssistantObjectToolsInner>>>,

/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

/// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
    #[serde(rename = "temperature")]
    #[validate(
            range(min = 0, max = 2),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<Nullable<f64>>,

/// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message. 
    #[serde(rename = "stream")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stream: Option<Nullable<bool>>,

/// The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `complete`. See `incomplete_details` for more info. 
    #[serde(rename = "max_prompt_tokens")]
    #[validate(
            range(min = 256),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_prompt_tokens: Option<Nullable<u32>>,

/// The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `complete`. See `incomplete_details` for more info. 
    #[serde(rename = "max_completion_tokens")]
    #[validate(
            range(min = 256),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_completion_tokens: Option<Nullable<u32>>,

    #[serde(rename = "truncation_strategy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub truncation_strategy: Option<models::TruncationObject>,

    #[serde(rename = "tool_choice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_choice: Option<models::AssistantsApiToolChoiceOption>,

    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_format: Option<models::AssistantsApiResponseFormatOption>,

}


impl CreateRunRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(assistant_id: String, ) -> CreateRunRequest {
        CreateRunRequest {
            assistant_id,
            model: None,
            instructions: None,
            additional_instructions: None,
            additional_messages: None,
            tools: None,
            metadata: None,
            temperature: Some(Nullable::Present(1)),
            stream: None,
            max_prompt_tokens: None,
            max_completion_tokens: None,
            truncation_strategy: None,
            tool_choice: None,
            response_format: None,
        }
    }
}

/// Converts the CreateRunRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateRunRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("assistant_id".to_string()),
            Some(self.assistant_id.to_string()),

            // Skipping model in query parameter serialization


            self.instructions.as_ref().map(|instructions| {
                [
                    "instructions".to_string(),
                    instructions.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.additional_instructions.as_ref().map(|additional_instructions| {
                [
                    "additional_instructions".to_string(),
                    additional_instructions.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping additional_messages in query parameter serialization

            // Skipping tools in query parameter serialization

            // Skipping metadata in query parameter serialization


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.stream.as_ref().map(|stream| {
                [
                    "stream".to_string(),
                    stream.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.max_prompt_tokens.as_ref().map(|max_prompt_tokens| {
                [
                    "max_prompt_tokens".to_string(),
                    max_prompt_tokens.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.max_completion_tokens.as_ref().map(|max_completion_tokens| {
                [
                    "max_completion_tokens".to_string(),
                    max_completion_tokens.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping truncation_strategy in query parameter serialization

            // Skipping tool_choice in query parameter serialization

            // Skipping response_format in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateRunRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateRunRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub assistant_id: Vec<String>,
            pub model: Vec<models::CreateRunRequestModel>,
            pub instructions: Vec<String>,
            pub additional_instructions: Vec<String>,
            pub additional_messages: Vec<Vec<models::CreateMessageRequest>>,
            pub tools: Vec<Vec<models::AssistantObjectToolsInner>>,
            pub metadata: Vec<crate::types::Object>,
            pub temperature: Vec<f64>,
            pub stream: Vec<bool>,
            pub max_prompt_tokens: Vec<u32>,
            pub max_completion_tokens: Vec<u32>,
            pub truncation_strategy: Vec<models::TruncationObject>,
            pub tool_choice: Vec<models::AssistantsApiToolChoiceOption>,
            pub response_format: Vec<models::AssistantsApiResponseFormatOption>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateRunRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "assistant_id" => intermediate_rep.assistant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "model" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateRunRequest".to_string()),
                    "instructions" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateRunRequest".to_string()),
                    "additional_instructions" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateRunRequest".to_string()),
                    "additional_messages" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateRunRequest".to_string()),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateRunRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "temperature" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateRunRequest".to_string()),
                    "stream" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateRunRequest".to_string()),
                    "max_prompt_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateRunRequest".to_string()),
                    "max_completion_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateRunRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "truncation_strategy" => intermediate_rep.truncation_strategy.push(<models::TruncationObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tool_choice" => intermediate_rep.tool_choice.push(<models::AssistantsApiToolChoiceOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_format" => intermediate_rep.response_format.push(<models::AssistantsApiResponseFormatOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateRunRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateRunRequest {
            assistant_id: intermediate_rep.assistant_id.into_iter().next().ok_or_else(|| "assistant_id missing in CreateRunRequest".to_string())?,
            model: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            instructions: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            additional_instructions: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            additional_messages: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            tools: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next(),
            temperature: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            stream: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            max_prompt_tokens: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            max_completion_tokens: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            truncation_strategy: intermediate_rep.truncation_strategy.into_iter().next(),
            tool_choice: intermediate_rep.tool_choice.into_iter().next(),
            response_format: intermediate_rep.response_format.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateRunRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateRunRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateRunRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateRunRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateRunRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateRunRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateRunRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The ID of the [Model](/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.

/// Any of:
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateRunRequestModel(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateRunRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateRunRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateRunRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateRunRequestModel {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}









#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateSpeechRequest {
    #[serde(rename = "model")]
    pub model: models::CreateSpeechRequestModel,

/// The text to generate audio for. The maximum length is 4096 characters.
    #[serde(rename = "input")]
    #[validate(
            length(max = 4096),
        )]
    pub input: String,

/// The voice to use when generating the audio. Supported voices are `alloy`, `echo`, `fable`, `onyx`, `nova`, and `shimmer`. Previews of the voices are available in the [Text to speech guide](/docs/guides/text-to-speech/voice-options).
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "voice")]
    pub voice: String,

/// The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_format: Option<String>,

/// The speed of the generated audio. Select a value from `0.25` to `4.0`. `1.0` is the default.
    #[serde(rename = "speed")]
    #[validate(
            range(min = 0.25, max = 4.0),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub speed: Option<f64>,

}


impl CreateSpeechRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(model: models::CreateSpeechRequestModel, input: String, voice: String, ) -> CreateSpeechRequest {
        CreateSpeechRequest {
            model,
            input,
            voice,
            response_format: Some("mp3".to_string()),
            speed: Some(1.0),
        }
    }
}

/// Converts the CreateSpeechRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateSpeechRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping model in query parameter serialization


            Some("input".to_string()),
            Some(self.input.to_string()),


            Some("voice".to_string()),
            Some(self.voice.to_string()),


            self.response_format.as_ref().map(|response_format| {
                [
                    "response_format".to_string(),
                    response_format.to_string(),
                ].join(",")
            }),


            self.speed.as_ref().map(|speed| {
                [
                    "speed".to_string(),
                    speed.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateSpeechRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateSpeechRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub model: Vec<models::CreateSpeechRequestModel>,
            pub input: Vec<String>,
            pub voice: Vec<String>,
            pub response_format: Vec<String>,
            pub speed: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateSpeechRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<models::CreateSpeechRequestModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input" => intermediate_rep.input.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "voice" => intermediate_rep.voice.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_format" => intermediate_rep.response_format.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "speed" => intermediate_rep.speed.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateSpeechRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateSpeechRequest {
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateSpeechRequest".to_string())?,
            input: intermediate_rep.input.into_iter().next().ok_or_else(|| "input missing in CreateSpeechRequest".to_string())?,
            voice: intermediate_rep.voice.into_iter().next().ok_or_else(|| "voice missing in CreateSpeechRequest".to_string())?,
            response_format: intermediate_rep.response_format.into_iter().next(),
            speed: intermediate_rep.speed.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateSpeechRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateSpeechRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateSpeechRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateSpeechRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateSpeechRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateSpeechRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateSpeechRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// One of the available [TTS models](/docs/models/tts): `tts-1` or `tts-1-hd` 

/// Any of:
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateSpeechRequestModel(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateSpeechRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateSpeechRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateSpeechRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateSpeechRequestModel {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}









#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateThreadAndRunRequest {
/// The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
    #[serde(rename = "assistant_id")]
    pub assistant_id: String,

    #[serde(rename = "thread")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub thread: Option<models::CreateThreadRequest>,

    #[serde(rename = "model")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<Nullable<models::CreateRunRequestModel>>,

/// Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.
    #[serde(rename = "instructions")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instructions: Option<Nullable<String>>,

/// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
    #[serde(rename = "tools")]
    #[validate(
            length(max = 20),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Nullable<Vec<models::CreateThreadAndRunRequestToolsInner>>>,

/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

/// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
    #[serde(rename = "temperature")]
    #[validate(
            range(min = 0, max = 2),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<Nullable<f64>>,

/// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message. 
    #[serde(rename = "stream")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stream: Option<Nullable<bool>>,

/// The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `complete`. See `incomplete_details` for more info. 
    #[serde(rename = "max_prompt_tokens")]
    #[validate(
            range(min = 256),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_prompt_tokens: Option<Nullable<u32>>,

/// The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info. 
    #[serde(rename = "max_completion_tokens")]
    #[validate(
            range(min = 256),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_completion_tokens: Option<Nullable<u32>>,

    #[serde(rename = "truncation_strategy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub truncation_strategy: Option<models::TruncationObject>,

    #[serde(rename = "tool_choice")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_choice: Option<models::AssistantsApiToolChoiceOption>,

    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_format: Option<models::AssistantsApiResponseFormatOption>,

}


impl CreateThreadAndRunRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(assistant_id: String, ) -> CreateThreadAndRunRequest {
        CreateThreadAndRunRequest {
            assistant_id,
            thread: None,
            model: None,
            instructions: None,
            tools: None,
            metadata: None,
            temperature: Some(Nullable::Present(1)),
            stream: None,
            max_prompt_tokens: None,
            max_completion_tokens: None,
            truncation_strategy: None,
            tool_choice: None,
            response_format: None,
        }
    }
}

/// Converts the CreateThreadAndRunRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateThreadAndRunRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("assistant_id".to_string()),
            Some(self.assistant_id.to_string()),

            // Skipping thread in query parameter serialization

            // Skipping model in query parameter serialization


            self.instructions.as_ref().map(|instructions| {
                [
                    "instructions".to_string(),
                    instructions.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping tools in query parameter serialization

            // Skipping metadata in query parameter serialization


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.stream.as_ref().map(|stream| {
                [
                    "stream".to_string(),
                    stream.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.max_prompt_tokens.as_ref().map(|max_prompt_tokens| {
                [
                    "max_prompt_tokens".to_string(),
                    max_prompt_tokens.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.max_completion_tokens.as_ref().map(|max_completion_tokens| {
                [
                    "max_completion_tokens".to_string(),
                    max_completion_tokens.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping truncation_strategy in query parameter serialization

            // Skipping tool_choice in query parameter serialization

            // Skipping response_format in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateThreadAndRunRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateThreadAndRunRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub assistant_id: Vec<String>,
            pub thread: Vec<models::CreateThreadRequest>,
            pub model: Vec<models::CreateRunRequestModel>,
            pub instructions: Vec<String>,
            pub tools: Vec<Vec<models::CreateThreadAndRunRequestToolsInner>>,
            pub metadata: Vec<crate::types::Object>,
            pub temperature: Vec<f64>,
            pub stream: Vec<bool>,
            pub max_prompt_tokens: Vec<u32>,
            pub max_completion_tokens: Vec<u32>,
            pub truncation_strategy: Vec<models::TruncationObject>,
            pub tool_choice: Vec<models::AssistantsApiToolChoiceOption>,
            pub response_format: Vec<models::AssistantsApiResponseFormatOption>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateThreadAndRunRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "assistant_id" => intermediate_rep.assistant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "thread" => intermediate_rep.thread.push(<models::CreateThreadRequest as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "model" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    "instructions" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "temperature" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    "stream" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    "max_prompt_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    "max_completion_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "truncation_strategy" => intermediate_rep.truncation_strategy.push(<models::TruncationObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tool_choice" => intermediate_rep.tool_choice.push(<models::AssistantsApiToolChoiceOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_format" => intermediate_rep.response_format.push(<models::AssistantsApiResponseFormatOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateThreadAndRunRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateThreadAndRunRequest {
            assistant_id: intermediate_rep.assistant_id.into_iter().next().ok_or_else(|| "assistant_id missing in CreateThreadAndRunRequest".to_string())?,
            thread: intermediate_rep.thread.into_iter().next(),
            model: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            instructions: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            tools: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next(),
            temperature: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            stream: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            max_prompt_tokens: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            max_completion_tokens: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            truncation_strategy: intermediate_rep.truncation_strategy.into_iter().next(),
            tool_choice: intermediate_rep.tool_choice.into_iter().next(),
            response_format: intermediate_rep.response_format.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateThreadAndRunRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateThreadAndRunRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateThreadAndRunRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateThreadAndRunRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateThreadAndRunRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateThreadAndRunRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateThreadAndRunRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - AssistantToolsCode
/// - AssistantToolsFunction
/// - AssistantToolsRetrieval
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateThreadAndRunRequestToolsInner(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateThreadAndRunRequestToolsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateThreadAndRunRequestToolsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateThreadAndRunRequestToolsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateThreadAndRunRequestToolsInner {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateThreadRequest {
/// A list of [messages](/docs/api-reference/messages) to start the thread with.
    #[serde(rename = "messages")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub messages: Option<Vec<models::CreateMessageRequest>>,

/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}


impl CreateThreadRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateThreadRequest {
        CreateThreadRequest {
            messages: None,
            metadata: None,
        }
    }
}

/// Converts the CreateThreadRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateThreadRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping messages in query parameter serialization

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateThreadRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateThreadRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub messages: Vec<Vec<models::CreateMessageRequest>>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateThreadRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "messages" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateThreadRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateThreadRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateThreadRequest {
            messages: intermediate_rep.messages.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateThreadRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateThreadRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateThreadRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateThreadRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateThreadRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateThreadRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateThreadRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - CreateTranscriptionResponseJson
/// - CreateTranscriptionResponseVerboseJson
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateTranscription200Response(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateTranscription200Response
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTranscription200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTranscription200Response {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateTranscription200Response {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available. 

/// Any of:
/// - String
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateTranscriptionRequestModel(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateTranscriptionRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTranscriptionRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTranscriptionRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateTranscriptionRequestModel {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}






/// Represents a transcription response returned by model, based on the provided input.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateTranscriptionResponseJson {
/// The transcribed text.
    #[serde(rename = "text")]
    pub text: String,

}


impl CreateTranscriptionResponseJson {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(text: String, ) -> CreateTranscriptionResponseJson {
        CreateTranscriptionResponseJson {
            text,
        }
    }
}

/// Converts the CreateTranscriptionResponseJson value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateTranscriptionResponseJson {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("text".to_string()),
            Some(self.text.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTranscriptionResponseJson value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTranscriptionResponseJson {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub text: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateTranscriptionResponseJson".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateTranscriptionResponseJson".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateTranscriptionResponseJson {
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in CreateTranscriptionResponseJson".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateTranscriptionResponseJson> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateTranscriptionResponseJson>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateTranscriptionResponseJson>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateTranscriptionResponseJson - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateTranscriptionResponseJson> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateTranscriptionResponseJson as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateTranscriptionResponseJson - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Represents a verbose json transcription response returned by model, based on the provided input.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateTranscriptionResponseVerboseJson {
/// The language of the input audio.
    #[serde(rename = "language")]
    pub language: String,

/// The duration of the input audio.
    #[serde(rename = "duration")]
    pub duration: String,

/// The transcribed text.
    #[serde(rename = "text")]
    pub text: String,

/// Extracted words and their corresponding timestamps.
    #[serde(rename = "words")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub words: Option<Vec<models::TranscriptionWord>>,

/// Segments of the transcribed text and their corresponding details.
    #[serde(rename = "segments")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub segments: Option<Vec<models::TranscriptionSegment>>,

}


impl CreateTranscriptionResponseVerboseJson {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(language: String, duration: String, text: String, ) -> CreateTranscriptionResponseVerboseJson {
        CreateTranscriptionResponseVerboseJson {
            language,
            duration,
            text,
            words: None,
            segments: None,
        }
    }
}

/// Converts the CreateTranscriptionResponseVerboseJson value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateTranscriptionResponseVerboseJson {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("language".to_string()),
            Some(self.language.to_string()),


            Some("duration".to_string()),
            Some(self.duration.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),

            // Skipping words in query parameter serialization

            // Skipping segments in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTranscriptionResponseVerboseJson value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTranscriptionResponseVerboseJson {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub language: Vec<String>,
            pub duration: Vec<String>,
            pub text: Vec<String>,
            pub words: Vec<Vec<models::TranscriptionWord>>,
            pub segments: Vec<Vec<models::TranscriptionSegment>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateTranscriptionResponseVerboseJson".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "duration" => intermediate_rep.duration.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "words" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateTranscriptionResponseVerboseJson".to_string()),
                    "segments" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateTranscriptionResponseVerboseJson".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateTranscriptionResponseVerboseJson".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateTranscriptionResponseVerboseJson {
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in CreateTranscriptionResponseVerboseJson".to_string())?,
            duration: intermediate_rep.duration.into_iter().next().ok_or_else(|| "duration missing in CreateTranscriptionResponseVerboseJson".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in CreateTranscriptionResponseVerboseJson".to_string())?,
            words: intermediate_rep.words.into_iter().next(),
            segments: intermediate_rep.segments.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateTranscriptionResponseVerboseJson> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateTranscriptionResponseVerboseJson>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateTranscriptionResponseVerboseJson>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateTranscriptionResponseVerboseJson - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateTranscriptionResponseVerboseJson> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateTranscriptionResponseVerboseJson as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateTranscriptionResponseVerboseJson - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - CreateTranslationResponseJson
/// - CreateTranslationResponseVerboseJson
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CreateTranslation200Response(Box<serde_json::value::RawValue>);

impl validator::Validate for CreateTranslation200Response
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTranslation200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTranslation200Response {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for CreateTranslation200Response {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateTranslationResponseJson {
    #[serde(rename = "text")]
    pub text: String,

}


impl CreateTranslationResponseJson {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(text: String, ) -> CreateTranslationResponseJson {
        CreateTranslationResponseJson {
            text,
        }
    }
}

/// Converts the CreateTranslationResponseJson value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateTranslationResponseJson {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("text".to_string()),
            Some(self.text.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTranslationResponseJson value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTranslationResponseJson {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub text: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateTranslationResponseJson".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateTranslationResponseJson".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateTranslationResponseJson {
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in CreateTranslationResponseJson".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateTranslationResponseJson> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateTranslationResponseJson>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateTranslationResponseJson>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateTranslationResponseJson - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateTranslationResponseJson> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateTranslationResponseJson as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateTranslationResponseJson - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateTranslationResponseVerboseJson {
/// The language of the output translation (always `english`).
    #[serde(rename = "language")]
    pub language: String,

/// The duration of the input audio.
    #[serde(rename = "duration")]
    pub duration: String,

/// The translated text.
    #[serde(rename = "text")]
    pub text: String,

/// Segments of the translated text and their corresponding details.
    #[serde(rename = "segments")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub segments: Option<Vec<models::TranscriptionSegment>>,

}


impl CreateTranslationResponseVerboseJson {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(language: String, duration: String, text: String, ) -> CreateTranslationResponseVerboseJson {
        CreateTranslationResponseVerboseJson {
            language,
            duration,
            text,
            segments: None,
        }
    }
}

/// Converts the CreateTranslationResponseVerboseJson value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateTranslationResponseVerboseJson {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("language".to_string()),
            Some(self.language.to_string()),


            Some("duration".to_string()),
            Some(self.duration.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),

            // Skipping segments in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTranslationResponseVerboseJson value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTranslationResponseVerboseJson {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub language: Vec<String>,
            pub duration: Vec<String>,
            pub text: Vec<String>,
            pub segments: Vec<Vec<models::TranscriptionSegment>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateTranslationResponseVerboseJson".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "duration" => intermediate_rep.duration.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "segments" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateTranslationResponseVerboseJson".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateTranslationResponseVerboseJson".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateTranslationResponseVerboseJson {
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in CreateTranslationResponseVerboseJson".to_string())?,
            duration: intermediate_rep.duration.into_iter().next().ok_or_else(|| "duration missing in CreateTranslationResponseVerboseJson".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in CreateTranslationResponseVerboseJson".to_string())?,
            segments: intermediate_rep.segments.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateTranslationResponseVerboseJson> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateTranslationResponseVerboseJson>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateTranslationResponseVerboseJson>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CreateTranslationResponseVerboseJson - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateTranslationResponseVerboseJson> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateTranslationResponseVerboseJson as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CreateTranslationResponseVerboseJson - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Deletes the association between the assistant and the file, but does not delete the [File](/docs/api-reference/files) object itself.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteAssistantFileResponse {
    #[serde(rename = "id")]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

}


impl DeleteAssistantFileResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, deleted: bool, object: String, ) -> DeleteAssistantFileResponse {
        DeleteAssistantFileResponse {
            id,
            deleted,
            object,
        }
    }
}

/// Converts the DeleteAssistantFileResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeleteAssistantFileResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteAssistantFileResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteAssistantFileResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteAssistantFileResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteAssistantFileResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteAssistantFileResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in DeleteAssistantFileResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in DeleteAssistantFileResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in DeleteAssistantFileResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteAssistantFileResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteAssistantFileResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteAssistantFileResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteAssistantFileResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeleteAssistantFileResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteAssistantFileResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteAssistantFileResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteAssistantResponse {
    #[serde(rename = "id")]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

}


impl DeleteAssistantResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, deleted: bool, object: String, ) -> DeleteAssistantResponse {
        DeleteAssistantResponse {
            id,
            deleted,
            object,
        }
    }
}

/// Converts the DeleteAssistantResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeleteAssistantResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteAssistantResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteAssistantResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteAssistantResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteAssistantResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteAssistantResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in DeleteAssistantResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in DeleteAssistantResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in DeleteAssistantResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteAssistantResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteAssistantResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteAssistantResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteAssistantResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeleteAssistantResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteAssistantResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteAssistantResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteFileResponse {
    #[serde(rename = "id")]
    pub id: String,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

}


impl DeleteFileResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, deleted: bool, ) -> DeleteFileResponse {
        DeleteFileResponse {
            id,
            object,
            deleted,
        }
    }
}

/// Converts the DeleteFileResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeleteFileResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteFileResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteFileResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub deleted: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteFileResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteFileResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteFileResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in DeleteFileResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in DeleteFileResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in DeleteFileResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteFileResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteFileResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteFileResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteFileResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeleteFileResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteFileResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteFileResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteMessageResponse {
    #[serde(rename = "id")]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

}


impl DeleteMessageResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, deleted: bool, object: String, ) -> DeleteMessageResponse {
        DeleteMessageResponse {
            id,
            deleted,
            object,
        }
    }
}

/// Converts the DeleteMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeleteMessageResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteMessageResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in DeleteMessageResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in DeleteMessageResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in DeleteMessageResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteMessageResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteMessageResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteMessageResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeleteMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteMessageResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteModelResponse {
    #[serde(rename = "id")]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

    #[serde(rename = "object")]
    pub object: String,

}


impl DeleteModelResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, deleted: bool, object: String, ) -> DeleteModelResponse {
        DeleteModelResponse {
            id,
            deleted,
            object,
        }
    }
}

/// Converts the DeleteModelResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeleteModelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteModelResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteModelResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteModelResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteModelResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteModelResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in DeleteModelResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in DeleteModelResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in DeleteModelResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteModelResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteModelResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteModelResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteModelResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeleteModelResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteModelResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteModelResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteThreadResponse {
    #[serde(rename = "id")]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

}


impl DeleteThreadResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, deleted: bool, object: String, ) -> DeleteThreadResponse {
        DeleteThreadResponse {
            id,
            deleted,
            object,
        }
    }
}

/// Converts the DeleteThreadResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeleteThreadResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteThreadResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteThreadResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteThreadResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteThreadResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteThreadResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in DeleteThreadResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in DeleteThreadResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in DeleteThreadResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteThreadResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteThreadResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteThreadResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DeleteThreadResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeleteThreadResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteThreadResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DeleteThreadResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a stream ends.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DoneEvent {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "data")]
    pub data: String,

}


impl DoneEvent {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: String, ) -> DoneEvent {
        DoneEvent {
            event,
            data,
        }
    }
}

/// Converts the DoneEvent value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DoneEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),


            Some("data".to_string()),
            Some(self.data.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DoneEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DoneEvent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DoneEvent".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DoneEvent".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DoneEvent {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in DoneEvent".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in DoneEvent".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DoneEvent> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DoneEvent>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DoneEvent>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for DoneEvent - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DoneEvent> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DoneEvent as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into DoneEvent - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Represents an embedding vector returned by embedding endpoint. 



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Embedding {
/// The index of the embedding in the list of embeddings.
    #[serde(rename = "index")]
    pub index: i32,

/// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](/docs/guides/embeddings). 
    #[serde(rename = "embedding")]
    pub embedding: Vec<f64>,

/// The object type, which is always \"embedding\".
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

}


impl Embedding {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, embedding: Vec<f64>, object: String, ) -> Embedding {
        Embedding {
            index,
            embedding,
            object,
        }
    }
}

/// Converts the Embedding value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Embedding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("embedding".to_string()),
            Some(self.embedding.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Embedding value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Embedding {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub embedding: Vec<Vec<f64>>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Embedding".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "embedding" => return std::result::Result::Err("Parsing a container in this style is not supported in Embedding".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Embedding".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Embedding {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in Embedding".to_string())?,
            embedding: intermediate_rep.embedding.into_iter().next().ok_or_else(|| "embedding missing in Embedding".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in Embedding".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Embedding> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Embedding>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Embedding>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Embedding - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Embedding> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Embedding as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Embedding - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Error {
    #[serde(rename = "code")]
    pub code: Nullable<String>,

    #[serde(rename = "message")]
    pub message: String,

    #[serde(rename = "param")]
    pub param: Nullable<String>,

    #[serde(rename = "type")]
    pub r#type: String,

}


impl Error {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(code: Nullable<String>, message: String, param: Nullable<String>, r#type: String, ) -> Error {
        Error {
            code,
            message,
            param,
            r#type,
        }
    }
}

/// Converts the Error value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("code".to_string()),
            Some(self.code.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("message".to_string()),
            Some(self.message.to_string()),


            Some("param".to_string()),
            Some(self.param.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("type".to_string()),
            Some(self.r#type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Error value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Error {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<String>,
            pub message: Vec<String>,
            pub param: Vec<String>,
            pub r#type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Error".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "code" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Error".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "param" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Error".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Error".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Error {
            code: std::result::Result::Err("Nullable types not supported in Error".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in Error".to_string())?,
            param: std::result::Result::Err("Nullable types not supported in Error".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in Error".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Error> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Error>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Error>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Error - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Error> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Error as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Error - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when an [error](/docs/guides/error-codes/api-errors) occurs. This can happen due to an internal server error or a timeout.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ErrorEvent {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::Error,

}


impl ErrorEvent {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::Error, ) -> ErrorEvent {
        ErrorEvent {
            event,
            data,
        }
    }
}

/// Converts the ErrorEvent value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ErrorEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ErrorEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ErrorEvent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::Error>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ErrorEvent".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::Error as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ErrorEvent".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ErrorEvent {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in ErrorEvent".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ErrorEvent".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ErrorEvent> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ErrorEvent>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ErrorEvent>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ErrorEvent - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ErrorEvent> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ErrorEvent as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ErrorEvent - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ErrorResponse {
    #[serde(rename = "error")]
    pub error: models::Error,

}


impl ErrorResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(error: models::Error, ) -> ErrorResponse {
        ErrorResponse {
            error,
        }
    }
}

/// Converts the ErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ErrorResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping error in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error: Vec<models::Error>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(<models::Error as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ErrorResponse {
            error: intermediate_rep.error.into_iter().next().ok_or_else(|| "error missing in ErrorResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ErrorResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ErrorResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ErrorResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ErrorResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuningIntegration {
/// The type of the integration being enabled for the fine-tuning job
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "wandb")]
    pub wandb: models::CreateFineTuningJobRequestIntegrationsInnerWandb,

}


impl FineTuningIntegration {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, wandb: models::CreateFineTuningJobRequestIntegrationsInnerWandb, ) -> FineTuningIntegration {
        FineTuningIntegration {
            r#type,
            wandb,
        }
    }
}

/// Converts the FineTuningIntegration value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuningIntegration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping wandb in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningIntegration value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningIntegration {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub wandb: Vec<models::CreateFineTuningJobRequestIntegrationsInnerWandb>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuningIntegration".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "wandb" => intermediate_rep.wandb.push(<models::CreateFineTuningJobRequestIntegrationsInnerWandb as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuningIntegration".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuningIntegration {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in FineTuningIntegration".to_string())?,
            wandb: intermediate_rep.wandb.into_iter().next().ok_or_else(|| "wandb missing in FineTuningIntegration".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuningIntegration> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuningIntegration>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuningIntegration>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FineTuningIntegration - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuningIntegration> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuningIntegration as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FineTuningIntegration - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The `fine_tuning.job` object represents a fine-tuning job that has been created through the API. 



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuningJob {
/// The object identifier, which can be referenced in the API endpoints.
    #[serde(rename = "id")]
    pub id: String,

/// The Unix timestamp (in seconds) for when the fine-tuning job was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    #[serde(rename = "error")]
    pub error: Nullable<models::FineTuningJobError>,

/// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
    #[serde(rename = "fine_tuned_model")]
    pub fine_tuned_model: Nullable<String>,

/// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
    #[serde(rename = "finished_at")]
    pub finished_at: Nullable<i32>,

    #[serde(rename = "hyperparameters")]
    pub hyperparameters: models::FineTuningJobHyperparameters,

/// The base model that is being fine-tuned.
    #[serde(rename = "model")]
    pub model: String,

/// The object type, which is always \"fine_tuning.job\".
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

/// The organization that owns the fine-tuning job.
    #[serde(rename = "organization_id")]
    pub organization_id: String,

/// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](/docs/api-reference/files/retrieve-contents).
    #[serde(rename = "result_files")]
    pub result_files: Vec<String>,

/// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

/// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
    #[serde(rename = "trained_tokens")]
    pub trained_tokens: Nullable<i32>,

/// The file ID used for training. You can retrieve the training data with the [Files API](/docs/api-reference/files/retrieve-contents).
    #[serde(rename = "training_file")]
    pub training_file: String,

/// The file ID used for validation. You can retrieve the validation results with the [Files API](/docs/api-reference/files/retrieve-contents).
    #[serde(rename = "validation_file")]
    pub validation_file: Nullable<String>,

/// A list of integrations to enable for this fine-tuning job.
    #[serde(rename = "integrations")]
    #[validate(
            length(max = 5),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub integrations: Option<Nullable<Vec<models::FineTuningJobIntegrationsInner>>>,

/// The seed used for the fine-tuning job.
    #[serde(rename = "seed")]
    pub seed: i32,

}


impl FineTuningJob {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, created_at: i32, error: Nullable<models::FineTuningJobError>, fine_tuned_model: Nullable<String>, finished_at: Nullable<i32>, hyperparameters: models::FineTuningJobHyperparameters, model: String, object: String, organization_id: String, result_files: Vec<String>, status: String, trained_tokens: Nullable<i32>, training_file: String, validation_file: Nullable<String>, seed: i32, ) -> FineTuningJob {
        FineTuningJob {
            id,
            created_at,
            error,
            fine_tuned_model,
            finished_at,
            hyperparameters,
            model,
            object,
            organization_id,
            result_files,
            status,
            trained_tokens,
            training_file,
            validation_file,
            integrations: None,
            seed,
        }
    }
}

/// Converts the FineTuningJob value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuningJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),

            // Skipping error in query parameter serialization


            Some("fine_tuned_model".to_string()),
            Some(self.fine_tuned_model.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("finished_at".to_string()),
            Some(self.finished_at.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping hyperparameters in query parameter serialization


            Some("model".to_string()),
            Some(self.model.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("organization_id".to_string()),
            Some(self.organization_id.to_string()),


            Some("result_files".to_string()),
            Some(self.result_files.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("status".to_string()),
            Some(self.status.to_string()),


            Some("trained_tokens".to_string()),
            Some(self.trained_tokens.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("training_file".to_string()),
            Some(self.training_file.to_string()),


            Some("validation_file".to_string()),
            Some(self.validation_file.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping integrations in query parameter serialization


            Some("seed".to_string()),
            Some(self.seed.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningJob value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningJob {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub created_at: Vec<i32>,
            pub error: Vec<models::FineTuningJobError>,
            pub fine_tuned_model: Vec<String>,
            pub finished_at: Vec<i32>,
            pub hyperparameters: Vec<models::FineTuningJobHyperparameters>,
            pub model: Vec<String>,
            pub object: Vec<String>,
            pub organization_id: Vec<String>,
            pub result_files: Vec<Vec<String>>,
            pub status: Vec<String>,
            pub trained_tokens: Vec<i32>,
            pub training_file: Vec<String>,
            pub validation_file: Vec<String>,
            pub integrations: Vec<Vec<models::FineTuningJobIntegrationsInner>>,
            pub seed: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuningJob".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "error" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuningJob".to_string()),
                    "fine_tuned_model" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuningJob".to_string()),
                    "finished_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuningJob".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "hyperparameters" => intermediate_rep.hyperparameters.push(<models::FineTuningJobHyperparameters as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "organization_id" => intermediate_rep.organization_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "result_files" => return std::result::Result::Err("Parsing a container in this style is not supported in FineTuningJob".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "trained_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuningJob".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "training_file" => intermediate_rep.training_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "validation_file" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuningJob".to_string()),
                    "integrations" => return std::result::Result::Err("Parsing a container in this style is not supported in FineTuningJob".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "seed" => intermediate_rep.seed.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuningJob".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuningJob {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in FineTuningJob".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in FineTuningJob".to_string())?,
            error: std::result::Result::Err("Nullable types not supported in FineTuningJob".to_string())?,
            fine_tuned_model: std::result::Result::Err("Nullable types not supported in FineTuningJob".to_string())?,
            finished_at: std::result::Result::Err("Nullable types not supported in FineTuningJob".to_string())?,
            hyperparameters: intermediate_rep.hyperparameters.into_iter().next().ok_or_else(|| "hyperparameters missing in FineTuningJob".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in FineTuningJob".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in FineTuningJob".to_string())?,
            organization_id: intermediate_rep.organization_id.into_iter().next().ok_or_else(|| "organization_id missing in FineTuningJob".to_string())?,
            result_files: intermediate_rep.result_files.into_iter().next().ok_or_else(|| "result_files missing in FineTuningJob".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in FineTuningJob".to_string())?,
            trained_tokens: std::result::Result::Err("Nullable types not supported in FineTuningJob".to_string())?,
            training_file: intermediate_rep.training_file.into_iter().next().ok_or_else(|| "training_file missing in FineTuningJob".to_string())?,
            validation_file: std::result::Result::Err("Nullable types not supported in FineTuningJob".to_string())?,
            integrations: std::result::Result::Err("Nullable types not supported in FineTuningJob".to_string())?,
            seed: intermediate_rep.seed.into_iter().next().ok_or_else(|| "seed missing in FineTuningJob".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuningJob> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuningJob>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuningJob>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FineTuningJob - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuningJob> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuningJob as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FineTuningJob - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The `fine_tuning.job.checkpoint` object represents a model checkpoint for a fine-tuning job that is ready to use. 



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuningJobCheckpoint {
/// The checkpoint identifier, which can be referenced in the API endpoints.
    #[serde(rename = "id")]
    pub id: String,

/// The Unix timestamp (in seconds) for when the checkpoint was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

/// The name of the fine-tuned checkpoint model that is created.
    #[serde(rename = "fine_tuned_model_checkpoint")]
    pub fine_tuned_model_checkpoint: String,

/// The step number that the checkpoint was created at.
    #[serde(rename = "step_number")]
    pub step_number: i32,

    #[serde(rename = "metrics")]
    pub metrics: models::FineTuningJobCheckpointMetrics,

/// The name of the fine-tuning job that this checkpoint was created from.
    #[serde(rename = "fine_tuning_job_id")]
    pub fine_tuning_job_id: String,

/// The object type, which is always \"fine_tuning.job.checkpoint\".
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

}


impl FineTuningJobCheckpoint {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, created_at: i32, fine_tuned_model_checkpoint: String, step_number: i32, metrics: models::FineTuningJobCheckpointMetrics, fine_tuning_job_id: String, object: String, ) -> FineTuningJobCheckpoint {
        FineTuningJobCheckpoint {
            id,
            created_at,
            fine_tuned_model_checkpoint,
            step_number,
            metrics,
            fine_tuning_job_id,
            object,
        }
    }
}

/// Converts the FineTuningJobCheckpoint value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuningJobCheckpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("fine_tuned_model_checkpoint".to_string()),
            Some(self.fine_tuned_model_checkpoint.to_string()),


            Some("step_number".to_string()),
            Some(self.step_number.to_string()),

            // Skipping metrics in query parameter serialization


            Some("fine_tuning_job_id".to_string()),
            Some(self.fine_tuning_job_id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningJobCheckpoint value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningJobCheckpoint {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub created_at: Vec<i32>,
            pub fine_tuned_model_checkpoint: Vec<String>,
            pub step_number: Vec<i32>,
            pub metrics: Vec<models::FineTuningJobCheckpointMetrics>,
            pub fine_tuning_job_id: Vec<String>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuningJobCheckpoint".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fine_tuned_model_checkpoint" => intermediate_rep.fine_tuned_model_checkpoint.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "step_number" => intermediate_rep.step_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metrics" => intermediate_rep.metrics.push(<models::FineTuningJobCheckpointMetrics as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fine_tuning_job_id" => intermediate_rep.fine_tuning_job_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuningJobCheckpoint".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuningJobCheckpoint {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in FineTuningJobCheckpoint".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in FineTuningJobCheckpoint".to_string())?,
            fine_tuned_model_checkpoint: intermediate_rep.fine_tuned_model_checkpoint.into_iter().next().ok_or_else(|| "fine_tuned_model_checkpoint missing in FineTuningJobCheckpoint".to_string())?,
            step_number: intermediate_rep.step_number.into_iter().next().ok_or_else(|| "step_number missing in FineTuningJobCheckpoint".to_string())?,
            metrics: intermediate_rep.metrics.into_iter().next().ok_or_else(|| "metrics missing in FineTuningJobCheckpoint".to_string())?,
            fine_tuning_job_id: intermediate_rep.fine_tuning_job_id.into_iter().next().ok_or_else(|| "fine_tuning_job_id missing in FineTuningJobCheckpoint".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in FineTuningJobCheckpoint".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuningJobCheckpoint> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuningJobCheckpoint>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuningJobCheckpoint>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FineTuningJobCheckpoint - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuningJobCheckpoint> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuningJobCheckpoint as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FineTuningJobCheckpoint - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Metrics at the step number during the fine-tuning job.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuningJobCheckpointMetrics {
    #[serde(rename = "step")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub step: Option<f64>,

    #[serde(rename = "train_loss")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub train_loss: Option<f64>,

    #[serde(rename = "train_mean_token_accuracy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub train_mean_token_accuracy: Option<f64>,

    #[serde(rename = "valid_loss")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub valid_loss: Option<f64>,

    #[serde(rename = "valid_mean_token_accuracy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub valid_mean_token_accuracy: Option<f64>,

    #[serde(rename = "full_valid_loss")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_valid_loss: Option<f64>,

    #[serde(rename = "full_valid_mean_token_accuracy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_valid_mean_token_accuracy: Option<f64>,

}


impl FineTuningJobCheckpointMetrics {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FineTuningJobCheckpointMetrics {
        FineTuningJobCheckpointMetrics {
            step: None,
            train_loss: None,
            train_mean_token_accuracy: None,
            valid_loss: None,
            valid_mean_token_accuracy: None,
            full_valid_loss: None,
            full_valid_mean_token_accuracy: None,
        }
    }
}

/// Converts the FineTuningJobCheckpointMetrics value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuningJobCheckpointMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.step.as_ref().map(|step| {
                [
                    "step".to_string(),
                    step.to_string(),
                ].join(",")
            }),


            self.train_loss.as_ref().map(|train_loss| {
                [
                    "train_loss".to_string(),
                    train_loss.to_string(),
                ].join(",")
            }),


            self.train_mean_token_accuracy.as_ref().map(|train_mean_token_accuracy| {
                [
                    "train_mean_token_accuracy".to_string(),
                    train_mean_token_accuracy.to_string(),
                ].join(",")
            }),


            self.valid_loss.as_ref().map(|valid_loss| {
                [
                    "valid_loss".to_string(),
                    valid_loss.to_string(),
                ].join(",")
            }),


            self.valid_mean_token_accuracy.as_ref().map(|valid_mean_token_accuracy| {
                [
                    "valid_mean_token_accuracy".to_string(),
                    valid_mean_token_accuracy.to_string(),
                ].join(",")
            }),


            self.full_valid_loss.as_ref().map(|full_valid_loss| {
                [
                    "full_valid_loss".to_string(),
                    full_valid_loss.to_string(),
                ].join(",")
            }),


            self.full_valid_mean_token_accuracy.as_ref().map(|full_valid_mean_token_accuracy| {
                [
                    "full_valid_mean_token_accuracy".to_string(),
                    full_valid_mean_token_accuracy.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningJobCheckpointMetrics value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningJobCheckpointMetrics {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub step: Vec<f64>,
            pub train_loss: Vec<f64>,
            pub train_mean_token_accuracy: Vec<f64>,
            pub valid_loss: Vec<f64>,
            pub valid_mean_token_accuracy: Vec<f64>,
            pub full_valid_loss: Vec<f64>,
            pub full_valid_mean_token_accuracy: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuningJobCheckpointMetrics".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "step" => intermediate_rep.step.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "train_loss" => intermediate_rep.train_loss.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "train_mean_token_accuracy" => intermediate_rep.train_mean_token_accuracy.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "valid_loss" => intermediate_rep.valid_loss.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "valid_mean_token_accuracy" => intermediate_rep.valid_mean_token_accuracy.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "full_valid_loss" => intermediate_rep.full_valid_loss.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "full_valid_mean_token_accuracy" => intermediate_rep.full_valid_mean_token_accuracy.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuningJobCheckpointMetrics".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuningJobCheckpointMetrics {
            step: intermediate_rep.step.into_iter().next(),
            train_loss: intermediate_rep.train_loss.into_iter().next(),
            train_mean_token_accuracy: intermediate_rep.train_mean_token_accuracy.into_iter().next(),
            valid_loss: intermediate_rep.valid_loss.into_iter().next(),
            valid_mean_token_accuracy: intermediate_rep.valid_mean_token_accuracy.into_iter().next(),
            full_valid_loss: intermediate_rep.full_valid_loss.into_iter().next(),
            full_valid_mean_token_accuracy: intermediate_rep.full_valid_mean_token_accuracy.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuningJobCheckpointMetrics> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuningJobCheckpointMetrics>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuningJobCheckpointMetrics>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FineTuningJobCheckpointMetrics - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuningJobCheckpointMetrics> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuningJobCheckpointMetrics as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FineTuningJobCheckpointMetrics - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuningJobError {
/// A machine-readable error code.
    #[serde(rename = "code")]
    pub code: String,

/// A human-readable error message.
    #[serde(rename = "message")]
    pub message: String,

/// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
    #[serde(rename = "param")]
    pub param: Nullable<String>,

}


impl FineTuningJobError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(code: String, message: String, param: Nullable<String>, ) -> FineTuningJobError {
        FineTuningJobError {
            code,
            message,
            param,
        }
    }
}

/// Converts the FineTuningJobError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuningJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("code".to_string()),
            Some(self.code.to_string()),


            Some("message".to_string()),
            Some(self.message.to_string()),


            Some("param".to_string()),
            Some(self.param.as_ref().map_or("null".to_string(), |x| x.to_string())),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningJobError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningJobError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<String>,
            pub message: Vec<String>,
            pub param: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuningJobError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "param" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuningJobError".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuningJobError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuningJobError {
            code: intermediate_rep.code.into_iter().next().ok_or_else(|| "code missing in FineTuningJobError".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in FineTuningJobError".to_string())?,
            param: std::result::Result::Err("Nullable types not supported in FineTuningJobError".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuningJobError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuningJobError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuningJobError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FineTuningJobError - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuningJobError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuningJobError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FineTuningJobError - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Fine-tuning job event object



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuningJobEvent {
    #[serde(rename = "id")]
    pub id: String,

    #[serde(rename = "created_at")]
    pub created_at: i32,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "level")]
    pub level: String,

    #[serde(rename = "message")]
    pub message: String,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

}


impl FineTuningJobEvent {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, created_at: i32, level: String, message: String, object: String, ) -> FineTuningJobEvent {
        FineTuningJobEvent {
            id,
            created_at,
            level,
            message,
            object,
        }
    }
}

/// Converts the FineTuningJobEvent value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuningJobEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("level".to_string()),
            Some(self.level.to_string()),


            Some("message".to_string()),
            Some(self.message.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningJobEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningJobEvent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub created_at: Vec<i32>,
            pub level: Vec<String>,
            pub message: Vec<String>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuningJobEvent".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "level" => intermediate_rep.level.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuningJobEvent".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuningJobEvent {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in FineTuningJobEvent".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in FineTuningJobEvent".to_string())?,
            level: intermediate_rep.level.into_iter().next().ok_or_else(|| "level missing in FineTuningJobEvent".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in FineTuningJobEvent".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in FineTuningJobEvent".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuningJobEvent> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuningJobEvent>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuningJobEvent>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FineTuningJobEvent - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuningJobEvent> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuningJobEvent as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FineTuningJobEvent - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](/docs/guides/fine-tuning) for more details.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuningJobHyperparameters {
    #[serde(rename = "n_epochs")]
    pub n_epochs: models::FineTuningJobHyperparametersNEpochs,

}


impl FineTuningJobHyperparameters {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(n_epochs: models::FineTuningJobHyperparametersNEpochs, ) -> FineTuningJobHyperparameters {
        FineTuningJobHyperparameters {
            n_epochs,
        }
    }
}

/// Converts the FineTuningJobHyperparameters value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuningJobHyperparameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping n_epochs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningJobHyperparameters value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningJobHyperparameters {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub n_epochs: Vec<models::FineTuningJobHyperparametersNEpochs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuningJobHyperparameters".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "n_epochs" => intermediate_rep.n_epochs.push(<models::FineTuningJobHyperparametersNEpochs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuningJobHyperparameters".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuningJobHyperparameters {
            n_epochs: intermediate_rep.n_epochs.into_iter().next().ok_or_else(|| "n_epochs missing in FineTuningJobHyperparameters".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuningJobHyperparameters> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuningJobHyperparameters>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuningJobHyperparameters>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FineTuningJobHyperparameters - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuningJobHyperparameters> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuningJobHyperparameters as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FineTuningJobHyperparameters - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset. \"auto\" decides the optimal number of epochs based on the size of the dataset. If setting the number manually, we support any number between 1 and 50 epochs.


/// One of:
/// - String
/// - i32
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FineTuningJobHyperparametersNEpochs(Box<serde_json::value::RawValue>);

impl validator::Validate for FineTuningJobHyperparametersNEpochs
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningJobHyperparametersNEpochs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningJobHyperparametersNEpochs {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for FineTuningJobHyperparametersNEpochs {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}







/// One of:
/// - FineTuningIntegration
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FineTuningJobIntegrationsInner(Box<serde_json::value::RawValue>);

impl validator::Validate for FineTuningJobIntegrationsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningJobIntegrationsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningJobIntegrationsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for FineTuningJobIntegrationsInner {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FunctionObject {
/// A description of what the function does, used by the model to choose when and how to call the function.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

/// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
    #[serde(rename = "name")]
    pub name: String,

/// The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/text-generation/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.   Omitting `parameters` defines a function with an empty parameter list.
    #[serde(rename = "parameters")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<std::collections::HashMap<String, crate::types::Object>>,

}


impl FunctionObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> FunctionObject {
        FunctionObject {
            description: None,
            name,
            parameters: None,
        }
    }
}

/// Converts the FunctionObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FunctionObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping parameters in query parameter serialization
            // Skipping parameters in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FunctionObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FunctionObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub name: Vec<String>,
            pub parameters: Vec<std::collections::HashMap<String, crate::types::Object>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FunctionObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "parameters" => return std::result::Result::Err("Parsing a container in this style is not supported in FunctionObject".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FunctionObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FunctionObject {
            description: intermediate_rep.description.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in FunctionObject".to_string())?,
            parameters: intermediate_rep.parameters.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FunctionObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FunctionObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FunctionObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FunctionObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FunctionObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FunctionObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FunctionObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Represents the url or the content of an image generated by the OpenAI API.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Image {
/// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
    #[serde(rename = "b64_json")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub b64_json: Option<String>,

/// The URL of the generated image, if `response_format` is `url` (default).
    #[serde(rename = "url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,

/// The prompt that was used to generate the image, if there was any revision to the prompt.
    #[serde(rename = "revised_prompt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub revised_prompt: Option<String>,

}


impl Image {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Image {
        Image {
            b64_json: None,
            url: None,
            revised_prompt: None,
        }
    }
}

/// Converts the Image value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Image {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.b64_json.as_ref().map(|b64_json| {
                [
                    "b64_json".to_string(),
                    b64_json.to_string(),
                ].join(",")
            }),


            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.to_string(),
                ].join(",")
            }),


            self.revised_prompt.as_ref().map(|revised_prompt| {
                [
                    "revised_prompt".to_string(),
                    revised_prompt.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Image value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Image {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub b64_json: Vec<String>,
            pub url: Vec<String>,
            pub revised_prompt: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Image".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "b64_json" => intermediate_rep.b64_json.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "revised_prompt" => intermediate_rep.revised_prompt.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Image".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Image {
            b64_json: intermediate_rep.b64_json.into_iter().next(),
            url: intermediate_rep.url.into_iter().next(),
            revised_prompt: intermediate_rep.revised_prompt.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Image> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Image>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Image>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Image - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Image> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Image as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Image - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImagesResponse {
    #[serde(rename = "created")]
    pub created: i32,

    #[serde(rename = "data")]
    pub data: Vec<models::Image>,

}


impl ImagesResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(created: i32, data: Vec<models::Image>, ) -> ImagesResponse {
        ImagesResponse {
            created,
            data,
        }
    }
}

/// Converts the ImagesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImagesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("created".to_string()),
            Some(self.created.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImagesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImagesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub created: Vec<i32>,
            pub data: Vec<Vec<models::Image>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImagesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ImagesResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImagesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImagesResponse {
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "created missing in ImagesResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ImagesResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImagesResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImagesResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImagesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImagesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImagesResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImagesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImagesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListAssistantFilesResponse {
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "data")]
    pub data: Vec<models::AssistantFileObject>,

    #[serde(rename = "first_id")]
    pub first_id: String,

    #[serde(rename = "last_id")]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}


impl ListAssistantFilesResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::AssistantFileObject>, first_id: String, last_id: String, has_more: bool, ) -> ListAssistantFilesResponse {
        ListAssistantFilesResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
    }
}

/// Converts the ListAssistantFilesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListAssistantFilesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListAssistantFilesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListAssistantFilesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::AssistantFileObject>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListAssistantFilesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListAssistantFilesResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListAssistantFilesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListAssistantFilesResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListAssistantFilesResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListAssistantFilesResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListAssistantFilesResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListAssistantFilesResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListAssistantFilesResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListAssistantFilesResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListAssistantFilesResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListAssistantFilesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListAssistantFilesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListAssistantFilesResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListAssistantFilesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListAssistantFilesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListAssistantsResponse {
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "data")]
    pub data: Vec<models::AssistantObject>,

    #[serde(rename = "first_id")]
    pub first_id: String,

    #[serde(rename = "last_id")]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}


impl ListAssistantsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::AssistantObject>, first_id: String, last_id: String, has_more: bool, ) -> ListAssistantsResponse {
        ListAssistantsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
    }
}

/// Converts the ListAssistantsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListAssistantsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListAssistantsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListAssistantsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::AssistantObject>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListAssistantsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListAssistantsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListAssistantsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListAssistantsResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListAssistantsResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListAssistantsResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListAssistantsResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListAssistantsResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListAssistantsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListAssistantsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListAssistantsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListAssistantsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListAssistantsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListAssistantsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListAssistantsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListAssistantsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListFilesResponse {
    #[serde(rename = "data")]
    pub data: Vec<models::OpenAiFile>,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

}


impl ListFilesResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(data: Vec<models::OpenAiFile>, object: String, ) -> ListFilesResponse {
        ListFilesResponse {
            data,
            object,
        }
    }
}

/// Converts the ListFilesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListFilesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListFilesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListFilesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<Vec<models::OpenAiFile>>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListFilesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListFilesResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListFilesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListFilesResponse {
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListFilesResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListFilesResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListFilesResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListFilesResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListFilesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListFilesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListFilesResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListFilesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListFilesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListFineTuningJobCheckpointsResponse {
    #[serde(rename = "data")]
    pub data: Vec<models::FineTuningJobCheckpoint>,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "first_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub first_id: Option<Nullable<String>>,

    #[serde(rename = "last_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_id: Option<Nullable<String>>,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}


impl ListFineTuningJobCheckpointsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(data: Vec<models::FineTuningJobCheckpoint>, object: String, has_more: bool, ) -> ListFineTuningJobCheckpointsResponse {
        ListFineTuningJobCheckpointsResponse {
            data,
            object,
            first_id: None,
            last_id: None,
            has_more,
        }
    }
}

/// Converts the ListFineTuningJobCheckpointsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListFineTuningJobCheckpointsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization


            Some("object".to_string()),
            Some(self.object.to_string()),


            self.first_id.as_ref().map(|first_id| {
                [
                    "first_id".to_string(),
                    first_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.last_id.as_ref().map(|last_id| {
                [
                    "last_id".to_string(),
                    last_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListFineTuningJobCheckpointsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListFineTuningJobCheckpointsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<Vec<models::FineTuningJobCheckpoint>>,
            pub object: Vec<String>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListFineTuningJobCheckpointsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListFineTuningJobCheckpointsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "first_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ListFineTuningJobCheckpointsResponse".to_string()),
                    "last_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ListFineTuningJobCheckpointsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListFineTuningJobCheckpointsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListFineTuningJobCheckpointsResponse {
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListFineTuningJobCheckpointsResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListFineTuningJobCheckpointsResponse".to_string())?,
            first_id: std::result::Result::Err("Nullable types not supported in ListFineTuningJobCheckpointsResponse".to_string())?,
            last_id: std::result::Result::Err("Nullable types not supported in ListFineTuningJobCheckpointsResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListFineTuningJobCheckpointsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListFineTuningJobCheckpointsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListFineTuningJobCheckpointsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListFineTuningJobCheckpointsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListFineTuningJobCheckpointsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListFineTuningJobCheckpointsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListFineTuningJobCheckpointsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListFineTuningJobCheckpointsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListFineTuningJobEventsResponse {
    #[serde(rename = "data")]
    pub data: Vec<models::FineTuningJobEvent>,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

}


impl ListFineTuningJobEventsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(data: Vec<models::FineTuningJobEvent>, object: String, ) -> ListFineTuningJobEventsResponse {
        ListFineTuningJobEventsResponse {
            data,
            object,
        }
    }
}

/// Converts the ListFineTuningJobEventsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListFineTuningJobEventsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListFineTuningJobEventsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListFineTuningJobEventsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<Vec<models::FineTuningJobEvent>>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListFineTuningJobEventsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListFineTuningJobEventsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListFineTuningJobEventsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListFineTuningJobEventsResponse {
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListFineTuningJobEventsResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListFineTuningJobEventsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListFineTuningJobEventsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListFineTuningJobEventsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListFineTuningJobEventsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListFineTuningJobEventsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListFineTuningJobEventsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListFineTuningJobEventsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListFineTuningJobEventsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListMessageFilesResponse {
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "data")]
    pub data: Vec<models::MessageFileObject>,

    #[serde(rename = "first_id")]
    pub first_id: String,

    #[serde(rename = "last_id")]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}


impl ListMessageFilesResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::MessageFileObject>, first_id: String, last_id: String, has_more: bool, ) -> ListMessageFilesResponse {
        ListMessageFilesResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
    }
}

/// Converts the ListMessageFilesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListMessageFilesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListMessageFilesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListMessageFilesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::MessageFileObject>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListMessageFilesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListMessageFilesResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListMessageFilesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListMessageFilesResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListMessageFilesResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListMessageFilesResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListMessageFilesResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListMessageFilesResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListMessageFilesResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListMessageFilesResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListMessageFilesResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListMessageFilesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListMessageFilesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListMessageFilesResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListMessageFilesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListMessageFilesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListMessagesResponse {
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "data")]
    pub data: Vec<models::MessageObject>,

    #[serde(rename = "first_id")]
    pub first_id: String,

    #[serde(rename = "last_id")]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}


impl ListMessagesResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::MessageObject>, first_id: String, last_id: String, has_more: bool, ) -> ListMessagesResponse {
        ListMessagesResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
    }
}

/// Converts the ListMessagesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListMessagesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListMessagesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListMessagesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::MessageObject>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListMessagesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListMessagesResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListMessagesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListMessagesResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListMessagesResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListMessagesResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListMessagesResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListMessagesResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListMessagesResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListMessagesResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListMessagesResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListMessagesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListMessagesResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListMessagesResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListMessagesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListMessagesResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListModelsResponse {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "data")]
    pub data: Vec<models::Model>,

}


impl ListModelsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::Model>, ) -> ListModelsResponse {
        ListModelsResponse {
            object,
            data,
        }
    }
}

/// Converts the ListModelsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListModelsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListModelsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListModelsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::Model>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListModelsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListModelsResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListModelsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListModelsResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListModelsResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListModelsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListModelsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListModelsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListModelsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListModelsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListModelsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListModelsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListModelsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListPaginatedFineTuningJobsResponse {
    #[serde(rename = "data")]
    pub data: Vec<models::FineTuningJob>,

    #[serde(rename = "has_more")]
    pub has_more: bool,

/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

}


impl ListPaginatedFineTuningJobsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(data: Vec<models::FineTuningJob>, has_more: bool, object: String, ) -> ListPaginatedFineTuningJobsResponse {
        ListPaginatedFineTuningJobsResponse {
            data,
            has_more,
            object,
        }
    }
}

/// Converts the ListPaginatedFineTuningJobsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListPaginatedFineTuningJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListPaginatedFineTuningJobsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListPaginatedFineTuningJobsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<Vec<models::FineTuningJob>>,
            pub has_more: Vec<bool>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListPaginatedFineTuningJobsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListPaginatedFineTuningJobsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListPaginatedFineTuningJobsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListPaginatedFineTuningJobsResponse {
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListPaginatedFineTuningJobsResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListPaginatedFineTuningJobsResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListPaginatedFineTuningJobsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListPaginatedFineTuningJobsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListPaginatedFineTuningJobsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListPaginatedFineTuningJobsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListPaginatedFineTuningJobsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListPaginatedFineTuningJobsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListPaginatedFineTuningJobsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListPaginatedFineTuningJobsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListRunStepsResponse {
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "data")]
    pub data: Vec<models::RunStepObject>,

    #[serde(rename = "first_id")]
    pub first_id: String,

    #[serde(rename = "last_id")]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}


impl ListRunStepsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::RunStepObject>, first_id: String, last_id: String, has_more: bool, ) -> ListRunStepsResponse {
        ListRunStepsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
    }
}

/// Converts the ListRunStepsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListRunStepsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListRunStepsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListRunStepsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::RunStepObject>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListRunStepsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListRunStepsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListRunStepsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListRunStepsResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListRunStepsResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListRunStepsResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListRunStepsResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListRunStepsResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListRunStepsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListRunStepsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListRunStepsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListRunStepsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListRunStepsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListRunStepsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListRunStepsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListRunStepsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListRunsResponse {
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "data")]
    pub data: Vec<models::RunObject>,

    #[serde(rename = "first_id")]
    pub first_id: String,

    #[serde(rename = "last_id")]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}


impl ListRunsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::RunObject>, first_id: String, last_id: String, has_more: bool, ) -> ListRunsResponse {
        ListRunsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
    }
}

/// Converts the ListRunsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListRunsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListRunsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListRunsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::RunObject>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListRunsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListRunsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListRunsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListRunsResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListRunsResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListRunsResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListRunsResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListRunsResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListRunsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListRunsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListRunsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListRunsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListRunsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListRunsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListRunsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListRunsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListThreadsResponse {
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "data")]
    pub data: Vec<models::ThreadObject>,

    #[serde(rename = "first_id")]
    pub first_id: String,

    #[serde(rename = "last_id")]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}


impl ListThreadsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::ThreadObject>, first_id: String, last_id: String, has_more: bool, ) -> ListThreadsResponse {
        ListThreadsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
    }
}

/// Converts the ListThreadsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListThreadsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListThreadsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListThreadsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::ThreadObject>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListThreadsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListThreadsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListThreadsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListThreadsResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListThreadsResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListThreadsResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListThreadsResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListThreadsResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListThreadsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListThreadsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListThreadsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListThreadsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ListThreadsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListThreadsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListThreadsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ListThreadsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// References an image [File](/docs/api-reference/files) in the content of a message.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentImageFileObject {
/// Always `image_file`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "image_file")]
    pub image_file: models::MessageContentImageFileObjectImageFile,

}


impl MessageContentImageFileObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, image_file: models::MessageContentImageFileObjectImageFile, ) -> MessageContentImageFileObject {
        MessageContentImageFileObject {
            r#type,
            image_file,
        }
    }
}

/// Converts the MessageContentImageFileObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentImageFileObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping image_file in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentImageFileObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentImageFileObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub image_file: Vec<models::MessageContentImageFileObjectImageFile>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentImageFileObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_file" => intermediate_rep.image_file.push(<models::MessageContentImageFileObjectImageFile as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentImageFileObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentImageFileObject {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in MessageContentImageFileObject".to_string())?,
            image_file: intermediate_rep.image_file.into_iter().next().ok_or_else(|| "image_file missing in MessageContentImageFileObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentImageFileObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentImageFileObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentImageFileObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageContentImageFileObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentImageFileObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentImageFileObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageContentImageFileObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentImageFileObjectImageFile {
/// The [File](/docs/api-reference/files) ID of the image in the message content.
    #[serde(rename = "file_id")]
    pub file_id: String,

}


impl MessageContentImageFileObjectImageFile {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(file_id: String, ) -> MessageContentImageFileObjectImageFile {
        MessageContentImageFileObjectImageFile {
            file_id,
        }
    }
}

/// Converts the MessageContentImageFileObjectImageFile value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentImageFileObjectImageFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("file_id".to_string()),
            Some(self.file_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentImageFileObjectImageFile value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentImageFileObjectImageFile {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentImageFileObjectImageFile".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentImageFileObjectImageFile".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentImageFileObjectImageFile {
            file_id: intermediate_rep.file_id.into_iter().next().ok_or_else(|| "file_id missing in MessageContentImageFileObjectImageFile".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentImageFileObjectImageFile> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentImageFileObjectImageFile>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentImageFileObjectImageFile>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageContentImageFileObjectImageFile - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentImageFileObjectImageFile> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentImageFileObjectImageFile as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageContentImageFileObjectImageFile - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"retrieval\" tool to search files.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentTextAnnotationsFileCitationObject {
/// Always `file_citation`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

/// The text in the message content that needs to be replaced.
    #[serde(rename = "text")]
    pub text: String,

    #[serde(rename = "file_citation")]
    pub file_citation: models::MessageContentTextAnnotationsFileCitationObjectFileCitation,

    #[serde(rename = "start_index")]
    #[validate(
            range(min = 0),
        )]
    pub start_index: u32,

    #[serde(rename = "end_index")]
    #[validate(
            range(min = 0),
        )]
    pub end_index: u32,

}


impl MessageContentTextAnnotationsFileCitationObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, text: String, file_citation: models::MessageContentTextAnnotationsFileCitationObjectFileCitation, start_index: u32, end_index: u32, ) -> MessageContentTextAnnotationsFileCitationObject {
        MessageContentTextAnnotationsFileCitationObject {
            r#type,
            text,
            file_citation,
            start_index,
            end_index,
        }
    }
}

/// Converts the MessageContentTextAnnotationsFileCitationObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentTextAnnotationsFileCitationObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),

            // Skipping file_citation in query parameter serialization


            Some("start_index".to_string()),
            Some(self.start_index.to_string()),


            Some("end_index".to_string()),
            Some(self.end_index.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentTextAnnotationsFileCitationObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentTextAnnotationsFileCitationObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub text: Vec<String>,
            pub file_citation: Vec<models::MessageContentTextAnnotationsFileCitationObjectFileCitation>,
            pub start_index: Vec<u32>,
            pub end_index: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentTextAnnotationsFileCitationObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_citation" => intermediate_rep.file_citation.push(<models::MessageContentTextAnnotationsFileCitationObjectFileCitation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start_index" => intermediate_rep.start_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_index" => intermediate_rep.end_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentTextAnnotationsFileCitationObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentTextAnnotationsFileCitationObject {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in MessageContentTextAnnotationsFileCitationObject".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in MessageContentTextAnnotationsFileCitationObject".to_string())?,
            file_citation: intermediate_rep.file_citation.into_iter().next().ok_or_else(|| "file_citation missing in MessageContentTextAnnotationsFileCitationObject".to_string())?,
            start_index: intermediate_rep.start_index.into_iter().next().ok_or_else(|| "start_index missing in MessageContentTextAnnotationsFileCitationObject".to_string())?,
            end_index: intermediate_rep.end_index.into_iter().next().ok_or_else(|| "end_index missing in MessageContentTextAnnotationsFileCitationObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageContentTextAnnotationsFileCitationObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentTextAnnotationsFileCitationObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageContentTextAnnotationsFileCitationObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentTextAnnotationsFileCitationObjectFileCitation {
/// The ID of the specific File the citation is from.
    #[serde(rename = "file_id")]
    pub file_id: String,

/// The specific quote in the file.
    #[serde(rename = "quote")]
    pub quote: String,

}


impl MessageContentTextAnnotationsFileCitationObjectFileCitation {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(file_id: String, quote: String, ) -> MessageContentTextAnnotationsFileCitationObjectFileCitation {
        MessageContentTextAnnotationsFileCitationObjectFileCitation {
            file_id,
            quote,
        }
    }
}

/// Converts the MessageContentTextAnnotationsFileCitationObjectFileCitation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentTextAnnotationsFileCitationObjectFileCitation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("file_id".to_string()),
            Some(self.file_id.to_string()),


            Some("quote".to_string()),
            Some(self.quote.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentTextAnnotationsFileCitationObjectFileCitation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentTextAnnotationsFileCitationObjectFileCitation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
            pub quote: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentTextAnnotationsFileCitationObjectFileCitation".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quote" => intermediate_rep.quote.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentTextAnnotationsFileCitationObjectFileCitation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentTextAnnotationsFileCitationObjectFileCitation {
            file_id: intermediate_rep.file_id.into_iter().next().ok_or_else(|| "file_id missing in MessageContentTextAnnotationsFileCitationObjectFileCitation".to_string())?,
            quote: intermediate_rep.quote.into_iter().next().ok_or_else(|| "quote missing in MessageContentTextAnnotationsFileCitationObjectFileCitation".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObjectFileCitation> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObjectFileCitation>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObjectFileCitation>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageContentTextAnnotationsFileCitationObjectFileCitation - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObjectFileCitation> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentTextAnnotationsFileCitationObjectFileCitation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageContentTextAnnotationsFileCitationObjectFileCitation - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A URL for the file that's generated when the assistant used the `code_interpreter` tool to generate a file.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentTextAnnotationsFilePathObject {
/// Always `file_path`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

/// The text in the message content that needs to be replaced.
    #[serde(rename = "text")]
    pub text: String,

    #[serde(rename = "file_path")]
    pub file_path: models::MessageContentTextAnnotationsFilePathObjectFilePath,

    #[serde(rename = "start_index")]
    #[validate(
            range(min = 0),
        )]
    pub start_index: u32,

    #[serde(rename = "end_index")]
    #[validate(
            range(min = 0),
        )]
    pub end_index: u32,

}


impl MessageContentTextAnnotationsFilePathObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, text: String, file_path: models::MessageContentTextAnnotationsFilePathObjectFilePath, start_index: u32, end_index: u32, ) -> MessageContentTextAnnotationsFilePathObject {
        MessageContentTextAnnotationsFilePathObject {
            r#type,
            text,
            file_path,
            start_index,
            end_index,
        }
    }
}

/// Converts the MessageContentTextAnnotationsFilePathObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentTextAnnotationsFilePathObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),

            // Skipping file_path in query parameter serialization


            Some("start_index".to_string()),
            Some(self.start_index.to_string()),


            Some("end_index".to_string()),
            Some(self.end_index.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentTextAnnotationsFilePathObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentTextAnnotationsFilePathObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub text: Vec<String>,
            pub file_path: Vec<models::MessageContentTextAnnotationsFilePathObjectFilePath>,
            pub start_index: Vec<u32>,
            pub end_index: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentTextAnnotationsFilePathObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_path" => intermediate_rep.file_path.push(<models::MessageContentTextAnnotationsFilePathObjectFilePath as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start_index" => intermediate_rep.start_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_index" => intermediate_rep.end_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentTextAnnotationsFilePathObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentTextAnnotationsFilePathObject {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in MessageContentTextAnnotationsFilePathObject".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in MessageContentTextAnnotationsFilePathObject".to_string())?,
            file_path: intermediate_rep.file_path.into_iter().next().ok_or_else(|| "file_path missing in MessageContentTextAnnotationsFilePathObject".to_string())?,
            start_index: intermediate_rep.start_index.into_iter().next().ok_or_else(|| "start_index missing in MessageContentTextAnnotationsFilePathObject".to_string())?,
            end_index: intermediate_rep.end_index.into_iter().next().ok_or_else(|| "end_index missing in MessageContentTextAnnotationsFilePathObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageContentTextAnnotationsFilePathObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentTextAnnotationsFilePathObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageContentTextAnnotationsFilePathObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentTextAnnotationsFilePathObjectFilePath {
/// The ID of the file that was generated.
    #[serde(rename = "file_id")]
    pub file_id: String,

}


impl MessageContentTextAnnotationsFilePathObjectFilePath {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(file_id: String, ) -> MessageContentTextAnnotationsFilePathObjectFilePath {
        MessageContentTextAnnotationsFilePathObjectFilePath {
            file_id,
        }
    }
}

/// Converts the MessageContentTextAnnotationsFilePathObjectFilePath value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentTextAnnotationsFilePathObjectFilePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("file_id".to_string()),
            Some(self.file_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentTextAnnotationsFilePathObjectFilePath value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentTextAnnotationsFilePathObjectFilePath {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentTextAnnotationsFilePathObjectFilePath".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentTextAnnotationsFilePathObjectFilePath".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentTextAnnotationsFilePathObjectFilePath {
            file_id: intermediate_rep.file_id.into_iter().next().ok_or_else(|| "file_id missing in MessageContentTextAnnotationsFilePathObjectFilePath".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObjectFilePath> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObjectFilePath>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObjectFilePath>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageContentTextAnnotationsFilePathObjectFilePath - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObjectFilePath> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentTextAnnotationsFilePathObjectFilePath as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageContentTextAnnotationsFilePathObjectFilePath - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The text content that is part of a message.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentTextObject {
/// Always `text`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "text")]
    pub text: models::MessageContentTextObjectText,

}


impl MessageContentTextObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, text: models::MessageContentTextObjectText, ) -> MessageContentTextObject {
        MessageContentTextObject {
            r#type,
            text,
        }
    }
}

/// Converts the MessageContentTextObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentTextObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping text in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentTextObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentTextObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub text: Vec<models::MessageContentTextObjectText>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentTextObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<models::MessageContentTextObjectText as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentTextObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentTextObject {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in MessageContentTextObject".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in MessageContentTextObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentTextObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentTextObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentTextObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageContentTextObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentTextObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentTextObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageContentTextObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentTextObjectText {
/// The data that makes up the text.
    #[serde(rename = "value")]
    pub value: String,

    #[serde(rename = "annotations")]
    pub annotations: Vec<models::MessageContentTextObjectTextAnnotationsInner>,

}


impl MessageContentTextObjectText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(value: String, annotations: Vec<models::MessageContentTextObjectTextAnnotationsInner>, ) -> MessageContentTextObjectText {
        MessageContentTextObjectText {
            value,
            annotations,
        }
    }
}

/// Converts the MessageContentTextObjectText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentTextObjectText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("value".to_string()),
            Some(self.value.to_string()),

            // Skipping annotations in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentTextObjectText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentTextObjectText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<String>,
            pub annotations: Vec<Vec<models::MessageContentTextObjectTextAnnotationsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentTextObjectText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in MessageContentTextObjectText".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentTextObjectText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentTextObjectText {
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in MessageContentTextObjectText".to_string())?,
            annotations: intermediate_rep.annotations.into_iter().next().ok_or_else(|| "annotations missing in MessageContentTextObjectText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentTextObjectText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentTextObjectText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentTextObjectText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageContentTextObjectText - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentTextObjectText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentTextObjectText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageContentTextObjectText - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - MessageContentTextAnnotationsFileCitationObject
/// - MessageContentTextAnnotationsFilePathObject
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MessageContentTextObjectTextAnnotationsInner(Box<serde_json::value::RawValue>);

impl validator::Validate for MessageContentTextObjectTextAnnotationsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentTextObjectTextAnnotationsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentTextObjectTextAnnotationsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for MessageContentTextObjectTextAnnotationsInner {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// References an image [File](/docs/api-reference/files) in the content of a message.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentImageFileObject {
/// The index of the content part in the message.
    #[serde(rename = "index")]
    pub index: i32,

/// Always `image_file`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "image_file")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_file: Option<models::MessageDeltaContentImageFileObjectImageFile>,

}


impl MessageDeltaContentImageFileObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r#type: String, ) -> MessageDeltaContentImageFileObject {
        MessageDeltaContentImageFileObject {
            index,
            r#type,
            image_file: None,
        }
    }
}

/// Converts the MessageDeltaContentImageFileObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentImageFileObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping image_file in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentImageFileObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentImageFileObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub r#type: Vec<String>,
            pub image_file: Vec<models::MessageDeltaContentImageFileObjectImageFile>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentImageFileObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_file" => intermediate_rep.image_file.push(<models::MessageDeltaContentImageFileObjectImageFile as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentImageFileObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentImageFileObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in MessageDeltaContentImageFileObject".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in MessageDeltaContentImageFileObject".to_string())?,
            image_file: intermediate_rep.image_file.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentImageFileObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentImageFileObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentImageFileObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageDeltaContentImageFileObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentImageFileObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentImageFileObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageDeltaContentImageFileObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentImageFileObjectImageFile {
/// The [File](/docs/api-reference/files) ID of the image in the message content.
    #[serde(rename = "file_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_id: Option<String>,

}


impl MessageDeltaContentImageFileObjectImageFile {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MessageDeltaContentImageFileObjectImageFile {
        MessageDeltaContentImageFileObjectImageFile {
            file_id: None,
        }
    }
}

/// Converts the MessageDeltaContentImageFileObjectImageFile value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentImageFileObjectImageFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_id.as_ref().map(|file_id| {
                [
                    "file_id".to_string(),
                    file_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentImageFileObjectImageFile value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentImageFileObjectImageFile {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentImageFileObjectImageFile".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentImageFileObjectImageFile".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentImageFileObjectImageFile {
            file_id: intermediate_rep.file_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentImageFileObjectImageFile> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentImageFileObjectImageFile>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentImageFileObjectImageFile>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageDeltaContentImageFileObjectImageFile - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentImageFileObjectImageFile> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentImageFileObjectImageFile as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageDeltaContentImageFileObjectImageFile - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"retrieval\" tool to search files.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentTextAnnotationsFileCitationObject {
/// The index of the annotation in the text content part.
    #[serde(rename = "index")]
    pub index: i32,

/// Always `file_citation`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

/// The text in the message content that needs to be replaced.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,

    #[serde(rename = "file_citation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_citation: Option<models::MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation>,

    #[serde(rename = "start_index")]
    #[validate(
            range(min = 0),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_index: Option<u32>,

    #[serde(rename = "end_index")]
    #[validate(
            range(min = 0),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_index: Option<u32>,

}


impl MessageDeltaContentTextAnnotationsFileCitationObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r#type: String, ) -> MessageDeltaContentTextAnnotationsFileCitationObject {
        MessageDeltaContentTextAnnotationsFileCitationObject {
            index,
            r#type,
            text: None,
            file_citation: None,
            start_index: None,
            end_index: None,
        }
    }
}

/// Converts the MessageDeltaContentTextAnnotationsFileCitationObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentTextAnnotationsFileCitationObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("type".to_string()),
            Some(self.r#type.to_string()),


            self.text.as_ref().map(|text| {
                [
                    "text".to_string(),
                    text.to_string(),
                ].join(",")
            }),

            // Skipping file_citation in query parameter serialization


            self.start_index.as_ref().map(|start_index| {
                [
                    "start_index".to_string(),
                    start_index.to_string(),
                ].join(",")
            }),


            self.end_index.as_ref().map(|end_index| {
                [
                    "end_index".to_string(),
                    end_index.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentTextAnnotationsFileCitationObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentTextAnnotationsFileCitationObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub r#type: Vec<String>,
            pub text: Vec<String>,
            pub file_citation: Vec<models::MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation>,
            pub start_index: Vec<u32>,
            pub end_index: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentTextAnnotationsFileCitationObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_citation" => intermediate_rep.file_citation.push(<models::MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start_index" => intermediate_rep.start_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_index" => intermediate_rep.end_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentTextAnnotationsFileCitationObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentTextAnnotationsFileCitationObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in MessageDeltaContentTextAnnotationsFileCitationObject".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in MessageDeltaContentTextAnnotationsFileCitationObject".to_string())?,
            text: intermediate_rep.text.into_iter().next(),
            file_citation: intermediate_rep.file_citation.into_iter().next(),
            start_index: intermediate_rep.start_index.into_iter().next(),
            end_index: intermediate_rep.end_index.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageDeltaContentTextAnnotationsFileCitationObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentTextAnnotationsFileCitationObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageDeltaContentTextAnnotationsFileCitationObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
/// The ID of the specific File the citation is from.
    #[serde(rename = "file_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_id: Option<String>,

/// The specific quote in the file.
    #[serde(rename = "quote")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quote: Option<String>,

}


impl MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
        MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
            file_id: None,
            quote: None,
        }
    }
}

/// Converts the MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_id.as_ref().map(|file_id| {
                [
                    "file_id".to_string(),
                    file_id.to_string(),
                ].join(",")
            }),


            self.quote.as_ref().map(|quote| {
                [
                    "quote".to_string(),
                    quote.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
            pub quote: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quote" => intermediate_rep.quote.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
            file_id: intermediate_rep.file_id.into_iter().next(),
            quote: intermediate_rep.quote.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// A URL for the file that's generated when the assistant used the `code_interpreter` tool to generate a file.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentTextAnnotationsFilePathObject {
/// The index of the annotation in the text content part.
    #[serde(rename = "index")]
    pub index: i32,

/// Always `file_path`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

/// The text in the message content that needs to be replaced.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,

    #[serde(rename = "file_path")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_path: Option<models::MessageDeltaContentTextAnnotationsFilePathObjectFilePath>,

    #[serde(rename = "start_index")]
    #[validate(
            range(min = 0),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_index: Option<u32>,

    #[serde(rename = "end_index")]
    #[validate(
            range(min = 0),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_index: Option<u32>,

}


impl MessageDeltaContentTextAnnotationsFilePathObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r#type: String, ) -> MessageDeltaContentTextAnnotationsFilePathObject {
        MessageDeltaContentTextAnnotationsFilePathObject {
            index,
            r#type,
            text: None,
            file_path: None,
            start_index: None,
            end_index: None,
        }
    }
}

/// Converts the MessageDeltaContentTextAnnotationsFilePathObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentTextAnnotationsFilePathObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("type".to_string()),
            Some(self.r#type.to_string()),


            self.text.as_ref().map(|text| {
                [
                    "text".to_string(),
                    text.to_string(),
                ].join(",")
            }),

            // Skipping file_path in query parameter serialization


            self.start_index.as_ref().map(|start_index| {
                [
                    "start_index".to_string(),
                    start_index.to_string(),
                ].join(",")
            }),


            self.end_index.as_ref().map(|end_index| {
                [
                    "end_index".to_string(),
                    end_index.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentTextAnnotationsFilePathObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentTextAnnotationsFilePathObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub r#type: Vec<String>,
            pub text: Vec<String>,
            pub file_path: Vec<models::MessageDeltaContentTextAnnotationsFilePathObjectFilePath>,
            pub start_index: Vec<u32>,
            pub end_index: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentTextAnnotationsFilePathObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_path" => intermediate_rep.file_path.push(<models::MessageDeltaContentTextAnnotationsFilePathObjectFilePath as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start_index" => intermediate_rep.start_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_index" => intermediate_rep.end_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentTextAnnotationsFilePathObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentTextAnnotationsFilePathObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in MessageDeltaContentTextAnnotationsFilePathObject".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in MessageDeltaContentTextAnnotationsFilePathObject".to_string())?,
            text: intermediate_rep.text.into_iter().next(),
            file_path: intermediate_rep.file_path.into_iter().next(),
            start_index: intermediate_rep.start_index.into_iter().next(),
            end_index: intermediate_rep.end_index.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageDeltaContentTextAnnotationsFilePathObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentTextAnnotationsFilePathObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageDeltaContentTextAnnotationsFilePathObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
/// The ID of the file that was generated.
    #[serde(rename = "file_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_id: Option<String>,

}


impl MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
        MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
            file_id: None,
        }
    }
}

/// Converts the MessageDeltaContentTextAnnotationsFilePathObjectFilePath value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_id.as_ref().map(|file_id| {
                [
                    "file_id".to_string(),
                    file_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentTextAnnotationsFilePathObjectFilePath value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentTextAnnotationsFilePathObjectFilePath".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentTextAnnotationsFilePathObjectFilePath".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
            file_id: intermediate_rep.file_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObjectFilePath> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObjectFilePath>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObjectFilePath>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageDeltaContentTextAnnotationsFilePathObjectFilePath - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObjectFilePath> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentTextAnnotationsFilePathObjectFilePath as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageDeltaContentTextAnnotationsFilePathObjectFilePath - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The text content that is part of a message.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentTextObject {
/// The index of the content part in the message.
    #[serde(rename = "index")]
    pub index: i32,

/// Always `text`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "text")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<models::MessageDeltaContentTextObjectText>,

}


impl MessageDeltaContentTextObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r#type: String, ) -> MessageDeltaContentTextObject {
        MessageDeltaContentTextObject {
            index,
            r#type,
            text: None,
        }
    }
}

/// Converts the MessageDeltaContentTextObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentTextObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping text in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentTextObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentTextObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub r#type: Vec<String>,
            pub text: Vec<models::MessageDeltaContentTextObjectText>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentTextObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<models::MessageDeltaContentTextObjectText as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentTextObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentTextObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in MessageDeltaContentTextObject".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in MessageDeltaContentTextObject".to_string())?,
            text: intermediate_rep.text.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentTextObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentTextObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentTextObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageDeltaContentTextObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentTextObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentTextObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageDeltaContentTextObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentTextObjectText {
/// The data that makes up the text.
    #[serde(rename = "value")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,

    #[serde(rename = "annotations")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<Vec<models::MessageDeltaContentTextObjectTextAnnotationsInner>>,

}


impl MessageDeltaContentTextObjectText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MessageDeltaContentTextObjectText {
        MessageDeltaContentTextObjectText {
            value: None,
            annotations: None,
        }
    }
}

/// Converts the MessageDeltaContentTextObjectText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentTextObjectText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),

            // Skipping annotations in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentTextObjectText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentTextObjectText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<String>,
            pub annotations: Vec<Vec<models::MessageDeltaContentTextObjectTextAnnotationsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentTextObjectText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in MessageDeltaContentTextObjectText".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentTextObjectText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentTextObjectText {
            value: intermediate_rep.value.into_iter().next(),
            annotations: intermediate_rep.annotations.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentTextObjectText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentTextObjectText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentTextObjectText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageDeltaContentTextObjectText - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentTextObjectText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentTextObjectText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageDeltaContentTextObjectText - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - MessageDeltaContentTextAnnotationsFileCitationObject
/// - MessageDeltaContentTextAnnotationsFilePathObject
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MessageDeltaContentTextObjectTextAnnotationsInner(Box<serde_json::value::RawValue>);

impl validator::Validate for MessageDeltaContentTextObjectTextAnnotationsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentTextObjectTextAnnotationsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentTextObjectTextAnnotationsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for MessageDeltaContentTextObjectTextAnnotationsInner {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Represents a message delta i.e. any changed fields on a message during streaming. 



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaObject {
/// The identifier of the message, which can be referenced in API endpoints.
    #[serde(rename = "id")]
    pub id: String,

/// The object type, which is always `thread.message.delta`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "delta")]
    pub delta: models::MessageDeltaObjectDelta,

}


impl MessageDeltaObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, delta: models::MessageDeltaObjectDelta, ) -> MessageDeltaObject {
        MessageDeltaObject {
            id,
            object,
            delta,
        }
    }
}

/// Converts the MessageDeltaObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping delta in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub delta: Vec<models::MessageDeltaObjectDelta>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "delta" => intermediate_rep.delta.push(<models::MessageDeltaObjectDelta as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in MessageDeltaObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in MessageDeltaObject".to_string())?,
            delta: intermediate_rep.delta.into_iter().next().ok_or_else(|| "delta missing in MessageDeltaObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageDeltaObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageDeltaObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The delta containing the fields that have changed on the Message.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaObjectDelta {
/// The entity that produced the message. One of `user` or `assistant`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,

/// The content of the message in array of text and/or images.
    #[serde(rename = "content")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<Vec<models::MessageDeltaObjectDeltaContentInner>>,

/// A list of [file](/docs/api-reference/files) IDs that the assistant should use. Useful for tools like retrieval and code_interpreter that can access files. A maximum of 10 files can be attached to a message.
    #[serde(rename = "file_ids")]
    #[validate(
            length(max = 10),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_ids: Option<Vec<String>>,

}


impl MessageDeltaObjectDelta {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MessageDeltaObjectDelta {
        MessageDeltaObjectDelta {
            role: None,
            content: None,
            file_ids: None,
        }
    }
}

/// Converts the MessageDeltaObjectDelta value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaObjectDelta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.role.as_ref().map(|role| {
                [
                    "role".to_string(),
                    role.to_string(),
                ].join(",")
            }),

            // Skipping content in query parameter serialization


            self.file_ids.as_ref().map(|file_ids| {
                [
                    "file_ids".to_string(),
                    file_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaObjectDelta value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaObjectDelta {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role: Vec<String>,
            pub content: Vec<Vec<models::MessageDeltaObjectDeltaContentInner>>,
            pub file_ids: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaObjectDelta".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "content" => return std::result::Result::Err("Parsing a container in this style is not supported in MessageDeltaObjectDelta".to_string()),
                    "file_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in MessageDeltaObjectDelta".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaObjectDelta".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaObjectDelta {
            role: intermediate_rep.role.into_iter().next(),
            content: intermediate_rep.content.into_iter().next(),
            file_ids: intermediate_rep.file_ids.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaObjectDelta> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaObjectDelta>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaObjectDelta>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageDeltaObjectDelta - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaObjectDelta> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaObjectDelta as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageDeltaObjectDelta - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - MessageDeltaContentImageFileObject
/// - MessageDeltaContentTextObject
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MessageDeltaObjectDeltaContentInner(Box<serde_json::value::RawValue>);

impl validator::Validate for MessageDeltaObjectDeltaContentInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaObjectDeltaContentInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaObjectDeltaContentInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for MessageDeltaObjectDeltaContentInner {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// A list of files attached to a `message`.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageFileObject {
/// The identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
    pub id: String,

/// The object type, which is always `thread.message.file`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

/// The Unix timestamp (in seconds) for when the message file was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

/// The ID of the [message](/docs/api-reference/messages) that the [File](/docs/api-reference/files) is attached to.
    #[serde(rename = "message_id")]
    pub message_id: String,

}


impl MessageFileObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, created_at: i32, message_id: String, ) -> MessageFileObject {
        MessageFileObject {
            id,
            object,
            created_at,
            message_id,
        }
    }
}

/// Converts the MessageFileObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageFileObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("message_id".to_string()),
            Some(self.message_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageFileObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageFileObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub created_at: Vec<i32>,
            pub message_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageFileObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message_id" => intermediate_rep.message_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageFileObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageFileObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in MessageFileObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in MessageFileObject".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in MessageFileObject".to_string())?,
            message_id: intermediate_rep.message_id.into_iter().next().ok_or_else(|| "message_id missing in MessageFileObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageFileObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageFileObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageFileObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageFileObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageFileObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageFileObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageFileObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Represents a message within a [thread](/docs/api-reference/threads).



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageObject {
/// The identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
    pub id: String,

/// The object type, which is always `thread.message`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

/// The Unix timestamp (in seconds) for when the message was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

/// The [thread](/docs/api-reference/threads) ID that this message belongs to.
    #[serde(rename = "thread_id")]
    pub thread_id: String,

/// The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "incomplete_details")]
    pub incomplete_details: Nullable<models::MessageObjectIncompleteDetails>,

/// The Unix timestamp (in seconds) for when the message was completed.
    #[serde(rename = "completed_at")]
    pub completed_at: Nullable<i32>,

/// The Unix timestamp (in seconds) for when the message was marked as incomplete.
    #[serde(rename = "incomplete_at")]
    pub incomplete_at: Nullable<i32>,

/// The entity that produced the message. One of `user` or `assistant`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
    pub role: String,

/// The content of the message in array of text and/or images.
    #[serde(rename = "content")]
    pub content: Vec<models::MessageObjectContentInner>,

/// If applicable, the ID of the [assistant](/docs/api-reference/assistants) that authored this message.
    #[serde(rename = "assistant_id")]
    pub assistant_id: Nullable<String>,

/// The ID of the [run](/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints.
    #[serde(rename = "run_id")]
    pub run_id: Nullable<String>,

/// A list of [file](/docs/api-reference/files) IDs that the assistant should use. Useful for tools like retrieval and code_interpreter that can access files. A maximum of 10 files can be attached to a message.
    #[serde(rename = "file_ids")]
    #[validate(
            length(max = 10),
        )]
    pub file_ids: Vec<String>,

/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
    #[serde(rename = "metadata")]
    pub metadata: crate::types::Object,

}


impl MessageObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, created_at: i32, thread_id: String, status: String, incomplete_details: Nullable<models::MessageObjectIncompleteDetails>, completed_at: Nullable<i32>, incomplete_at: Nullable<i32>, role: String, content: Vec<models::MessageObjectContentInner>, assistant_id: Nullable<String>, run_id: Nullable<String>, file_ids: Vec<String>, metadata: crate::types::Object, ) -> MessageObject {
        MessageObject {
            id,
            object,
            created_at,
            thread_id,
            status,
            incomplete_details,
            completed_at,
            incomplete_at,
            role,
            content,
            assistant_id,
            run_id,
            file_ids,
            metadata,
        }
    }
}

/// Converts the MessageObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("thread_id".to_string()),
            Some(self.thread_id.to_string()),


            Some("status".to_string()),
            Some(self.status.to_string()),

            // Skipping incomplete_details in query parameter serialization


            Some("completed_at".to_string()),
            Some(self.completed_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("incomplete_at".to_string()),
            Some(self.incomplete_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("role".to_string()),
            Some(self.role.to_string()),

            // Skipping content in query parameter serialization


            Some("assistant_id".to_string()),
            Some(self.assistant_id.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("run_id".to_string()),
            Some(self.run_id.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("file_ids".to_string()),
            Some(self.file_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub created_at: Vec<i32>,
            pub thread_id: Vec<String>,
            pub status: Vec<String>,
            pub incomplete_details: Vec<models::MessageObjectIncompleteDetails>,
            pub completed_at: Vec<i32>,
            pub incomplete_at: Vec<i32>,
            pub role: Vec<String>,
            pub content: Vec<Vec<models::MessageObjectContentInner>>,
            pub assistant_id: Vec<String>,
            pub run_id: Vec<String>,
            pub file_ids: Vec<Vec<String>>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "thread_id" => intermediate_rep.thread_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "incomplete_details" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MessageObject".to_string()),
                    "completed_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MessageObject".to_string()),
                    "incomplete_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MessageObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "content" => return std::result::Result::Err("Parsing a container in this style is not supported in MessageObject".to_string()),
                    "assistant_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MessageObject".to_string()),
                    "run_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MessageObject".to_string()),
                    "file_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in MessageObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in MessageObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in MessageObject".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in MessageObject".to_string())?,
            thread_id: intermediate_rep.thread_id.into_iter().next().ok_or_else(|| "thread_id missing in MessageObject".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in MessageObject".to_string())?,
            incomplete_details: std::result::Result::Err("Nullable types not supported in MessageObject".to_string())?,
            completed_at: std::result::Result::Err("Nullable types not supported in MessageObject".to_string())?,
            incomplete_at: std::result::Result::Err("Nullable types not supported in MessageObject".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in MessageObject".to_string())?,
            content: intermediate_rep.content.into_iter().next().ok_or_else(|| "content missing in MessageObject".to_string())?,
            assistant_id: std::result::Result::Err("Nullable types not supported in MessageObject".to_string())?,
            run_id: std::result::Result::Err("Nullable types not supported in MessageObject".to_string())?,
            file_ids: intermediate_rep.file_ids.into_iter().next().ok_or_else(|| "file_ids missing in MessageObject".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next().ok_or_else(|| "metadata missing in MessageObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - MessageContentImageFileObject
/// - MessageContentTextObject
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MessageObjectContentInner(Box<serde_json::value::RawValue>);

impl validator::Validate for MessageObjectContentInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageObjectContentInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageObjectContentInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for MessageObjectContentInner {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// On an incomplete message, details about why the message is incomplete.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageObjectIncompleteDetails {
/// The reason the message is incomplete.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "reason")]
    pub reason: String,

}


impl MessageObjectIncompleteDetails {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(reason: String, ) -> MessageObjectIncompleteDetails {
        MessageObjectIncompleteDetails {
            reason,
        }
    }
}

/// Converts the MessageObjectIncompleteDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageObjectIncompleteDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("reason".to_string()),
            Some(self.reason.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageObjectIncompleteDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageObjectIncompleteDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub reason: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageObjectIncompleteDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageObjectIncompleteDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageObjectIncompleteDetails {
            reason: intermediate_rep.reason.into_iter().next().ok_or_else(|| "reason missing in MessageObjectIncompleteDetails".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageObjectIncompleteDetails> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageObjectIncompleteDetails>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageObjectIncompleteDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageObjectIncompleteDetails - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageObjectIncompleteDetails> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageObjectIncompleteDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageObjectIncompleteDetails - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - MessageStreamEventOneOf
/// - MessageStreamEventOneOf1
/// - MessageStreamEventOneOf2
/// - MessageStreamEventOneOf3
/// - MessageStreamEventOneOf4
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct MessageStreamEvent(Box<serde_json::value::RawValue>);

impl validator::Validate for MessageStreamEvent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageStreamEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageStreamEvent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for MessageStreamEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Occurs when a [message](/docs/api-reference/messages/object) is created.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageStreamEventOneOf {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::MessageObject,

}


impl MessageStreamEventOneOf {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::MessageObject, ) -> MessageStreamEventOneOf {
        MessageStreamEventOneOf {
            event,
            data,
        }
    }
}

/// Converts the MessageStreamEventOneOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageStreamEventOneOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageStreamEventOneOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageStreamEventOneOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::MessageObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageStreamEventOneOf".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::MessageObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageStreamEventOneOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageStreamEventOneOf {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in MessageStreamEventOneOf".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in MessageStreamEventOneOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageStreamEventOneOf> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageStreamEventOneOf>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageStreamEventOneOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageStreamEventOneOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageStreamEventOneOf> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageStreamEventOneOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageStreamEventOneOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [message](/docs/api-reference/messages/object) moves to an `in_progress` state.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageStreamEventOneOf1 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::MessageObject,

}


impl MessageStreamEventOneOf1 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::MessageObject, ) -> MessageStreamEventOneOf1 {
        MessageStreamEventOneOf1 {
            event,
            data,
        }
    }
}

/// Converts the MessageStreamEventOneOf1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageStreamEventOneOf1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageStreamEventOneOf1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageStreamEventOneOf1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::MessageObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageStreamEventOneOf1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::MessageObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageStreamEventOneOf1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageStreamEventOneOf1 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in MessageStreamEventOneOf1".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in MessageStreamEventOneOf1".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageStreamEventOneOf1> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageStreamEventOneOf1>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageStreamEventOneOf1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageStreamEventOneOf1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageStreamEventOneOf1> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageStreamEventOneOf1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageStreamEventOneOf1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when parts of a [Message](/docs/api-reference/messages/object) are being streamed.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageStreamEventOneOf2 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::MessageDeltaObject,

}


impl MessageStreamEventOneOf2 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::MessageDeltaObject, ) -> MessageStreamEventOneOf2 {
        MessageStreamEventOneOf2 {
            event,
            data,
        }
    }
}

/// Converts the MessageStreamEventOneOf2 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageStreamEventOneOf2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageStreamEventOneOf2 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageStreamEventOneOf2 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::MessageDeltaObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageStreamEventOneOf2".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::MessageDeltaObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageStreamEventOneOf2".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageStreamEventOneOf2 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in MessageStreamEventOneOf2".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in MessageStreamEventOneOf2".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageStreamEventOneOf2> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageStreamEventOneOf2>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageStreamEventOneOf2>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageStreamEventOneOf2 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageStreamEventOneOf2> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageStreamEventOneOf2 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageStreamEventOneOf2 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [message](/docs/api-reference/messages/object) is completed.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageStreamEventOneOf3 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::MessageObject,

}


impl MessageStreamEventOneOf3 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::MessageObject, ) -> MessageStreamEventOneOf3 {
        MessageStreamEventOneOf3 {
            event,
            data,
        }
    }
}

/// Converts the MessageStreamEventOneOf3 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageStreamEventOneOf3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageStreamEventOneOf3 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageStreamEventOneOf3 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::MessageObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageStreamEventOneOf3".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::MessageObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageStreamEventOneOf3".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageStreamEventOneOf3 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in MessageStreamEventOneOf3".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in MessageStreamEventOneOf3".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageStreamEventOneOf3> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageStreamEventOneOf3>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageStreamEventOneOf3>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageStreamEventOneOf3 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageStreamEventOneOf3> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageStreamEventOneOf3 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageStreamEventOneOf3 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [message](/docs/api-reference/messages/object) ends before it is completed.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageStreamEventOneOf4 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::MessageObject,

}


impl MessageStreamEventOneOf4 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::MessageObject, ) -> MessageStreamEventOneOf4 {
        MessageStreamEventOneOf4 {
            event,
            data,
        }
    }
}

/// Converts the MessageStreamEventOneOf4 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageStreamEventOneOf4 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageStreamEventOneOf4 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageStreamEventOneOf4 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::MessageObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageStreamEventOneOf4".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::MessageObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageStreamEventOneOf4".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageStreamEventOneOf4 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in MessageStreamEventOneOf4".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in MessageStreamEventOneOf4".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageStreamEventOneOf4> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageStreamEventOneOf4>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageStreamEventOneOf4>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MessageStreamEventOneOf4 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageStreamEventOneOf4> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageStreamEventOneOf4 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MessageStreamEventOneOf4 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Describes an OpenAI model offering that can be used with the API.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Model {
/// The model identifier, which can be referenced in the API endpoints.
    #[serde(rename = "id")]
    pub id: String,

/// The Unix timestamp (in seconds) when the model was created.
    #[serde(rename = "created")]
    pub created: i32,

/// The object type, which is always \"model\".
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

/// The organization that owns the model.
    #[serde(rename = "owned_by")]
    pub owned_by: String,

}


impl Model {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, created: i32, object: String, owned_by: String, ) -> Model {
        Model {
            id,
            created,
            object,
            owned_by,
        }
    }
}

/// Converts the Model value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Model {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("created".to_string()),
            Some(self.created.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("owned_by".to_string()),
            Some(self.owned_by.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Model value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Model {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub created: Vec<i32>,
            pub object: Vec<String>,
            pub owned_by: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Model".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "owned_by" => intermediate_rep.owned_by.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Model".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Model {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in Model".to_string())?,
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "created missing in Model".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in Model".to_string())?,
            owned_by: intermediate_rep.owned_by.into_iter().next().ok_or_else(|| "owned_by missing in Model".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Model> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Model>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Model>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Model - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Model> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Model as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Model - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModifyAssistantRequest {
    #[serde(rename = "model")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<String>,

/// The name of the assistant. The maximum length is 256 characters. 
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

/// The description of the assistant. The maximum length is 512 characters. 
    #[serde(rename = "description")]
    #[validate(
            length(max = 512),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

/// The system instructions that the assistant uses. The maximum length is 256,000 characters. 
    #[serde(rename = "instructions")]
    #[validate(
            length(max = 256000),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instructions: Option<Nullable<String>>,

/// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`. 
    #[serde(rename = "tools")]
    #[validate(
            length(max = 128),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Vec<models::AssistantObjectToolsInner>>,

/// A list of [File](/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. If a file was previously attached to the list but does not show up in the list, it will be deleted from the assistant. 
    #[serde(rename = "file_ids")]
    #[validate(
            length(max = 20),
        )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_ids: Option<Vec<String>>,

/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}


impl ModifyAssistantRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ModifyAssistantRequest {
        ModifyAssistantRequest {
            model: None,
            name: None,
            description: None,
            instructions: None,
            tools: None,
            file_ids: None,
            metadata: None,
        }
    }
}

/// Converts the ModifyAssistantRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ModifyAssistantRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.model.as_ref().map(|model| {
                [
                    "model".to_string(),
                    model.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.instructions.as_ref().map(|instructions| {
                [
                    "instructions".to_string(),
                    instructions.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping tools in query parameter serialization


            self.file_ids.as_ref().map(|file_ids| {
                [
                    "file_ids".to_string(),
                    file_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModifyAssistantRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModifyAssistantRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub model: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub instructions: Vec<String>,
            pub tools: Vec<Vec<models::AssistantObjectToolsInner>>,
            pub file_ids: Vec<Vec<String>>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModifyAssistantRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ModifyAssistantRequest".to_string()),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ModifyAssistantRequest".to_string()),
                    "instructions" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ModifyAssistantRequest".to_string()),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in ModifyAssistantRequest".to_string()),
                    "file_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in ModifyAssistantRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModifyAssistantRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModifyAssistantRequest {
            model: intermediate_rep.model.into_iter().next(),
            name: std::result::Result::Err("Nullable types not supported in ModifyAssistantRequest".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in ModifyAssistantRequest".to_string())?,
            instructions: std::result::Result::Err("Nullable types not supported in ModifyAssistantRequest".to_string())?,
            tools: intermediate_rep.tools.into_iter().next(),
            file_ids: intermediate_rep.file_ids.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModifyAssistantRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ModifyAssistantRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModifyAssistantRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ModifyAssistantRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ModifyAssistantRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModifyAssistantRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ModifyAssistantRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModifyMessageRequest {
/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}


impl ModifyMessageRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ModifyMessageRequest {
        ModifyMessageRequest {
            metadata: None,
        }
    }
}

/// Converts the ModifyMessageRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ModifyMessageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModifyMessageRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModifyMessageRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModifyMessageRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModifyMessageRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModifyMessageRequest {
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModifyMessageRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ModifyMessageRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModifyMessageRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ModifyMessageRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ModifyMessageRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModifyMessageRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ModifyMessageRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModifyRunRequest {
/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}


impl ModifyRunRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ModifyRunRequest {
        ModifyRunRequest {
            metadata: None,
        }
    }
}

/// Converts the ModifyRunRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ModifyRunRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModifyRunRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModifyRunRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModifyRunRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModifyRunRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModifyRunRequest {
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModifyRunRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ModifyRunRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModifyRunRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ModifyRunRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ModifyRunRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModifyRunRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ModifyRunRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModifyThreadRequest {
/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}


impl ModifyThreadRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ModifyThreadRequest {
        ModifyThreadRequest {
            metadata: None,
        }
    }
}

/// Converts the ModifyThreadRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ModifyThreadRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModifyThreadRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModifyThreadRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModifyThreadRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModifyThreadRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModifyThreadRequest {
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModifyThreadRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ModifyThreadRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModifyThreadRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ModifyThreadRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ModifyThreadRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModifyThreadRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ModifyThreadRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The `File` object represents a document that has been uploaded to OpenAI.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OpenAiFile {
/// The file identifier, which can be referenced in the API endpoints.
    #[serde(rename = "id")]
    pub id: String,

/// The size of the file, in bytes.
    #[serde(rename = "bytes")]
    pub bytes: i32,

/// The Unix timestamp (in seconds) for when the file was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

/// The name of the file.
    #[serde(rename = "filename")]
    pub filename: String,

/// The object type, which is always `file`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

/// The intended purpose of the file. Supported values are `fine-tune`, `fine-tune-results`, `assistants`, and `assistants_output`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "purpose")]
    pub purpose: String,

/// Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

/// Deprecated. For details on why a fine-tuning training file failed validation, see the `error` field on `fine_tuning.job`.
    #[serde(rename = "status_details")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status_details: Option<String>,

}


impl OpenAiFile {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, bytes: i32, created_at: i32, filename: String, object: String, purpose: String, status: String, ) -> OpenAiFile {
        OpenAiFile {
            id,
            bytes,
            created_at,
            filename,
            object,
            purpose,
            status,
            status_details: None,
        }
    }
}

/// Converts the OpenAiFile value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OpenAiFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("bytes".to_string()),
            Some(self.bytes.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("filename".to_string()),
            Some(self.filename.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("purpose".to_string()),
            Some(self.purpose.to_string()),


            Some("status".to_string()),
            Some(self.status.to_string()),


            self.status_details.as_ref().map(|status_details| {
                [
                    "status_details".to_string(),
                    status_details.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OpenAiFile value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OpenAiFile {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub bytes: Vec<i32>,
            pub created_at: Vec<i32>,
            pub filename: Vec<String>,
            pub object: Vec<String>,
            pub purpose: Vec<String>,
            pub status: Vec<String>,
            pub status_details: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OpenAiFile".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "bytes" => intermediate_rep.bytes.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "filename" => intermediate_rep.filename.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "purpose" => intermediate_rep.purpose.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status_details" => intermediate_rep.status_details.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OpenAiFile".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OpenAiFile {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in OpenAiFile".to_string())?,
            bytes: intermediate_rep.bytes.into_iter().next().ok_or_else(|| "bytes missing in OpenAiFile".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in OpenAiFile".to_string())?,
            filename: intermediate_rep.filename.into_iter().next().ok_or_else(|| "filename missing in OpenAiFile".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in OpenAiFile".to_string())?,
            purpose: intermediate_rep.purpose.into_iter().next().ok_or_else(|| "purpose missing in OpenAiFile".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in OpenAiFile".to_string())?,
            status_details: intermediate_rep.status_details.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OpenAiFile> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OpenAiFile>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OpenAiFile>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OpenAiFile - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OpenAiFile> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OpenAiFile as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OpenAiFile - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunCompletionUsage {
/// Number of completion tokens used over the course of the run.
    #[serde(rename = "completion_tokens")]
    pub completion_tokens: i32,

/// Number of prompt tokens used over the course of the run.
    #[serde(rename = "prompt_tokens")]
    pub prompt_tokens: i32,

/// Total number of tokens used (prompt + completion).
    #[serde(rename = "total_tokens")]
    pub total_tokens: i32,

}


impl RunCompletionUsage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(completion_tokens: i32, prompt_tokens: i32, total_tokens: i32, ) -> RunCompletionUsage {
        RunCompletionUsage {
            completion_tokens,
            prompt_tokens,
            total_tokens,
        }
    }
}

/// Converts the RunCompletionUsage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunCompletionUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("completion_tokens".to_string()),
            Some(self.completion_tokens.to_string()),


            Some("prompt_tokens".to_string()),
            Some(self.prompt_tokens.to_string()),


            Some("total_tokens".to_string()),
            Some(self.total_tokens.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunCompletionUsage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunCompletionUsage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub completion_tokens: Vec<i32>,
            pub prompt_tokens: Vec<i32>,
            pub total_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunCompletionUsage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "completion_tokens" => intermediate_rep.completion_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prompt_tokens" => intermediate_rep.prompt_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total_tokens" => intermediate_rep.total_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunCompletionUsage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunCompletionUsage {
            completion_tokens: intermediate_rep.completion_tokens.into_iter().next().ok_or_else(|| "completion_tokens missing in RunCompletionUsage".to_string())?,
            prompt_tokens: intermediate_rep.prompt_tokens.into_iter().next().ok_or_else(|| "prompt_tokens missing in RunCompletionUsage".to_string())?,
            total_tokens: intermediate_rep.total_tokens.into_iter().next().ok_or_else(|| "total_tokens missing in RunCompletionUsage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunCompletionUsage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunCompletionUsage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunCompletionUsage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunCompletionUsage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunCompletionUsage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunCompletionUsage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunCompletionUsage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Represents an execution run on a [thread](/docs/api-reference/threads).



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunObject {
/// The identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
    pub id: String,

/// The object type, which is always `thread.run`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

/// The Unix timestamp (in seconds) for when the run was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

/// The ID of the [thread](/docs/api-reference/threads) that was executed on as a part of this run.
    #[serde(rename = "thread_id")]
    pub thread_id: String,

/// The ID of the [assistant](/docs/api-reference/assistants) used for execution of this run.
    #[serde(rename = "assistant_id")]
    pub assistant_id: String,

/// The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, or `expired`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "required_action")]
    pub required_action: Nullable<models::RunObjectRequiredAction>,

    #[serde(rename = "last_error")]
    pub last_error: Nullable<models::RunObjectLastError>,

/// The Unix timestamp (in seconds) for when the run will expire.
    #[serde(rename = "expires_at")]
    pub expires_at: Nullable<i32>,

/// The Unix timestamp (in seconds) for when the run was started.
    #[serde(rename = "started_at")]
    pub started_at: Nullable<i32>,

/// The Unix timestamp (in seconds) for when the run was cancelled.
    #[serde(rename = "cancelled_at")]
    pub cancelled_at: Nullable<i32>,

/// The Unix timestamp (in seconds) for when the run failed.
    #[serde(rename = "failed_at")]
    pub failed_at: Nullable<i32>,

/// The Unix timestamp (in seconds) for when the run was completed.
    #[serde(rename = "completed_at")]
    pub completed_at: Nullable<i32>,

    #[serde(rename = "incomplete_details")]
    pub incomplete_details: Nullable<models::RunObjectIncompleteDetails>,

/// The model that the [assistant](/docs/api-reference/assistants) used for this run.
    #[serde(rename = "model")]
    pub model: String,

/// The instructions that the [assistant](/docs/api-reference/assistants) used for this run.
    #[serde(rename = "instructions")]
    pub instructions: String,

/// The list of tools that the [assistant](/docs/api-reference/assistants) used for this run.
    #[serde(rename = "tools")]
    #[validate(
            length(max = 20),
        )]
    pub tools: Vec<models::AssistantObjectToolsInner>,

/// The list of [File](/docs/api-reference/files) IDs the [assistant](/docs/api-reference/assistants) used for this run.
    #[serde(rename = "file_ids")]
    pub file_ids: Vec<String>,

/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
    #[serde(rename = "metadata")]
    pub metadata: crate::types::Object,

    #[serde(rename = "usage")]
    pub usage: Nullable<models::RunCompletionUsage>,

/// The sampling temperature used for this run. If not set, defaults to 1.
    #[serde(rename = "temperature")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<Nullable<f64>>,

/// The maximum number of prompt tokens specified to have been used over the course of the run. 
    #[serde(rename = "max_prompt_tokens")]
    #[validate(
            range(min = 256),
        )]
    pub max_prompt_tokens: Nullable<u32>,

/// The maximum number of completion tokens specified to have been used over the course of the run. 
    #[serde(rename = "max_completion_tokens")]
    #[validate(
            range(min = 256),
        )]
    pub max_completion_tokens: Nullable<u32>,

    #[serde(rename = "truncation_strategy")]
    pub truncation_strategy: models::TruncationObject,

    #[serde(rename = "tool_choice")]
    pub tool_choice: models::AssistantsApiToolChoiceOption,

    #[serde(rename = "response_format")]
    pub response_format: models::AssistantsApiResponseFormatOption,

}


impl RunObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, created_at: i32, thread_id: String, assistant_id: String, status: String, required_action: Nullable<models::RunObjectRequiredAction>, last_error: Nullable<models::RunObjectLastError>, expires_at: Nullable<i32>, started_at: Nullable<i32>, cancelled_at: Nullable<i32>, failed_at: Nullable<i32>, completed_at: Nullable<i32>, incomplete_details: Nullable<models::RunObjectIncompleteDetails>, model: String, instructions: String, tools: Vec<models::AssistantObjectToolsInner>, file_ids: Vec<String>, metadata: crate::types::Object, usage: Nullable<models::RunCompletionUsage>, max_prompt_tokens: Nullable<u32>, max_completion_tokens: Nullable<u32>, truncation_strategy: models::TruncationObject, tool_choice: models::AssistantsApiToolChoiceOption, response_format: models::AssistantsApiResponseFormatOption, ) -> RunObject {
        RunObject {
            id,
            object,
            created_at,
            thread_id,
            assistant_id,
            status,
            required_action,
            last_error,
            expires_at,
            started_at,
            cancelled_at,
            failed_at,
            completed_at,
            incomplete_details,
            model,
            instructions,
            tools,
            file_ids,
            metadata,
            usage,
            temperature: None,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            response_format,
        }
    }
}

/// Converts the RunObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("thread_id".to_string()),
            Some(self.thread_id.to_string()),


            Some("assistant_id".to_string()),
            Some(self.assistant_id.to_string()),


            Some("status".to_string()),
            Some(self.status.to_string()),

            // Skipping required_action in query parameter serialization

            // Skipping last_error in query parameter serialization


            Some("expires_at".to_string()),
            Some(self.expires_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("started_at".to_string()),
            Some(self.started_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("cancelled_at".to_string()),
            Some(self.cancelled_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("failed_at".to_string()),
            Some(self.failed_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("completed_at".to_string()),
            Some(self.completed_at.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping incomplete_details in query parameter serialization


            Some("model".to_string()),
            Some(self.model.to_string()),


            Some("instructions".to_string()),
            Some(self.instructions.to_string()),

            // Skipping tools in query parameter serialization


            Some("file_ids".to_string()),
            Some(self.file_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping metadata in query parameter serialization

            // Skipping usage in query parameter serialization


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            Some("max_prompt_tokens".to_string()),
            Some(self.max_prompt_tokens.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("max_completion_tokens".to_string()),
            Some(self.max_completion_tokens.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping truncation_strategy in query parameter serialization

            // Skipping tool_choice in query parameter serialization

            // Skipping response_format in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub created_at: Vec<i32>,
            pub thread_id: Vec<String>,
            pub assistant_id: Vec<String>,
            pub status: Vec<String>,
            pub required_action: Vec<models::RunObjectRequiredAction>,
            pub last_error: Vec<models::RunObjectLastError>,
            pub expires_at: Vec<i32>,
            pub started_at: Vec<i32>,
            pub cancelled_at: Vec<i32>,
            pub failed_at: Vec<i32>,
            pub completed_at: Vec<i32>,
            pub incomplete_details: Vec<models::RunObjectIncompleteDetails>,
            pub model: Vec<String>,
            pub instructions: Vec<String>,
            pub tools: Vec<Vec<models::AssistantObjectToolsInner>>,
            pub file_ids: Vec<Vec<String>>,
            pub metadata: Vec<crate::types::Object>,
            pub usage: Vec<models::RunCompletionUsage>,
            pub temperature: Vec<f64>,
            pub max_prompt_tokens: Vec<u32>,
            pub max_completion_tokens: Vec<u32>,
            pub truncation_strategy: Vec<models::TruncationObject>,
            pub tool_choice: Vec<models::AssistantsApiToolChoiceOption>,
            pub response_format: Vec<models::AssistantsApiResponseFormatOption>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "thread_id" => intermediate_rep.thread_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "assistant_id" => intermediate_rep.assistant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "required_action" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "last_error" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "expires_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "started_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "cancelled_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "failed_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "completed_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "incomplete_details" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "instructions" => intermediate_rep.instructions.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in RunObject".to_string()),
                    "file_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in RunObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "usage" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "temperature" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "max_prompt_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "max_completion_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "truncation_strategy" => intermediate_rep.truncation_strategy.push(<models::TruncationObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tool_choice" => intermediate_rep.tool_choice.push(<models::AssistantsApiToolChoiceOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_format" => intermediate_rep.response_format.push(<models::AssistantsApiResponseFormatOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in RunObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in RunObject".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in RunObject".to_string())?,
            thread_id: intermediate_rep.thread_id.into_iter().next().ok_or_else(|| "thread_id missing in RunObject".to_string())?,
            assistant_id: intermediate_rep.assistant_id.into_iter().next().ok_or_else(|| "assistant_id missing in RunObject".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in RunObject".to_string())?,
            required_action: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            last_error: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            expires_at: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            started_at: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            cancelled_at: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            failed_at: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            completed_at: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            incomplete_details: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in RunObject".to_string())?,
            instructions: intermediate_rep.instructions.into_iter().next().ok_or_else(|| "instructions missing in RunObject".to_string())?,
            tools: intermediate_rep.tools.into_iter().next().ok_or_else(|| "tools missing in RunObject".to_string())?,
            file_ids: intermediate_rep.file_ids.into_iter().next().ok_or_else(|| "file_ids missing in RunObject".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next().ok_or_else(|| "metadata missing in RunObject".to_string())?,
            usage: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            temperature: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            max_prompt_tokens: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            max_completion_tokens: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            truncation_strategy: intermediate_rep.truncation_strategy.into_iter().next().ok_or_else(|| "truncation_strategy missing in RunObject".to_string())?,
            tool_choice: intermediate_rep.tool_choice.into_iter().next().ok_or_else(|| "tool_choice missing in RunObject".to_string())?,
            response_format: intermediate_rep.response_format.into_iter().next().ok_or_else(|| "response_format missing in RunObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Details on why the run is incomplete. Will be `null` if the run is not incomplete.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunObjectIncompleteDetails {
/// The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "reason")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,

}


impl RunObjectIncompleteDetails {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RunObjectIncompleteDetails {
        RunObjectIncompleteDetails {
            reason: None,
        }
    }
}

/// Converts the RunObjectIncompleteDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunObjectIncompleteDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.reason.as_ref().map(|reason| {
                [
                    "reason".to_string(),
                    reason.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunObjectIncompleteDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunObjectIncompleteDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub reason: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunObjectIncompleteDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunObjectIncompleteDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunObjectIncompleteDetails {
            reason: intermediate_rep.reason.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunObjectIncompleteDetails> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunObjectIncompleteDetails>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunObjectIncompleteDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunObjectIncompleteDetails - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunObjectIncompleteDetails> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunObjectIncompleteDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunObjectIncompleteDetails - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The last error associated with this run. Will be `null` if there are no errors.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunObjectLastError {
/// One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "code")]
    pub code: String,

/// A human-readable description of the error.
    #[serde(rename = "message")]
    pub message: String,

}


impl RunObjectLastError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(code: String, message: String, ) -> RunObjectLastError {
        RunObjectLastError {
            code,
            message,
        }
    }
}

/// Converts the RunObjectLastError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunObjectLastError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("code".to_string()),
            Some(self.code.to_string()),


            Some("message".to_string()),
            Some(self.message.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunObjectLastError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunObjectLastError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<String>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunObjectLastError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunObjectLastError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunObjectLastError {
            code: intermediate_rep.code.into_iter().next().ok_or_else(|| "code missing in RunObjectLastError".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in RunObjectLastError".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunObjectLastError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunObjectLastError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunObjectLastError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunObjectLastError - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunObjectLastError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunObjectLastError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunObjectLastError - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Details on the action required to continue the run. Will be `null` if no action is required.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunObjectRequiredAction {
/// For now, this is always `submit_tool_outputs`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "submit_tool_outputs")]
    pub submit_tool_outputs: models::RunObjectRequiredActionSubmitToolOutputs,

}


impl RunObjectRequiredAction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, submit_tool_outputs: models::RunObjectRequiredActionSubmitToolOutputs, ) -> RunObjectRequiredAction {
        RunObjectRequiredAction {
            r#type,
            submit_tool_outputs,
        }
    }
}

/// Converts the RunObjectRequiredAction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunObjectRequiredAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping submit_tool_outputs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunObjectRequiredAction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunObjectRequiredAction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub submit_tool_outputs: Vec<models::RunObjectRequiredActionSubmitToolOutputs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunObjectRequiredAction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "submit_tool_outputs" => intermediate_rep.submit_tool_outputs.push(<models::RunObjectRequiredActionSubmitToolOutputs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunObjectRequiredAction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunObjectRequiredAction {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunObjectRequiredAction".to_string())?,
            submit_tool_outputs: intermediate_rep.submit_tool_outputs.into_iter().next().ok_or_else(|| "submit_tool_outputs missing in RunObjectRequiredAction".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunObjectRequiredAction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunObjectRequiredAction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunObjectRequiredAction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunObjectRequiredAction - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunObjectRequiredAction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunObjectRequiredAction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunObjectRequiredAction - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Details on the tool outputs needed for this run to continue.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunObjectRequiredActionSubmitToolOutputs {
/// A list of the relevant tool calls.
    #[serde(rename = "tool_calls")]
    pub tool_calls: Vec<models::RunToolCallObject>,

}


impl RunObjectRequiredActionSubmitToolOutputs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(tool_calls: Vec<models::RunToolCallObject>, ) -> RunObjectRequiredActionSubmitToolOutputs {
        RunObjectRequiredActionSubmitToolOutputs {
            tool_calls,
        }
    }
}

/// Converts the RunObjectRequiredActionSubmitToolOutputs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunObjectRequiredActionSubmitToolOutputs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping tool_calls in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunObjectRequiredActionSubmitToolOutputs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunObjectRequiredActionSubmitToolOutputs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tool_calls: Vec<Vec<models::RunToolCallObject>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunObjectRequiredActionSubmitToolOutputs".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "tool_calls" => return std::result::Result::Err("Parsing a container in this style is not supported in RunObjectRequiredActionSubmitToolOutputs".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunObjectRequiredActionSubmitToolOutputs".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunObjectRequiredActionSubmitToolOutputs {
            tool_calls: intermediate_rep.tool_calls.into_iter().next().ok_or_else(|| "tool_calls missing in RunObjectRequiredActionSubmitToolOutputs".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunObjectRequiredActionSubmitToolOutputs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunObjectRequiredActionSubmitToolOutputs>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunObjectRequiredActionSubmitToolOutputs>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunObjectRequiredActionSubmitToolOutputs - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunObjectRequiredActionSubmitToolOutputs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunObjectRequiredActionSubmitToolOutputs as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunObjectRequiredActionSubmitToolOutputs - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepCompletionUsage {
/// Number of completion tokens used over the course of the run step.
    #[serde(rename = "completion_tokens")]
    pub completion_tokens: i32,

/// Number of prompt tokens used over the course of the run step.
    #[serde(rename = "prompt_tokens")]
    pub prompt_tokens: i32,

/// Total number of tokens used (prompt + completion).
    #[serde(rename = "total_tokens")]
    pub total_tokens: i32,

}


impl RunStepCompletionUsage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(completion_tokens: i32, prompt_tokens: i32, total_tokens: i32, ) -> RunStepCompletionUsage {
        RunStepCompletionUsage {
            completion_tokens,
            prompt_tokens,
            total_tokens,
        }
    }
}

/// Converts the RunStepCompletionUsage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepCompletionUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("completion_tokens".to_string()),
            Some(self.completion_tokens.to_string()),


            Some("prompt_tokens".to_string()),
            Some(self.prompt_tokens.to_string()),


            Some("total_tokens".to_string()),
            Some(self.total_tokens.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepCompletionUsage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepCompletionUsage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub completion_tokens: Vec<i32>,
            pub prompt_tokens: Vec<i32>,
            pub total_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepCompletionUsage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "completion_tokens" => intermediate_rep.completion_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prompt_tokens" => intermediate_rep.prompt_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total_tokens" => intermediate_rep.total_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepCompletionUsage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepCompletionUsage {
            completion_tokens: intermediate_rep.completion_tokens.into_iter().next().ok_or_else(|| "completion_tokens missing in RunStepCompletionUsage".to_string())?,
            prompt_tokens: intermediate_rep.prompt_tokens.into_iter().next().ok_or_else(|| "prompt_tokens missing in RunStepCompletionUsage".to_string())?,
            total_tokens: intermediate_rep.total_tokens.into_iter().next().ok_or_else(|| "total_tokens missing in RunStepCompletionUsage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepCompletionUsage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepCompletionUsage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepCompletionUsage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepCompletionUsage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepCompletionUsage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepCompletionUsage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepCompletionUsage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Represents a run step delta i.e. any changed fields on a run step during streaming. 



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaObject {
/// The identifier of the run step, which can be referenced in API endpoints.
    #[serde(rename = "id")]
    pub id: String,

/// The object type, which is always `thread.run.step.delta`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

    #[serde(rename = "delta")]
    pub delta: models::RunStepDeltaObjectDelta,

}


impl RunStepDeltaObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, delta: models::RunStepDeltaObjectDelta, ) -> RunStepDeltaObject {
        RunStepDeltaObject {
            id,
            object,
            delta,
        }
    }
}

/// Converts the RunStepDeltaObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping delta in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub delta: Vec<models::RunStepDeltaObjectDelta>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "delta" => intermediate_rep.delta.push(<models::RunStepDeltaObjectDelta as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in RunStepDeltaObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in RunStepDeltaObject".to_string())?,
            delta: intermediate_rep.delta.into_iter().next().ok_or_else(|| "delta missing in RunStepDeltaObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDeltaObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDeltaObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The delta containing the fields that have changed on the run step.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaObjectDelta {
    #[serde(rename = "step_details")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub step_details: Option<models::RunStepDeltaObjectDeltaStepDetails>,

}


impl RunStepDeltaObjectDelta {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RunStepDeltaObjectDelta {
        RunStepDeltaObjectDelta {
            step_details: None,
        }
    }
}

/// Converts the RunStepDeltaObjectDelta value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaObjectDelta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping step_details in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaObjectDelta value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaObjectDelta {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub step_details: Vec<models::RunStepDeltaObjectDeltaStepDetails>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaObjectDelta".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "step_details" => intermediate_rep.step_details.push(<models::RunStepDeltaObjectDeltaStepDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaObjectDelta".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaObjectDelta {
            step_details: intermediate_rep.step_details.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaObjectDelta> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaObjectDelta>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaObjectDelta>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDeltaObjectDelta - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaObjectDelta> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaObjectDelta as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDeltaObjectDelta - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The details of the run step.


/// One of:
/// - RunStepDeltaStepDetailsMessageCreationObject
/// - RunStepDeltaStepDetailsToolCallsObject
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RunStepDeltaObjectDeltaStepDetails(Box<serde_json::value::RawValue>);

impl validator::Validate for RunStepDeltaObjectDeltaStepDetails
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaObjectDeltaStepDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaObjectDeltaStepDetails {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for RunStepDeltaObjectDeltaStepDetails {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Details of the message creation by the run step.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsMessageCreationObject {
/// Always `message_creation`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "message_creation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message_creation: Option<models::RunStepDeltaStepDetailsMessageCreationObjectMessageCreation>,

}


impl RunStepDeltaStepDetailsMessageCreationObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, ) -> RunStepDeltaStepDetailsMessageCreationObject {
        RunStepDeltaStepDetailsMessageCreationObject {
            r#type,
            message_creation: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsMessageCreationObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsMessageCreationObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping message_creation in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsMessageCreationObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsMessageCreationObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub message_creation: Vec<models::RunStepDeltaStepDetailsMessageCreationObjectMessageCreation>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsMessageCreationObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message_creation" => intermediate_rep.message_creation.push(<models::RunStepDeltaStepDetailsMessageCreationObjectMessageCreation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsMessageCreationObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsMessageCreationObject {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunStepDeltaStepDetailsMessageCreationObject".to_string())?,
            message_creation: intermediate_rep.message_creation.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDeltaStepDetailsMessageCreationObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsMessageCreationObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDeltaStepDetailsMessageCreationObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
/// The ID of the message that was created by this run step.
    #[serde(rename = "message_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message_id: Option<String>,

}


impl RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
        RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
            message_id: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsMessageCreationObjectMessageCreation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.message_id.as_ref().map(|message_id| {
                [
                    "message_id".to_string(),
                    message_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsMessageCreationObjectMessageCreation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub message_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsMessageCreationObjectMessageCreation".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "message_id" => intermediate_rep.message_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsMessageCreationObjectMessageCreation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
            message_id: intermediate_rep.message_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObjectMessageCreation> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObjectMessageCreation>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObjectMessageCreation>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDeltaStepDetailsMessageCreationObjectMessageCreation - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObjectMessageCreation> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsMessageCreationObjectMessageCreation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDeltaStepDetailsMessageCreationObjectMessageCreation - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Details of the Code Interpreter tool call the run step was involved in.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsCodeObject {
/// The index of the tool call in the tool calls array.
    #[serde(rename = "index")]
    pub index: i32,

/// The ID of the tool call.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "code_interpreter")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_interpreter: Option<models::RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>,

}


impl RunStepDeltaStepDetailsToolCallsCodeObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r#type: String, ) -> RunStepDeltaStepDetailsToolCallsCodeObject {
        RunStepDeltaStepDetailsToolCallsCodeObject {
            index,
            id: None,
            r#type,
            code_interpreter: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsCodeObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsCodeObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping code_interpreter in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsCodeObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsCodeObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub id: Vec<String>,
            pub r#type: Vec<String>,
            pub code_interpreter: Vec<models::RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsCodeObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "code_interpreter" => intermediate_rep.code_interpreter.push(<models::RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsCodeObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsCodeObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in RunStepDeltaStepDetailsToolCallsCodeObject".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunStepDeltaStepDetailsToolCallsCodeObject".to_string())?,
            code_interpreter: intermediate_rep.code_interpreter.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDeltaStepDetailsToolCallsCodeObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsCodeObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDeltaStepDetailsToolCallsCodeObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The Code Interpreter tool call definition.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
/// The input to the Code Interpreter tool call.
    #[serde(rename = "input")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub input: Option<String>,

/// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
    #[serde(rename = "outputs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub outputs: Option<Vec<models::RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>>,

}


impl RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
        RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
            input: None,
            outputs: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.input.as_ref().map(|input| {
                [
                    "input".to_string(),
                    input.to_string(),
                ].join(",")
            }),

            // Skipping outputs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub input: Vec<String>,
            pub outputs: Vec<Vec<models::RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "input" => intermediate_rep.input.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "outputs" => return std::result::Result::Err("Parsing a container in this style is not supported in RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
            input: intermediate_rep.input.into_iter().next(),
            outputs: intermediate_rep.outputs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - RunStepDeltaStepDetailsToolCallsCodeOutputImageObject
/// - RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner(Box<serde_json::value::RawValue>);

impl validator::Validate for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
/// The index of the output in the outputs array.
    #[serde(rename = "index")]
    pub index: i32,

/// Always `image`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<models::RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage>,

}


impl RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r#type: String, ) -> RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
        RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
            index,
            r#type,
            image: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping image in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub r#type: Vec<String>,
            pub image: Vec<models::RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsCodeOutputImageObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image" => intermediate_rep.image.push(<models::RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsCodeOutputImageObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in RunStepDeltaStepDetailsToolCallsCodeOutputImageObject".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunStepDeltaStepDetailsToolCallsCodeOutputImageObject".to_string())?,
            image: intermediate_rep.image.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDeltaStepDetailsToolCallsCodeOutputImageObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsCodeOutputImageObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDeltaStepDetailsToolCallsCodeOutputImageObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
/// The [file](/docs/api-reference/files) ID of the image.
    #[serde(rename = "file_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_id: Option<String>,

}


impl RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
        RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
            file_id: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_id.as_ref().map(|file_id| {
                [
                    "file_id".to_string(),
                    file_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
            file_id: intermediate_rep.file_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Text output from the Code Interpreter tool call as part of a run step.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
/// The index of the output in the outputs array.
    #[serde(rename = "index")]
    pub index: i32,

/// Always `logs`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

/// The text output from the Code Interpreter tool call.
    #[serde(rename = "logs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logs: Option<String>,

}


impl RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r#type: String, ) -> RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
        RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
            index,
            r#type,
            logs: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("type".to_string()),
            Some(self.r#type.to_string()),


            self.logs.as_ref().map(|logs| {
                [
                    "logs".to_string(),
                    logs.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub r#type: Vec<String>,
            pub logs: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "logs" => intermediate_rep.logs.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject".to_string())?,
            logs: intermediate_rep.logs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsFunctionObject {
/// The index of the tool call in the tool calls array.
    #[serde(rename = "index")]
    pub index: i32,

/// The ID of the tool call object.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// The type of tool call. This is always going to be `function` for this type of tool call.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "function")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub function: Option<models::RunStepDeltaStepDetailsToolCallsFunctionObjectFunction>,

}


impl RunStepDeltaStepDetailsToolCallsFunctionObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r#type: String, ) -> RunStepDeltaStepDetailsToolCallsFunctionObject {
        RunStepDeltaStepDetailsToolCallsFunctionObject {
            index,
            id: None,
            r#type,
            function: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsFunctionObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsFunctionObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsFunctionObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsFunctionObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub id: Vec<String>,
            pub r#type: Vec<String>,
            pub function: Vec<models::RunStepDeltaStepDetailsToolCallsFunctionObjectFunction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsFunctionObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::RunStepDeltaStepDetailsToolCallsFunctionObjectFunction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsFunctionObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsFunctionObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in RunStepDeltaStepDetailsToolCallsFunctionObject".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunStepDeltaStepDetailsToolCallsFunctionObject".to_string())?,
            function: intermediate_rep.function.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDeltaStepDetailsToolCallsFunctionObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsFunctionObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDeltaStepDetailsToolCallsFunctionObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The definition of the function that was called.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
/// The name of the function.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// The arguments passed to the function.
    #[serde(rename = "arguments")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub arguments: Option<String>,

/// The output of the function. This will be `null` if the outputs have not been [submitted](/docs/api-reference/runs/submitToolOutputs) yet.
    #[serde(rename = "output")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output: Option<Nullable<String>>,

}


impl RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
        RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
            name: None,
            arguments: None,
            output: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsFunctionObjectFunction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.arguments.as_ref().map(|arguments| {
                [
                    "arguments".to_string(),
                    arguments.to_string(),
                ].join(",")
            }),


            self.output.as_ref().map(|output| {
                [
                    "output".to_string(),
                    output.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsFunctionObjectFunction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub arguments: Vec<String>,
            pub output: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsFunctionObjectFunction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "output" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepDeltaStepDetailsToolCallsFunctionObjectFunction".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsFunctionObjectFunction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
            name: intermediate_rep.name.into_iter().next(),
            arguments: intermediate_rep.arguments.into_iter().next(),
            output: std::result::Result::Err("Nullable types not supported in RunStepDeltaStepDetailsToolCallsFunctionObjectFunction".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObjectFunction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObjectFunction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObjectFunction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDeltaStepDetailsToolCallsFunctionObjectFunction - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObjectFunction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsFunctionObjectFunction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDeltaStepDetailsToolCallsFunctionObjectFunction - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Details of the tool call.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsObject {
/// Always `tool_calls`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

/// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `retrieval`, or `function`. 
    #[serde(rename = "tool_calls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_calls: Option<Vec<models::RunStepDeltaStepDetailsToolCallsObjectToolCallsInner>>,

}


impl RunStepDeltaStepDetailsToolCallsObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, ) -> RunStepDeltaStepDetailsToolCallsObject {
        RunStepDeltaStepDetailsToolCallsObject {
            r#type,
            tool_calls: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping tool_calls in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub tool_calls: Vec<Vec<models::RunStepDeltaStepDetailsToolCallsObjectToolCallsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tool_calls" => return std::result::Result::Err("Parsing a container in this style is not supported in RunStepDeltaStepDetailsToolCallsObject".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsObject {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunStepDeltaStepDetailsToolCallsObject".to_string())?,
            tool_calls: intermediate_rep.tool_calls.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDeltaStepDetailsToolCallsObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDeltaStepDetailsToolCallsObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - RunStepDeltaStepDetailsToolCallsCodeObject
/// - RunStepDeltaStepDetailsToolCallsFunctionObject
/// - RunStepDeltaStepDetailsToolCallsRetrievalObject
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RunStepDeltaStepDetailsToolCallsObjectToolCallsInner(Box<serde_json::value::RawValue>);

impl validator::Validate for RunStepDeltaStepDetailsToolCallsObjectToolCallsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsObjectToolCallsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsObjectToolCallsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for RunStepDeltaStepDetailsToolCallsObjectToolCallsInner {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsRetrievalObject {
/// The index of the tool call in the tool calls array.
    #[serde(rename = "index")]
    pub index: i32,

/// The ID of the tool call object.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

/// The type of tool call. This is always going to be `retrieval` for this type of tool call.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

/// For now, this is always going to be an empty object.
    #[serde(rename = "retrieval")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub retrieval: Option<crate::types::Object>,

}


impl RunStepDeltaStepDetailsToolCallsRetrievalObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r#type: String, ) -> RunStepDeltaStepDetailsToolCallsRetrievalObject {
        RunStepDeltaStepDetailsToolCallsRetrievalObject {
            index,
            id: None,
            r#type,
            retrieval: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsRetrievalObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsRetrievalObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping retrieval in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsRetrievalObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsRetrievalObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub id: Vec<String>,
            pub r#type: Vec<String>,
            pub retrieval: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsRetrievalObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "retrieval" => intermediate_rep.retrieval.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsRetrievalObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsRetrievalObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in RunStepDeltaStepDetailsToolCallsRetrievalObject".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunStepDeltaStepDetailsToolCallsRetrievalObject".to_string())?,
            retrieval: intermediate_rep.retrieval.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsRetrievalObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsRetrievalObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsRetrievalObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDeltaStepDetailsToolCallsRetrievalObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsRetrievalObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsRetrievalObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDeltaStepDetailsToolCallsRetrievalObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Details of the message creation by the run step.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsMessageCreationObject {
/// Always `message_creation`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "message_creation")]
    pub message_creation: models::RunStepDetailsMessageCreationObjectMessageCreation,

}


impl RunStepDetailsMessageCreationObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, message_creation: models::RunStepDetailsMessageCreationObjectMessageCreation, ) -> RunStepDetailsMessageCreationObject {
        RunStepDetailsMessageCreationObject {
            r#type,
            message_creation,
        }
    }
}

/// Converts the RunStepDetailsMessageCreationObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsMessageCreationObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping message_creation in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsMessageCreationObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsMessageCreationObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub message_creation: Vec<models::RunStepDetailsMessageCreationObjectMessageCreation>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsMessageCreationObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message_creation" => intermediate_rep.message_creation.push(<models::RunStepDetailsMessageCreationObjectMessageCreation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsMessageCreationObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsMessageCreationObject {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunStepDetailsMessageCreationObject".to_string())?,
            message_creation: intermediate_rep.message_creation.into_iter().next().ok_or_else(|| "message_creation missing in RunStepDetailsMessageCreationObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsMessageCreationObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsMessageCreationObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsMessageCreationObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDetailsMessageCreationObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsMessageCreationObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsMessageCreationObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDetailsMessageCreationObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsMessageCreationObjectMessageCreation {
/// The ID of the message that was created by this run step.
    #[serde(rename = "message_id")]
    pub message_id: String,

}


impl RunStepDetailsMessageCreationObjectMessageCreation {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(message_id: String, ) -> RunStepDetailsMessageCreationObjectMessageCreation {
        RunStepDetailsMessageCreationObjectMessageCreation {
            message_id,
        }
    }
}

/// Converts the RunStepDetailsMessageCreationObjectMessageCreation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsMessageCreationObjectMessageCreation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("message_id".to_string()),
            Some(self.message_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsMessageCreationObjectMessageCreation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsMessageCreationObjectMessageCreation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub message_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsMessageCreationObjectMessageCreation".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "message_id" => intermediate_rep.message_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsMessageCreationObjectMessageCreation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsMessageCreationObjectMessageCreation {
            message_id: intermediate_rep.message_id.into_iter().next().ok_or_else(|| "message_id missing in RunStepDetailsMessageCreationObjectMessageCreation".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsMessageCreationObjectMessageCreation> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsMessageCreationObjectMessageCreation>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsMessageCreationObjectMessageCreation>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDetailsMessageCreationObjectMessageCreation - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsMessageCreationObjectMessageCreation> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsMessageCreationObjectMessageCreation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDetailsMessageCreationObjectMessageCreation - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Details of the Code Interpreter tool call the run step was involved in.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsCodeObject {
/// The ID of the tool call.
    #[serde(rename = "id")]
    pub id: String,

/// The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "code_interpreter")]
    pub code_interpreter: models::RunStepDetailsToolCallsCodeObjectCodeInterpreter,

}


impl RunStepDetailsToolCallsCodeObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, r#type: String, code_interpreter: models::RunStepDetailsToolCallsCodeObjectCodeInterpreter, ) -> RunStepDetailsToolCallsCodeObject {
        RunStepDetailsToolCallsCodeObject {
            id,
            r#type,
            code_interpreter,
        }
    }
}

/// Converts the RunStepDetailsToolCallsCodeObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsCodeObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping code_interpreter in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsCodeObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsCodeObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r#type: Vec<String>,
            pub code_interpreter: Vec<models::RunStepDetailsToolCallsCodeObjectCodeInterpreter>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsCodeObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "code_interpreter" => intermediate_rep.code_interpreter.push(<models::RunStepDetailsToolCallsCodeObjectCodeInterpreter as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsCodeObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsCodeObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in RunStepDetailsToolCallsCodeObject".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunStepDetailsToolCallsCodeObject".to_string())?,
            code_interpreter: intermediate_rep.code_interpreter.into_iter().next().ok_or_else(|| "code_interpreter missing in RunStepDetailsToolCallsCodeObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsCodeObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsCodeObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsCodeObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDetailsToolCallsCodeObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsCodeObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsCodeObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDetailsToolCallsCodeObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The Code Interpreter tool call definition.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsCodeObjectCodeInterpreter {
/// The input to the Code Interpreter tool call.
    #[serde(rename = "input")]
    pub input: String,

/// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
    #[serde(rename = "outputs")]
    pub outputs: Vec<models::RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>,

}


impl RunStepDetailsToolCallsCodeObjectCodeInterpreter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(input: String, outputs: Vec<models::RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>, ) -> RunStepDetailsToolCallsCodeObjectCodeInterpreter {
        RunStepDetailsToolCallsCodeObjectCodeInterpreter {
            input,
            outputs,
        }
    }
}

/// Converts the RunStepDetailsToolCallsCodeObjectCodeInterpreter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsCodeObjectCodeInterpreter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("input".to_string()),
            Some(self.input.to_string()),

            // Skipping outputs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsCodeObjectCodeInterpreter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsCodeObjectCodeInterpreter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub input: Vec<String>,
            pub outputs: Vec<Vec<models::RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsCodeObjectCodeInterpreter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "input" => intermediate_rep.input.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "outputs" => return std::result::Result::Err("Parsing a container in this style is not supported in RunStepDetailsToolCallsCodeObjectCodeInterpreter".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsCodeObjectCodeInterpreter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsCodeObjectCodeInterpreter {
            input: intermediate_rep.input.into_iter().next().ok_or_else(|| "input missing in RunStepDetailsToolCallsCodeObjectCodeInterpreter".to_string())?,
            outputs: intermediate_rep.outputs.into_iter().next().ok_or_else(|| "outputs missing in RunStepDetailsToolCallsCodeObjectCodeInterpreter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsCodeObjectCodeInterpreter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsCodeObjectCodeInterpreter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsCodeObjectCodeInterpreter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDetailsToolCallsCodeObjectCodeInterpreter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsCodeObjectCodeInterpreter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsCodeObjectCodeInterpreter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDetailsToolCallsCodeObjectCodeInterpreter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - RunStepDetailsToolCallsCodeOutputImageObject
/// - RunStepDetailsToolCallsCodeOutputLogsObject
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner(Box<serde_json::value::RawValue>);

impl validator::Validate for RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsCodeOutputImageObject {
/// Always `image`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "image")]
    pub image: models::RunStepDetailsToolCallsCodeOutputImageObjectImage,

}


impl RunStepDetailsToolCallsCodeOutputImageObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, image: models::RunStepDetailsToolCallsCodeOutputImageObjectImage, ) -> RunStepDetailsToolCallsCodeOutputImageObject {
        RunStepDetailsToolCallsCodeOutputImageObject {
            r#type,
            image,
        }
    }
}

/// Converts the RunStepDetailsToolCallsCodeOutputImageObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsCodeOutputImageObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping image in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsCodeOutputImageObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsCodeOutputImageObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub image: Vec<models::RunStepDetailsToolCallsCodeOutputImageObjectImage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsCodeOutputImageObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image" => intermediate_rep.image.push(<models::RunStepDetailsToolCallsCodeOutputImageObjectImage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsCodeOutputImageObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsCodeOutputImageObject {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunStepDetailsToolCallsCodeOutputImageObject".to_string())?,
            image: intermediate_rep.image.into_iter().next().ok_or_else(|| "image missing in RunStepDetailsToolCallsCodeOutputImageObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDetailsToolCallsCodeOutputImageObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsCodeOutputImageObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDetailsToolCallsCodeOutputImageObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsCodeOutputImageObjectImage {
/// The [file](/docs/api-reference/files) ID of the image.
    #[serde(rename = "file_id")]
    pub file_id: String,

}


impl RunStepDetailsToolCallsCodeOutputImageObjectImage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(file_id: String, ) -> RunStepDetailsToolCallsCodeOutputImageObjectImage {
        RunStepDetailsToolCallsCodeOutputImageObjectImage {
            file_id,
        }
    }
}

/// Converts the RunStepDetailsToolCallsCodeOutputImageObjectImage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsCodeOutputImageObjectImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("file_id".to_string()),
            Some(self.file_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsCodeOutputImageObjectImage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsCodeOutputImageObjectImage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsCodeOutputImageObjectImage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsCodeOutputImageObjectImage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsCodeOutputImageObjectImage {
            file_id: intermediate_rep.file_id.into_iter().next().ok_or_else(|| "file_id missing in RunStepDetailsToolCallsCodeOutputImageObjectImage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObjectImage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObjectImage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObjectImage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDetailsToolCallsCodeOutputImageObjectImage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObjectImage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsCodeOutputImageObjectImage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDetailsToolCallsCodeOutputImageObjectImage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Text output from the Code Interpreter tool call as part of a run step.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsCodeOutputLogsObject {
/// Always `logs`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

/// The text output from the Code Interpreter tool call.
    #[serde(rename = "logs")]
    pub logs: String,

}


impl RunStepDetailsToolCallsCodeOutputLogsObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, logs: String, ) -> RunStepDetailsToolCallsCodeOutputLogsObject {
        RunStepDetailsToolCallsCodeOutputLogsObject {
            r#type,
            logs,
        }
    }
}

/// Converts the RunStepDetailsToolCallsCodeOutputLogsObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsCodeOutputLogsObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),


            Some("logs".to_string()),
            Some(self.logs.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsCodeOutputLogsObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsCodeOutputLogsObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub logs: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsCodeOutputLogsObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "logs" => intermediate_rep.logs.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsCodeOutputLogsObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsCodeOutputLogsObject {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunStepDetailsToolCallsCodeOutputLogsObject".to_string())?,
            logs: intermediate_rep.logs.into_iter().next().ok_or_else(|| "logs missing in RunStepDetailsToolCallsCodeOutputLogsObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputLogsObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputLogsObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputLogsObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDetailsToolCallsCodeOutputLogsObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputLogsObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsCodeOutputLogsObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDetailsToolCallsCodeOutputLogsObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsFunctionObject {
/// The ID of the tool call object.
    #[serde(rename = "id")]
    pub id: String,

/// The type of tool call. This is always going to be `function` for this type of tool call.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "function")]
    pub function: models::RunStepDetailsToolCallsFunctionObjectFunction,

}


impl RunStepDetailsToolCallsFunctionObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, r#type: String, function: models::RunStepDetailsToolCallsFunctionObjectFunction, ) -> RunStepDetailsToolCallsFunctionObject {
        RunStepDetailsToolCallsFunctionObject {
            id,
            r#type,
            function,
        }
    }
}

/// Converts the RunStepDetailsToolCallsFunctionObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsFunctionObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsFunctionObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsFunctionObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r#type: Vec<String>,
            pub function: Vec<models::RunStepDetailsToolCallsFunctionObjectFunction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsFunctionObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::RunStepDetailsToolCallsFunctionObjectFunction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsFunctionObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsFunctionObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in RunStepDetailsToolCallsFunctionObject".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunStepDetailsToolCallsFunctionObject".to_string())?,
            function: intermediate_rep.function.into_iter().next().ok_or_else(|| "function missing in RunStepDetailsToolCallsFunctionObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDetailsToolCallsFunctionObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsFunctionObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDetailsToolCallsFunctionObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The definition of the function that was called.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsFunctionObjectFunction {
/// The name of the function.
    #[serde(rename = "name")]
    pub name: String,

/// The arguments passed to the function.
    #[serde(rename = "arguments")]
    pub arguments: String,

/// The output of the function. This will be `null` if the outputs have not been [submitted](/docs/api-reference/runs/submitToolOutputs) yet.
    #[serde(rename = "output")]
    pub output: Nullable<String>,

}


impl RunStepDetailsToolCallsFunctionObjectFunction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, arguments: String, output: Nullable<String>, ) -> RunStepDetailsToolCallsFunctionObjectFunction {
        RunStepDetailsToolCallsFunctionObjectFunction {
            name,
            arguments,
            output,
        }
    }
}

/// Converts the RunStepDetailsToolCallsFunctionObjectFunction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsFunctionObjectFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("arguments".to_string()),
            Some(self.arguments.to_string()),


            Some("output".to_string()),
            Some(self.output.as_ref().map_or("null".to_string(), |x| x.to_string())),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsFunctionObjectFunction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsFunctionObjectFunction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub arguments: Vec<String>,
            pub output: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsFunctionObjectFunction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "output" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepDetailsToolCallsFunctionObjectFunction".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsFunctionObjectFunction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsFunctionObjectFunction {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in RunStepDetailsToolCallsFunctionObjectFunction".to_string())?,
            arguments: intermediate_rep.arguments.into_iter().next().ok_or_else(|| "arguments missing in RunStepDetailsToolCallsFunctionObjectFunction".to_string())?,
            output: std::result::Result::Err("Nullable types not supported in RunStepDetailsToolCallsFunctionObjectFunction".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObjectFunction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObjectFunction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObjectFunction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDetailsToolCallsFunctionObjectFunction - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObjectFunction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsFunctionObjectFunction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDetailsToolCallsFunctionObjectFunction - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Details of the tool call.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsObject {
/// Always `tool_calls`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

/// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `retrieval`, or `function`. 
    #[serde(rename = "tool_calls")]
    pub tool_calls: Vec<models::RunStepDetailsToolCallsObjectToolCallsInner>,

}


impl RunStepDetailsToolCallsObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r#type: String, tool_calls: Vec<models::RunStepDetailsToolCallsObjectToolCallsInner>, ) -> RunStepDetailsToolCallsObject {
        RunStepDetailsToolCallsObject {
            r#type,
            tool_calls,
        }
    }
}

/// Converts the RunStepDetailsToolCallsObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping tool_calls in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub tool_calls: Vec<Vec<models::RunStepDetailsToolCallsObjectToolCallsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tool_calls" => return std::result::Result::Err("Parsing a container in this style is not supported in RunStepDetailsToolCallsObject".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsObject {
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunStepDetailsToolCallsObject".to_string())?,
            tool_calls: intermediate_rep.tool_calls.into_iter().next().ok_or_else(|| "tool_calls missing in RunStepDetailsToolCallsObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDetailsToolCallsObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDetailsToolCallsObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - RunStepDetailsToolCallsCodeObject
/// - RunStepDetailsToolCallsFunctionObject
/// - RunStepDetailsToolCallsRetrievalObject
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RunStepDetailsToolCallsObjectToolCallsInner(Box<serde_json::value::RawValue>);

impl validator::Validate for RunStepDetailsToolCallsObjectToolCallsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsObjectToolCallsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsObjectToolCallsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for RunStepDetailsToolCallsObjectToolCallsInner {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}








#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsRetrievalObject {
/// The ID of the tool call object.
    #[serde(rename = "id")]
    pub id: String,

/// The type of tool call. This is always going to be `retrieval` for this type of tool call.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

/// For now, this is always going to be an empty object.
    #[serde(rename = "retrieval")]
    pub retrieval: crate::types::Object,

}


impl RunStepDetailsToolCallsRetrievalObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, r#type: String, retrieval: crate::types::Object, ) -> RunStepDetailsToolCallsRetrievalObject {
        RunStepDetailsToolCallsRetrievalObject {
            id,
            r#type,
            retrieval,
        }
    }
}

/// Converts the RunStepDetailsToolCallsRetrievalObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsRetrievalObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping retrieval in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsRetrievalObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsRetrievalObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r#type: Vec<String>,
            pub retrieval: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsRetrievalObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "retrieval" => intermediate_rep.retrieval.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsRetrievalObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsRetrievalObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in RunStepDetailsToolCallsRetrievalObject".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunStepDetailsToolCallsRetrievalObject".to_string())?,
            retrieval: intermediate_rep.retrieval.into_iter().next().ok_or_else(|| "retrieval missing in RunStepDetailsToolCallsRetrievalObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsRetrievalObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsRetrievalObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsRetrievalObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepDetailsToolCallsRetrievalObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsRetrievalObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsRetrievalObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepDetailsToolCallsRetrievalObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Represents a step in execution of a run. 



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepObject {
/// The identifier of the run step, which can be referenced in API endpoints.
    #[serde(rename = "id")]
    pub id: String,

/// The object type, which is always `thread.run.step`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

/// The Unix timestamp (in seconds) for when the run step was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

/// The ID of the [assistant](/docs/api-reference/assistants) associated with the run step.
    #[serde(rename = "assistant_id")]
    pub assistant_id: String,

/// The ID of the [thread](/docs/api-reference/threads) that was run.
    #[serde(rename = "thread_id")]
    pub thread_id: String,

/// The ID of the [run](/docs/api-reference/runs) that this run step is a part of.
    #[serde(rename = "run_id")]
    pub run_id: String,

/// The type of run step, which can be either `message_creation` or `tool_calls`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

/// The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
    pub status: String,

    #[serde(rename = "step_details")]
    pub step_details: models::RunStepObjectStepDetails,

    #[serde(rename = "last_error")]
    pub last_error: Nullable<models::RunStepObjectLastError>,

/// The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
    #[serde(rename = "expired_at")]
    pub expired_at: Nullable<i32>,

/// The Unix timestamp (in seconds) for when the run step was cancelled.
    #[serde(rename = "cancelled_at")]
    pub cancelled_at: Nullable<i32>,

/// The Unix timestamp (in seconds) for when the run step failed.
    #[serde(rename = "failed_at")]
    pub failed_at: Nullable<i32>,

/// The Unix timestamp (in seconds) for when the run step completed.
    #[serde(rename = "completed_at")]
    pub completed_at: Nullable<i32>,

/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
    #[serde(rename = "metadata")]
    pub metadata: crate::types::Object,

    #[serde(rename = "usage")]
    pub usage: Nullable<models::RunStepCompletionUsage>,

}


impl RunStepObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, created_at: i32, assistant_id: String, thread_id: String, run_id: String, r#type: String, status: String, step_details: models::RunStepObjectStepDetails, last_error: Nullable<models::RunStepObjectLastError>, expired_at: Nullable<i32>, cancelled_at: Nullable<i32>, failed_at: Nullable<i32>, completed_at: Nullable<i32>, metadata: crate::types::Object, usage: Nullable<models::RunStepCompletionUsage>, ) -> RunStepObject {
        RunStepObject {
            id,
            object,
            created_at,
            assistant_id,
            thread_id,
            run_id,
            r#type,
            status,
            step_details,
            last_error,
            expired_at,
            cancelled_at,
            failed_at,
            completed_at,
            metadata,
            usage,
        }
    }
}

/// Converts the RunStepObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("assistant_id".to_string()),
            Some(self.assistant_id.to_string()),


            Some("thread_id".to_string()),
            Some(self.thread_id.to_string()),


            Some("run_id".to_string()),
            Some(self.run_id.to_string()),


            Some("type".to_string()),
            Some(self.r#type.to_string()),


            Some("status".to_string()),
            Some(self.status.to_string()),

            // Skipping step_details in query parameter serialization

            // Skipping last_error in query parameter serialization


            Some("expired_at".to_string()),
            Some(self.expired_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("cancelled_at".to_string()),
            Some(self.cancelled_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("failed_at".to_string()),
            Some(self.failed_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("completed_at".to_string()),
            Some(self.completed_at.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping metadata in query parameter serialization

            // Skipping usage in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub created_at: Vec<i32>,
            pub assistant_id: Vec<String>,
            pub thread_id: Vec<String>,
            pub run_id: Vec<String>,
            pub r#type: Vec<String>,
            pub status: Vec<String>,
            pub step_details: Vec<models::RunStepObjectStepDetails>,
            pub last_error: Vec<models::RunStepObjectLastError>,
            pub expired_at: Vec<i32>,
            pub cancelled_at: Vec<i32>,
            pub failed_at: Vec<i32>,
            pub completed_at: Vec<i32>,
            pub metadata: Vec<crate::types::Object>,
            pub usage: Vec<models::RunStepCompletionUsage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "assistant_id" => intermediate_rep.assistant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "thread_id" => intermediate_rep.thread_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "run_id" => intermediate_rep.run_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "step_details" => intermediate_rep.step_details.push(<models::RunStepObjectStepDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "last_error" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepObject".to_string()),
                    "expired_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepObject".to_string()),
                    "cancelled_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepObject".to_string()),
                    "failed_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepObject".to_string()),
                    "completed_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "usage" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepObject".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in RunStepObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in RunStepObject".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in RunStepObject".to_string())?,
            assistant_id: intermediate_rep.assistant_id.into_iter().next().ok_or_else(|| "assistant_id missing in RunStepObject".to_string())?,
            thread_id: intermediate_rep.thread_id.into_iter().next().ok_or_else(|| "thread_id missing in RunStepObject".to_string())?,
            run_id: intermediate_rep.run_id.into_iter().next().ok_or_else(|| "run_id missing in RunStepObject".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunStepObject".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in RunStepObject".to_string())?,
            step_details: intermediate_rep.step_details.into_iter().next().ok_or_else(|| "step_details missing in RunStepObject".to_string())?,
            last_error: std::result::Result::Err("Nullable types not supported in RunStepObject".to_string())?,
            expired_at: std::result::Result::Err("Nullable types not supported in RunStepObject".to_string())?,
            cancelled_at: std::result::Result::Err("Nullable types not supported in RunStepObject".to_string())?,
            failed_at: std::result::Result::Err("Nullable types not supported in RunStepObject".to_string())?,
            completed_at: std::result::Result::Err("Nullable types not supported in RunStepObject".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next().ok_or_else(|| "metadata missing in RunStepObject".to_string())?,
            usage: std::result::Result::Err("Nullable types not supported in RunStepObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The last error associated with this run step. Will be `null` if there are no errors.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepObjectLastError {
/// One of `server_error` or `rate_limit_exceeded`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "code")]
    pub code: String,

/// A human-readable description of the error.
    #[serde(rename = "message")]
    pub message: String,

}


impl RunStepObjectLastError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(code: String, message: String, ) -> RunStepObjectLastError {
        RunStepObjectLastError {
            code,
            message,
        }
    }
}

/// Converts the RunStepObjectLastError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepObjectLastError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("code".to_string()),
            Some(self.code.to_string()),


            Some("message".to_string()),
            Some(self.message.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepObjectLastError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepObjectLastError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<String>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepObjectLastError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepObjectLastError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepObjectLastError {
            code: intermediate_rep.code.into_iter().next().ok_or_else(|| "code missing in RunStepObjectLastError".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in RunStepObjectLastError".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepObjectLastError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepObjectLastError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepObjectLastError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepObjectLastError - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepObjectLastError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepObjectLastError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepObjectLastError - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The details of the run step.


/// One of:
/// - RunStepDetailsMessageCreationObject
/// - RunStepDetailsToolCallsObject
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RunStepObjectStepDetails(Box<serde_json::value::RawValue>);

impl validator::Validate for RunStepObjectStepDetails
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepObjectStepDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepObjectStepDetails {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for RunStepObjectStepDetails {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}







/// One of:
/// - RunStepStreamEventOneOf
/// - RunStepStreamEventOneOf1
/// - RunStepStreamEventOneOf2
/// - RunStepStreamEventOneOf3
/// - RunStepStreamEventOneOf4
/// - RunStepStreamEventOneOf5
/// - RunStepStreamEventOneOf6
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RunStepStreamEvent(Box<serde_json::value::RawValue>);

impl validator::Validate for RunStepStreamEvent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEvent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for RunStepStreamEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Occurs when a [run step](/docs/api-reference/runs/step-object) is created.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepStreamEventOneOf {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunStepObject,

}


impl RunStepStreamEventOneOf {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunStepObject, ) -> RunStepStreamEventOneOf {
        RunStepStreamEventOneOf {
            event,
            data,
        }
    }
}

/// Converts the RunStepStreamEventOneOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepStreamEventOneOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEventOneOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEventOneOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunStepObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepStreamEventOneOf".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunStepObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepStreamEventOneOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepStreamEventOneOf {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStepStreamEventOneOf".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStepStreamEventOneOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepStreamEventOneOf> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepStreamEventOneOf>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepStreamEventOneOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepStreamEventOneOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepStreamEventOneOf> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepStreamEventOneOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepStreamEventOneOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [run step](/docs/api-reference/runs/step-object) moves to an `in_progress` state.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepStreamEventOneOf1 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunStepObject,

}


impl RunStepStreamEventOneOf1 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunStepObject, ) -> RunStepStreamEventOneOf1 {
        RunStepStreamEventOneOf1 {
            event,
            data,
        }
    }
}

/// Converts the RunStepStreamEventOneOf1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepStreamEventOneOf1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEventOneOf1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEventOneOf1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunStepObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepStreamEventOneOf1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunStepObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepStreamEventOneOf1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepStreamEventOneOf1 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStepStreamEventOneOf1".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStepStreamEventOneOf1".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepStreamEventOneOf1> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepStreamEventOneOf1>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepStreamEventOneOf1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepStreamEventOneOf1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepStreamEventOneOf1> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepStreamEventOneOf1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepStreamEventOneOf1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when parts of a [run step](/docs/api-reference/runs/step-object) are being streamed.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepStreamEventOneOf2 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunStepDeltaObject,

}


impl RunStepStreamEventOneOf2 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunStepDeltaObject, ) -> RunStepStreamEventOneOf2 {
        RunStepStreamEventOneOf2 {
            event,
            data,
        }
    }
}

/// Converts the RunStepStreamEventOneOf2 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepStreamEventOneOf2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEventOneOf2 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEventOneOf2 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunStepDeltaObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepStreamEventOneOf2".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunStepDeltaObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepStreamEventOneOf2".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepStreamEventOneOf2 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStepStreamEventOneOf2".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStepStreamEventOneOf2".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepStreamEventOneOf2> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepStreamEventOneOf2>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepStreamEventOneOf2>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepStreamEventOneOf2 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepStreamEventOneOf2> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepStreamEventOneOf2 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepStreamEventOneOf2 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [run step](/docs/api-reference/runs/step-object) is completed.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepStreamEventOneOf3 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunStepObject,

}


impl RunStepStreamEventOneOf3 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunStepObject, ) -> RunStepStreamEventOneOf3 {
        RunStepStreamEventOneOf3 {
            event,
            data,
        }
    }
}

/// Converts the RunStepStreamEventOneOf3 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepStreamEventOneOf3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEventOneOf3 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEventOneOf3 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunStepObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepStreamEventOneOf3".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunStepObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepStreamEventOneOf3".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepStreamEventOneOf3 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStepStreamEventOneOf3".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStepStreamEventOneOf3".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepStreamEventOneOf3> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepStreamEventOneOf3>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepStreamEventOneOf3>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepStreamEventOneOf3 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepStreamEventOneOf3> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepStreamEventOneOf3 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepStreamEventOneOf3 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [run step](/docs/api-reference/runs/step-object) fails.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepStreamEventOneOf4 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunStepObject,

}


impl RunStepStreamEventOneOf4 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunStepObject, ) -> RunStepStreamEventOneOf4 {
        RunStepStreamEventOneOf4 {
            event,
            data,
        }
    }
}

/// Converts the RunStepStreamEventOneOf4 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepStreamEventOneOf4 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEventOneOf4 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEventOneOf4 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunStepObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepStreamEventOneOf4".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunStepObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepStreamEventOneOf4".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepStreamEventOneOf4 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStepStreamEventOneOf4".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStepStreamEventOneOf4".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepStreamEventOneOf4> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepStreamEventOneOf4>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepStreamEventOneOf4>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepStreamEventOneOf4 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepStreamEventOneOf4> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepStreamEventOneOf4 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepStreamEventOneOf4 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [run step](/docs/api-reference/runs/step-object) is cancelled.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepStreamEventOneOf5 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunStepObject,

}


impl RunStepStreamEventOneOf5 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunStepObject, ) -> RunStepStreamEventOneOf5 {
        RunStepStreamEventOneOf5 {
            event,
            data,
        }
    }
}

/// Converts the RunStepStreamEventOneOf5 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepStreamEventOneOf5 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEventOneOf5 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEventOneOf5 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunStepObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepStreamEventOneOf5".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunStepObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepStreamEventOneOf5".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepStreamEventOneOf5 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStepStreamEventOneOf5".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStepStreamEventOneOf5".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepStreamEventOneOf5> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepStreamEventOneOf5>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepStreamEventOneOf5>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepStreamEventOneOf5 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepStreamEventOneOf5> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepStreamEventOneOf5 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepStreamEventOneOf5 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [run step](/docs/api-reference/runs/step-object) expires.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepStreamEventOneOf6 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunStepObject,

}


impl RunStepStreamEventOneOf6 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunStepObject, ) -> RunStepStreamEventOneOf6 {
        RunStepStreamEventOneOf6 {
            event,
            data,
        }
    }
}

/// Converts the RunStepStreamEventOneOf6 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepStreamEventOneOf6 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEventOneOf6 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEventOneOf6 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunStepObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepStreamEventOneOf6".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunStepObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepStreamEventOneOf6".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepStreamEventOneOf6 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStepStreamEventOneOf6".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStepStreamEventOneOf6".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepStreamEventOneOf6> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepStreamEventOneOf6>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepStreamEventOneOf6>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStepStreamEventOneOf6 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepStreamEventOneOf6> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepStreamEventOneOf6 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStepStreamEventOneOf6 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - RunStreamEventOneOf
/// - RunStreamEventOneOf1
/// - RunStreamEventOneOf2
/// - RunStreamEventOneOf3
/// - RunStreamEventOneOf4
/// - RunStreamEventOneOf5
/// - RunStreamEventOneOf6
/// - RunStreamEventOneOf7
/// - RunStreamEventOneOf8
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct RunStreamEvent(Box<serde_json::value::RawValue>);

impl validator::Validate for RunStreamEvent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEvent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for RunStreamEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Occurs when a new [run](/docs/api-reference/runs/object) is created.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunObject,

}


impl RunStreamEventOneOf {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf {
        RunStreamEventOneOf {
            event,
            data,
        }
    }
}

/// Converts the RunStreamEventOneOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStreamEventOneOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStreamEventOneOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [run](/docs/api-reference/runs/object) moves to a `queued` status.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf1 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunObject,

}


impl RunStreamEventOneOf1 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf1 {
        RunStreamEventOneOf1 {
            event,
            data,
        }
    }
}

/// Converts the RunStreamEventOneOf1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf1 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf1".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf1".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf1> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf1>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStreamEventOneOf1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf1> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStreamEventOneOf1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [run](/docs/api-reference/runs/object) moves to an `in_progress` status.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf2 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunObject,

}


impl RunStreamEventOneOf2 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf2 {
        RunStreamEventOneOf2 {
            event,
            data,
        }
    }
}

/// Converts the RunStreamEventOneOf2 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf2 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf2 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf2".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf2".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf2 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf2".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf2".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf2> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf2>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf2>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStreamEventOneOf2 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf2> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf2 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStreamEventOneOf2 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [run](/docs/api-reference/runs/object) moves to a `requires_action` status.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf3 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunObject,

}


impl RunStreamEventOneOf3 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf3 {
        RunStreamEventOneOf3 {
            event,
            data,
        }
    }
}

/// Converts the RunStreamEventOneOf3 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf3 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf3 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf3".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf3".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf3 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf3".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf3".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf3> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf3>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf3>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStreamEventOneOf3 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf3> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf3 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStreamEventOneOf3 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [run](/docs/api-reference/runs/object) is completed.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf4 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunObject,

}


impl RunStreamEventOneOf4 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf4 {
        RunStreamEventOneOf4 {
            event,
            data,
        }
    }
}

/// Converts the RunStreamEventOneOf4 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf4 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf4 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf4 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf4".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf4".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf4 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf4".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf4".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf4> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf4>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf4>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStreamEventOneOf4 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf4> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf4 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStreamEventOneOf4 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [run](/docs/api-reference/runs/object) fails.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf5 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunObject,

}


impl RunStreamEventOneOf5 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf5 {
        RunStreamEventOneOf5 {
            event,
            data,
        }
    }
}

/// Converts the RunStreamEventOneOf5 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf5 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf5 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf5 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf5".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf5".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf5 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf5".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf5".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf5> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf5>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf5>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStreamEventOneOf5 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf5> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf5 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStreamEventOneOf5 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [run](/docs/api-reference/runs/object) moves to a `cancelling` status.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf6 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunObject,

}


impl RunStreamEventOneOf6 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf6 {
        RunStreamEventOneOf6 {
            event,
            data,
        }
    }
}

/// Converts the RunStreamEventOneOf6 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf6 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf6 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf6 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf6".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf6".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf6 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf6".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf6".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf6> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf6>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf6>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStreamEventOneOf6 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf6> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf6 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStreamEventOneOf6 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [run](/docs/api-reference/runs/object) is cancelled.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf7 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunObject,

}


impl RunStreamEventOneOf7 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf7 {
        RunStreamEventOneOf7 {
            event,
            data,
        }
    }
}

/// Converts the RunStreamEventOneOf7 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf7 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf7 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf7 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf7".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf7".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf7 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf7".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf7".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf7> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf7>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf7>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStreamEventOneOf7 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf7> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf7 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStreamEventOneOf7 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Occurs when a [run](/docs/api-reference/runs/object) expires.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf8 {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::RunObject,

}


impl RunStreamEventOneOf8 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf8 {
        RunStreamEventOneOf8 {
            event,
            data,
        }
    }
}

/// Converts the RunStreamEventOneOf8 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf8 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf8 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf8 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf8".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf8".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf8 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf8".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf8".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf8> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf8>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf8>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunStreamEventOneOf8 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf8> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf8 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunStreamEventOneOf8 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Tool call objects



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunToolCallObject {
/// The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](/docs/api-reference/runs/submitToolOutputs) endpoint.
    #[serde(rename = "id")]
    pub id: String,

/// The type of tool call the output is required for. For now, this is always `function`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    pub r#type: String,

    #[serde(rename = "function")]
    pub function: models::RunToolCallObjectFunction,

}


impl RunToolCallObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, r#type: String, function: models::RunToolCallObjectFunction, ) -> RunToolCallObject {
        RunToolCallObject {
            id,
            r#type,
            function,
        }
    }
}

/// Converts the RunToolCallObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunToolCallObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("type".to_string()),
            Some(self.r#type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunToolCallObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunToolCallObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r#type: Vec<String>,
            pub function: Vec<models::RunToolCallObjectFunction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunToolCallObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::RunToolCallObjectFunction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunToolCallObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunToolCallObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in RunToolCallObject".to_string())?,
            r#type: intermediate_rep.r#type.into_iter().next().ok_or_else(|| "type missing in RunToolCallObject".to_string())?,
            function: intermediate_rep.function.into_iter().next().ok_or_else(|| "function missing in RunToolCallObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunToolCallObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunToolCallObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunToolCallObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunToolCallObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunToolCallObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunToolCallObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunToolCallObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// The function definition.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunToolCallObjectFunction {
/// The name of the function.
    #[serde(rename = "name")]
    pub name: String,

/// The arguments that the model expects you to pass to the function.
    #[serde(rename = "arguments")]
    pub arguments: String,

}


impl RunToolCallObjectFunction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, arguments: String, ) -> RunToolCallObjectFunction {
        RunToolCallObjectFunction {
            name,
            arguments,
        }
    }
}

/// Converts the RunToolCallObjectFunction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunToolCallObjectFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("arguments".to_string()),
            Some(self.arguments.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunToolCallObjectFunction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunToolCallObjectFunction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub arguments: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunToolCallObjectFunction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunToolCallObjectFunction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunToolCallObjectFunction {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in RunToolCallObjectFunction".to_string())?,
            arguments: intermediate_rep.arguments.into_iter().next().ok_or_else(|| "arguments missing in RunToolCallObjectFunction".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunToolCallObjectFunction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunToolCallObjectFunction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunToolCallObjectFunction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for RunToolCallObjectFunction - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunToolCallObjectFunction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunToolCallObjectFunction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into RunToolCallObjectFunction - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SubmitToolOutputsRunRequest {
/// A list of tools for which the outputs are being submitted.
    #[serde(rename = "tool_outputs")]
    pub tool_outputs: Vec<models::SubmitToolOutputsRunRequestToolOutputsInner>,

/// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message. 
    #[serde(rename = "stream")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stream: Option<Nullable<bool>>,

}


impl SubmitToolOutputsRunRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(tool_outputs: Vec<models::SubmitToolOutputsRunRequestToolOutputsInner>, ) -> SubmitToolOutputsRunRequest {
        SubmitToolOutputsRunRequest {
            tool_outputs,
            stream: None,
        }
    }
}

/// Converts the SubmitToolOutputsRunRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SubmitToolOutputsRunRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping tool_outputs in query parameter serialization


            self.stream.as_ref().map(|stream| {
                [
                    "stream".to_string(),
                    stream.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SubmitToolOutputsRunRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SubmitToolOutputsRunRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tool_outputs: Vec<Vec<models::SubmitToolOutputsRunRequestToolOutputsInner>>,
            pub stream: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SubmitToolOutputsRunRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "tool_outputs" => return std::result::Result::Err("Parsing a container in this style is not supported in SubmitToolOutputsRunRequest".to_string()),
                    "stream" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SubmitToolOutputsRunRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SubmitToolOutputsRunRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SubmitToolOutputsRunRequest {
            tool_outputs: intermediate_rep.tool_outputs.into_iter().next().ok_or_else(|| "tool_outputs missing in SubmitToolOutputsRunRequest".to_string())?,
            stream: std::result::Result::Err("Nullable types not supported in SubmitToolOutputsRunRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SubmitToolOutputsRunRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SubmitToolOutputsRunRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SubmitToolOutputsRunRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SubmitToolOutputsRunRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SubmitToolOutputsRunRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SubmitToolOutputsRunRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SubmitToolOutputsRunRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SubmitToolOutputsRunRequestToolOutputsInner {
/// The ID of the tool call in the `required_action` object within the run object the output is being submitted for.
    #[serde(rename = "tool_call_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_call_id: Option<String>,

/// The output of the tool call to be submitted to continue the run.
    #[serde(rename = "output")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output: Option<String>,

}


impl SubmitToolOutputsRunRequestToolOutputsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SubmitToolOutputsRunRequestToolOutputsInner {
        SubmitToolOutputsRunRequestToolOutputsInner {
            tool_call_id: None,
            output: None,
        }
    }
}

/// Converts the SubmitToolOutputsRunRequestToolOutputsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SubmitToolOutputsRunRequestToolOutputsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.tool_call_id.as_ref().map(|tool_call_id| {
                [
                    "tool_call_id".to_string(),
                    tool_call_id.to_string(),
                ].join(",")
            }),


            self.output.as_ref().map(|output| {
                [
                    "output".to_string(),
                    output.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SubmitToolOutputsRunRequestToolOutputsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SubmitToolOutputsRunRequestToolOutputsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tool_call_id: Vec<String>,
            pub output: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SubmitToolOutputsRunRequestToolOutputsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "tool_call_id" => intermediate_rep.tool_call_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output" => intermediate_rep.output.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SubmitToolOutputsRunRequestToolOutputsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SubmitToolOutputsRunRequestToolOutputsInner {
            tool_call_id: intermediate_rep.tool_call_id.into_iter().next(),
            output: intermediate_rep.output.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SubmitToolOutputsRunRequestToolOutputsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SubmitToolOutputsRunRequestToolOutputsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SubmitToolOutputsRunRequestToolOutputsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for SubmitToolOutputsRunRequestToolOutputsInner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SubmitToolOutputsRunRequestToolOutputsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SubmitToolOutputsRunRequestToolOutputsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into SubmitToolOutputsRunRequestToolOutputsInner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}




/// Represents a thread that contains [messages](/docs/api-reference/messages).



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ThreadObject {
/// The identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
    pub id: String,

/// The object type, which is always `thread`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
    pub object: String,

/// The Unix timestamp (in seconds) for when the thread was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

/// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
    #[serde(rename = "metadata")]
    pub metadata: crate::types::Object,

}


impl ThreadObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, created_at: i32, metadata: crate::types::Object, ) -> ThreadObject {
        ThreadObject {
            id,
            object,
            created_at,
            metadata,
        }
    }
}

/// Converts the ThreadObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ThreadObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ThreadObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ThreadObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub created_at: Vec<i32>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ThreadObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ThreadObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ThreadObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ThreadObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ThreadObject".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in ThreadObject".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next().ok_or_else(|| "metadata missing in ThreadObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ThreadObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ThreadObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ThreadObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ThreadObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ThreadObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ThreadObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ThreadObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}






/// One of:
/// - ThreadStreamEventOneOf
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ThreadStreamEvent(Box<serde_json::value::RawValue>);

impl validator::Validate for ThreadStreamEvent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ThreadStreamEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ThreadStreamEvent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl PartialEq for ThreadStreamEvent {
    fn eq(&self, other: &Self) -> bool {
        self.0.get() == other.0.get()
    }
}





/// Occurs when a new [thread](/docs/api-reference/threads/object) is created.



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ThreadStreamEventOneOf {
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
    pub event: String,

    #[serde(rename = "data")]
    pub data: models::ThreadObject,

}


impl ThreadStreamEventOneOf {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::ThreadObject, ) -> ThreadStreamEventOneOf {
        ThreadStreamEventOneOf {
            event,
            data,
        }
    }
}

/// Converts the ThreadStreamEventOneOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ThreadStreamEventOneOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ThreadStreamEventOneOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ThreadStreamEventOneOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::ThreadObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ThreadStreamEventOneOf".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::ThreadObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ThreadStreamEventOneOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ThreadStreamEventOneOf {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in ThreadStreamEventOneOf".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ThreadStreamEventOneOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ThreadStreamEventOneOf> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ThreadStreamEventOneOf>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ThreadStreamEventOneOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ThreadStreamEventOneOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ThreadStreamEventOneOf> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ThreadStreamEventOneOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ThreadStreamEventOneOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TranscriptionSegment {
/// Unique identifier of the segment.
    #[serde(rename = "id")]
    pub id: i32,

/// Seek offset of the segment.
    #[serde(rename = "seek")]
    pub seek: i32,

/// Start time of the segment in seconds.
    #[serde(rename = "start")]
    pub start: f32,

/// End time of the segment in seconds.
    #[serde(rename = "end")]
    pub end: f32,

/// Text content of the segment.
    #[serde(rename = "text")]
    pub text: String,

/// Array of token IDs for the text content.
    #[serde(rename = "tokens")]
    pub tokens: Vec<i32>,

/// Temperature parameter used for generating the segment.
    #[serde(rename = "temperature")]
    pub temperature: f32,

/// Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.
    #[serde(rename = "avg_logprob")]
    pub avg_logprob: f32,

/// Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.
    #[serde(rename = "compression_ratio")]
    pub compression_ratio: f32,

/// Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent.
    #[serde(rename = "no_speech_prob")]
    pub no_speech_prob: f32,

}


impl TranscriptionSegment {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, seek: i32, start: f32, end: f32, text: String, tokens: Vec<i32>, temperature: f32, avg_logprob: f32, compression_ratio: f32, no_speech_prob: f32, ) -> TranscriptionSegment {
        TranscriptionSegment {
            id,
            seek,
            start,
            end,
            text,
            tokens,
            temperature,
            avg_logprob,
            compression_ratio,
            no_speech_prob,
        }
    }
}

/// Converts the TranscriptionSegment value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TranscriptionSegment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("seek".to_string()),
            Some(self.seek.to_string()),


            Some("start".to_string()),
            Some(self.start.to_string()),


            Some("end".to_string()),
            Some(self.end.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),


            Some("tokens".to_string()),
            Some(self.tokens.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("temperature".to_string()),
            Some(self.temperature.to_string()),


            Some("avg_logprob".to_string()),
            Some(self.avg_logprob.to_string()),


            Some("compression_ratio".to_string()),
            Some(self.compression_ratio.to_string()),


            Some("no_speech_prob".to_string()),
            Some(self.no_speech_prob.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TranscriptionSegment value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TranscriptionSegment {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub seek: Vec<i32>,
            pub start: Vec<f32>,
            pub end: Vec<f32>,
            pub text: Vec<String>,
            pub tokens: Vec<Vec<i32>>,
            pub temperature: Vec<f32>,
            pub avg_logprob: Vec<f32>,
            pub compression_ratio: Vec<f32>,
            pub no_speech_prob: Vec<f32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TranscriptionSegment".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "seek" => intermediate_rep.seek.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start" => intermediate_rep.start.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end" => intermediate_rep.end.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tokens" => return std::result::Result::Err("Parsing a container in this style is not supported in TranscriptionSegment".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "temperature" => intermediate_rep.temperature.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "avg_logprob" => intermediate_rep.avg_logprob.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "compression_ratio" => intermediate_rep.compression_ratio.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "no_speech_prob" => intermediate_rep.no_speech_prob.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TranscriptionSegment".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TranscriptionSegment {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in TranscriptionSegment".to_string())?,
            seek: intermediate_rep.seek.into_iter().next().ok_or_else(|| "seek missing in TranscriptionSegment".to_string())?,
            start: intermediate_rep.start.into_iter().next().ok_or_else(|| "start missing in TranscriptionSegment".to_string())?,
            end: intermediate_rep.end.into_iter().next().ok_or_else(|| "end missing in TranscriptionSegment".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in TranscriptionSegment".to_string())?,
            tokens: intermediate_rep.tokens.into_iter().next().ok_or_else(|| "tokens missing in TranscriptionSegment".to_string())?,
            temperature: intermediate_rep.temperature.into_iter().next().ok_or_else(|| "temperature missing in TranscriptionSegment".to_string())?,
            avg_logprob: intermediate_rep.avg_logprob.into_iter().next().ok_or_else(|| "avg_logprob missing in TranscriptionSegment".to_string())?,
            compression_ratio: intermediate_rep.compression_ratio.into_iter().next().ok_or_else(|| "compression_ratio missing in TranscriptionSegment".to_string())?,
            no_speech_prob: intermediate_rep.no_speech_prob.into_iter().next().ok_or_else(|| "no_speech_prob missing in TranscriptionSegment".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TranscriptionSegment> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TranscriptionSegment>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TranscriptionSegment>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TranscriptionSegment - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TranscriptionSegment> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TranscriptionSegment as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TranscriptionSegment - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TranscriptionWord {
/// The text content of the word.
    #[serde(rename = "word")]
    pub word: String,

/// Start time of the word in seconds.
    #[serde(rename = "start")]
    pub start: f32,

/// End time of the word in seconds.
    #[serde(rename = "end")]
    pub end: f32,

}


impl TranscriptionWord {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(word: String, start: f32, end: f32, ) -> TranscriptionWord {
        TranscriptionWord {
            word,
            start,
            end,
        }
    }
}

/// Converts the TranscriptionWord value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TranscriptionWord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("word".to_string()),
            Some(self.word.to_string()),


            Some("start".to_string()),
            Some(self.start.to_string()),


            Some("end".to_string()),
            Some(self.end.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TranscriptionWord value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TranscriptionWord {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub word: Vec<String>,
            pub start: Vec<f32>,
            pub end: Vec<f32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TranscriptionWord".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "word" => intermediate_rep.word.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start" => intermediate_rep.start.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end" => intermediate_rep.end.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TranscriptionWord".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TranscriptionWord {
            word: intermediate_rep.word.into_iter().next().ok_or_else(|| "word missing in TranscriptionWord".to_string())?,
            start: intermediate_rep.start.into_iter().next().ok_or_else(|| "start missing in TranscriptionWord".to_string())?,
            end: intermediate_rep.end.into_iter().next().ok_or_else(|| "end missing in TranscriptionWord".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TranscriptionWord> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TranscriptionWord>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TranscriptionWord>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TranscriptionWord - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TranscriptionWord> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TranscriptionWord as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TranscriptionWord - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TruncationObject {
/// The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`.
/// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r#type: Option<String>,

/// The number of most recent messages from the thread when constructing the context for the run.
    #[serde(rename = "last_messages")]
    #[validate(
            range(min = 1),
        )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_messages: Option<Nullable<u32>>,

}


impl TruncationObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TruncationObject {
        TruncationObject {
            r#type: None,
            last_messages: None,
        }
    }
}

/// Converts the TruncationObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TruncationObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r#type.as_ref().map(|r#type| {
                [
                    "type".to_string(),
                    r#type.to_string(),
                ].join(",")
            }),


            self.last_messages.as_ref().map(|last_messages| {
                [
                    "last_messages".to_string(),
                    last_messages.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TruncationObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TruncationObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r#type: Vec<String>,
            pub last_messages: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TruncationObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r#type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "last_messages" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in TruncationObject".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TruncationObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TruncationObject {
            r#type: intermediate_rep.r#type.into_iter().next(),
            last_messages: std::result::Result::Err("Nullable types not supported in TruncationObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TruncationObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TruncationObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TruncationObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TruncationObject - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TruncationObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TruncationObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TruncationObject - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}



