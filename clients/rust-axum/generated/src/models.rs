#![allow(unused_qualifications)]

use http::HeaderValue;
use validator::Validate;

#[cfg(feature = "server")]
use crate::header;
use crate::{models, types::*};

#[allow(dead_code)]
fn from_validation_error(e: validator::ValidationError) -> validator::ValidationErrors {
  let mut errs = validator::ValidationErrors::new();
  errs.add("na", e);
  errs
}

#[allow(dead_code)]
pub fn check_xss_string(v: &str) -> std::result::Result<(), validator::ValidationError> {
    if ammonia::is_html(v) {
        std::result::Result::Err(validator::ValidationError::new("xss detected"))
    } else {
        std::result::Result::Ok(())
    }
}

#[allow(dead_code)]
pub fn check_xss_vec_string(v: &[String]) -> std::result::Result<(), validator::ValidationError> {
    if v.iter().any(|i| ammonia::is_html(i)) {
        std::result::Result::Err(validator::ValidationError::new("xss detected"))
    } else {
        std::result::Result::Ok(())
    }
}

#[allow(dead_code)]
pub fn check_xss_map_string(
    v: &std::collections::HashMap<String, String>,
) -> std::result::Result<(), validator::ValidationError> {
    if v.keys().any(|k| ammonia::is_html(k)) || v.values().any(|v| ammonia::is_html(v)) {
        std::result::Result::Err(validator::ValidationError::new("xss detected"))
    } else {
        std::result::Result::Ok(())
    }
}

#[allow(dead_code)]
pub fn check_xss_map_nested<T>(
    v: &std::collections::HashMap<String, T>,
) -> std::result::Result<(), validator::ValidationError>
where
    T: validator::Validate,
{
    if v.keys().any(|k| ammonia::is_html(k)) || v.values().any(|v| v.validate().is_err()) {
        std::result::Result::Err(validator::ValidationError::new("xss detected"))
    } else {
        std::result::Result::Ok(())
    }
}

#[allow(dead_code)]
pub fn check_xss_map<T>(v: &std::collections::HashMap<String, T>) -> std::result::Result<(), validator::ValidationError> {
    if v.keys().any(|k| ammonia::is_html(k)) {
        std::result::Result::Err(validator::ValidationError::new("xss detected"))
    } else {
        std::result::Result::Ok(())
    }
}


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct CancelRunPathParams {
            /// The ID of the thread to which this run belongs.
                pub thread_id: String,
            /// The ID of the run to cancel.
                pub run_id: String,
    }




    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct CreateMessagePathParams {
            /// The ID of the [thread](/docs/api-reference/threads) to create a message for.
                pub thread_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct CreateRunPathParams {
            /// The ID of the thread to run.
                pub thread_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct CreateRunQueryParams {
            /// A list of additional fields to include in the response. Currently the only supported value is `step_details.tool_calls[*].file_search.results[*].content` to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "include[]")]
                    #[serde(default)]
                    pub include_left_square_bracket_right_square_bracket: Vec<String>,
    }




    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct DeleteAssistantPathParams {
            /// The ID of the assistant to delete.
                pub assistant_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct DeleteMessagePathParams {
            /// The ID of the thread to which this message belongs.
                pub thread_id: String,
            /// The ID of the message to delete.
                pub message_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct DeleteThreadPathParams {
            /// The ID of the thread to delete.
                pub thread_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GetAssistantPathParams {
            /// The ID of the assistant to retrieve.
                pub assistant_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GetMessagePathParams {
            /// The ID of the [thread](/docs/api-reference/threads) to which this message belongs.
                pub thread_id: String,
            /// The ID of the message to retrieve.
                pub message_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GetRunPathParams {
            /// The ID of the [thread](/docs/api-reference/threads) that was run.
                pub thread_id: String,
            /// The ID of the run to retrieve.
                pub run_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GetRunStepPathParams {
            /// The ID of the thread to which the run and run step belongs.
                pub thread_id: String,
            /// The ID of the run to which the run step belongs.
                pub run_id: String,
            /// The ID of the run step to retrieve.
                pub step_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GetRunStepQueryParams {
            /// A list of additional fields to include in the response. Currently the only supported value is `step_details.tool_calls[*].file_search.results[*].content` to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "include[]")]
                    #[serde(default)]
                    pub include_left_square_bracket_right_square_bracket: Vec<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GetThreadPathParams {
            /// The ID of the thread to retrieve.
                pub thread_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListAssistantsQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub order: Option<String>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
            /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
                #[serde(rename = "before")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub before: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListMessagesPathParams {
            /// The ID of the [thread](/docs/api-reference/threads) the messages belong to.
                pub thread_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListMessagesQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub order: Option<String>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
            /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
                #[serde(rename = "before")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub before: Option<String>,
            /// Filter messages by the run ID that generated them. 
                #[serde(rename = "run_id")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub run_id: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListRunStepsPathParams {
            /// The ID of the thread the run and run steps belong to.
                pub thread_id: String,
            /// The ID of the run the run steps belong to.
                pub run_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListRunStepsQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub order: Option<String>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
            /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
                #[serde(rename = "before")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub before: Option<String>,
            /// A list of additional fields to include in the response. Currently the only supported value is `step_details.tool_calls[*].file_search.results[*].content` to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "include[]")]
                    #[serde(default)]
                    pub include_left_square_bracket_right_square_bracket: Vec<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListRunsPathParams {
            /// The ID of the thread the run belongs to.
                pub thread_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListRunsQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub order: Option<String>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
            /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
                #[serde(rename = "before")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub before: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ModifyAssistantPathParams {
            /// The ID of the assistant to modify.
                pub assistant_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ModifyMessagePathParams {
            /// The ID of the thread to which this message belongs.
                pub thread_id: String,
            /// The ID of the message to modify.
                pub message_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ModifyRunPathParams {
            /// The ID of the [thread](/docs/api-reference/threads) that was run.
                pub thread_id: String,
            /// The ID of the run to modify.
                pub run_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ModifyThreadPathParams {
            /// The ID of the thread to modify. Only the `metadata` can be modified.
                pub thread_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SubmitToolOuputsToRunPathParams {
            /// The ID of the [thread](/docs/api-reference/threads) to which this run belongs.
                pub thread_id: String,
            /// The ID of the run that requires the tool output submission.
                pub run_id: String,
    }






    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListAuditLogsQueryParams {
            /// Return only events whose `effective_at` (Unix seconds) is in this range.
                #[serde(rename = "effective_at")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub effective_at: Option<crate::types::Object>,
            /// Return only events for these projects.
                #[serde(rename = "project_ids[]")]
                    #[serde(default)]
                    pub project_ids_left_square_bracket_right_square_bracket: Vec<String>,
            /// Return only events with a `type` in one of these values. For example, `project.created`. For all options, see the documentation for the [audit log object](/docs/api-reference/audit-logs/object).
                #[serde(rename = "event_types[]")]
                    #[serde(default)]
                    pub event_types_left_square_bracket_right_square_bracket: Vec<models::AuditLogEventType>,
            /// Return only events performed by these actors. Can be a user ID, a service account ID, or an api key tracking ID.
                #[serde(rename = "actor_ids[]")]
                    #[serde(default)]
                    pub actor_ids_left_square_bracket_right_square_bracket: Vec<String>,
            /// Return only events performed by users with these emails.
                #[serde(rename = "actor_emails[]")]
                    #[serde(default)]
                    pub actor_emails_left_square_bracket_right_square_bracket: Vec<String>,
            /// Return only events performed on these targets. For example, a project ID updated.
                #[serde(rename = "resource_ids[]")]
                    #[serde(default)]
                    pub resource_ids_left_square_bracket_right_square_bracket: Vec<String>,
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
            /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
                #[serde(rename = "before")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub before: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct CancelBatchPathParams {
            /// The ID of the batch to cancel.
                pub batch_id: String,
    }




    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListBatchesQueryParams {
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct RetrieveBatchPathParams {
            /// The ID of the batch to retrieve.
                pub batch_id: String,
    }






    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct AdminApiKeysDeletePathParams {
                pub key_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct AdminApiKeysGetPathParams {
                pub key_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct AdminApiKeysListQueryParams {
                #[serde(rename = "after")]
                    #[serde(deserialize_with = "deserialize_optional_nullable")]
                    #[serde(default = "default_optional_nullable")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<Nullable<String>>,
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub order: Option<String>,
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
    }




    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct DeleteFilePathParams {
            /// The ID of the file to use for this request.
                pub file_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct DownloadFilePathParams {
            /// The ID of the file to use for this request.
                pub file_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListFilesQueryParams {
            /// Only return files with the given purpose.
                #[serde(rename = "purpose")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub purpose: Option<String>,
            /// A limit on the number of objects to be returned. Limit can range between 1 and 10,000, and the default is 10,000. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub order: Option<String>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct RetrieveFilePathParams {
            /// The ID of the file to use for this request.
                pub file_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct CancelFineTuningJobPathParams {
            /// The ID of the fine-tuning job to cancel. 
                pub fine_tuning_job_id: String,
    }




    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListFineTuningEventsPathParams {
            /// The ID of the fine-tuning job to get events for. 
                pub fine_tuning_job_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListFineTuningEventsQueryParams {
            /// Identifier for the last event from the previous pagination request.
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
            /// Number of events to retrieve.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListFineTuningJobCheckpointsPathParams {
            /// The ID of the fine-tuning job to get checkpoints for. 
                pub fine_tuning_job_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListFineTuningJobCheckpointsQueryParams {
            /// Identifier for the last checkpoint ID from the previous pagination request.
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
            /// Number of checkpoints to retrieve.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListPaginatedFineTuningJobsQueryParams {
            /// Identifier for the last job from the previous pagination request.
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
            /// Number of fine-tuning jobs to retrieve.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct RetrieveFineTuningJobPathParams {
            /// The ID of the fine-tuning job. 
                pub fine_tuning_job_id: String,
    }






    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct DeleteInvitePathParams {
            /// The ID of the invite to delete.
                pub invite_id: String,
    }




    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListInvitesQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct RetrieveInvitePathParams {
            /// The ID of the invite to retrieve.
                pub invite_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct DeleteModelPathParams {
            /// The model to delete
                pub model: String,
    }




    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct RetrieveModelPathParams {
            /// The ID of the model to use for this request
                pub model: String,
    }




    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ArchiveProjectPathParams {
            /// The ID of the project.
                pub project_id: String,
    }




    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct CreateProjectServiceAccountPathParams {
            /// The ID of the project.
                pub project_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct CreateProjectUserPathParams {
            /// The ID of the project.
                pub project_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct DeleteProjectApiKeyPathParams {
            /// The ID of the project.
                pub project_id: String,
            /// The ID of the API key.
                pub key_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct DeleteProjectServiceAccountPathParams {
            /// The ID of the project.
                pub project_id: String,
            /// The ID of the service account.
                pub service_account_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct DeleteProjectUserPathParams {
            /// The ID of the project.
                pub project_id: String,
            /// The ID of the user.
                pub user_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListProjectApiKeysPathParams {
            /// The ID of the project.
                pub project_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListProjectApiKeysQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListProjectRateLimitsPathParams {
            /// The ID of the project.
                pub project_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListProjectRateLimitsQueryParams {
            /// A limit on the number of objects to be returned. The default is 100. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
            /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, beginning with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
                #[serde(rename = "before")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub before: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListProjectServiceAccountsPathParams {
            /// The ID of the project.
                pub project_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListProjectServiceAccountsQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListProjectUsersPathParams {
            /// The ID of the project.
                pub project_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListProjectUsersQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListProjectsQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
            /// If `true` returns all projects including those that have been `archived`. Archived projects are not included by default.
                #[serde(rename = "include_archived")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub include_archived: Option<bool>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ModifyProjectPathParams {
            /// The ID of the project.
                pub project_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ModifyProjectUserPathParams {
            /// The ID of the project.
                pub project_id: String,
            /// The ID of the user.
                pub user_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct RetrieveProjectPathParams {
            /// The ID of the project.
                pub project_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct RetrieveProjectApiKeyPathParams {
            /// The ID of the project.
                pub project_id: String,
            /// The ID of the API key.
                pub key_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct RetrieveProjectServiceAccountPathParams {
            /// The ID of the project.
                pub project_id: String,
            /// The ID of the service account.
                pub service_account_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct RetrieveProjectUserPathParams {
            /// The ID of the project.
                pub project_id: String,
            /// The ID of the user.
                pub user_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct UpdateProjectRateLimitsPathParams {
            /// The ID of the project.
                pub project_id: String,
            /// The ID of the rate limit.
                pub rate_limit_id: String,
    }




    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct AddUploadPartPathParams {
            /// The ID of the Upload. 
                pub upload_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct CancelUploadPathParams {
            /// The ID of the Upload. 
                pub upload_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct CompleteUploadPathParams {
            /// The ID of the Upload. 
                pub upload_id: String,
    }




    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct UsageAudioSpeechesQueryParams {
            /// Start time (Unix seconds) of the query time range, inclusive.
                #[serde(rename = "start_time")]
                    pub start_time: i32,
            /// End time (Unix seconds) of the query time range, exclusive.
                #[serde(rename = "end_time")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub end_time: Option<i32>,
            /// Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "bucket_width")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub bucket_width: Option<String>,
            /// Return only usage for these projects.
                #[serde(rename = "project_ids")]
                    #[serde(default)]
                    pub project_ids: Vec<String>,
            /// Return only usage for these users.
                #[serde(rename = "user_ids")]
                    #[serde(default)]
                    pub user_ids: Vec<String>,
            /// Return only usage for these API keys.
                #[serde(rename = "api_key_ids")]
                    #[serde(default)]
                    pub api_key_ids: Vec<String>,
            /// Return only usage for these models.
                #[serde(rename = "models")]
                    #[serde(default)]
                    pub models: Vec<String>,
            /// Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "group_by")]
                    #[serde(default)]
                    pub group_by: Vec<String>,
            /// Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
                #[serde(rename = "page")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub page: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct UsageAudioTranscriptionsQueryParams {
            /// Start time (Unix seconds) of the query time range, inclusive.
                #[serde(rename = "start_time")]
                    pub start_time: i32,
            /// End time (Unix seconds) of the query time range, exclusive.
                #[serde(rename = "end_time")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub end_time: Option<i32>,
            /// Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "bucket_width")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub bucket_width: Option<String>,
            /// Return only usage for these projects.
                #[serde(rename = "project_ids")]
                    #[serde(default)]
                    pub project_ids: Vec<String>,
            /// Return only usage for these users.
                #[serde(rename = "user_ids")]
                    #[serde(default)]
                    pub user_ids: Vec<String>,
            /// Return only usage for these API keys.
                #[serde(rename = "api_key_ids")]
                    #[serde(default)]
                    pub api_key_ids: Vec<String>,
            /// Return only usage for these models.
                #[serde(rename = "models")]
                    #[serde(default)]
                    pub models: Vec<String>,
            /// Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "group_by")]
                    #[serde(default)]
                    pub group_by: Vec<String>,
            /// Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
                #[serde(rename = "page")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub page: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct UsageCodeInterpreterSessionsQueryParams {
            /// Start time (Unix seconds) of the query time range, inclusive.
                #[serde(rename = "start_time")]
                    pub start_time: i32,
            /// End time (Unix seconds) of the query time range, exclusive.
                #[serde(rename = "end_time")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub end_time: Option<i32>,
            /// Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "bucket_width")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub bucket_width: Option<String>,
            /// Return only usage for these projects.
                #[serde(rename = "project_ids")]
                    #[serde(default)]
                    pub project_ids: Vec<String>,
            /// Group the usage data by the specified fields. Support fields include `project_id`.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "group_by")]
                    #[serde(default)]
                    pub group_by: Vec<String>,
            /// Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
                #[serde(rename = "page")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub page: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct UsageCompletionsQueryParams {
            /// Start time (Unix seconds) of the query time range, inclusive.
                #[serde(rename = "start_time")]
                    pub start_time: i32,
            /// End time (Unix seconds) of the query time range, exclusive.
                #[serde(rename = "end_time")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub end_time: Option<i32>,
            /// Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "bucket_width")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub bucket_width: Option<String>,
            /// Return only usage for these projects.
                #[serde(rename = "project_ids")]
                    #[serde(default)]
                    pub project_ids: Vec<String>,
            /// Return only usage for these users.
                #[serde(rename = "user_ids")]
                    #[serde(default)]
                    pub user_ids: Vec<String>,
            /// Return only usage for these API keys.
                #[serde(rename = "api_key_ids")]
                    #[serde(default)]
                    pub api_key_ids: Vec<String>,
            /// Return only usage for these models.
                #[serde(rename = "models")]
                    #[serde(default)]
                    pub models: Vec<String>,
            /// If `true`, return batch jobs only. If `false`, return non-batch jobs only. By default, return both. 
                #[serde(rename = "batch")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub batch: Option<bool>,
            /// Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model`, `batch` or any combination of them.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "group_by")]
                    #[serde(default)]
                    pub group_by: Vec<String>,
            /// Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
                #[serde(rename = "page")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub page: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct UsageCostsQueryParams {
            /// Start time (Unix seconds) of the query time range, inclusive.
                #[serde(rename = "start_time")]
                    pub start_time: i32,
            /// End time (Unix seconds) of the query time range, exclusive.
                #[serde(rename = "end_time")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub end_time: Option<i32>,
            /// Width of each time bucket in response. Currently only `1d` is supported, default to `1d`.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "bucket_width")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub bucket_width: Option<String>,
            /// Return only costs for these projects.
                #[serde(rename = "project_ids")]
                    #[serde(default)]
                    pub project_ids: Vec<String>,
            /// Group the costs by the specified fields. Support fields include `project_id`, `line_item` and any combination of them.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "group_by")]
                    #[serde(default)]
                    pub group_by: Vec<String>,
            /// A limit on the number of buckets to be returned. Limit can range between 1 and 180, and the default is 7. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
                #[serde(rename = "page")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub page: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct UsageEmbeddingsQueryParams {
            /// Start time (Unix seconds) of the query time range, inclusive.
                #[serde(rename = "start_time")]
                    pub start_time: i32,
            /// End time (Unix seconds) of the query time range, exclusive.
                #[serde(rename = "end_time")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub end_time: Option<i32>,
            /// Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "bucket_width")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub bucket_width: Option<String>,
            /// Return only usage for these projects.
                #[serde(rename = "project_ids")]
                    #[serde(default)]
                    pub project_ids: Vec<String>,
            /// Return only usage for these users.
                #[serde(rename = "user_ids")]
                    #[serde(default)]
                    pub user_ids: Vec<String>,
            /// Return only usage for these API keys.
                #[serde(rename = "api_key_ids")]
                    #[serde(default)]
                    pub api_key_ids: Vec<String>,
            /// Return only usage for these models.
                #[serde(rename = "models")]
                    #[serde(default)]
                    pub models: Vec<String>,
            /// Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "group_by")]
                    #[serde(default)]
                    pub group_by: Vec<String>,
            /// Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
                #[serde(rename = "page")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub page: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct UsageImagesQueryParams {
            /// Start time (Unix seconds) of the query time range, inclusive.
                #[serde(rename = "start_time")]
                    pub start_time: i32,
            /// End time (Unix seconds) of the query time range, exclusive.
                #[serde(rename = "end_time")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub end_time: Option<i32>,
            /// Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "bucket_width")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub bucket_width: Option<String>,
            /// Return only usages for these sources. Possible values are `image.generation`, `image.edit`, `image.variation` or any combination of them.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "sources")]
                    #[serde(default)]
                    pub sources: Vec<String>,
            /// Return only usages for these image sizes. Possible values are `256x256`, `512x512`, `1024x1024`, `1792x1792`, `1024x1792` or any combination of them.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "sizes")]
                    #[serde(default)]
                    pub sizes: Vec<String>,
            /// Return only usage for these projects.
                #[serde(rename = "project_ids")]
                    #[serde(default)]
                    pub project_ids: Vec<String>,
            /// Return only usage for these users.
                #[serde(rename = "user_ids")]
                    #[serde(default)]
                    pub user_ids: Vec<String>,
            /// Return only usage for these API keys.
                #[serde(rename = "api_key_ids")]
                    #[serde(default)]
                    pub api_key_ids: Vec<String>,
            /// Return only usage for these models.
                #[serde(rename = "models")]
                    #[serde(default)]
                    pub models: Vec<String>,
            /// Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model`, `size`, `source` or any combination of them.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "group_by")]
                    #[serde(default)]
                    pub group_by: Vec<String>,
            /// Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
                #[serde(rename = "page")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub page: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct UsageModerationsQueryParams {
            /// Start time (Unix seconds) of the query time range, inclusive.
                #[serde(rename = "start_time")]
                    pub start_time: i32,
            /// End time (Unix seconds) of the query time range, exclusive.
                #[serde(rename = "end_time")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub end_time: Option<i32>,
            /// Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "bucket_width")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub bucket_width: Option<String>,
            /// Return only usage for these projects.
                #[serde(rename = "project_ids")]
                    #[serde(default)]
                    pub project_ids: Vec<String>,
            /// Return only usage for these users.
                #[serde(rename = "user_ids")]
                    #[serde(default)]
                    pub user_ids: Vec<String>,
            /// Return only usage for these API keys.
                #[serde(rename = "api_key_ids")]
                    #[serde(default)]
                    pub api_key_ids: Vec<String>,
            /// Return only usage for these models.
                #[serde(rename = "models")]
                    #[serde(default)]
                    pub models: Vec<String>,
            /// Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "group_by")]
                    #[serde(default)]
                    pub group_by: Vec<String>,
            /// Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
                #[serde(rename = "page")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub page: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct UsageVectorStoresQueryParams {
            /// Start time (Unix seconds) of the query time range, inclusive.
                #[serde(rename = "start_time")]
                    pub start_time: i32,
            /// End time (Unix seconds) of the query time range, exclusive.
                #[serde(rename = "end_time")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub end_time: Option<i32>,
            /// Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "bucket_width")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub bucket_width: Option<String>,
            /// Return only usage for these projects.
                #[serde(rename = "project_ids")]
                    #[serde(default)]
                    pub project_ids: Vec<String>,
            /// Group the usage data by the specified fields. Support fields include `project_id`.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "group_by")]
                    #[serde(default)]
                    pub group_by: Vec<String>,
            /// Specifies the number of buckets to return. - `bucket_width=1d`: default: 7, max: 31 - `bucket_width=1h`: default: 24, max: 168 - `bucket_width=1m`: default: 60, max: 1440 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. Corresponding to the `next_page` field from the previous response.
                #[serde(rename = "page")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub page: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct DeleteUserPathParams {
            /// The ID of the user.
                pub user_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListUsersQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ModifyUserPathParams {
            /// The ID of the user.
                pub user_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct RetrieveUserPathParams {
            /// The ID of the user.
                pub user_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct CancelVectorStoreFileBatchPathParams {
            /// The ID of the vector store that the file batch belongs to.
                pub vector_store_id: String,
            /// The ID of the file batch to cancel.
                pub batch_id: String,
    }




    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct CreateVectorStoreFilePathParams {
            /// The ID of the vector store for which to create a File. 
                pub vector_store_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct CreateVectorStoreFileBatchPathParams {
            /// The ID of the vector store for which to create a File Batch. 
                pub vector_store_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct DeleteVectorStorePathParams {
            /// The ID of the vector store to delete.
                pub vector_store_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct DeleteVectorStoreFilePathParams {
            /// The ID of the vector store that the file belongs to.
                pub vector_store_id: String,
            /// The ID of the file to delete.
                pub file_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GetVectorStorePathParams {
            /// The ID of the vector store to retrieve.
                pub vector_store_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GetVectorStoreFilePathParams {
            /// The ID of the vector store that the file belongs to.
                pub vector_store_id: String,
            /// The ID of the file being retrieved.
                pub file_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GetVectorStoreFileBatchPathParams {
            /// The ID of the vector store that the file batch belongs to.
                pub vector_store_id: String,
            /// The ID of the file batch being retrieved.
                pub batch_id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListFilesInVectorStoreBatchPathParams {
            /// The ID of the vector store that the files belong to.
                pub vector_store_id: String,
            /// The ID of the file batch that the files belong to.
                pub batch_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListFilesInVectorStoreBatchQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub order: Option<String>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
            /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
                #[serde(rename = "before")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub before: Option<String>,
            /// Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "filter")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub filter: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListVectorStoreFilesPathParams {
            /// The ID of the vector store that the files belong to.
                pub vector_store_id: String,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListVectorStoreFilesQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub order: Option<String>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
            /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
                #[serde(rename = "before")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub before: Option<String>,
            /// Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`.
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "filter")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub filter: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ListVectorStoresQueryParams {
            /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order. 
            /// Note: inline enums are not fully supported by openapi-generator
                #[serde(rename = "order")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub order: Option<String>,
            /// A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list. 
                #[serde(rename = "after")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub after: Option<String>,
            /// A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list. 
                #[serde(rename = "before")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub before: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ModifyVectorStorePathParams {
            /// The ID of the vector store to modify.
                pub vector_store_id: String,
    }




#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdminApiKey {
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub object: Option<String>,

    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "redacted_value")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub redacted_value: Option<String>,

    #[serde(rename = "value")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,

    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<i64>,

    #[serde(rename = "owner")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<models::AdminApiKeyOwner>,

}



impl AdminApiKey {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdminApiKey {
        AdminApiKey {
 object: None,
 id: None,
 name: None,
 redacted_value: None,
 value: None,
 created_at: None,
 owner: None,
        }
    }
}

/// Converts the AdminApiKey value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdminApiKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.object.as_ref().map(|object| {
                [
                    "object".to_string(),
                    object.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.redacted_value.as_ref().map(|redacted_value| {
                [
                    "redacted_value".to_string(),
                    redacted_value.to_string(),
                ].join(",")
            }),


            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),


            self.created_at.as_ref().map(|created_at| {
                [
                    "created_at".to_string(),
                    created_at.to_string(),
                ].join(",")
            }),

            // Skipping owner in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdminApiKey value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdminApiKey {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub redacted_value: Vec<String>,
            pub value: Vec<String>,
            pub created_at: Vec<i64>,
            pub owner: Vec<models::AdminApiKeyOwner>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdminApiKey".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "redacted_value" => intermediate_rep.redacted_value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "owner" => intermediate_rep.owner.push(<models::AdminApiKeyOwner as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdminApiKey".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdminApiKey {
            object: intermediate_rep.object.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            redacted_value: intermediate_rep.redacted_value.into_iter().next(),
            value: intermediate_rep.value.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            owner: intermediate_rep.owner.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdminApiKey> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdminApiKey>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdminApiKey>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AdminApiKey - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdminApiKey> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdminApiKey as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AdminApiKey - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdminApiKeyOwner {
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<i64>,

    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,

}



impl AdminApiKeyOwner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdminApiKeyOwner {
        AdminApiKeyOwner {
 r_type: None,
 id: None,
 name: None,
 created_at: None,
 role: None,
        }
    }
}

/// Converts the AdminApiKeyOwner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdminApiKeyOwner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.created_at.as_ref().map(|created_at| {
                [
                    "created_at".to_string(),
                    created_at.to_string(),
                ].join(",")
            }),


            self.role.as_ref().map(|role| {
                [
                    "role".to_string(),
                    role.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdminApiKeyOwner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdminApiKeyOwner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub created_at: Vec<i64>,
            pub role: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdminApiKeyOwner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdminApiKeyOwner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdminApiKeyOwner {
            r_type: intermediate_rep.r_type.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            role: intermediate_rep.role.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdminApiKeyOwner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdminApiKeyOwner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdminApiKeyOwner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AdminApiKeyOwner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdminApiKeyOwner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdminApiKeyOwner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AdminApiKeyOwner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdminApiKeysCreateRequest {
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

}



impl AdminApiKeysCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> AdminApiKeysCreateRequest {
        AdminApiKeysCreateRequest {
 name,
        }
    }
}

/// Converts the AdminApiKeysCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdminApiKeysCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdminApiKeysCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdminApiKeysCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdminApiKeysCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdminApiKeysCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdminApiKeysCreateRequest {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in AdminApiKeysCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdminApiKeysCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdminApiKeysCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdminApiKeysCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AdminApiKeysCreateRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdminApiKeysCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdminApiKeysCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AdminApiKeysCreateRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdminApiKeysDelete200Response {
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub object: Option<String>,

    #[serde(rename = "deleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,

}



impl AdminApiKeysDelete200Response {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AdminApiKeysDelete200Response {
        AdminApiKeysDelete200Response {
 id: None,
 object: None,
 deleted: None,
        }
    }
}

/// Converts the AdminApiKeysDelete200Response value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AdminApiKeysDelete200Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.object.as_ref().map(|object| {
                [
                    "object".to_string(),
                    object.to_string(),
                ].join(",")
            }),


            self.deleted.as_ref().map(|deleted| {
                [
                    "deleted".to_string(),
                    deleted.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdminApiKeysDelete200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdminApiKeysDelete200Response {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub deleted: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdminApiKeysDelete200Response".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdminApiKeysDelete200Response".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdminApiKeysDelete200Response {
            id: intermediate_rep.id.into_iter().next(),
            object: intermediate_rep.object.into_iter().next(),
            deleted: intermediate_rep.deleted.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdminApiKeysDelete200Response> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AdminApiKeysDelete200Response>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdminApiKeysDelete200Response>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AdminApiKeysDelete200Response - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AdminApiKeysDelete200Response> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdminApiKeysDelete200Response as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AdminApiKeysDelete200Response - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ApiKeyList {
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub object: Option<String>,

    #[serde(rename = "data")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<Vec<models::AdminApiKey>>,

    #[serde(rename = "has_more")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_more: Option<bool>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub first_id: Option<String>,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_id: Option<String>,

}



impl ApiKeyList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ApiKeyList {
        ApiKeyList {
 object: None,
 data: None,
 has_more: None,
 first_id: None,
 last_id: None,
        }
    }
}

/// Converts the ApiKeyList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ApiKeyList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.object.as_ref().map(|object| {
                [
                    "object".to_string(),
                    object.to_string(),
                ].join(",")
            }),

            // Skipping data in query parameter serialization


            self.has_more.as_ref().map(|has_more| {
                [
                    "has_more".to_string(),
                    has_more.to_string(),
                ].join(",")
            }),


            self.first_id.as_ref().map(|first_id| {
                [
                    "first_id".to_string(),
                    first_id.to_string(),
                ].join(",")
            }),


            self.last_id.as_ref().map(|last_id| {
                [
                    "last_id".to_string(),
                    last_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ApiKeyList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ApiKeyList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::AdminApiKey>>,
            pub has_more: Vec<bool>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ApiKeyList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ApiKeyList".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ApiKeyList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ApiKeyList {
            object: intermediate_rep.object.into_iter().next(),
            data: intermediate_rep.data.into_iter().next(),
            has_more: intermediate_rep.has_more.into_iter().next(),
            first_id: intermediate_rep.first_id.into_iter().next(),
            last_id: intermediate_rep.last_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ApiKeyList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ApiKeyList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ApiKeyList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ApiKeyList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ApiKeyList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ApiKeyList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ApiKeyList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum ArrayOfContentPartsInner {
    MessageContentImageFileObject(models::MessageContentImageFileObject),
    MessageContentImageUrlObject(models::MessageContentImageUrlObject),
    MessageRequestContentTextObject(models::MessageRequestContentTextObject),
}

impl validator::Validate for ArrayOfContentPartsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::MessageContentImageFileObject(v) => v.validate(),
            Self::MessageContentImageUrlObject(v) => v.validate(),
            Self::MessageRequestContentTextObject(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ArrayOfContentPartsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ArrayOfContentPartsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::MessageContentImageFileObject> for ArrayOfContentPartsInner {
    fn from(value: models::MessageContentImageFileObject) -> Self {
        Self::MessageContentImageFileObject(value)
    }
}
impl From<models::MessageContentImageUrlObject> for ArrayOfContentPartsInner {
    fn from(value: models::MessageContentImageUrlObject) -> Self {
        Self::MessageContentImageUrlObject(value)
    }
}
impl From<models::MessageRequestContentTextObject> for ArrayOfContentPartsInner {
    fn from(value: models::MessageRequestContentTextObject) -> Self {
        Self::MessageRequestContentTextObject(value)
    }
}





/// Represents an `assistant` that can call the model and use tools.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantObject {
    /// The identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The object type, which is always `assistant`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The Unix timestamp (in seconds) for when the assistant was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    /// The name of the assistant. The maximum length is 256 characters. 
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
    )]
    pub name: Nullable<String>,

    /// The description of the assistant. The maximum length is 512 characters. 
    #[serde(rename = "description")]
    #[validate(
            length(max = 512),
    )]
    pub description: Nullable<String>,

    /// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them. 
    #[serde(rename = "model")]
          #[validate(custom(function = "check_xss_string"))]
    pub model: String,

    /// The system instructions that the assistant uses. The maximum length is 256,000 characters. 
    #[serde(rename = "instructions")]
    #[validate(
            length(max = 256000),
    )]
    pub instructions: Nullable<String>,

    /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`. 
    #[serde(rename = "tools")]
    #[validate(
            length(max = 128),
          nested,
    )]
    pub tools: Vec<models::AssistantObjectToolsInner>,

    #[serde(rename = "tool_resources")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_resources: Option<Nullable<models::AssistantObjectToolResources>>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    pub metadata: crate::types::Object,

    /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
    #[serde(rename = "temperature")]
    #[validate(
            range(min = 0f64, max = 2f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<Nullable<f64>>,

    /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
    #[serde(rename = "top_p")]
    #[validate(
            range(min = 0f64, max = 1f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub top_p: Option<Nullable<f64>>,

    #[serde(rename = "response_format")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_format: Option<models::AssistantsApiResponseFormatOption>,

}



impl AssistantObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, created_at: i32, name: Nullable<String>, description: Nullable<String>, model: String, instructions: Nullable<String>, tools: Vec<models::AssistantObjectToolsInner>, metadata: crate::types::Object, ) -> AssistantObject {
        AssistantObject {
 id,
 object,
 created_at,
 name,
 description,
 model,
 instructions,
 tools,
 tool_resources: None,
 metadata,
 temperature: Some(Nullable::Present(1.0)),
 top_p: Some(Nullable::Present(1.0)),
 response_format: None,
        }
    }
}

/// Converts the AssistantObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("name".to_string()),
            Some(self.name.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("description".to_string()),
            Some(self.description.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("model".to_string()),
            Some(self.model.to_string()),


            Some("instructions".to_string()),
            Some(self.instructions.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping tools in query parameter serialization

            // Skipping tool_resources in query parameter serialization

            // Skipping metadata in query parameter serialization


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.top_p.as_ref().map(|top_p| {
                [
                    "top_p".to_string(),
                    top_p.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping response_format in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub created_at: Vec<i32>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub model: Vec<String>,
            pub instructions: Vec<String>,
            pub tools: Vec<Vec<models::AssistantObjectToolsInner>>,
            pub tool_resources: Vec<models::AssistantObjectToolResources>,
            pub metadata: Vec<crate::types::Object>,
            pub temperature: Vec<f64>,
            pub top_p: Vec<f64>,
            pub response_format: Vec<models::AssistantsApiResponseFormatOption>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AssistantObject".to_string()),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AssistantObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "instructions" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AssistantObject".to_string()),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in AssistantObject".to_string()),
                    "tool_resources" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AssistantObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "temperature" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AssistantObject".to_string()),
                    "top_p" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AssistantObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "response_format" => intermediate_rep.response_format.push(<models::AssistantsApiResponseFormatOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in AssistantObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in AssistantObject".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in AssistantObject".to_string())?,
            name: std::result::Result::Err("Nullable types not supported in AssistantObject".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in AssistantObject".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in AssistantObject".to_string())?,
            instructions: std::result::Result::Err("Nullable types not supported in AssistantObject".to_string())?,
            tools: intermediate_rep.tools.into_iter().next().ok_or_else(|| "tools missing in AssistantObject".to_string())?,
            tool_resources: std::result::Result::Err("Nullable types not supported in AssistantObject".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next().ok_or_else(|| "metadata missing in AssistantObject".to_string())?,
            temperature: std::result::Result::Err("Nullable types not supported in AssistantObject".to_string())?,
            top_p: std::result::Result::Err("Nullable types not supported in AssistantObject".to_string())?,
            response_format: intermediate_rep.response_format.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AssistantObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AssistantObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantObjectToolResources {
    #[serde(rename = "code_interpreter")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_interpreter: Option<models::AssistantObjectToolResourcesCodeInterpreter>,

    #[serde(rename = "file_search")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_search: Option<models::AssistantObjectToolResourcesFileSearch>,

}



impl AssistantObjectToolResources {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AssistantObjectToolResources {
        AssistantObjectToolResources {
 code_interpreter: None,
 file_search: None,
        }
    }
}

/// Converts the AssistantObjectToolResources value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantObjectToolResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping code_interpreter in query parameter serialization

            // Skipping file_search in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantObjectToolResources value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantObjectToolResources {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code_interpreter: Vec<models::AssistantObjectToolResourcesCodeInterpreter>,
            pub file_search: Vec<models::AssistantObjectToolResourcesFileSearch>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantObjectToolResources".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code_interpreter" => intermediate_rep.code_interpreter.push(<models::AssistantObjectToolResourcesCodeInterpreter as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_search" => intermediate_rep.file_search.push(<models::AssistantObjectToolResourcesFileSearch as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantObjectToolResources".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantObjectToolResources {
            code_interpreter: intermediate_rep.code_interpreter.into_iter().next(),
            file_search: intermediate_rep.file_search.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantObjectToolResources> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantObjectToolResources>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantObjectToolResources>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AssistantObjectToolResources - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantObjectToolResources> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantObjectToolResources as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AssistantObjectToolResources - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantObjectToolResourcesCodeInterpreter {
    /// A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter`` tool. There can be a maximum of 20 files associated with the tool. 
    #[serde(rename = "file_ids")]
    #[validate(
            length(max = 20),
          custom(function = "check_xss_vec_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_ids: Option<Vec<String>>,

}



impl AssistantObjectToolResourcesCodeInterpreter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AssistantObjectToolResourcesCodeInterpreter {
        AssistantObjectToolResourcesCodeInterpreter {
 file_ids: None,
        }
    }
}

/// Converts the AssistantObjectToolResourcesCodeInterpreter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantObjectToolResourcesCodeInterpreter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_ids.as_ref().map(|file_ids| {
                [
                    "file_ids".to_string(),
                    file_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantObjectToolResourcesCodeInterpreter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantObjectToolResourcesCodeInterpreter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_ids: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantObjectToolResourcesCodeInterpreter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "file_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in AssistantObjectToolResourcesCodeInterpreter".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantObjectToolResourcesCodeInterpreter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantObjectToolResourcesCodeInterpreter {
            file_ids: intermediate_rep.file_ids.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantObjectToolResourcesCodeInterpreter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantObjectToolResourcesCodeInterpreter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantObjectToolResourcesCodeInterpreter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AssistantObjectToolResourcesCodeInterpreter - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantObjectToolResourcesCodeInterpreter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantObjectToolResourcesCodeInterpreter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AssistantObjectToolResourcesCodeInterpreter - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantObjectToolResourcesFileSearch {
    /// The ID of the [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant. 
    #[serde(rename = "vector_store_ids")]
    #[validate(
            length(max = 1),
          custom(function = "check_xss_vec_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vector_store_ids: Option<Vec<String>>,

}



impl AssistantObjectToolResourcesFileSearch {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AssistantObjectToolResourcesFileSearch {
        AssistantObjectToolResourcesFileSearch {
 vector_store_ids: None,
        }
    }
}

/// Converts the AssistantObjectToolResourcesFileSearch value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantObjectToolResourcesFileSearch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.vector_store_ids.as_ref().map(|vector_store_ids| {
                [
                    "vector_store_ids".to_string(),
                    vector_store_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantObjectToolResourcesFileSearch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantObjectToolResourcesFileSearch {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub vector_store_ids: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantObjectToolResourcesFileSearch".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "vector_store_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in AssistantObjectToolResourcesFileSearch".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantObjectToolResourcesFileSearch".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantObjectToolResourcesFileSearch {
            vector_store_ids: intermediate_rep.vector_store_ids.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantObjectToolResourcesFileSearch> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantObjectToolResourcesFileSearch>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantObjectToolResourcesFileSearch>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AssistantObjectToolResourcesFileSearch - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantObjectToolResourcesFileSearch> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantObjectToolResourcesFileSearch as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AssistantObjectToolResourcesFileSearch - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum AssistantObjectToolsInner {
    AssistantToolsCode(models::AssistantToolsCode),
    AssistantToolsFileSearch(models::AssistantToolsFileSearch),
    AssistantToolsFunction(models::AssistantToolsFunction),
}

impl validator::Validate for AssistantObjectToolsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::AssistantToolsCode(v) => v.validate(),
            Self::AssistantToolsFileSearch(v) => v.validate(),
            Self::AssistantToolsFunction(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantObjectToolsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantObjectToolsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::AssistantToolsCode> for AssistantObjectToolsInner {
    fn from(value: models::AssistantToolsCode) -> Self {
        Self::AssistantToolsCode(value)
    }
}
impl From<models::AssistantToolsFileSearch> for AssistantObjectToolsInner {
    fn from(value: models::AssistantToolsFileSearch) -> Self {
        Self::AssistantToolsFileSearch(value)
    }
}
impl From<models::AssistantToolsFunction> for AssistantObjectToolsInner {
    fn from(value: models::AssistantToolsFunction) -> Self {
        Self::AssistantToolsFunction(value)
    }
}





/// Represents an event emitted when streaming a Run.  Each event in a server-sent events stream has an `event` and `data` property:  ``` event: thread.created data: {\"id\": \"thread_123\", \"object\": \"thread\", ...} ```  We emit events whenever a new object is created, transitions to a new state, or is being streamed in parts (deltas). For example, we emit `thread.run.created` when a new run is created, `thread.run.completed` when a run completes, and so on. When an Assistant chooses to create a message during a run, we emit a `thread.message.created event`, a `thread.message.in_progress` event, many `thread.message.delta` events, and finally a `thread.message.completed` event.  We may add additional events over time, so we recommend handling unknown events gracefully in your code. See the [Assistants API quickstart](/docs/assistants/overview) to learn how to integrate the Assistants API with streaming. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum AssistantStreamEvent {
    ThreadStreamEvent(models::ThreadStreamEvent),
    RunStreamEvent(models::RunStreamEvent),
    RunStepStreamEvent(models::RunStepStreamEvent),
    MessageStreamEvent(models::MessageStreamEvent),
    ErrorEvent(models::ErrorEvent),
    DoneEvent(models::DoneEvent),
}

impl validator::Validate for AssistantStreamEvent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::ThreadStreamEvent(v) => v.validate(),
            Self::RunStreamEvent(v) => v.validate(),
            Self::RunStepStreamEvent(v) => v.validate(),
            Self::MessageStreamEvent(v) => v.validate(),
            Self::ErrorEvent(v) => v.validate(),
            Self::DoneEvent(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantStreamEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantStreamEvent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::ThreadStreamEvent> for AssistantStreamEvent {
    fn from(value: models::ThreadStreamEvent) -> Self {
        Self::ThreadStreamEvent(value)
    }
}
impl From<models::RunStreamEvent> for AssistantStreamEvent {
    fn from(value: models::RunStreamEvent) -> Self {
        Self::RunStreamEvent(value)
    }
}
impl From<models::RunStepStreamEvent> for AssistantStreamEvent {
    fn from(value: models::RunStepStreamEvent) -> Self {
        Self::RunStepStreamEvent(value)
    }
}
impl From<models::MessageStreamEvent> for AssistantStreamEvent {
    fn from(value: models::MessageStreamEvent) -> Self {
        Self::MessageStreamEvent(value)
    }
}
impl From<models::ErrorEvent> for AssistantStreamEvent {
    fn from(value: models::ErrorEvent) -> Self {
        Self::ErrorEvent(value)
    }
}
impl From<models::DoneEvent> for AssistantStreamEvent {
    fn from(value: models::DoneEvent) -> Self {
        Self::DoneEvent(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantToolsCode {
    /// The type of tool being defined: `code_interpreter`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

}



impl AssistantToolsCode {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> AssistantToolsCode {
        AssistantToolsCode {
 r_type,
        }
    }
}

/// Converts the AssistantToolsCode value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantToolsCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantToolsCode value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantToolsCode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantToolsCode".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantToolsCode".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantToolsCode {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in AssistantToolsCode".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantToolsCode> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantToolsCode>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantToolsCode>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AssistantToolsCode - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantToolsCode> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantToolsCode as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AssistantToolsCode - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantToolsFileSearch {
    /// The type of tool being defined: `file_search`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "file_search")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_search: Option<models::AssistantToolsFileSearchFileSearch>,

}



impl AssistantToolsFileSearch {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> AssistantToolsFileSearch {
        AssistantToolsFileSearch {
 r_type,
 file_search: None,
        }
    }
}

/// Converts the AssistantToolsFileSearch value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantToolsFileSearch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping file_search in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantToolsFileSearch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantToolsFileSearch {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub file_search: Vec<models::AssistantToolsFileSearchFileSearch>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantToolsFileSearch".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_search" => intermediate_rep.file_search.push(<models::AssistantToolsFileSearchFileSearch as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantToolsFileSearch".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantToolsFileSearch {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in AssistantToolsFileSearch".to_string())?,
            file_search: intermediate_rep.file_search.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantToolsFileSearch> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantToolsFileSearch>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantToolsFileSearch>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AssistantToolsFileSearch - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantToolsFileSearch> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantToolsFileSearch as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AssistantToolsFileSearch - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Overrides for the file search tool.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantToolsFileSearchFileSearch {
    /// The maximum number of results the file search tool should output. The default is 20 for `gpt-4*` models and 5 for `gpt-3.5-turbo`. This number should be between 1 and 50 inclusive.  Note that the file search tool may output fewer than `max_num_results` results. See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
    #[serde(rename = "max_num_results")]
    #[validate(
            range(min = 1u8, max = 50u8),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_num_results: Option<u8>,

    #[serde(rename = "ranking_options")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ranking_options: Option<models::FileSearchRankingOptions>,

}



impl AssistantToolsFileSearchFileSearch {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AssistantToolsFileSearchFileSearch {
        AssistantToolsFileSearchFileSearch {
 max_num_results: None,
 ranking_options: None,
        }
    }
}

/// Converts the AssistantToolsFileSearchFileSearch value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantToolsFileSearchFileSearch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.max_num_results.as_ref().map(|max_num_results| {
                [
                    "max_num_results".to_string(),
                    max_num_results.to_string(),
                ].join(",")
            }),

            // Skipping ranking_options in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantToolsFileSearchFileSearch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantToolsFileSearchFileSearch {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub max_num_results: Vec<u8>,
            pub ranking_options: Vec<models::FileSearchRankingOptions>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantToolsFileSearchFileSearch".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "max_num_results" => intermediate_rep.max_num_results.push(<u8 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ranking_options" => intermediate_rep.ranking_options.push(<models::FileSearchRankingOptions as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantToolsFileSearchFileSearch".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantToolsFileSearchFileSearch {
            max_num_results: intermediate_rep.max_num_results.into_iter().next(),
            ranking_options: intermediate_rep.ranking_options.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantToolsFileSearchFileSearch> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantToolsFileSearchFileSearch>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantToolsFileSearchFileSearch>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AssistantToolsFileSearchFileSearch - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantToolsFileSearchFileSearch> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantToolsFileSearchFileSearch as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AssistantToolsFileSearchFileSearch - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantToolsFileSearchTypeOnly {
    /// The type of tool being defined: `file_search`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

}



impl AssistantToolsFileSearchTypeOnly {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> AssistantToolsFileSearchTypeOnly {
        AssistantToolsFileSearchTypeOnly {
 r_type,
        }
    }
}

/// Converts the AssistantToolsFileSearchTypeOnly value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantToolsFileSearchTypeOnly {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantToolsFileSearchTypeOnly value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantToolsFileSearchTypeOnly {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantToolsFileSearchTypeOnly".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantToolsFileSearchTypeOnly".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantToolsFileSearchTypeOnly {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in AssistantToolsFileSearchTypeOnly".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantToolsFileSearchTypeOnly> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantToolsFileSearchTypeOnly>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantToolsFileSearchTypeOnly>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AssistantToolsFileSearchTypeOnly - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantToolsFileSearchTypeOnly> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantToolsFileSearchTypeOnly as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AssistantToolsFileSearchTypeOnly - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantToolsFunction {
    /// The type of tool being defined: `function`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "function")]
          #[validate(nested)]
    pub function: models::FunctionObject,

}



impl AssistantToolsFunction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, function: models::FunctionObject, ) -> AssistantToolsFunction {
        AssistantToolsFunction {
 r_type,
 function,
        }
    }
}

/// Converts the AssistantToolsFunction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantToolsFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantToolsFunction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantToolsFunction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub function: Vec<models::FunctionObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantToolsFunction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::FunctionObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantToolsFunction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantToolsFunction {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in AssistantToolsFunction".to_string())?,
            function: intermediate_rep.function.into_iter().next().ok_or_else(|| "function missing in AssistantToolsFunction".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantToolsFunction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantToolsFunction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantToolsFunction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AssistantToolsFunction - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantToolsFunction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantToolsFunction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AssistantToolsFunction - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.  Setting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).  Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the message the model generates is valid JSON.  **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \"stuck\" request. Also note that the message content may be partially cut off if `finish_reason=\"length\"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum AssistantsApiResponseFormatOption {
    String(String),
    ResponseFormatText(models::ResponseFormatText),
    ResponseFormatJsonObject(models::ResponseFormatJsonObject),
    ResponseFormatJsonSchema(models::ResponseFormatJsonSchema),
}

impl validator::Validate for AssistantsApiResponseFormatOption
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::ResponseFormatText(v) => v.validate(),
            Self::ResponseFormatJsonObject(v) => v.validate(),
            Self::ResponseFormatJsonSchema(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantsApiResponseFormatOption value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantsApiResponseFormatOption {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for AssistantsApiResponseFormatOption {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<models::ResponseFormatText> for AssistantsApiResponseFormatOption {
    fn from(value: models::ResponseFormatText) -> Self {
        Self::ResponseFormatText(value)
    }
}
impl From<models::ResponseFormatJsonObject> for AssistantsApiResponseFormatOption {
    fn from(value: models::ResponseFormatJsonObject) -> Self {
        Self::ResponseFormatJsonObject(value)
    }
}
impl From<models::ResponseFormatJsonSchema> for AssistantsApiResponseFormatOption {
    fn from(value: models::ResponseFormatJsonSchema) -> Self {
        Self::ResponseFormatJsonSchema(value)
    }
}





/// Controls which (if any) tool is called by the model. `none` means the model will not call any tools and instead generates a message. `auto` is the default value and means the model can pick between generating a message or calling one or more tools. `required` means the model must call one or more tools before responding to the user. Specifying a particular tool like `{\"type\": \"file_search\"}` or `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum AssistantsApiToolChoiceOption {
    String(String),
    AssistantsNamedToolChoice(models::AssistantsNamedToolChoice),
}

impl validator::Validate for AssistantsApiToolChoiceOption
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::AssistantsNamedToolChoice(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantsApiToolChoiceOption value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantsApiToolChoiceOption {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for AssistantsApiToolChoiceOption {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<models::AssistantsNamedToolChoice> for AssistantsApiToolChoiceOption {
    fn from(value: models::AssistantsNamedToolChoice) -> Self {
        Self::AssistantsNamedToolChoice(value)
    }
}





/// Specifies a tool the model should use. Use to force the model to call a specific tool.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantsNamedToolChoice {
    /// The type of the tool. If type is `function`, the function name must be set
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "function")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub function: Option<models::AssistantsNamedToolChoiceFunction>,

}



impl AssistantsNamedToolChoice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> AssistantsNamedToolChoice {
        AssistantsNamedToolChoice {
 r_type,
 function: None,
        }
    }
}

/// Converts the AssistantsNamedToolChoice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantsNamedToolChoice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantsNamedToolChoice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantsNamedToolChoice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub function: Vec<models::AssistantsNamedToolChoiceFunction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantsNamedToolChoice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::AssistantsNamedToolChoiceFunction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantsNamedToolChoice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantsNamedToolChoice {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in AssistantsNamedToolChoice".to_string())?,
            function: intermediate_rep.function.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantsNamedToolChoice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantsNamedToolChoice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantsNamedToolChoice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AssistantsNamedToolChoice - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantsNamedToolChoice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantsNamedToolChoice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AssistantsNamedToolChoice - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AssistantsNamedToolChoiceFunction {
    /// The name of the function to call.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

}



impl AssistantsNamedToolChoiceFunction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> AssistantsNamedToolChoiceFunction {
        AssistantsNamedToolChoiceFunction {
 name,
        }
    }
}

/// Converts the AssistantsNamedToolChoiceFunction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AssistantsNamedToolChoiceFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AssistantsNamedToolChoiceFunction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AssistantsNamedToolChoiceFunction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AssistantsNamedToolChoiceFunction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AssistantsNamedToolChoiceFunction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AssistantsNamedToolChoiceFunction {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in AssistantsNamedToolChoiceFunction".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AssistantsNamedToolChoiceFunction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AssistantsNamedToolChoiceFunction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AssistantsNamedToolChoiceFunction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AssistantsNamedToolChoiceFunction - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AssistantsNamedToolChoiceFunction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AssistantsNamedToolChoiceFunction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AssistantsNamedToolChoiceFunction - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`. 
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types, clippy::large_enum_variant)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AudioResponseFormat {
    #[serde(rename = "json")]
    Json,
    #[serde(rename = "text")]
    Text,
    #[serde(rename = "srt")]
    Srt,
    #[serde(rename = "verbose_json")]
    VerboseJson,
    #[serde(rename = "vtt")]
    Vtt,
}

impl validator::Validate for AudioResponseFormat
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::fmt::Display for AudioResponseFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AudioResponseFormat::Json => write!(f, "json"),
            AudioResponseFormat::Text => write!(f, "text"),
            AudioResponseFormat::Srt => write!(f, "srt"),
            AudioResponseFormat::VerboseJson => write!(f, "verbose_json"),
            AudioResponseFormat::Vtt => write!(f, "vtt"),
        }
    }
}

impl std::str::FromStr for AudioResponseFormat {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "json" => std::result::Result::Ok(AudioResponseFormat::Json),
            "text" => std::result::Result::Ok(AudioResponseFormat::Text),
            "srt" => std::result::Result::Ok(AudioResponseFormat::Srt),
            "verbose_json" => std::result::Result::Ok(AudioResponseFormat::VerboseJson),
            "vtt" => std::result::Result::Ok(AudioResponseFormat::Vtt),
            _ => std::result::Result::Err(format!(r#"Value not valid: {s}"#)),
        }
    }
}


/// A log of a user action or configuration change within this organization.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLog {
    /// The ID of this log.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    #[serde(rename = "type")]
          #[validate(nested)]
    pub r_type: models::AuditLogEventType,

    /// The Unix timestamp (in seconds) of the event.
    #[serde(rename = "effective_at")]
    pub effective_at: i32,

    #[serde(rename = "project")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub project: Option<models::AuditLogProject>,

    #[serde(rename = "actor")]
          #[validate(nested)]
    pub actor: models::AuditLogActor,

    #[serde(rename = "api_key.created")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key_created: Option<models::AuditLogApiKeyCreated>,

    #[serde(rename = "api_key.updated")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key_updated: Option<models::AuditLogApiKeyUpdated>,

    #[serde(rename = "api_key.deleted")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key_deleted: Option<models::AuditLogApiKeyDeleted>,

    #[serde(rename = "invite.sent")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub invite_sent: Option<models::AuditLogInviteSent>,

    #[serde(rename = "invite.accepted")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub invite_accepted: Option<models::AuditLogInviteAccepted>,

    #[serde(rename = "invite.deleted")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub invite_deleted: Option<models::AuditLogInviteAccepted>,

    #[serde(rename = "login.failed")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub login_failed: Option<models::AuditLogLoginFailed>,

    #[serde(rename = "logout.failed")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logout_failed: Option<models::AuditLogLoginFailed>,

    #[serde(rename = "organization.updated")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_updated: Option<models::AuditLogOrganizationUpdated>,

    #[serde(rename = "project.created")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_created: Option<models::AuditLogProjectCreated>,

    #[serde(rename = "project.updated")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_updated: Option<models::AuditLogProjectUpdated>,

    #[serde(rename = "project.archived")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_archived: Option<models::AuditLogProjectArchived>,

    #[serde(rename = "rate_limit.updated")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate_limit_updated: Option<models::AuditLogRateLimitUpdated>,

    #[serde(rename = "rate_limit.deleted")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate_limit_deleted: Option<models::AuditLogRateLimitDeleted>,

    #[serde(rename = "service_account.created")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_account_created: Option<models::AuditLogServiceAccountCreated>,

    #[serde(rename = "service_account.updated")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_account_updated: Option<models::AuditLogServiceAccountUpdated>,

    #[serde(rename = "service_account.deleted")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_account_deleted: Option<models::AuditLogServiceAccountDeleted>,

    #[serde(rename = "user.added")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_added: Option<models::AuditLogUserAdded>,

    #[serde(rename = "user.updated")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_updated: Option<models::AuditLogUserUpdated>,

    #[serde(rename = "user.deleted")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_deleted: Option<models::AuditLogUserDeleted>,

}



impl AuditLog {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, r_type: models::AuditLogEventType, effective_at: i32, actor: models::AuditLogActor, ) -> AuditLog {
        AuditLog {
 id,
 r_type,
 effective_at,
 project: None,
 actor,
 api_key_created: None,
 api_key_updated: None,
 api_key_deleted: None,
 invite_sent: None,
 invite_accepted: None,
 invite_deleted: None,
 login_failed: None,
 logout_failed: None,
 organization_updated: None,
 project_created: None,
 project_updated: None,
 project_archived: None,
 rate_limit_updated: None,
 rate_limit_deleted: None,
 service_account_created: None,
 service_account_updated: None,
 service_account_deleted: None,
 user_added: None,
 user_updated: None,
 user_deleted: None,
        }
    }
}

/// Converts the AuditLog value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLog {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),

            // Skipping type in query parameter serialization


            Some("effective_at".to_string()),
            Some(self.effective_at.to_string()),

            // Skipping project in query parameter serialization

            // Skipping actor in query parameter serialization

            // Skipping api_key.created in query parameter serialization

            // Skipping api_key.updated in query parameter serialization

            // Skipping api_key.deleted in query parameter serialization

            // Skipping invite.sent in query parameter serialization

            // Skipping invite.accepted in query parameter serialization

            // Skipping invite.deleted in query parameter serialization

            // Skipping login.failed in query parameter serialization

            // Skipping logout.failed in query parameter serialization

            // Skipping organization.updated in query parameter serialization

            // Skipping project.created in query parameter serialization

            // Skipping project.updated in query parameter serialization

            // Skipping project.archived in query parameter serialization

            // Skipping rate_limit.updated in query parameter serialization

            // Skipping rate_limit.deleted in query parameter serialization

            // Skipping service_account.created in query parameter serialization

            // Skipping service_account.updated in query parameter serialization

            // Skipping service_account.deleted in query parameter serialization

            // Skipping user.added in query parameter serialization

            // Skipping user.updated in query parameter serialization

            // Skipping user.deleted in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLog value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLog {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r_type: Vec<models::AuditLogEventType>,
            pub effective_at: Vec<i32>,
            pub project: Vec<models::AuditLogProject>,
            pub actor: Vec<models::AuditLogActor>,
            pub api_key_created: Vec<models::AuditLogApiKeyCreated>,
            pub api_key_updated: Vec<models::AuditLogApiKeyUpdated>,
            pub api_key_deleted: Vec<models::AuditLogApiKeyDeleted>,
            pub invite_sent: Vec<models::AuditLogInviteSent>,
            pub invite_accepted: Vec<models::AuditLogInviteAccepted>,
            pub invite_deleted: Vec<models::AuditLogInviteAccepted>,
            pub login_failed: Vec<models::AuditLogLoginFailed>,
            pub logout_failed: Vec<models::AuditLogLoginFailed>,
            pub organization_updated: Vec<models::AuditLogOrganizationUpdated>,
            pub project_created: Vec<models::AuditLogProjectCreated>,
            pub project_updated: Vec<models::AuditLogProjectUpdated>,
            pub project_archived: Vec<models::AuditLogProjectArchived>,
            pub rate_limit_updated: Vec<models::AuditLogRateLimitUpdated>,
            pub rate_limit_deleted: Vec<models::AuditLogRateLimitDeleted>,
            pub service_account_created: Vec<models::AuditLogServiceAccountCreated>,
            pub service_account_updated: Vec<models::AuditLogServiceAccountUpdated>,
            pub service_account_deleted: Vec<models::AuditLogServiceAccountDeleted>,
            pub user_added: Vec<models::AuditLogUserAdded>,
            pub user_updated: Vec<models::AuditLogUserUpdated>,
            pub user_deleted: Vec<models::AuditLogUserDeleted>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLog".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<models::AuditLogEventType as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "effective_at" => intermediate_rep.effective_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "project" => intermediate_rep.project.push(<models::AuditLogProject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "actor" => intermediate_rep.actor.push(<models::AuditLogActor as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "api_key.created" => intermediate_rep.api_key_created.push(<models::AuditLogApiKeyCreated as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "api_key.updated" => intermediate_rep.api_key_updated.push(<models::AuditLogApiKeyUpdated as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "api_key.deleted" => intermediate_rep.api_key_deleted.push(<models::AuditLogApiKeyDeleted as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "invite.sent" => intermediate_rep.invite_sent.push(<models::AuditLogInviteSent as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "invite.accepted" => intermediate_rep.invite_accepted.push(<models::AuditLogInviteAccepted as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "invite.deleted" => intermediate_rep.invite_deleted.push(<models::AuditLogInviteAccepted as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "login.failed" => intermediate_rep.login_failed.push(<models::AuditLogLoginFailed as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "logout.failed" => intermediate_rep.logout_failed.push(<models::AuditLogLoginFailed as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "organization.updated" => intermediate_rep.organization_updated.push(<models::AuditLogOrganizationUpdated as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "project.created" => intermediate_rep.project_created.push(<models::AuditLogProjectCreated as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "project.updated" => intermediate_rep.project_updated.push(<models::AuditLogProjectUpdated as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "project.archived" => intermediate_rep.project_archived.push(<models::AuditLogProjectArchived as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rate_limit.updated" => intermediate_rep.rate_limit_updated.push(<models::AuditLogRateLimitUpdated as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rate_limit.deleted" => intermediate_rep.rate_limit_deleted.push(<models::AuditLogRateLimitDeleted as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "service_account.created" => intermediate_rep.service_account_created.push(<models::AuditLogServiceAccountCreated as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "service_account.updated" => intermediate_rep.service_account_updated.push(<models::AuditLogServiceAccountUpdated as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "service_account.deleted" => intermediate_rep.service_account_deleted.push(<models::AuditLogServiceAccountDeleted as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user.added" => intermediate_rep.user_added.push(<models::AuditLogUserAdded as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user.updated" => intermediate_rep.user_updated.push(<models::AuditLogUserUpdated as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user.deleted" => intermediate_rep.user_deleted.push(<models::AuditLogUserDeleted as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLog".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLog {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in AuditLog".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in AuditLog".to_string())?,
            effective_at: intermediate_rep.effective_at.into_iter().next().ok_or_else(|| "effective_at missing in AuditLog".to_string())?,
            project: intermediate_rep.project.into_iter().next(),
            actor: intermediate_rep.actor.into_iter().next().ok_or_else(|| "actor missing in AuditLog".to_string())?,
            api_key_created: intermediate_rep.api_key_created.into_iter().next(),
            api_key_updated: intermediate_rep.api_key_updated.into_iter().next(),
            api_key_deleted: intermediate_rep.api_key_deleted.into_iter().next(),
            invite_sent: intermediate_rep.invite_sent.into_iter().next(),
            invite_accepted: intermediate_rep.invite_accepted.into_iter().next(),
            invite_deleted: intermediate_rep.invite_deleted.into_iter().next(),
            login_failed: intermediate_rep.login_failed.into_iter().next(),
            logout_failed: intermediate_rep.logout_failed.into_iter().next(),
            organization_updated: intermediate_rep.organization_updated.into_iter().next(),
            project_created: intermediate_rep.project_created.into_iter().next(),
            project_updated: intermediate_rep.project_updated.into_iter().next(),
            project_archived: intermediate_rep.project_archived.into_iter().next(),
            rate_limit_updated: intermediate_rep.rate_limit_updated.into_iter().next(),
            rate_limit_deleted: intermediate_rep.rate_limit_deleted.into_iter().next(),
            service_account_created: intermediate_rep.service_account_created.into_iter().next(),
            service_account_updated: intermediate_rep.service_account_updated.into_iter().next(),
            service_account_deleted: intermediate_rep.service_account_deleted.into_iter().next(),
            user_added: intermediate_rep.user_added.into_iter().next(),
            user_updated: intermediate_rep.user_updated.into_iter().next(),
            user_deleted: intermediate_rep.user_deleted.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLog> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLog>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLog>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLog - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLog> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLog as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLog - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The actor who performed the audit logged action.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogActor {
    /// The type of actor. Is either `session` or `api_key`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    #[serde(rename = "session")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub session: Option<models::AuditLogActorSession>,

    #[serde(rename = "api_key")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key: Option<models::AuditLogActorApiKey>,

}



impl AuditLogActor {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogActor {
        AuditLogActor {
 r_type: None,
 session: None,
 api_key: None,
        }
    }
}

/// Converts the AuditLogActor value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogActor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),

            // Skipping session in query parameter serialization

            // Skipping api_key in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogActor value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogActor {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub session: Vec<models::AuditLogActorSession>,
            pub api_key: Vec<models::AuditLogActorApiKey>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogActor".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "session" => intermediate_rep.session.push(<models::AuditLogActorSession as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "api_key" => intermediate_rep.api_key.push(<models::AuditLogActorApiKey as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogActor".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogActor {
            r_type: intermediate_rep.r_type.into_iter().next(),
            session: intermediate_rep.session.into_iter().next(),
            api_key: intermediate_rep.api_key.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogActor> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogActor>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogActor>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogActor - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogActor> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogActor as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogActor - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The API Key used to perform the audit logged action.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogActorApiKey {
    /// The tracking id of the API key.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// The type of API key. Can be either `user` or `service_account`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    #[serde(rename = "user")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<models::AuditLogActorUser>,

    #[serde(rename = "service_account")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_account: Option<models::AuditLogActorServiceAccount>,

}



impl AuditLogActorApiKey {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogActorApiKey {
        AuditLogActorApiKey {
 id: None,
 r_type: None,
 user: None,
 service_account: None,
        }
    }
}

/// Converts the AuditLogActorApiKey value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogActorApiKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),

            // Skipping user in query parameter serialization

            // Skipping service_account in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogActorApiKey value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogActorApiKey {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r_type: Vec<String>,
            pub user: Vec<models::AuditLogActorUser>,
            pub service_account: Vec<models::AuditLogActorServiceAccount>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogActorApiKey".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<models::AuditLogActorUser as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "service_account" => intermediate_rep.service_account.push(<models::AuditLogActorServiceAccount as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogActorApiKey".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogActorApiKey {
            id: intermediate_rep.id.into_iter().next(),
            r_type: intermediate_rep.r_type.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
            service_account: intermediate_rep.service_account.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogActorApiKey> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogActorApiKey>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogActorApiKey>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogActorApiKey - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogActorApiKey> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogActorApiKey as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogActorApiKey - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The service account that performed the audit logged action.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogActorServiceAccount {
    /// The service account id.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}



impl AuditLogActorServiceAccount {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogActorServiceAccount {
        AuditLogActorServiceAccount {
 id: None,
        }
    }
}

/// Converts the AuditLogActorServiceAccount value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogActorServiceAccount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogActorServiceAccount value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogActorServiceAccount {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogActorServiceAccount".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogActorServiceAccount".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogActorServiceAccount {
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogActorServiceAccount> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogActorServiceAccount>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogActorServiceAccount>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogActorServiceAccount - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogActorServiceAccount> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogActorServiceAccount as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogActorServiceAccount - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The session in which the audit logged action was performed.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogActorSession {
    #[serde(rename = "user")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<models::AuditLogActorUser>,

    /// The IP address from which the action was performed.
    #[serde(rename = "ip_address")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ip_address: Option<String>,

}



impl AuditLogActorSession {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogActorSession {
        AuditLogActorSession {
 user: None,
 ip_address: None,
        }
    }
}

/// Converts the AuditLogActorSession value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogActorSession {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping user in query parameter serialization


            self.ip_address.as_ref().map(|ip_address| {
                [
                    "ip_address".to_string(),
                    ip_address.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogActorSession value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogActorSession {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub user: Vec<models::AuditLogActorUser>,
            pub ip_address: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogActorSession".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<models::AuditLogActorUser as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "ip_address" => intermediate_rep.ip_address.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogActorSession".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogActorSession {
            user: intermediate_rep.user.into_iter().next(),
            ip_address: intermediate_rep.ip_address.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogActorSession> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogActorSession>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogActorSession>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogActorSession - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogActorSession> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogActorSession as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogActorSession - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The user who performed the audit logged action.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogActorUser {
    /// The user id.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// The user email.
    #[serde(rename = "email")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,

}



impl AuditLogActorUser {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogActorUser {
        AuditLogActorUser {
 id: None,
 email: None,
        }
    }
}

/// Converts the AuditLogActorUser value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogActorUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.email.as_ref().map(|email| {
                [
                    "email".to_string(),
                    email.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogActorUser value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogActorUser {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub email: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogActorUser".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogActorUser".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogActorUser {
            id: intermediate_rep.id.into_iter().next(),
            email: intermediate_rep.email.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogActorUser> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogActorUser>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogActorUser>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogActorUser - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogActorUser> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogActorUser as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogActorUser - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogApiKeyCreated {
    /// The tracking ID of the API key.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "data")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<models::AuditLogApiKeyCreatedData>,

}



impl AuditLogApiKeyCreated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogApiKeyCreated {
        AuditLogApiKeyCreated {
 id: None,
 data: None,
        }
    }
}

/// Converts the AuditLogApiKeyCreated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogApiKeyCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogApiKeyCreated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogApiKeyCreated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub data: Vec<models::AuditLogApiKeyCreatedData>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogApiKeyCreated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::AuditLogApiKeyCreatedData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogApiKeyCreated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogApiKeyCreated {
            id: intermediate_rep.id.into_iter().next(),
            data: intermediate_rep.data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogApiKeyCreated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogApiKeyCreated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogApiKeyCreated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogApiKeyCreated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogApiKeyCreated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogApiKeyCreated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogApiKeyCreated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The payload used to create the API key.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogApiKeyCreatedData {
    /// A list of scopes allowed for the API key, e.g. `[\"api.model.request\"]`
    #[serde(rename = "scopes")]
          #[validate(custom(function = "check_xss_vec_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scopes: Option<Vec<String>>,

}



impl AuditLogApiKeyCreatedData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogApiKeyCreatedData {
        AuditLogApiKeyCreatedData {
 scopes: None,
        }
    }
}

/// Converts the AuditLogApiKeyCreatedData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogApiKeyCreatedData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.scopes.as_ref().map(|scopes| {
                [
                    "scopes".to_string(),
                    scopes.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogApiKeyCreatedData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogApiKeyCreatedData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub scopes: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogApiKeyCreatedData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "scopes" => return std::result::Result::Err("Parsing a container in this style is not supported in AuditLogApiKeyCreatedData".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogApiKeyCreatedData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogApiKeyCreatedData {
            scopes: intermediate_rep.scopes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogApiKeyCreatedData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogApiKeyCreatedData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogApiKeyCreatedData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogApiKeyCreatedData - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogApiKeyCreatedData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogApiKeyCreatedData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogApiKeyCreatedData - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogApiKeyDeleted {
    /// The tracking ID of the API key.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}



impl AuditLogApiKeyDeleted {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogApiKeyDeleted {
        AuditLogApiKeyDeleted {
 id: None,
        }
    }
}

/// Converts the AuditLogApiKeyDeleted value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogApiKeyDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogApiKeyDeleted value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogApiKeyDeleted {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogApiKeyDeleted".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogApiKeyDeleted".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogApiKeyDeleted {
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogApiKeyDeleted> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogApiKeyDeleted>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogApiKeyDeleted>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogApiKeyDeleted - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogApiKeyDeleted> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogApiKeyDeleted as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogApiKeyDeleted - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogApiKeyUpdated {
    /// The tracking ID of the API key.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "changes_requested")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes_requested: Option<models::AuditLogApiKeyUpdatedChangesRequested>,

}



impl AuditLogApiKeyUpdated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogApiKeyUpdated {
        AuditLogApiKeyUpdated {
 id: None,
 changes_requested: None,
        }
    }
}

/// Converts the AuditLogApiKeyUpdated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogApiKeyUpdated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping changes_requested in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogApiKeyUpdated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogApiKeyUpdated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub changes_requested: Vec<models::AuditLogApiKeyUpdatedChangesRequested>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogApiKeyUpdated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "changes_requested" => intermediate_rep.changes_requested.push(<models::AuditLogApiKeyUpdatedChangesRequested as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogApiKeyUpdated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogApiKeyUpdated {
            id: intermediate_rep.id.into_iter().next(),
            changes_requested: intermediate_rep.changes_requested.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogApiKeyUpdated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogApiKeyUpdated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogApiKeyUpdated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogApiKeyUpdated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogApiKeyUpdated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogApiKeyUpdated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogApiKeyUpdated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The payload used to update the API key.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogApiKeyUpdatedChangesRequested {
    /// A list of scopes allowed for the API key, e.g. `[\"api.model.request\"]`
    #[serde(rename = "scopes")]
          #[validate(custom(function = "check_xss_vec_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scopes: Option<Vec<String>>,

}



impl AuditLogApiKeyUpdatedChangesRequested {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogApiKeyUpdatedChangesRequested {
        AuditLogApiKeyUpdatedChangesRequested {
 scopes: None,
        }
    }
}

/// Converts the AuditLogApiKeyUpdatedChangesRequested value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogApiKeyUpdatedChangesRequested {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.scopes.as_ref().map(|scopes| {
                [
                    "scopes".to_string(),
                    scopes.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogApiKeyUpdatedChangesRequested value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogApiKeyUpdatedChangesRequested {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub scopes: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogApiKeyUpdatedChangesRequested".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "scopes" => return std::result::Result::Err("Parsing a container in this style is not supported in AuditLogApiKeyUpdatedChangesRequested".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogApiKeyUpdatedChangesRequested".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogApiKeyUpdatedChangesRequested {
            scopes: intermediate_rep.scopes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogApiKeyUpdatedChangesRequested> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogApiKeyUpdatedChangesRequested>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogApiKeyUpdatedChangesRequested>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogApiKeyUpdatedChangesRequested - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogApiKeyUpdatedChangesRequested> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogApiKeyUpdatedChangesRequested as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogApiKeyUpdatedChangesRequested - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The event type.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types, clippy::large_enum_variant)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AuditLogEventType {
    #[serde(rename = "api_key.created")]
    ApiKeyCreated,
    #[serde(rename = "api_key.updated")]
    ApiKeyUpdated,
    #[serde(rename = "api_key.deleted")]
    ApiKeyDeleted,
    #[serde(rename = "invite.sent")]
    InviteSent,
    #[serde(rename = "invite.accepted")]
    InviteAccepted,
    #[serde(rename = "invite.deleted")]
    InviteDeleted,
    #[serde(rename = "login.succeeded")]
    LoginSucceeded,
    #[serde(rename = "login.failed")]
    LoginFailed,
    #[serde(rename = "logout.succeeded")]
    LogoutSucceeded,
    #[serde(rename = "logout.failed")]
    LogoutFailed,
    #[serde(rename = "organization.updated")]
    OrganizationUpdated,
    #[serde(rename = "project.created")]
    ProjectCreated,
    #[serde(rename = "project.updated")]
    ProjectUpdated,
    #[serde(rename = "project.archived")]
    ProjectArchived,
    #[serde(rename = "service_account.created")]
    ServiceAccountCreated,
    #[serde(rename = "service_account.updated")]
    ServiceAccountUpdated,
    #[serde(rename = "service_account.deleted")]
    ServiceAccountDeleted,
    #[serde(rename = "rate_limit.updated")]
    RateLimitUpdated,
    #[serde(rename = "rate_limit.deleted")]
    RateLimitDeleted,
    #[serde(rename = "user.added")]
    UserAdded,
    #[serde(rename = "user.updated")]
    UserUpdated,
    #[serde(rename = "user.deleted")]
    UserDeleted,
}

impl validator::Validate for AuditLogEventType
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::fmt::Display for AuditLogEventType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AuditLogEventType::ApiKeyCreated => write!(f, "api_key.created"),
            AuditLogEventType::ApiKeyUpdated => write!(f, "api_key.updated"),
            AuditLogEventType::ApiKeyDeleted => write!(f, "api_key.deleted"),
            AuditLogEventType::InviteSent => write!(f, "invite.sent"),
            AuditLogEventType::InviteAccepted => write!(f, "invite.accepted"),
            AuditLogEventType::InviteDeleted => write!(f, "invite.deleted"),
            AuditLogEventType::LoginSucceeded => write!(f, "login.succeeded"),
            AuditLogEventType::LoginFailed => write!(f, "login.failed"),
            AuditLogEventType::LogoutSucceeded => write!(f, "logout.succeeded"),
            AuditLogEventType::LogoutFailed => write!(f, "logout.failed"),
            AuditLogEventType::OrganizationUpdated => write!(f, "organization.updated"),
            AuditLogEventType::ProjectCreated => write!(f, "project.created"),
            AuditLogEventType::ProjectUpdated => write!(f, "project.updated"),
            AuditLogEventType::ProjectArchived => write!(f, "project.archived"),
            AuditLogEventType::ServiceAccountCreated => write!(f, "service_account.created"),
            AuditLogEventType::ServiceAccountUpdated => write!(f, "service_account.updated"),
            AuditLogEventType::ServiceAccountDeleted => write!(f, "service_account.deleted"),
            AuditLogEventType::RateLimitUpdated => write!(f, "rate_limit.updated"),
            AuditLogEventType::RateLimitDeleted => write!(f, "rate_limit.deleted"),
            AuditLogEventType::UserAdded => write!(f, "user.added"),
            AuditLogEventType::UserUpdated => write!(f, "user.updated"),
            AuditLogEventType::UserDeleted => write!(f, "user.deleted"),
        }
    }
}

impl std::str::FromStr for AuditLogEventType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "api_key.created" => std::result::Result::Ok(AuditLogEventType::ApiKeyCreated),
            "api_key.updated" => std::result::Result::Ok(AuditLogEventType::ApiKeyUpdated),
            "api_key.deleted" => std::result::Result::Ok(AuditLogEventType::ApiKeyDeleted),
            "invite.sent" => std::result::Result::Ok(AuditLogEventType::InviteSent),
            "invite.accepted" => std::result::Result::Ok(AuditLogEventType::InviteAccepted),
            "invite.deleted" => std::result::Result::Ok(AuditLogEventType::InviteDeleted),
            "login.succeeded" => std::result::Result::Ok(AuditLogEventType::LoginSucceeded),
            "login.failed" => std::result::Result::Ok(AuditLogEventType::LoginFailed),
            "logout.succeeded" => std::result::Result::Ok(AuditLogEventType::LogoutSucceeded),
            "logout.failed" => std::result::Result::Ok(AuditLogEventType::LogoutFailed),
            "organization.updated" => std::result::Result::Ok(AuditLogEventType::OrganizationUpdated),
            "project.created" => std::result::Result::Ok(AuditLogEventType::ProjectCreated),
            "project.updated" => std::result::Result::Ok(AuditLogEventType::ProjectUpdated),
            "project.archived" => std::result::Result::Ok(AuditLogEventType::ProjectArchived),
            "service_account.created" => std::result::Result::Ok(AuditLogEventType::ServiceAccountCreated),
            "service_account.updated" => std::result::Result::Ok(AuditLogEventType::ServiceAccountUpdated),
            "service_account.deleted" => std::result::Result::Ok(AuditLogEventType::ServiceAccountDeleted),
            "rate_limit.updated" => std::result::Result::Ok(AuditLogEventType::RateLimitUpdated),
            "rate_limit.deleted" => std::result::Result::Ok(AuditLogEventType::RateLimitDeleted),
            "user.added" => std::result::Result::Ok(AuditLogEventType::UserAdded),
            "user.updated" => std::result::Result::Ok(AuditLogEventType::UserUpdated),
            "user.deleted" => std::result::Result::Ok(AuditLogEventType::UserDeleted),
            _ => std::result::Result::Err(format!(r#"Value not valid: {s}"#)),
        }
    }
}


/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogInviteAccepted {
    /// The ID of the invite.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}



impl AuditLogInviteAccepted {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogInviteAccepted {
        AuditLogInviteAccepted {
 id: None,
        }
    }
}

/// Converts the AuditLogInviteAccepted value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogInviteAccepted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogInviteAccepted value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogInviteAccepted {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogInviteAccepted".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogInviteAccepted".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogInviteAccepted {
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogInviteAccepted> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogInviteAccepted>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogInviteAccepted>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogInviteAccepted - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogInviteAccepted> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogInviteAccepted as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogInviteAccepted - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogInviteSent {
    /// The ID of the invite.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "data")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<models::AuditLogInviteSentData>,

}



impl AuditLogInviteSent {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogInviteSent {
        AuditLogInviteSent {
 id: None,
 data: None,
        }
    }
}

/// Converts the AuditLogInviteSent value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogInviteSent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogInviteSent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogInviteSent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub data: Vec<models::AuditLogInviteSentData>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogInviteSent".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::AuditLogInviteSentData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogInviteSent".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogInviteSent {
            id: intermediate_rep.id.into_iter().next(),
            data: intermediate_rep.data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogInviteSent> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogInviteSent>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogInviteSent>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogInviteSent - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogInviteSent> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogInviteSent as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogInviteSent - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The payload used to create the invite.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogInviteSentData {
    /// The email invited to the organization.
    #[serde(rename = "email")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,

    /// The role the email was invited to be. Is either `owner` or `member`.
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,

}



impl AuditLogInviteSentData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogInviteSentData {
        AuditLogInviteSentData {
 email: None,
 role: None,
        }
    }
}

/// Converts the AuditLogInviteSentData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogInviteSentData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.email.as_ref().map(|email| {
                [
                    "email".to_string(),
                    email.to_string(),
                ].join(",")
            }),


            self.role.as_ref().map(|role| {
                [
                    "role".to_string(),
                    role.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogInviteSentData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogInviteSentData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub email: Vec<String>,
            pub role: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogInviteSentData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogInviteSentData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogInviteSentData {
            email: intermediate_rep.email.into_iter().next(),
            role: intermediate_rep.role.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogInviteSentData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogInviteSentData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogInviteSentData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogInviteSentData - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogInviteSentData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogInviteSentData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogInviteSentData - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogLoginFailed {
    /// The error code of the failure.
    #[serde(rename = "error_code")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_code: Option<String>,

    /// The error message of the failure.
    #[serde(rename = "error_message")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_message: Option<String>,

}



impl AuditLogLoginFailed {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogLoginFailed {
        AuditLogLoginFailed {
 error_code: None,
 error_message: None,
        }
    }
}

/// Converts the AuditLogLoginFailed value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogLoginFailed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.error_code.as_ref().map(|error_code| {
                [
                    "error_code".to_string(),
                    error_code.to_string(),
                ].join(",")
            }),


            self.error_message.as_ref().map(|error_message| {
                [
                    "error_message".to_string(),
                    error_message.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogLoginFailed value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogLoginFailed {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error_code: Vec<String>,
            pub error_message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogLoginFailed".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "error_code" => intermediate_rep.error_code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "error_message" => intermediate_rep.error_message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogLoginFailed".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogLoginFailed {
            error_code: intermediate_rep.error_code.into_iter().next(),
            error_message: intermediate_rep.error_message.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogLoginFailed> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogLoginFailed>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogLoginFailed>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogLoginFailed - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogLoginFailed> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogLoginFailed as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogLoginFailed - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogOrganizationUpdated {
    /// The organization ID.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "changes_requested")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes_requested: Option<models::AuditLogOrganizationUpdatedChangesRequested>,

}



impl AuditLogOrganizationUpdated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogOrganizationUpdated {
        AuditLogOrganizationUpdated {
 id: None,
 changes_requested: None,
        }
    }
}

/// Converts the AuditLogOrganizationUpdated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogOrganizationUpdated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping changes_requested in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogOrganizationUpdated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogOrganizationUpdated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub changes_requested: Vec<models::AuditLogOrganizationUpdatedChangesRequested>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogOrganizationUpdated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "changes_requested" => intermediate_rep.changes_requested.push(<models::AuditLogOrganizationUpdatedChangesRequested as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogOrganizationUpdated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogOrganizationUpdated {
            id: intermediate_rep.id.into_iter().next(),
            changes_requested: intermediate_rep.changes_requested.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogOrganizationUpdated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogOrganizationUpdated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogOrganizationUpdated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogOrganizationUpdated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogOrganizationUpdated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogOrganizationUpdated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogOrganizationUpdated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The payload used to update the organization settings.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogOrganizationUpdatedChangesRequested {
    /// The organization title.
    #[serde(rename = "title")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,

    /// The organization description.
    #[serde(rename = "description")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// The organization name.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "settings")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub settings: Option<models::AuditLogOrganizationUpdatedChangesRequestedSettings>,

}



impl AuditLogOrganizationUpdatedChangesRequested {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogOrganizationUpdatedChangesRequested {
        AuditLogOrganizationUpdatedChangesRequested {
 title: None,
 description: None,
 name: None,
 settings: None,
        }
    }
}

/// Converts the AuditLogOrganizationUpdatedChangesRequested value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogOrganizationUpdatedChangesRequested {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping settings in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogOrganizationUpdatedChangesRequested value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogOrganizationUpdatedChangesRequested {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub title: Vec<String>,
            pub description: Vec<String>,
            pub name: Vec<String>,
            pub settings: Vec<models::AuditLogOrganizationUpdatedChangesRequestedSettings>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogOrganizationUpdatedChangesRequested".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "settings" => intermediate_rep.settings.push(<models::AuditLogOrganizationUpdatedChangesRequestedSettings as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogOrganizationUpdatedChangesRequested".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogOrganizationUpdatedChangesRequested {
            title: intermediate_rep.title.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            settings: intermediate_rep.settings.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogOrganizationUpdatedChangesRequested> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogOrganizationUpdatedChangesRequested>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogOrganizationUpdatedChangesRequested>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogOrganizationUpdatedChangesRequested - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogOrganizationUpdatedChangesRequested> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogOrganizationUpdatedChangesRequested as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogOrganizationUpdatedChangesRequested - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogOrganizationUpdatedChangesRequestedSettings {
    /// Visibility of the threads page which shows messages created with the Assistants API and Playground. One of `ANY_ROLE`, `OWNERS`, or `NONE`.
    #[serde(rename = "threads_ui_visibility")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub threads_ui_visibility: Option<String>,

    /// Visibility of the usage dashboard which shows activity and costs for your organization. One of `ANY_ROLE` or `OWNERS`.
    #[serde(rename = "usage_dashboard_visibility")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub usage_dashboard_visibility: Option<String>,

}



impl AuditLogOrganizationUpdatedChangesRequestedSettings {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogOrganizationUpdatedChangesRequestedSettings {
        AuditLogOrganizationUpdatedChangesRequestedSettings {
 threads_ui_visibility: None,
 usage_dashboard_visibility: None,
        }
    }
}

/// Converts the AuditLogOrganizationUpdatedChangesRequestedSettings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogOrganizationUpdatedChangesRequestedSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.threads_ui_visibility.as_ref().map(|threads_ui_visibility| {
                [
                    "threads_ui_visibility".to_string(),
                    threads_ui_visibility.to_string(),
                ].join(",")
            }),


            self.usage_dashboard_visibility.as_ref().map(|usage_dashboard_visibility| {
                [
                    "usage_dashboard_visibility".to_string(),
                    usage_dashboard_visibility.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogOrganizationUpdatedChangesRequestedSettings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogOrganizationUpdatedChangesRequestedSettings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub threads_ui_visibility: Vec<String>,
            pub usage_dashboard_visibility: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogOrganizationUpdatedChangesRequestedSettings".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "threads_ui_visibility" => intermediate_rep.threads_ui_visibility.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usage_dashboard_visibility" => intermediate_rep.usage_dashboard_visibility.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogOrganizationUpdatedChangesRequestedSettings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogOrganizationUpdatedChangesRequestedSettings {
            threads_ui_visibility: intermediate_rep.threads_ui_visibility.into_iter().next(),
            usage_dashboard_visibility: intermediate_rep.usage_dashboard_visibility.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogOrganizationUpdatedChangesRequestedSettings> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogOrganizationUpdatedChangesRequestedSettings>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogOrganizationUpdatedChangesRequestedSettings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogOrganizationUpdatedChangesRequestedSettings - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogOrganizationUpdatedChangesRequestedSettings> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogOrganizationUpdatedChangesRequestedSettings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogOrganizationUpdatedChangesRequestedSettings - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The project that the action was scoped to. Absent for actions not scoped to projects.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogProject {
    /// The project ID.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// The project title.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}



impl AuditLogProject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogProject {
        AuditLogProject {
 id: None,
 name: None,
        }
    }
}

/// Converts the AuditLogProject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogProject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogProject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogProject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogProject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogProject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogProject {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogProject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogProject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogProject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogProject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogProject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogProject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogProject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogProjectArchived {
    /// The project ID.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}



impl AuditLogProjectArchived {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogProjectArchived {
        AuditLogProjectArchived {
 id: None,
        }
    }
}

/// Converts the AuditLogProjectArchived value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogProjectArchived {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogProjectArchived value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogProjectArchived {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogProjectArchived".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogProjectArchived".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogProjectArchived {
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogProjectArchived> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogProjectArchived>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogProjectArchived>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogProjectArchived - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogProjectArchived> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogProjectArchived as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogProjectArchived - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogProjectCreated {
    /// The project ID.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "data")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<models::AuditLogProjectCreatedData>,

}



impl AuditLogProjectCreated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogProjectCreated {
        AuditLogProjectCreated {
 id: None,
 data: None,
        }
    }
}

/// Converts the AuditLogProjectCreated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogProjectCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogProjectCreated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogProjectCreated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub data: Vec<models::AuditLogProjectCreatedData>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogProjectCreated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::AuditLogProjectCreatedData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogProjectCreated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogProjectCreated {
            id: intermediate_rep.id.into_iter().next(),
            data: intermediate_rep.data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogProjectCreated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogProjectCreated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogProjectCreated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogProjectCreated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogProjectCreated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogProjectCreated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogProjectCreated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The payload used to create the project.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogProjectCreatedData {
    /// The project name.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// The title of the project as seen on the dashboard.
    #[serde(rename = "title")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,

}



impl AuditLogProjectCreatedData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogProjectCreatedData {
        AuditLogProjectCreatedData {
 name: None,
 title: None,
        }
    }
}

/// Converts the AuditLogProjectCreatedData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogProjectCreatedData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogProjectCreatedData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogProjectCreatedData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub title: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogProjectCreatedData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogProjectCreatedData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogProjectCreatedData {
            name: intermediate_rep.name.into_iter().next(),
            title: intermediate_rep.title.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogProjectCreatedData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogProjectCreatedData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogProjectCreatedData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogProjectCreatedData - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogProjectCreatedData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogProjectCreatedData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogProjectCreatedData - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogProjectUpdated {
    /// The project ID.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "changes_requested")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes_requested: Option<models::AuditLogProjectUpdatedChangesRequested>,

}



impl AuditLogProjectUpdated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogProjectUpdated {
        AuditLogProjectUpdated {
 id: None,
 changes_requested: None,
        }
    }
}

/// Converts the AuditLogProjectUpdated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogProjectUpdated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping changes_requested in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogProjectUpdated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogProjectUpdated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub changes_requested: Vec<models::AuditLogProjectUpdatedChangesRequested>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogProjectUpdated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "changes_requested" => intermediate_rep.changes_requested.push(<models::AuditLogProjectUpdatedChangesRequested as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogProjectUpdated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogProjectUpdated {
            id: intermediate_rep.id.into_iter().next(),
            changes_requested: intermediate_rep.changes_requested.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogProjectUpdated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogProjectUpdated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogProjectUpdated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogProjectUpdated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogProjectUpdated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogProjectUpdated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogProjectUpdated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The payload used to update the project.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogProjectUpdatedChangesRequested {
    /// The title of the project as seen on the dashboard.
    #[serde(rename = "title")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,

}



impl AuditLogProjectUpdatedChangesRequested {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogProjectUpdatedChangesRequested {
        AuditLogProjectUpdatedChangesRequested {
 title: None,
        }
    }
}

/// Converts the AuditLogProjectUpdatedChangesRequested value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogProjectUpdatedChangesRequested {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.title.as_ref().map(|title| {
                [
                    "title".to_string(),
                    title.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogProjectUpdatedChangesRequested value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogProjectUpdatedChangesRequested {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub title: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogProjectUpdatedChangesRequested".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "title" => intermediate_rep.title.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogProjectUpdatedChangesRequested".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogProjectUpdatedChangesRequested {
            title: intermediate_rep.title.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogProjectUpdatedChangesRequested> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogProjectUpdatedChangesRequested>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogProjectUpdatedChangesRequested>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogProjectUpdatedChangesRequested - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogProjectUpdatedChangesRequested> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogProjectUpdatedChangesRequested as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogProjectUpdatedChangesRequested - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogRateLimitDeleted {
    /// The rate limit ID
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}



impl AuditLogRateLimitDeleted {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogRateLimitDeleted {
        AuditLogRateLimitDeleted {
 id: None,
        }
    }
}

/// Converts the AuditLogRateLimitDeleted value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogRateLimitDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogRateLimitDeleted value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogRateLimitDeleted {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogRateLimitDeleted".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogRateLimitDeleted".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogRateLimitDeleted {
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogRateLimitDeleted> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogRateLimitDeleted>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogRateLimitDeleted>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogRateLimitDeleted - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogRateLimitDeleted> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogRateLimitDeleted as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogRateLimitDeleted - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogRateLimitUpdated {
    /// The rate limit ID
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "changes_requested")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes_requested: Option<models::AuditLogRateLimitUpdatedChangesRequested>,

}



impl AuditLogRateLimitUpdated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogRateLimitUpdated {
        AuditLogRateLimitUpdated {
 id: None,
 changes_requested: None,
        }
    }
}

/// Converts the AuditLogRateLimitUpdated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogRateLimitUpdated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping changes_requested in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogRateLimitUpdated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogRateLimitUpdated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub changes_requested: Vec<models::AuditLogRateLimitUpdatedChangesRequested>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogRateLimitUpdated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "changes_requested" => intermediate_rep.changes_requested.push(<models::AuditLogRateLimitUpdatedChangesRequested as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogRateLimitUpdated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogRateLimitUpdated {
            id: intermediate_rep.id.into_iter().next(),
            changes_requested: intermediate_rep.changes_requested.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogRateLimitUpdated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogRateLimitUpdated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogRateLimitUpdated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogRateLimitUpdated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogRateLimitUpdated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogRateLimitUpdated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogRateLimitUpdated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The payload used to update the rate limits.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogRateLimitUpdatedChangesRequested {
    /// The maximum requests per minute.
    #[serde(rename = "max_requests_per_1_minute")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_requests_per_1_minute: Option<i32>,

    /// The maximum tokens per minute.
    #[serde(rename = "max_tokens_per_1_minute")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_tokens_per_1_minute: Option<i32>,

    /// The maximum images per minute. Only relevant for certain models.
    #[serde(rename = "max_images_per_1_minute")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_images_per_1_minute: Option<i32>,

    /// The maximum audio megabytes per minute. Only relevant for certain models.
    #[serde(rename = "max_audio_megabytes_per_1_minute")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_audio_megabytes_per_1_minute: Option<i32>,

    /// The maximum requests per day. Only relevant for certain models.
    #[serde(rename = "max_requests_per_1_day")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_requests_per_1_day: Option<i32>,

    /// The maximum batch input tokens per day. Only relevant for certain models.
    #[serde(rename = "batch_1_day_max_input_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub batch_1_day_max_input_tokens: Option<i32>,

}



impl AuditLogRateLimitUpdatedChangesRequested {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogRateLimitUpdatedChangesRequested {
        AuditLogRateLimitUpdatedChangesRequested {
 max_requests_per_1_minute: None,
 max_tokens_per_1_minute: None,
 max_images_per_1_minute: None,
 max_audio_megabytes_per_1_minute: None,
 max_requests_per_1_day: None,
 batch_1_day_max_input_tokens: None,
        }
    }
}

/// Converts the AuditLogRateLimitUpdatedChangesRequested value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogRateLimitUpdatedChangesRequested {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.max_requests_per_1_minute.as_ref().map(|max_requests_per_1_minute| {
                [
                    "max_requests_per_1_minute".to_string(),
                    max_requests_per_1_minute.to_string(),
                ].join(",")
            }),


            self.max_tokens_per_1_minute.as_ref().map(|max_tokens_per_1_minute| {
                [
                    "max_tokens_per_1_minute".to_string(),
                    max_tokens_per_1_minute.to_string(),
                ].join(",")
            }),


            self.max_images_per_1_minute.as_ref().map(|max_images_per_1_minute| {
                [
                    "max_images_per_1_minute".to_string(),
                    max_images_per_1_minute.to_string(),
                ].join(",")
            }),


            self.max_audio_megabytes_per_1_minute.as_ref().map(|max_audio_megabytes_per_1_minute| {
                [
                    "max_audio_megabytes_per_1_minute".to_string(),
                    max_audio_megabytes_per_1_minute.to_string(),
                ].join(",")
            }),


            self.max_requests_per_1_day.as_ref().map(|max_requests_per_1_day| {
                [
                    "max_requests_per_1_day".to_string(),
                    max_requests_per_1_day.to_string(),
                ].join(",")
            }),


            self.batch_1_day_max_input_tokens.as_ref().map(|batch_1_day_max_input_tokens| {
                [
                    "batch_1_day_max_input_tokens".to_string(),
                    batch_1_day_max_input_tokens.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogRateLimitUpdatedChangesRequested value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogRateLimitUpdatedChangesRequested {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub max_requests_per_1_minute: Vec<i32>,
            pub max_tokens_per_1_minute: Vec<i32>,
            pub max_images_per_1_minute: Vec<i32>,
            pub max_audio_megabytes_per_1_minute: Vec<i32>,
            pub max_requests_per_1_day: Vec<i32>,
            pub batch_1_day_max_input_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogRateLimitUpdatedChangesRequested".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "max_requests_per_1_minute" => intermediate_rep.max_requests_per_1_minute.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_tokens_per_1_minute" => intermediate_rep.max_tokens_per_1_minute.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_images_per_1_minute" => intermediate_rep.max_images_per_1_minute.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_audio_megabytes_per_1_minute" => intermediate_rep.max_audio_megabytes_per_1_minute.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_requests_per_1_day" => intermediate_rep.max_requests_per_1_day.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "batch_1_day_max_input_tokens" => intermediate_rep.batch_1_day_max_input_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogRateLimitUpdatedChangesRequested".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogRateLimitUpdatedChangesRequested {
            max_requests_per_1_minute: intermediate_rep.max_requests_per_1_minute.into_iter().next(),
            max_tokens_per_1_minute: intermediate_rep.max_tokens_per_1_minute.into_iter().next(),
            max_images_per_1_minute: intermediate_rep.max_images_per_1_minute.into_iter().next(),
            max_audio_megabytes_per_1_minute: intermediate_rep.max_audio_megabytes_per_1_minute.into_iter().next(),
            max_requests_per_1_day: intermediate_rep.max_requests_per_1_day.into_iter().next(),
            batch_1_day_max_input_tokens: intermediate_rep.batch_1_day_max_input_tokens.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogRateLimitUpdatedChangesRequested> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogRateLimitUpdatedChangesRequested>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogRateLimitUpdatedChangesRequested>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogRateLimitUpdatedChangesRequested - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogRateLimitUpdatedChangesRequested> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogRateLimitUpdatedChangesRequested as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogRateLimitUpdatedChangesRequested - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogServiceAccountCreated {
    /// The service account ID.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "data")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<models::AuditLogServiceAccountCreatedData>,

}



impl AuditLogServiceAccountCreated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogServiceAccountCreated {
        AuditLogServiceAccountCreated {
 id: None,
 data: None,
        }
    }
}

/// Converts the AuditLogServiceAccountCreated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogServiceAccountCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogServiceAccountCreated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogServiceAccountCreated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub data: Vec<models::AuditLogServiceAccountCreatedData>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogServiceAccountCreated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::AuditLogServiceAccountCreatedData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogServiceAccountCreated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogServiceAccountCreated {
            id: intermediate_rep.id.into_iter().next(),
            data: intermediate_rep.data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogServiceAccountCreated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogServiceAccountCreated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogServiceAccountCreated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogServiceAccountCreated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogServiceAccountCreated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogServiceAccountCreated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogServiceAccountCreated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The payload used to create the service account.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogServiceAccountCreatedData {
    /// The role of the service account. Is either `owner` or `member`.
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,

}



impl AuditLogServiceAccountCreatedData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogServiceAccountCreatedData {
        AuditLogServiceAccountCreatedData {
 role: None,
        }
    }
}

/// Converts the AuditLogServiceAccountCreatedData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogServiceAccountCreatedData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.role.as_ref().map(|role| {
                [
                    "role".to_string(),
                    role.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogServiceAccountCreatedData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogServiceAccountCreatedData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogServiceAccountCreatedData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogServiceAccountCreatedData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogServiceAccountCreatedData {
            role: intermediate_rep.role.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogServiceAccountCreatedData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogServiceAccountCreatedData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogServiceAccountCreatedData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogServiceAccountCreatedData - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogServiceAccountCreatedData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogServiceAccountCreatedData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogServiceAccountCreatedData - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogServiceAccountDeleted {
    /// The service account ID.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}



impl AuditLogServiceAccountDeleted {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogServiceAccountDeleted {
        AuditLogServiceAccountDeleted {
 id: None,
        }
    }
}

/// Converts the AuditLogServiceAccountDeleted value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogServiceAccountDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogServiceAccountDeleted value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogServiceAccountDeleted {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogServiceAccountDeleted".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogServiceAccountDeleted".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogServiceAccountDeleted {
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogServiceAccountDeleted> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogServiceAccountDeleted>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogServiceAccountDeleted>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogServiceAccountDeleted - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogServiceAccountDeleted> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogServiceAccountDeleted as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogServiceAccountDeleted - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogServiceAccountUpdated {
    /// The service account ID.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "changes_requested")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes_requested: Option<models::AuditLogServiceAccountUpdatedChangesRequested>,

}



impl AuditLogServiceAccountUpdated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogServiceAccountUpdated {
        AuditLogServiceAccountUpdated {
 id: None,
 changes_requested: None,
        }
    }
}

/// Converts the AuditLogServiceAccountUpdated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogServiceAccountUpdated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping changes_requested in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogServiceAccountUpdated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogServiceAccountUpdated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub changes_requested: Vec<models::AuditLogServiceAccountUpdatedChangesRequested>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogServiceAccountUpdated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "changes_requested" => intermediate_rep.changes_requested.push(<models::AuditLogServiceAccountUpdatedChangesRequested as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogServiceAccountUpdated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogServiceAccountUpdated {
            id: intermediate_rep.id.into_iter().next(),
            changes_requested: intermediate_rep.changes_requested.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogServiceAccountUpdated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogServiceAccountUpdated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogServiceAccountUpdated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogServiceAccountUpdated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogServiceAccountUpdated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogServiceAccountUpdated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogServiceAccountUpdated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The payload used to updated the service account.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogServiceAccountUpdatedChangesRequested {
    /// The role of the service account. Is either `owner` or `member`.
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,

}



impl AuditLogServiceAccountUpdatedChangesRequested {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogServiceAccountUpdatedChangesRequested {
        AuditLogServiceAccountUpdatedChangesRequested {
 role: None,
        }
    }
}

/// Converts the AuditLogServiceAccountUpdatedChangesRequested value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogServiceAccountUpdatedChangesRequested {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.role.as_ref().map(|role| {
                [
                    "role".to_string(),
                    role.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogServiceAccountUpdatedChangesRequested value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogServiceAccountUpdatedChangesRequested {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogServiceAccountUpdatedChangesRequested".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogServiceAccountUpdatedChangesRequested".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogServiceAccountUpdatedChangesRequested {
            role: intermediate_rep.role.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogServiceAccountUpdatedChangesRequested> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogServiceAccountUpdatedChangesRequested>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogServiceAccountUpdatedChangesRequested>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogServiceAccountUpdatedChangesRequested - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogServiceAccountUpdatedChangesRequested> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogServiceAccountUpdatedChangesRequested as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogServiceAccountUpdatedChangesRequested - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogUserAdded {
    /// The user ID.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "data")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<models::AuditLogUserAddedData>,

}



impl AuditLogUserAdded {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogUserAdded {
        AuditLogUserAdded {
 id: None,
 data: None,
        }
    }
}

/// Converts the AuditLogUserAdded value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogUserAdded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogUserAdded value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogUserAdded {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub data: Vec<models::AuditLogUserAddedData>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogUserAdded".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::AuditLogUserAddedData as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogUserAdded".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogUserAdded {
            id: intermediate_rep.id.into_iter().next(),
            data: intermediate_rep.data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogUserAdded> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogUserAdded>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogUserAdded>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogUserAdded - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogUserAdded> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogUserAdded as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogUserAdded - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The payload used to add the user to the project.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogUserAddedData {
    /// The role of the user. Is either `owner` or `member`.
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,

}



impl AuditLogUserAddedData {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogUserAddedData {
        AuditLogUserAddedData {
 role: None,
        }
    }
}

/// Converts the AuditLogUserAddedData value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogUserAddedData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.role.as_ref().map(|role| {
                [
                    "role".to_string(),
                    role.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogUserAddedData value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogUserAddedData {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogUserAddedData".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogUserAddedData".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogUserAddedData {
            role: intermediate_rep.role.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogUserAddedData> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogUserAddedData>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogUserAddedData>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogUserAddedData - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogUserAddedData> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogUserAddedData as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogUserAddedData - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogUserDeleted {
    /// The user ID.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

}



impl AuditLogUserDeleted {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogUserDeleted {
        AuditLogUserDeleted {
 id: None,
        }
    }
}

/// Converts the AuditLogUserDeleted value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogUserDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogUserDeleted value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogUserDeleted {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogUserDeleted".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogUserDeleted".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogUserDeleted {
            id: intermediate_rep.id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogUserDeleted> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogUserDeleted>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogUserDeleted>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogUserDeleted - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogUserDeleted> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogUserDeleted as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogUserDeleted - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details for events with this `type`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogUserUpdated {
    /// The project ID.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "changes_requested")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes_requested: Option<models::AuditLogUserUpdatedChangesRequested>,

}



impl AuditLogUserUpdated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogUserUpdated {
        AuditLogUserUpdated {
 id: None,
 changes_requested: None,
        }
    }
}

/// Converts the AuditLogUserUpdated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogUserUpdated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping changes_requested in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogUserUpdated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogUserUpdated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub changes_requested: Vec<models::AuditLogUserUpdatedChangesRequested>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogUserUpdated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "changes_requested" => intermediate_rep.changes_requested.push(<models::AuditLogUserUpdatedChangesRequested as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogUserUpdated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogUserUpdated {
            id: intermediate_rep.id.into_iter().next(),
            changes_requested: intermediate_rep.changes_requested.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogUserUpdated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogUserUpdated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogUserUpdated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogUserUpdated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogUserUpdated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogUserUpdated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogUserUpdated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The payload used to update the user.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AuditLogUserUpdatedChangesRequested {
    /// The role of the user. Is either `owner` or `member`.
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,

}



impl AuditLogUserUpdatedChangesRequested {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> AuditLogUserUpdatedChangesRequested {
        AuditLogUserUpdatedChangesRequested {
 role: None,
        }
    }
}

/// Converts the AuditLogUserUpdatedChangesRequested value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AuditLogUserUpdatedChangesRequested {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.role.as_ref().map(|role| {
                [
                    "role".to_string(),
                    role.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AuditLogUserUpdatedChangesRequested value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AuditLogUserUpdatedChangesRequested {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AuditLogUserUpdatedChangesRequested".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AuditLogUserUpdatedChangesRequested".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AuditLogUserUpdatedChangesRequested {
            role: intermediate_rep.role.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AuditLogUserUpdatedChangesRequested> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AuditLogUserUpdatedChangesRequested>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AuditLogUserUpdatedChangesRequested>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AuditLogUserUpdatedChangesRequested - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AuditLogUserUpdatedChangesRequested> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AuditLogUserUpdatedChangesRequested as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AuditLogUserUpdatedChangesRequested - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AutoChunkingStrategy {
    /// Always `auto`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

}



impl AutoChunkingStrategy {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> AutoChunkingStrategy {
        AutoChunkingStrategy {
 r_type,
        }
    }
}

/// Converts the AutoChunkingStrategy value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AutoChunkingStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AutoChunkingStrategy value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AutoChunkingStrategy {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AutoChunkingStrategy".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AutoChunkingStrategy".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AutoChunkingStrategy {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in AutoChunkingStrategy".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AutoChunkingStrategy> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AutoChunkingStrategy>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AutoChunkingStrategy>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AutoChunkingStrategy - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AutoChunkingStrategy> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AutoChunkingStrategy as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AutoChunkingStrategy - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AutoChunkingStrategyRequestParam {
    /// Always `auto`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

}



impl AutoChunkingStrategyRequestParam {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> AutoChunkingStrategyRequestParam {
        AutoChunkingStrategyRequestParam {
 r_type,
        }
    }
}

/// Converts the AutoChunkingStrategyRequestParam value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AutoChunkingStrategyRequestParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AutoChunkingStrategyRequestParam value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AutoChunkingStrategyRequestParam {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AutoChunkingStrategyRequestParam".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AutoChunkingStrategyRequestParam".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AutoChunkingStrategyRequestParam {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in AutoChunkingStrategyRequestParam".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AutoChunkingStrategyRequestParam> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AutoChunkingStrategyRequestParam>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AutoChunkingStrategyRequestParam>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AutoChunkingStrategyRequestParam - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AutoChunkingStrategyRequestParam> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AutoChunkingStrategyRequestParam as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AutoChunkingStrategyRequestParam - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Batch {
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The object type, which is always `batch`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The OpenAI API endpoint used by the batch.
    #[serde(rename = "endpoint")]
          #[validate(custom(function = "check_xss_string"))]
    pub endpoint: String,

    #[serde(rename = "errors")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_errors: Option<models::BatchErrors>,

    /// The ID of the input file for the batch.
    #[serde(rename = "input_file_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub input_file_id: String,

    /// The time frame within which the batch should be processed.
    #[serde(rename = "completion_window")]
          #[validate(custom(function = "check_xss_string"))]
    pub completion_window: String,

    /// The current status of the batch.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
          #[validate(custom(function = "check_xss_string"))]
    pub status: String,

    /// The ID of the file containing the outputs of successfully executed requests.
    #[serde(rename = "output_file_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output_file_id: Option<String>,

    /// The ID of the file containing the outputs of requests with errors.
    #[serde(rename = "error_file_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_file_id: Option<String>,

    /// The Unix timestamp (in seconds) for when the batch was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    /// The Unix timestamp (in seconds) for when the batch started processing.
    #[serde(rename = "in_progress_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub in_progress_at: Option<i32>,

    /// The Unix timestamp (in seconds) for when the batch will expire.
    #[serde(rename = "expires_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<i32>,

    /// The Unix timestamp (in seconds) for when the batch started finalizing.
    #[serde(rename = "finalizing_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub finalizing_at: Option<i32>,

    /// The Unix timestamp (in seconds) for when the batch was completed.
    #[serde(rename = "completed_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<i32>,

    /// The Unix timestamp (in seconds) for when the batch failed.
    #[serde(rename = "failed_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub failed_at: Option<i32>,

    /// The Unix timestamp (in seconds) for when the batch expired.
    #[serde(rename = "expired_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expired_at: Option<i32>,

    /// The Unix timestamp (in seconds) for when the batch started cancelling.
    #[serde(rename = "cancelling_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cancelling_at: Option<i32>,

    /// The Unix timestamp (in seconds) for when the batch was cancelled.
    #[serde(rename = "cancelled_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cancelled_at: Option<i32>,

    #[serde(rename = "request_counts")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub request_counts: Option<models::BatchRequestCounts>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}



impl Batch {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, endpoint: String, input_file_id: String, completion_window: String, status: String, created_at: i32, ) -> Batch {
        Batch {
 id,
 object,
 endpoint,
 r_errors: None,
 input_file_id,
 completion_window,
 status,
 output_file_id: None,
 error_file_id: None,
 created_at,
 in_progress_at: None,
 expires_at: None,
 finalizing_at: None,
 completed_at: None,
 failed_at: None,
 expired_at: None,
 cancelling_at: None,
 cancelled_at: None,
 request_counts: None,
 metadata: None,
        }
    }
}

/// Converts the Batch value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Batch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("endpoint".to_string()),
            Some(self.endpoint.to_string()),

            // Skipping errors in query parameter serialization


            Some("input_file_id".to_string()),
            Some(self.input_file_id.to_string()),


            Some("completion_window".to_string()),
            Some(self.completion_window.to_string()),


            Some("status".to_string()),
            Some(self.status.to_string()),


            self.output_file_id.as_ref().map(|output_file_id| {
                [
                    "output_file_id".to_string(),
                    output_file_id.to_string(),
                ].join(",")
            }),


            self.error_file_id.as_ref().map(|error_file_id| {
                [
                    "error_file_id".to_string(),
                    error_file_id.to_string(),
                ].join(",")
            }),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            self.in_progress_at.as_ref().map(|in_progress_at| {
                [
                    "in_progress_at".to_string(),
                    in_progress_at.to_string(),
                ].join(",")
            }),


            self.expires_at.as_ref().map(|expires_at| {
                [
                    "expires_at".to_string(),
                    expires_at.to_string(),
                ].join(",")
            }),


            self.finalizing_at.as_ref().map(|finalizing_at| {
                [
                    "finalizing_at".to_string(),
                    finalizing_at.to_string(),
                ].join(",")
            }),


            self.completed_at.as_ref().map(|completed_at| {
                [
                    "completed_at".to_string(),
                    completed_at.to_string(),
                ].join(",")
            }),


            self.failed_at.as_ref().map(|failed_at| {
                [
                    "failed_at".to_string(),
                    failed_at.to_string(),
                ].join(",")
            }),


            self.expired_at.as_ref().map(|expired_at| {
                [
                    "expired_at".to_string(),
                    expired_at.to_string(),
                ].join(",")
            }),


            self.cancelling_at.as_ref().map(|cancelling_at| {
                [
                    "cancelling_at".to_string(),
                    cancelling_at.to_string(),
                ].join(",")
            }),


            self.cancelled_at.as_ref().map(|cancelled_at| {
                [
                    "cancelled_at".to_string(),
                    cancelled_at.to_string(),
                ].join(",")
            }),

            // Skipping request_counts in query parameter serialization

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Batch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Batch {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub endpoint: Vec<String>,
            pub r_errors: Vec<models::BatchErrors>,
            pub input_file_id: Vec<String>,
            pub completion_window: Vec<String>,
            pub status: Vec<String>,
            pub output_file_id: Vec<String>,
            pub error_file_id: Vec<String>,
            pub created_at: Vec<i32>,
            pub in_progress_at: Vec<i32>,
            pub expires_at: Vec<i32>,
            pub finalizing_at: Vec<i32>,
            pub completed_at: Vec<i32>,
            pub failed_at: Vec<i32>,
            pub expired_at: Vec<i32>,
            pub cancelling_at: Vec<i32>,
            pub cancelled_at: Vec<i32>,
            pub request_counts: Vec<models::BatchRequestCounts>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Batch".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "endpoint" => intermediate_rep.endpoint.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "errors" => intermediate_rep.r_errors.push(<models::BatchErrors as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input_file_id" => intermediate_rep.input_file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "completion_window" => intermediate_rep.completion_window.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_file_id" => intermediate_rep.output_file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "error_file_id" => intermediate_rep.error_file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "in_progress_at" => intermediate_rep.in_progress_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expires_at" => intermediate_rep.expires_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "finalizing_at" => intermediate_rep.finalizing_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "completed_at" => intermediate_rep.completed_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "failed_at" => intermediate_rep.failed_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expired_at" => intermediate_rep.expired_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cancelling_at" => intermediate_rep.cancelling_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cancelled_at" => intermediate_rep.cancelled_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "request_counts" => intermediate_rep.request_counts.push(<models::BatchRequestCounts as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Batch".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Batch {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in Batch".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in Batch".to_string())?,
            endpoint: intermediate_rep.endpoint.into_iter().next().ok_or_else(|| "endpoint missing in Batch".to_string())?,
            r_errors: intermediate_rep.r_errors.into_iter().next(),
            input_file_id: intermediate_rep.input_file_id.into_iter().next().ok_or_else(|| "input_file_id missing in Batch".to_string())?,
            completion_window: intermediate_rep.completion_window.into_iter().next().ok_or_else(|| "completion_window missing in Batch".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in Batch".to_string())?,
            output_file_id: intermediate_rep.output_file_id.into_iter().next(),
            error_file_id: intermediate_rep.error_file_id.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in Batch".to_string())?,
            in_progress_at: intermediate_rep.in_progress_at.into_iter().next(),
            expires_at: intermediate_rep.expires_at.into_iter().next(),
            finalizing_at: intermediate_rep.finalizing_at.into_iter().next(),
            completed_at: intermediate_rep.completed_at.into_iter().next(),
            failed_at: intermediate_rep.failed_at.into_iter().next(),
            expired_at: intermediate_rep.expired_at.into_iter().next(),
            cancelling_at: intermediate_rep.cancelling_at.into_iter().next(),
            cancelled_at: intermediate_rep.cancelled_at.into_iter().next(),
            request_counts: intermediate_rep.request_counts.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Batch> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Batch>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Batch>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for Batch - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Batch> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Batch as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into Batch - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BatchErrors {
    /// The object type, which is always `list`.
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub object: Option<String>,

    #[serde(rename = "data")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<Vec<models::BatchErrorsDataInner>>,

}



impl BatchErrors {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BatchErrors {
        BatchErrors {
 object: None,
 data: None,
        }
    }
}

/// Converts the BatchErrors value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BatchErrors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.object.as_ref().map(|object| {
                [
                    "object".to_string(),
                    object.to_string(),
                ].join(",")
            }),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BatchErrors value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BatchErrors {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::BatchErrorsDataInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BatchErrors".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in BatchErrors".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BatchErrors".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BatchErrors {
            object: intermediate_rep.object.into_iter().next(),
            data: intermediate_rep.data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BatchErrors> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BatchErrors>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BatchErrors>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BatchErrors - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BatchErrors> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BatchErrors as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BatchErrors - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BatchErrorsDataInner {
    /// An error code identifying the error type.
    #[serde(rename = "code")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<String>,

    /// A human-readable message providing more details about the error.
    #[serde(rename = "message")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    /// The name of the parameter that caused the error, if applicable.
    #[serde(rename = "param")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub param: Option<Nullable<String>>,

    /// The line number of the input file where the error occurred, if applicable.
    #[serde(rename = "line")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub line: Option<Nullable<i32>>,

}



impl BatchErrorsDataInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BatchErrorsDataInner {
        BatchErrorsDataInner {
 code: None,
 message: None,
 param: None,
 line: None,
        }
    }
}

/// Converts the BatchErrorsDataInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BatchErrorsDataInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.param.as_ref().map(|param| {
                [
                    "param".to_string(),
                    param.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.line.as_ref().map(|line| {
                [
                    "line".to_string(),
                    line.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BatchErrorsDataInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BatchErrorsDataInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<String>,
            pub message: Vec<String>,
            pub param: Vec<String>,
            pub line: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BatchErrorsDataInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "param" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in BatchErrorsDataInner".to_string()),
                    "line" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in BatchErrorsDataInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BatchErrorsDataInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BatchErrorsDataInner {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            param: std::result::Result::Err("Nullable types not supported in BatchErrorsDataInner".to_string())?,
            line: std::result::Result::Err("Nullable types not supported in BatchErrorsDataInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BatchErrorsDataInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BatchErrorsDataInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BatchErrorsDataInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BatchErrorsDataInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BatchErrorsDataInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BatchErrorsDataInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BatchErrorsDataInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The request counts for different statuses within the batch.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BatchRequestCounts {
    /// Total number of requests in the batch.
    #[serde(rename = "total")]
    pub total: i32,

    /// Number of requests that have been completed successfully.
    #[serde(rename = "completed")]
    pub completed: i32,

    /// Number of requests that have failed.
    #[serde(rename = "failed")]
    pub failed: i32,

}



impl BatchRequestCounts {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(total: i32, completed: i32, failed: i32, ) -> BatchRequestCounts {
        BatchRequestCounts {
 total,
 completed,
 failed,
        }
    }
}

/// Converts the BatchRequestCounts value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BatchRequestCounts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("total".to_string()),
            Some(self.total.to_string()),


            Some("completed".to_string()),
            Some(self.completed.to_string()),


            Some("failed".to_string()),
            Some(self.failed.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BatchRequestCounts value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BatchRequestCounts {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub total: Vec<i32>,
            pub completed: Vec<i32>,
            pub failed: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BatchRequestCounts".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "total" => intermediate_rep.total.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "completed" => intermediate_rep.completed.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "failed" => intermediate_rep.failed.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BatchRequestCounts".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BatchRequestCounts {
            total: intermediate_rep.total.into_iter().next().ok_or_else(|| "total missing in BatchRequestCounts".to_string())?,
            completed: intermediate_rep.completed.into_iter().next().ok_or_else(|| "completed missing in BatchRequestCounts".to_string())?,
            failed: intermediate_rep.failed.into_iter().next().ok_or_else(|| "failed missing in BatchRequestCounts".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BatchRequestCounts> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BatchRequestCounts>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BatchRequestCounts>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BatchRequestCounts - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BatchRequestCounts> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BatchRequestCounts as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BatchRequestCounts - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The per-line object of the batch input file
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BatchRequestInput {
    /// A developer-provided per-request id that will be used to match outputs to inputs. Must be unique for each request in a batch.
    #[serde(rename = "custom_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_id: Option<String>,

    /// The HTTP method to be used for the request. Currently only `POST` is supported.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "method")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub method: Option<String>,

    /// The OpenAI API relative URL to be used for the request. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported.
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,

}



impl BatchRequestInput {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BatchRequestInput {
        BatchRequestInput {
 custom_id: None,
 method: None,
 url: None,
        }
    }
}

/// Converts the BatchRequestInput value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BatchRequestInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.custom_id.as_ref().map(|custom_id| {
                [
                    "custom_id".to_string(),
                    custom_id.to_string(),
                ].join(",")
            }),


            self.method.as_ref().map(|method| {
                [
                    "method".to_string(),
                    method.to_string(),
                ].join(",")
            }),


            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BatchRequestInput value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BatchRequestInput {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub custom_id: Vec<String>,
            pub method: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BatchRequestInput".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "custom_id" => intermediate_rep.custom_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "method" => intermediate_rep.method.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BatchRequestInput".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BatchRequestInput {
            custom_id: intermediate_rep.custom_id.into_iter().next(),
            method: intermediate_rep.method.into_iter().next(),
            url: intermediate_rep.url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BatchRequestInput> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BatchRequestInput>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BatchRequestInput>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BatchRequestInput - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BatchRequestInput> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BatchRequestInput as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BatchRequestInput - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The per-line object of the batch output and error files
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BatchRequestOutput {
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// A developer-provided per-request id that will be used to match outputs to inputs.
    #[serde(rename = "custom_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_id: Option<String>,

    #[serde(rename = "response")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response: Option<Nullable<models::BatchRequestOutputResponse>>,

    #[serde(rename = "error")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<Nullable<models::BatchRequestOutputError>>,

}



impl BatchRequestOutput {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BatchRequestOutput {
        BatchRequestOutput {
 id: None,
 custom_id: None,
 response: None,
 error: None,
        }
    }
}

/// Converts the BatchRequestOutput value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BatchRequestOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.custom_id.as_ref().map(|custom_id| {
                [
                    "custom_id".to_string(),
                    custom_id.to_string(),
                ].join(",")
            }),

            // Skipping response in query parameter serialization

            // Skipping error in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BatchRequestOutput value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BatchRequestOutput {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub custom_id: Vec<String>,
            pub response: Vec<models::BatchRequestOutputResponse>,
            pub error: Vec<models::BatchRequestOutputError>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BatchRequestOutput".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "custom_id" => intermediate_rep.custom_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "response" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in BatchRequestOutput".to_string()),
                    "error" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in BatchRequestOutput".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BatchRequestOutput".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BatchRequestOutput {
            id: intermediate_rep.id.into_iter().next(),
            custom_id: intermediate_rep.custom_id.into_iter().next(),
            response: std::result::Result::Err("Nullable types not supported in BatchRequestOutput".to_string())?,
            error: std::result::Result::Err("Nullable types not supported in BatchRequestOutput".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BatchRequestOutput> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BatchRequestOutput>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BatchRequestOutput>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BatchRequestOutput - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BatchRequestOutput> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BatchRequestOutput as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BatchRequestOutput - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// For requests that failed with a non-HTTP error, this will contain more information on the cause of the failure.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BatchRequestOutputError {
    /// A machine-readable error code.
    #[serde(rename = "code")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<String>,

    /// A human-readable error message.
    #[serde(rename = "message")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

}



impl BatchRequestOutputError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BatchRequestOutputError {
        BatchRequestOutputError {
 code: None,
 message: None,
        }
    }
}

/// Converts the BatchRequestOutputError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BatchRequestOutputError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BatchRequestOutputError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BatchRequestOutputError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<String>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BatchRequestOutputError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BatchRequestOutputError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BatchRequestOutputError {
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BatchRequestOutputError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BatchRequestOutputError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BatchRequestOutputError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BatchRequestOutputError - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BatchRequestOutputError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BatchRequestOutputError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BatchRequestOutputError - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BatchRequestOutputResponse {
    /// The HTTP status code of the response
    #[serde(rename = "status_code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status_code: Option<i32>,

    /// An unique identifier for the OpenAI API request. Please include this request ID when contacting support.
    #[serde(rename = "request_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub request_id: Option<String>,

    /// The JSON body of the response
    #[serde(rename = "body")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<crate::types::Object>,

}



impl BatchRequestOutputResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BatchRequestOutputResponse {
        BatchRequestOutputResponse {
 status_code: None,
 request_id: None,
 body: None,
        }
    }
}

/// Converts the BatchRequestOutputResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BatchRequestOutputResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.status_code.as_ref().map(|status_code| {
                [
                    "status_code".to_string(),
                    status_code.to_string(),
                ].join(",")
            }),


            self.request_id.as_ref().map(|request_id| {
                [
                    "request_id".to_string(),
                    request_id.to_string(),
                ].join(",")
            }),

            // Skipping body in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BatchRequestOutputResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BatchRequestOutputResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub status_code: Vec<i32>,
            pub request_id: Vec<String>,
            pub body: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BatchRequestOutputResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "status_code" => intermediate_rep.status_code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "request_id" => intermediate_rep.request_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "body" => intermediate_rep.body.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BatchRequestOutputResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BatchRequestOutputResponse {
            status_code: intermediate_rep.status_code.into_iter().next(),
            request_id: intermediate_rep.request_id.into_iter().next(),
            body: intermediate_rep.body.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BatchRequestOutputResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BatchRequestOutputResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BatchRequestOutputResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BatchRequestOutputResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BatchRequestOutputResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BatchRequestOutputResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BatchRequestOutputResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionFunctionCallOption {
    /// The name of the function to call.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

}



impl ChatCompletionFunctionCallOption {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> ChatCompletionFunctionCallOption {
        ChatCompletionFunctionCallOption {
 name,
        }
    }
}

/// Converts the ChatCompletionFunctionCallOption value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionFunctionCallOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionFunctionCallOption value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionFunctionCallOption {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionFunctionCallOption".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionFunctionCallOption".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionFunctionCallOption {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ChatCompletionFunctionCallOption".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionFunctionCallOption> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionFunctionCallOption>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionFunctionCallOption>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionFunctionCallOption - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionFunctionCallOption> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionFunctionCallOption as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionFunctionCallOption - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionFunctions {
    /// A description of what the function does, used by the model to choose when and how to call the function.
    #[serde(rename = "description")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.   Omitting `parameters` defines a function with an empty parameter list.
    #[serde(rename = "parameters")]
          #[validate(custom(function = "check_xss_map"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<std::collections::HashMap<String, crate::types::Object>>,

}



impl ChatCompletionFunctions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> ChatCompletionFunctions {
        ChatCompletionFunctions {
 description: None,
 name,
 parameters: None,
        }
    }
}

/// Converts the ChatCompletionFunctions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionFunctions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping parameters in query parameter serialization
            // Skipping parameters in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionFunctions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionFunctions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub name: Vec<String>,
            pub parameters: Vec<std::collections::HashMap<String, crate::types::Object>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionFunctions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "parameters" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatCompletionFunctions".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionFunctions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionFunctions {
            description: intermediate_rep.description.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ChatCompletionFunctions".to_string())?,
            parameters: intermediate_rep.parameters.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionFunctions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionFunctions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionFunctions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionFunctions - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionFunctions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionFunctions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionFunctions - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionMessageToolCall {
    /// The ID of the tool call.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The type of the tool. Currently, only `function` is supported.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "function")]
          #[validate(nested)]
    pub function: models::ChatCompletionMessageToolCallFunction,

}



impl ChatCompletionMessageToolCall {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, r_type: String, function: models::ChatCompletionMessageToolCallFunction, ) -> ChatCompletionMessageToolCall {
        ChatCompletionMessageToolCall {
 id,
 r_type,
 function,
        }
    }
}

/// Converts the ChatCompletionMessageToolCall value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionMessageToolCall {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionMessageToolCall value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionMessageToolCall {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r_type: Vec<String>,
            pub function: Vec<models::ChatCompletionMessageToolCallFunction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionMessageToolCall".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::ChatCompletionMessageToolCallFunction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionMessageToolCall".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionMessageToolCall {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ChatCompletionMessageToolCall".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in ChatCompletionMessageToolCall".to_string())?,
            function: intermediate_rep.function.into_iter().next().ok_or_else(|| "function missing in ChatCompletionMessageToolCall".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionMessageToolCall> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionMessageToolCall>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionMessageToolCall>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionMessageToolCall - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionMessageToolCall> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionMessageToolCall as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionMessageToolCall - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionMessageToolCallChunk {
    #[serde(rename = "index")]
    pub index: i32,

    /// The ID of the tool call.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// The type of the tool. Currently, only `function` is supported.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    #[serde(rename = "function")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub function: Option<models::ChatCompletionMessageToolCallChunkFunction>,

}



impl ChatCompletionMessageToolCallChunk {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, ) -> ChatCompletionMessageToolCallChunk {
        ChatCompletionMessageToolCallChunk {
 index,
 id: None,
 r_type: None,
 function: None,
        }
    }
}

/// Converts the ChatCompletionMessageToolCallChunk value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionMessageToolCallChunk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionMessageToolCallChunk value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionMessageToolCallChunk {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub id: Vec<String>,
            pub r_type: Vec<String>,
            pub function: Vec<models::ChatCompletionMessageToolCallChunkFunction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionMessageToolCallChunk".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::ChatCompletionMessageToolCallChunkFunction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionMessageToolCallChunk".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionMessageToolCallChunk {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in ChatCompletionMessageToolCallChunk".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            r_type: intermediate_rep.r_type.into_iter().next(),
            function: intermediate_rep.function.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionMessageToolCallChunk> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionMessageToolCallChunk>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionMessageToolCallChunk>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionMessageToolCallChunk - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionMessageToolCallChunk> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionMessageToolCallChunk as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionMessageToolCallChunk - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionMessageToolCallChunkFunction {
    /// The name of the function to call.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
    #[serde(rename = "arguments")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub arguments: Option<String>,

}



impl ChatCompletionMessageToolCallChunkFunction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ChatCompletionMessageToolCallChunkFunction {
        ChatCompletionMessageToolCallChunkFunction {
 name: None,
 arguments: None,
        }
    }
}

/// Converts the ChatCompletionMessageToolCallChunkFunction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionMessageToolCallChunkFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.arguments.as_ref().map(|arguments| {
                [
                    "arguments".to_string(),
                    arguments.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionMessageToolCallChunkFunction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionMessageToolCallChunkFunction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub arguments: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionMessageToolCallChunkFunction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionMessageToolCallChunkFunction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionMessageToolCallChunkFunction {
            name: intermediate_rep.name.into_iter().next(),
            arguments: intermediate_rep.arguments.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionMessageToolCallChunkFunction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionMessageToolCallChunkFunction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionMessageToolCallChunkFunction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionMessageToolCallChunkFunction - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionMessageToolCallChunkFunction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionMessageToolCallChunkFunction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionMessageToolCallChunkFunction - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The function that the model called.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionMessageToolCallFunction {
    /// The name of the function to call.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
    #[serde(rename = "arguments")]
          #[validate(custom(function = "check_xss_string"))]
    pub arguments: String,

}



impl ChatCompletionMessageToolCallFunction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, arguments: String, ) -> ChatCompletionMessageToolCallFunction {
        ChatCompletionMessageToolCallFunction {
 name,
 arguments,
        }
    }
}

/// Converts the ChatCompletionMessageToolCallFunction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionMessageToolCallFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("arguments".to_string()),
            Some(self.arguments.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionMessageToolCallFunction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionMessageToolCallFunction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub arguments: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionMessageToolCallFunction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionMessageToolCallFunction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionMessageToolCallFunction {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ChatCompletionMessageToolCallFunction".to_string())?,
            arguments: intermediate_rep.arguments.into_iter().next().ok_or_else(|| "arguments missing in ChatCompletionMessageToolCallFunction".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionMessageToolCallFunction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionMessageToolCallFunction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionMessageToolCallFunction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionMessageToolCallFunction - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionMessageToolCallFunction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionMessageToolCallFunction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionMessageToolCallFunction - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Specifies a tool the model should use. Use to force the model to call a specific function.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionNamedToolChoice {
    /// The type of the tool. Currently, only `function` is supported.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "function")]
          #[validate(nested)]
    pub function: models::AssistantsNamedToolChoiceFunction,

}



impl ChatCompletionNamedToolChoice {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, function: models::AssistantsNamedToolChoiceFunction, ) -> ChatCompletionNamedToolChoice {
        ChatCompletionNamedToolChoice {
 r_type,
 function,
        }
    }
}

/// Converts the ChatCompletionNamedToolChoice value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionNamedToolChoice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionNamedToolChoice value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionNamedToolChoice {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub function: Vec<models::AssistantsNamedToolChoiceFunction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionNamedToolChoice".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::AssistantsNamedToolChoiceFunction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionNamedToolChoice".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionNamedToolChoice {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in ChatCompletionNamedToolChoice".to_string())?,
            function: intermediate_rep.function.into_iter().next().ok_or_else(|| "function missing in ChatCompletionNamedToolChoice".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionNamedToolChoice> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionNamedToolChoice>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionNamedToolChoice>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionNamedToolChoice - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionNamedToolChoice> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionNamedToolChoice as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionNamedToolChoice - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Messages sent by the model in response to user messages. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestAssistantMessage {
    #[serde(rename = "content")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<Nullable<models::ChatCompletionRequestAssistantMessageContent>>,

    /// The refusal message by the assistant.
    #[serde(rename = "refusal")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub refusal: Option<Nullable<String>>,

    /// The role of the messages author, in this case `assistant`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "audio")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audio: Option<Nullable<models::ChatCompletionRequestAssistantMessageAudio>>,

    /// The tool calls generated by the model, such as function calls.
    #[serde(rename = "tool_calls")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_calls: Option<Vec<models::ChatCompletionMessageToolCall>>,

    #[serde(rename = "function_call")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub function_call: Option<Nullable<models::ChatCompletionRequestAssistantMessageFunctionCall>>,

}



impl ChatCompletionRequestAssistantMessage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(role: String, ) -> ChatCompletionRequestAssistantMessage {
        ChatCompletionRequestAssistantMessage {
 content: None,
 refusal: None,
 role,
 name: None,
 audio: None,
 tool_calls: None,
 function_call: None,
        }
    }
}

/// Converts the ChatCompletionRequestAssistantMessage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestAssistantMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping content in query parameter serialization


            self.refusal.as_ref().map(|refusal| {
                [
                    "refusal".to_string(),
                    refusal.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            Some("role".to_string()),
            Some(self.role.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping audio in query parameter serialization

            // Skipping tool_calls in query parameter serialization

            // Skipping function_call in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestAssistantMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestAssistantMessage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content: Vec<models::ChatCompletionRequestAssistantMessageContent>,
            pub refusal: Vec<String>,
            pub role: Vec<String>,
            pub name: Vec<String>,
            pub audio: Vec<models::ChatCompletionRequestAssistantMessageAudio>,
            pub tool_calls: Vec<Vec<models::ChatCompletionMessageToolCall>>,
            pub function_call: Vec<models::ChatCompletionRequestAssistantMessageFunctionCall>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestAssistantMessage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "content" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ChatCompletionRequestAssistantMessage".to_string()),
                    "refusal" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ChatCompletionRequestAssistantMessage".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "audio" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ChatCompletionRequestAssistantMessage".to_string()),
                    "tool_calls" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatCompletionRequestAssistantMessage".to_string()),
                    "function_call" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ChatCompletionRequestAssistantMessage".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestAssistantMessage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestAssistantMessage {
            content: std::result::Result::Err("Nullable types not supported in ChatCompletionRequestAssistantMessage".to_string())?,
            refusal: std::result::Result::Err("Nullable types not supported in ChatCompletionRequestAssistantMessage".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ChatCompletionRequestAssistantMessage".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            audio: std::result::Result::Err("Nullable types not supported in ChatCompletionRequestAssistantMessage".to_string())?,
            tool_calls: intermediate_rep.tool_calls.into_iter().next(),
            function_call: std::result::Result::Err("Nullable types not supported in ChatCompletionRequestAssistantMessage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestAssistantMessage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestAssistantMessage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestAssistantMessage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestAssistantMessage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestAssistantMessage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestAssistantMessage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestAssistantMessage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Data about a previous audio response from the model.  [Learn more](/docs/guides/audio). 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestAssistantMessageAudio {
    /// Unique identifier for a previous audio response from the model. 
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

}



impl ChatCompletionRequestAssistantMessageAudio {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, ) -> ChatCompletionRequestAssistantMessageAudio {
        ChatCompletionRequestAssistantMessageAudio {
 id,
        }
    }
}

/// Converts the ChatCompletionRequestAssistantMessageAudio value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestAssistantMessageAudio {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestAssistantMessageAudio value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestAssistantMessageAudio {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestAssistantMessageAudio".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestAssistantMessageAudio".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestAssistantMessageAudio {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ChatCompletionRequestAssistantMessageAudio".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestAssistantMessageAudio> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestAssistantMessageAudio>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestAssistantMessageAudio>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestAssistantMessageAudio - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestAssistantMessageAudio> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestAssistantMessageAudio as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestAssistantMessageAudio - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum ChatCompletionRequestAssistantMessageContent {
    String(String),
    VecOfChatCompletionRequestAssistantMessageContentPart(Vec<models::ChatCompletionRequestAssistantMessageContentPart>),
}

impl validator::Validate for ChatCompletionRequestAssistantMessageContent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::VecOfChatCompletionRequestAssistantMessageContentPart(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestAssistantMessageContent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestAssistantMessageContent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for ChatCompletionRequestAssistantMessageContent {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<Vec<models::ChatCompletionRequestAssistantMessageContentPart>> for ChatCompletionRequestAssistantMessageContent {
    fn from(value: Vec<models::ChatCompletionRequestAssistantMessageContentPart>) -> Self {
        Self::VecOfChatCompletionRequestAssistantMessageContentPart(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum ChatCompletionRequestAssistantMessageContentPart {
    ChatCompletionRequestMessageContentPartText(models::ChatCompletionRequestMessageContentPartText),
    ChatCompletionRequestMessageContentPartRefusal(models::ChatCompletionRequestMessageContentPartRefusal),
}

impl validator::Validate for ChatCompletionRequestAssistantMessageContentPart
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::ChatCompletionRequestMessageContentPartText(v) => v.validate(),
            Self::ChatCompletionRequestMessageContentPartRefusal(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestAssistantMessageContentPart value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestAssistantMessageContentPart {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::ChatCompletionRequestMessageContentPartText> for ChatCompletionRequestAssistantMessageContentPart {
    fn from(value: models::ChatCompletionRequestMessageContentPartText) -> Self {
        Self::ChatCompletionRequestMessageContentPartText(value)
    }
}
impl From<models::ChatCompletionRequestMessageContentPartRefusal> for ChatCompletionRequestAssistantMessageContentPart {
    fn from(value: models::ChatCompletionRequestMessageContentPartRefusal) -> Self {
        Self::ChatCompletionRequestMessageContentPartRefusal(value)
    }
}





/// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestAssistantMessageFunctionCall {
    /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
    #[serde(rename = "arguments")]
          #[validate(custom(function = "check_xss_string"))]
    pub arguments: String,

    /// The name of the function to call.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

}



impl ChatCompletionRequestAssistantMessageFunctionCall {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(arguments: String, name: String, ) -> ChatCompletionRequestAssistantMessageFunctionCall {
        ChatCompletionRequestAssistantMessageFunctionCall {
 arguments,
 name,
        }
    }
}

/// Converts the ChatCompletionRequestAssistantMessageFunctionCall value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestAssistantMessageFunctionCall {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("arguments".to_string()),
            Some(self.arguments.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestAssistantMessageFunctionCall value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestAssistantMessageFunctionCall {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub arguments: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestAssistantMessageFunctionCall".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestAssistantMessageFunctionCall".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestAssistantMessageFunctionCall {
            arguments: intermediate_rep.arguments.into_iter().next().ok_or_else(|| "arguments missing in ChatCompletionRequestAssistantMessageFunctionCall".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ChatCompletionRequestAssistantMessageFunctionCall".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestAssistantMessageFunctionCall> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestAssistantMessageFunctionCall>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestAssistantMessageFunctionCall>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestAssistantMessageFunctionCall - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestAssistantMessageFunctionCall> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestAssistantMessageFunctionCall as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestAssistantMessageFunctionCall - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Developer-provided instructions that the model should follow, regardless of messages sent by the user. With o1 models and newer, `developer` messages replace the previous `system` messages. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestDeveloperMessage {
    #[serde(rename = "content")]
          #[validate(nested)]
    pub content: models::ChatCompletionRequestDeveloperMessageContent,

    /// The role of the messages author, in this case `developer`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}



impl ChatCompletionRequestDeveloperMessage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(content: models::ChatCompletionRequestDeveloperMessageContent, role: String, ) -> ChatCompletionRequestDeveloperMessage {
        ChatCompletionRequestDeveloperMessage {
 content,
 role,
 name: None,
        }
    }
}

/// Converts the ChatCompletionRequestDeveloperMessage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestDeveloperMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping content in query parameter serialization


            Some("role".to_string()),
            Some(self.role.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestDeveloperMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestDeveloperMessage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content: Vec<models::ChatCompletionRequestDeveloperMessageContent>,
            pub role: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestDeveloperMessage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "content" => intermediate_rep.content.push(<models::ChatCompletionRequestDeveloperMessageContent as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestDeveloperMessage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestDeveloperMessage {
            content: intermediate_rep.content.into_iter().next().ok_or_else(|| "content missing in ChatCompletionRequestDeveloperMessage".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ChatCompletionRequestDeveloperMessage".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestDeveloperMessage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestDeveloperMessage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestDeveloperMessage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestDeveloperMessage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestDeveloperMessage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestDeveloperMessage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestDeveloperMessage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The contents of the developer message.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum ChatCompletionRequestDeveloperMessageContent {
    String(String),
    VecOfChatCompletionRequestMessageContentPartText(Vec<models::ChatCompletionRequestMessageContentPartText>),
}

impl validator::Validate for ChatCompletionRequestDeveloperMessageContent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::VecOfChatCompletionRequestMessageContentPartText(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestDeveloperMessageContent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestDeveloperMessageContent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for ChatCompletionRequestDeveloperMessageContent {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<Vec<models::ChatCompletionRequestMessageContentPartText>> for ChatCompletionRequestDeveloperMessageContent {
    fn from(value: Vec<models::ChatCompletionRequestMessageContentPartText>) -> Self {
        Self::VecOfChatCompletionRequestMessageContentPartText(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestFunctionMessage {
    /// The role of the messages author, in this case `function`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    /// The contents of the function message.
    #[serde(rename = "content")]
    pub content: Nullable<String>,

    /// The name of the function to call.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

}



impl ChatCompletionRequestFunctionMessage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(role: String, content: Nullable<String>, name: String, ) -> ChatCompletionRequestFunctionMessage {
        ChatCompletionRequestFunctionMessage {
 role,
 content,
 name,
        }
    }
}

/// Converts the ChatCompletionRequestFunctionMessage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestFunctionMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("role".to_string()),
            Some(self.role.to_string()),


            Some("content".to_string()),
            Some(self.content.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestFunctionMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestFunctionMessage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role: Vec<String>,
            pub content: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestFunctionMessage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "content" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ChatCompletionRequestFunctionMessage".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestFunctionMessage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestFunctionMessage {
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ChatCompletionRequestFunctionMessage".to_string())?,
            content: std::result::Result::Err("Nullable types not supported in ChatCompletionRequestFunctionMessage".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ChatCompletionRequestFunctionMessage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestFunctionMessage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestFunctionMessage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestFunctionMessage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestFunctionMessage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestFunctionMessage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestFunctionMessage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestFunctionMessage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum ChatCompletionRequestMessage {
    ChatCompletionRequestDeveloperMessage(models::ChatCompletionRequestDeveloperMessage),
    ChatCompletionRequestSystemMessage(models::ChatCompletionRequestSystemMessage),
    ChatCompletionRequestUserMessage(models::ChatCompletionRequestUserMessage),
    ChatCompletionRequestAssistantMessage(models::ChatCompletionRequestAssistantMessage),
    ChatCompletionRequestToolMessage(models::ChatCompletionRequestToolMessage),
    ChatCompletionRequestFunctionMessage(models::ChatCompletionRequestFunctionMessage),
}

impl validator::Validate for ChatCompletionRequestMessage
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::ChatCompletionRequestDeveloperMessage(v) => v.validate(),
            Self::ChatCompletionRequestSystemMessage(v) => v.validate(),
            Self::ChatCompletionRequestUserMessage(v) => v.validate(),
            Self::ChatCompletionRequestAssistantMessage(v) => v.validate(),
            Self::ChatCompletionRequestToolMessage(v) => v.validate(),
            Self::ChatCompletionRequestFunctionMessage(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestMessage {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::ChatCompletionRequestDeveloperMessage> for ChatCompletionRequestMessage {
    fn from(value: models::ChatCompletionRequestDeveloperMessage) -> Self {
        Self::ChatCompletionRequestDeveloperMessage(value)
    }
}
impl From<models::ChatCompletionRequestSystemMessage> for ChatCompletionRequestMessage {
    fn from(value: models::ChatCompletionRequestSystemMessage) -> Self {
        Self::ChatCompletionRequestSystemMessage(value)
    }
}
impl From<models::ChatCompletionRequestUserMessage> for ChatCompletionRequestMessage {
    fn from(value: models::ChatCompletionRequestUserMessage) -> Self {
        Self::ChatCompletionRequestUserMessage(value)
    }
}
impl From<models::ChatCompletionRequestAssistantMessage> for ChatCompletionRequestMessage {
    fn from(value: models::ChatCompletionRequestAssistantMessage) -> Self {
        Self::ChatCompletionRequestAssistantMessage(value)
    }
}
impl From<models::ChatCompletionRequestToolMessage> for ChatCompletionRequestMessage {
    fn from(value: models::ChatCompletionRequestToolMessage) -> Self {
        Self::ChatCompletionRequestToolMessage(value)
    }
}
impl From<models::ChatCompletionRequestFunctionMessage> for ChatCompletionRequestMessage {
    fn from(value: models::ChatCompletionRequestFunctionMessage) -> Self {
        Self::ChatCompletionRequestFunctionMessage(value)
    }
}





/// Learn about [audio inputs](/docs/guides/audio). 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestMessageContentPartAudio {
    /// The type of the content part. Always `input_audio`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "input_audio")]
          #[validate(nested)]
    pub input_audio: models::ChatCompletionRequestMessageContentPartAudioInputAudio,

}



impl ChatCompletionRequestMessageContentPartAudio {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, input_audio: models::ChatCompletionRequestMessageContentPartAudioInputAudio, ) -> ChatCompletionRequestMessageContentPartAudio {
        ChatCompletionRequestMessageContentPartAudio {
 r_type,
 input_audio,
        }
    }
}

/// Converts the ChatCompletionRequestMessageContentPartAudio value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestMessageContentPartAudio {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping input_audio in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestMessageContentPartAudio value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestMessageContentPartAudio {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub input_audio: Vec<models::ChatCompletionRequestMessageContentPartAudioInputAudio>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestMessageContentPartAudio".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input_audio" => intermediate_rep.input_audio.push(<models::ChatCompletionRequestMessageContentPartAudioInputAudio as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestMessageContentPartAudio".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestMessageContentPartAudio {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in ChatCompletionRequestMessageContentPartAudio".to_string())?,
            input_audio: intermediate_rep.input_audio.into_iter().next().ok_or_else(|| "input_audio missing in ChatCompletionRequestMessageContentPartAudio".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestMessageContentPartAudio> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestMessageContentPartAudio>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestMessageContentPartAudio>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestMessageContentPartAudio - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestMessageContentPartAudio> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestMessageContentPartAudio as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestMessageContentPartAudio - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestMessageContentPartAudioInputAudio {
    /// Base64 encoded audio data.
    #[serde(rename = "data")]
          #[validate(custom(function = "check_xss_string"))]
    pub data: String,

    /// The format of the encoded audio data. Currently supports \"wav\" and \"mp3\". 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "format")]
          #[validate(custom(function = "check_xss_string"))]
    pub format: String,

}



impl ChatCompletionRequestMessageContentPartAudioInputAudio {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(data: String, format: String, ) -> ChatCompletionRequestMessageContentPartAudioInputAudio {
        ChatCompletionRequestMessageContentPartAudioInputAudio {
 data,
 format,
        }
    }
}

/// Converts the ChatCompletionRequestMessageContentPartAudioInputAudio value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestMessageContentPartAudioInputAudio {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("data".to_string()),
            Some(self.data.to_string()),


            Some("format".to_string()),
            Some(self.format.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestMessageContentPartAudioInputAudio value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestMessageContentPartAudioInputAudio {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<String>,
            pub format: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestMessageContentPartAudioInputAudio".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "format" => intermediate_rep.format.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestMessageContentPartAudioInputAudio".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestMessageContentPartAudioInputAudio {
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ChatCompletionRequestMessageContentPartAudioInputAudio".to_string())?,
            format: intermediate_rep.format.into_iter().next().ok_or_else(|| "format missing in ChatCompletionRequestMessageContentPartAudioInputAudio".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestMessageContentPartAudioInputAudio> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestMessageContentPartAudioInputAudio>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestMessageContentPartAudioInputAudio>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestMessageContentPartAudioInputAudio - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestMessageContentPartAudioInputAudio> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestMessageContentPartAudioInputAudio as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestMessageContentPartAudioInputAudio - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Learn about [image inputs](/docs/guides/vision). 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestMessageContentPartImage {
    /// The type of the content part.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "image_url")]
          #[validate(nested)]
    pub image_url: models::ChatCompletionRequestMessageContentPartImageImageUrl,

}



impl ChatCompletionRequestMessageContentPartImage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, image_url: models::ChatCompletionRequestMessageContentPartImageImageUrl, ) -> ChatCompletionRequestMessageContentPartImage {
        ChatCompletionRequestMessageContentPartImage {
 r_type,
 image_url,
        }
    }
}

/// Converts the ChatCompletionRequestMessageContentPartImage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestMessageContentPartImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping image_url in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestMessageContentPartImage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestMessageContentPartImage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub image_url: Vec<models::ChatCompletionRequestMessageContentPartImageImageUrl>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestMessageContentPartImage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_url" => intermediate_rep.image_url.push(<models::ChatCompletionRequestMessageContentPartImageImageUrl as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestMessageContentPartImage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestMessageContentPartImage {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in ChatCompletionRequestMessageContentPartImage".to_string())?,
            image_url: intermediate_rep.image_url.into_iter().next().ok_or_else(|| "image_url missing in ChatCompletionRequestMessageContentPartImage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestMessageContentPartImage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestMessageContentPartImage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestMessageContentPartImage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestMessageContentPartImageImageUrl {
    /// Either a URL of the image or the base64 encoded image data.
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

    /// Specifies the detail level of the image. Learn more in the [Vision guide](/docs/guides/vision#low-or-high-fidelity-image-understanding).
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "detail")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub detail: Option<String>,

}



impl ChatCompletionRequestMessageContentPartImageImageUrl {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(url: String, ) -> ChatCompletionRequestMessageContentPartImageImageUrl {
        ChatCompletionRequestMessageContentPartImageImageUrl {
 url,
 detail: None,
        }
    }
}

/// Converts the ChatCompletionRequestMessageContentPartImageImageUrl value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestMessageContentPartImageImageUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("url".to_string()),
            Some(self.url.to_string()),


            self.detail.as_ref().map(|detail| {
                [
                    "detail".to_string(),
                    detail.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestMessageContentPartImageImageUrl value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestMessageContentPartImageImageUrl {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
            pub detail: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestMessageContentPartImageImageUrl".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "detail" => intermediate_rep.detail.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestMessageContentPartImageImageUrl".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestMessageContentPartImageImageUrl {
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in ChatCompletionRequestMessageContentPartImageImageUrl".to_string())?,
            detail: intermediate_rep.detail.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImageImageUrl> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImageImageUrl>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImageImageUrl>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestMessageContentPartImageImageUrl - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestMessageContentPartImageImageUrl> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestMessageContentPartImageImageUrl as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestMessageContentPartImageImageUrl - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestMessageContentPartRefusal {
    /// The type of the content part.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The refusal message generated by the model.
    #[serde(rename = "refusal")]
          #[validate(custom(function = "check_xss_string"))]
    pub refusal: String,

}



impl ChatCompletionRequestMessageContentPartRefusal {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, refusal: String, ) -> ChatCompletionRequestMessageContentPartRefusal {
        ChatCompletionRequestMessageContentPartRefusal {
 r_type,
 refusal,
        }
    }
}

/// Converts the ChatCompletionRequestMessageContentPartRefusal value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestMessageContentPartRefusal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("refusal".to_string()),
            Some(self.refusal.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestMessageContentPartRefusal value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestMessageContentPartRefusal {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub refusal: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestMessageContentPartRefusal".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "refusal" => intermediate_rep.refusal.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestMessageContentPartRefusal".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestMessageContentPartRefusal {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in ChatCompletionRequestMessageContentPartRefusal".to_string())?,
            refusal: intermediate_rep.refusal.into_iter().next().ok_or_else(|| "refusal missing in ChatCompletionRequestMessageContentPartRefusal".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestMessageContentPartRefusal> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestMessageContentPartRefusal>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestMessageContentPartRefusal>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestMessageContentPartRefusal - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestMessageContentPartRefusal> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestMessageContentPartRefusal as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestMessageContentPartRefusal - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Learn about [text inputs](/docs/guides/text-generation). 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestMessageContentPartText {
    /// The type of the content part.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The text content.
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    pub text: String,

}



impl ChatCompletionRequestMessageContentPartText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, text: String, ) -> ChatCompletionRequestMessageContentPartText {
        ChatCompletionRequestMessageContentPartText {
 r_type,
 text,
        }
    }
}

/// Converts the ChatCompletionRequestMessageContentPartText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestMessageContentPartText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestMessageContentPartText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestMessageContentPartText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub text: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestMessageContentPartText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestMessageContentPartText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestMessageContentPartText {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in ChatCompletionRequestMessageContentPartText".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in ChatCompletionRequestMessageContentPartText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestMessageContentPartText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestMessageContentPartText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestMessageContentPartText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestMessageContentPartText - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestMessageContentPartText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestMessageContentPartText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestMessageContentPartText - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Developer-provided instructions that the model should follow, regardless of messages sent by the user. With o1 models and newer, use `developer` messages for this purpose instead. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestSystemMessage {
    #[serde(rename = "content")]
          #[validate(nested)]
    pub content: models::ChatCompletionRequestSystemMessageContent,

    /// The role of the messages author, in this case `system`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}



impl ChatCompletionRequestSystemMessage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(content: models::ChatCompletionRequestSystemMessageContent, role: String, ) -> ChatCompletionRequestSystemMessage {
        ChatCompletionRequestSystemMessage {
 content,
 role,
 name: None,
        }
    }
}

/// Converts the ChatCompletionRequestSystemMessage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestSystemMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping content in query parameter serialization


            Some("role".to_string()),
            Some(self.role.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestSystemMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestSystemMessage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content: Vec<models::ChatCompletionRequestSystemMessageContent>,
            pub role: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestSystemMessage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "content" => intermediate_rep.content.push(<models::ChatCompletionRequestSystemMessageContent as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestSystemMessage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestSystemMessage {
            content: intermediate_rep.content.into_iter().next().ok_or_else(|| "content missing in ChatCompletionRequestSystemMessage".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ChatCompletionRequestSystemMessage".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestSystemMessage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestSystemMessage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestSystemMessage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestSystemMessage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestSystemMessage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestSystemMessage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestSystemMessage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The contents of the system message.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum ChatCompletionRequestSystemMessageContent {
    String(String),
    VecOfChatCompletionRequestSystemMessageContentPart(Vec<models::ChatCompletionRequestSystemMessageContentPart>),
}

impl validator::Validate for ChatCompletionRequestSystemMessageContent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::VecOfChatCompletionRequestSystemMessageContentPart(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestSystemMessageContent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestSystemMessageContent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for ChatCompletionRequestSystemMessageContent {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<Vec<models::ChatCompletionRequestSystemMessageContentPart>> for ChatCompletionRequestSystemMessageContent {
    fn from(value: Vec<models::ChatCompletionRequestSystemMessageContentPart>) -> Self {
        Self::VecOfChatCompletionRequestSystemMessageContentPart(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestSystemMessageContentPart {
}



impl ChatCompletionRequestSystemMessageContentPart {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ChatCompletionRequestSystemMessageContentPart {
        ChatCompletionRequestSystemMessageContentPart {
        }
    }
}

/// Converts the ChatCompletionRequestSystemMessageContentPart value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestSystemMessageContentPart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestSystemMessageContentPart value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestSystemMessageContentPart {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestSystemMessageContentPart".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestSystemMessageContentPart".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestSystemMessageContentPart {
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestSystemMessageContentPart> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestSystemMessageContentPart>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestSystemMessageContentPart>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestSystemMessageContentPart - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestSystemMessageContentPart> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestSystemMessageContentPart as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestSystemMessageContentPart - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestToolMessage {
    /// The role of the messages author, in this case `tool`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    #[serde(rename = "content")]
          #[validate(nested)]
    pub content: models::ChatCompletionRequestToolMessageContent,

    /// Tool call that this message is responding to.
    #[serde(rename = "tool_call_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub tool_call_id: String,

}



impl ChatCompletionRequestToolMessage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(role: String, content: models::ChatCompletionRequestToolMessageContent, tool_call_id: String, ) -> ChatCompletionRequestToolMessage {
        ChatCompletionRequestToolMessage {
 role,
 content,
 tool_call_id,
        }
    }
}

/// Converts the ChatCompletionRequestToolMessage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestToolMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("role".to_string()),
            Some(self.role.to_string()),

            // Skipping content in query parameter serialization


            Some("tool_call_id".to_string()),
            Some(self.tool_call_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestToolMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestToolMessage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role: Vec<String>,
            pub content: Vec<models::ChatCompletionRequestToolMessageContent>,
            pub tool_call_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestToolMessage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content" => intermediate_rep.content.push(<models::ChatCompletionRequestToolMessageContent as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tool_call_id" => intermediate_rep.tool_call_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestToolMessage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestToolMessage {
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ChatCompletionRequestToolMessage".to_string())?,
            content: intermediate_rep.content.into_iter().next().ok_or_else(|| "content missing in ChatCompletionRequestToolMessage".to_string())?,
            tool_call_id: intermediate_rep.tool_call_id.into_iter().next().ok_or_else(|| "tool_call_id missing in ChatCompletionRequestToolMessage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestToolMessage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestToolMessage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestToolMessage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestToolMessage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestToolMessage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestToolMessage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestToolMessage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The contents of the tool message.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum ChatCompletionRequestToolMessageContent {
    String(String),
    VecOfChatCompletionRequestToolMessageContentPart(Vec<models::ChatCompletionRequestToolMessageContentPart>),
}

impl validator::Validate for ChatCompletionRequestToolMessageContent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::VecOfChatCompletionRequestToolMessageContentPart(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestToolMessageContent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestToolMessageContent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for ChatCompletionRequestToolMessageContent {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<Vec<models::ChatCompletionRequestToolMessageContentPart>> for ChatCompletionRequestToolMessageContent {
    fn from(value: Vec<models::ChatCompletionRequestToolMessageContentPart>) -> Self {
        Self::VecOfChatCompletionRequestToolMessageContentPart(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestToolMessageContentPart {
}



impl ChatCompletionRequestToolMessageContentPart {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ChatCompletionRequestToolMessageContentPart {
        ChatCompletionRequestToolMessageContentPart {
        }
    }
}

/// Converts the ChatCompletionRequestToolMessageContentPart value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestToolMessageContentPart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestToolMessageContentPart value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestToolMessageContentPart {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestToolMessageContentPart".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestToolMessageContentPart".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestToolMessageContentPart {
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestToolMessageContentPart> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestToolMessageContentPart>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestToolMessageContentPart>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestToolMessageContentPart - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestToolMessageContentPart> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestToolMessageContentPart as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestToolMessageContentPart - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Messages sent by an end user, containing prompts or additional context information. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionRequestUserMessage {
    #[serde(rename = "content")]
          #[validate(nested)]
    pub content: models::ChatCompletionRequestUserMessageContent,

    /// The role of the messages author, in this case `user`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}



impl ChatCompletionRequestUserMessage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(content: models::ChatCompletionRequestUserMessageContent, role: String, ) -> ChatCompletionRequestUserMessage {
        ChatCompletionRequestUserMessage {
 content,
 role,
 name: None,
        }
    }
}

/// Converts the ChatCompletionRequestUserMessage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionRequestUserMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping content in query parameter serialization


            Some("role".to_string()),
            Some(self.role.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestUserMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestUserMessage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content: Vec<models::ChatCompletionRequestUserMessageContent>,
            pub role: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionRequestUserMessage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "content" => intermediate_rep.content.push(<models::ChatCompletionRequestUserMessageContent as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionRequestUserMessage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionRequestUserMessage {
            content: intermediate_rep.content.into_iter().next().ok_or_else(|| "content missing in ChatCompletionRequestUserMessage".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ChatCompletionRequestUserMessage".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionRequestUserMessage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionRequestUserMessage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionRequestUserMessage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionRequestUserMessage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionRequestUserMessage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionRequestUserMessage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionRequestUserMessage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The contents of the user message. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum ChatCompletionRequestUserMessageContent {
    String(String),
    VecOfChatCompletionRequestUserMessageContentPart(Vec<models::ChatCompletionRequestUserMessageContentPart>),
}

impl validator::Validate for ChatCompletionRequestUserMessageContent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::VecOfChatCompletionRequestUserMessageContentPart(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestUserMessageContent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestUserMessageContent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for ChatCompletionRequestUserMessageContent {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<Vec<models::ChatCompletionRequestUserMessageContentPart>> for ChatCompletionRequestUserMessageContent {
    fn from(value: Vec<models::ChatCompletionRequestUserMessageContentPart>) -> Self {
        Self::VecOfChatCompletionRequestUserMessageContentPart(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum ChatCompletionRequestUserMessageContentPart {
    ChatCompletionRequestMessageContentPartText(models::ChatCompletionRequestMessageContentPartText),
    ChatCompletionRequestMessageContentPartImage(models::ChatCompletionRequestMessageContentPartImage),
    ChatCompletionRequestMessageContentPartAudio(models::ChatCompletionRequestMessageContentPartAudio),
}

impl validator::Validate for ChatCompletionRequestUserMessageContentPart
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::ChatCompletionRequestMessageContentPartText(v) => v.validate(),
            Self::ChatCompletionRequestMessageContentPartImage(v) => v.validate(),
            Self::ChatCompletionRequestMessageContentPartAudio(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionRequestUserMessageContentPart value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionRequestUserMessageContentPart {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::ChatCompletionRequestMessageContentPartText> for ChatCompletionRequestUserMessageContentPart {
    fn from(value: models::ChatCompletionRequestMessageContentPartText) -> Self {
        Self::ChatCompletionRequestMessageContentPartText(value)
    }
}
impl From<models::ChatCompletionRequestMessageContentPartImage> for ChatCompletionRequestUserMessageContentPart {
    fn from(value: models::ChatCompletionRequestMessageContentPartImage) -> Self {
        Self::ChatCompletionRequestMessageContentPartImage(value)
    }
}
impl From<models::ChatCompletionRequestMessageContentPartAudio> for ChatCompletionRequestUserMessageContentPart {
    fn from(value: models::ChatCompletionRequestMessageContentPartAudio) -> Self {
        Self::ChatCompletionRequestMessageContentPartAudio(value)
    }
}





/// A chat completion message generated by the model.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionResponseMessage {
    /// The contents of the message.
    #[serde(rename = "content")]
    pub content: Nullable<String>,

    /// The refusal message generated by the model.
    #[serde(rename = "refusal")]
    pub refusal: Nullable<String>,

    /// The tool calls generated by the model, such as function calls.
    #[serde(rename = "tool_calls")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_calls: Option<Vec<models::ChatCompletionMessageToolCall>>,

    /// The role of the author of this message.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    #[serde(rename = "function_call")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub function_call: Option<models::ChatCompletionResponseMessageFunctionCall>,

    #[serde(rename = "audio")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audio: Option<Nullable<models::ChatCompletionResponseMessageAudio>>,

}



impl ChatCompletionResponseMessage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(content: Nullable<String>, refusal: Nullable<String>, role: String, ) -> ChatCompletionResponseMessage {
        ChatCompletionResponseMessage {
 content,
 refusal,
 tool_calls: None,
 role,
 function_call: None,
 audio: None,
        }
    }
}

/// Converts the ChatCompletionResponseMessage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionResponseMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("content".to_string()),
            Some(self.content.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("refusal".to_string()),
            Some(self.refusal.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping tool_calls in query parameter serialization


            Some("role".to_string()),
            Some(self.role.to_string()),

            // Skipping function_call in query parameter serialization

            // Skipping audio in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionResponseMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionResponseMessage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content: Vec<String>,
            pub refusal: Vec<String>,
            pub tool_calls: Vec<Vec<models::ChatCompletionMessageToolCall>>,
            pub role: Vec<String>,
            pub function_call: Vec<models::ChatCompletionResponseMessageFunctionCall>,
            pub audio: Vec<models::ChatCompletionResponseMessageAudio>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionResponseMessage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "content" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ChatCompletionResponseMessage".to_string()),
                    "refusal" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ChatCompletionResponseMessage".to_string()),
                    "tool_calls" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatCompletionResponseMessage".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function_call" => intermediate_rep.function_call.push(<models::ChatCompletionResponseMessageFunctionCall as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "audio" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ChatCompletionResponseMessage".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionResponseMessage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionResponseMessage {
            content: std::result::Result::Err("Nullable types not supported in ChatCompletionResponseMessage".to_string())?,
            refusal: std::result::Result::Err("Nullable types not supported in ChatCompletionResponseMessage".to_string())?,
            tool_calls: intermediate_rep.tool_calls.into_iter().next(),
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ChatCompletionResponseMessage".to_string())?,
            function_call: intermediate_rep.function_call.into_iter().next(),
            audio: std::result::Result::Err("Nullable types not supported in ChatCompletionResponseMessage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionResponseMessage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionResponseMessage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionResponseMessage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionResponseMessage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionResponseMessage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionResponseMessage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionResponseMessage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// If the audio output modality is requested, this object contains data about the audio response from the model. [Learn more](/docs/guides/audio). 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionResponseMessageAudio {
    /// Unique identifier for this audio response.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The Unix timestamp (in seconds) for when this audio response will no longer be accessible on the server for use in multi-turn conversations. 
    #[serde(rename = "expires_at")]
    pub expires_at: i32,

    /// Base64 encoded audio bytes generated by the model, in the format specified in the request. 
    #[serde(rename = "data")]
          #[validate(custom(function = "check_xss_string"))]
    pub data: String,

    /// Transcript of the audio generated by the model.
    #[serde(rename = "transcript")]
          #[validate(custom(function = "check_xss_string"))]
    pub transcript: String,

}



impl ChatCompletionResponseMessageAudio {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, expires_at: i32, data: String, transcript: String, ) -> ChatCompletionResponseMessageAudio {
        ChatCompletionResponseMessageAudio {
 id,
 expires_at,
 data,
 transcript,
        }
    }
}

/// Converts the ChatCompletionResponseMessageAudio value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionResponseMessageAudio {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("expires_at".to_string()),
            Some(self.expires_at.to_string()),


            Some("data".to_string()),
            Some(self.data.to_string()),


            Some("transcript".to_string()),
            Some(self.transcript.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionResponseMessageAudio value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionResponseMessageAudio {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub expires_at: Vec<i32>,
            pub data: Vec<String>,
            pub transcript: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionResponseMessageAudio".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expires_at" => intermediate_rep.expires_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "transcript" => intermediate_rep.transcript.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionResponseMessageAudio".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionResponseMessageAudio {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ChatCompletionResponseMessageAudio".to_string())?,
            expires_at: intermediate_rep.expires_at.into_iter().next().ok_or_else(|| "expires_at missing in ChatCompletionResponseMessageAudio".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ChatCompletionResponseMessageAudio".to_string())?,
            transcript: intermediate_rep.transcript.into_iter().next().ok_or_else(|| "transcript missing in ChatCompletionResponseMessageAudio".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionResponseMessageAudio> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionResponseMessageAudio>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionResponseMessageAudio>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionResponseMessageAudio - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionResponseMessageAudio> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionResponseMessageAudio as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionResponseMessageAudio - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionResponseMessageFunctionCall {
    /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
    #[serde(rename = "arguments")]
          #[validate(custom(function = "check_xss_string"))]
    pub arguments: String,

    /// The name of the function to call.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

}



impl ChatCompletionResponseMessageFunctionCall {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(arguments: String, name: String, ) -> ChatCompletionResponseMessageFunctionCall {
        ChatCompletionResponseMessageFunctionCall {
 arguments,
 name,
        }
    }
}

/// Converts the ChatCompletionResponseMessageFunctionCall value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionResponseMessageFunctionCall {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("arguments".to_string()),
            Some(self.arguments.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionResponseMessageFunctionCall value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionResponseMessageFunctionCall {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub arguments: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionResponseMessageFunctionCall".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionResponseMessageFunctionCall".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionResponseMessageFunctionCall {
            arguments: intermediate_rep.arguments.into_iter().next().ok_or_else(|| "arguments missing in ChatCompletionResponseMessageFunctionCall".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ChatCompletionResponseMessageFunctionCall".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionResponseMessageFunctionCall> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionResponseMessageFunctionCall>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionResponseMessageFunctionCall>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionResponseMessageFunctionCall - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionResponseMessageFunctionCall> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionResponseMessageFunctionCall as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionResponseMessageFunctionCall - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The role of the author of a message
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types, clippy::large_enum_variant)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ChatCompletionRole {
    #[serde(rename = "system")]
    System,
    #[serde(rename = "user")]
    User,
    #[serde(rename = "assistant")]
    Assistant,
    #[serde(rename = "tool")]
    Tool,
    #[serde(rename = "function")]
    Function,
}

impl validator::Validate for ChatCompletionRole
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        std::result::Result::Ok(())
    }
}

impl std::fmt::Display for ChatCompletionRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ChatCompletionRole::System => write!(f, "system"),
            ChatCompletionRole::User => write!(f, "user"),
            ChatCompletionRole::Assistant => write!(f, "assistant"),
            ChatCompletionRole::Tool => write!(f, "tool"),
            ChatCompletionRole::Function => write!(f, "function"),
        }
    }
}

impl std::str::FromStr for ChatCompletionRole {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "system" => std::result::Result::Ok(ChatCompletionRole::System),
            "user" => std::result::Result::Ok(ChatCompletionRole::User),
            "assistant" => std::result::Result::Ok(ChatCompletionRole::Assistant),
            "tool" => std::result::Result::Ok(ChatCompletionRole::Tool),
            "function" => std::result::Result::Ok(ChatCompletionRole::Function),
            _ => std::result::Result::Err(format!(r#"Value not valid: {s}"#)),
        }
    }
}


/// Options for streaming response. Only set this when you set `stream: true`. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionStreamOptions {
    /// If set, an additional chunk will be streamed before the `data: [DONE]` message. The `usage` field on this chunk shows the token usage statistics for the entire request, and the `choices` field will always be an empty array. All other chunks will also include a `usage` field, but with a null value. 
    #[serde(rename = "include_usage")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub include_usage: Option<bool>,

}



impl ChatCompletionStreamOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ChatCompletionStreamOptions {
        ChatCompletionStreamOptions {
 include_usage: None,
        }
    }
}

/// Converts the ChatCompletionStreamOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionStreamOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.include_usage.as_ref().map(|include_usage| {
                [
                    "include_usage".to_string(),
                    include_usage.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionStreamOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionStreamOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub include_usage: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionStreamOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "include_usage" => intermediate_rep.include_usage.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionStreamOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionStreamOptions {
            include_usage: intermediate_rep.include_usage.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionStreamOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionStreamOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionStreamOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionStreamOptions - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionStreamOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionStreamOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionStreamOptions - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A chat completion delta generated by streamed model responses.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionStreamResponseDelta {
    /// The contents of the chunk message.
    #[serde(rename = "content")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<Nullable<String>>,

    #[serde(rename = "function_call")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub function_call: Option<models::ChatCompletionStreamResponseDeltaFunctionCall>,

    #[serde(rename = "tool_calls")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_calls: Option<Vec<models::ChatCompletionMessageToolCallChunk>>,

    /// The role of the author of this message.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,

    /// The refusal message generated by the model.
    #[serde(rename = "refusal")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub refusal: Option<Nullable<String>>,

}



impl ChatCompletionStreamResponseDelta {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ChatCompletionStreamResponseDelta {
        ChatCompletionStreamResponseDelta {
 content: None,
 function_call: None,
 tool_calls: None,
 role: None,
 refusal: None,
        }
    }
}

/// Converts the ChatCompletionStreamResponseDelta value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionStreamResponseDelta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.content.as_ref().map(|content| {
                [
                    "content".to_string(),
                    content.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping function_call in query parameter serialization

            // Skipping tool_calls in query parameter serialization


            self.role.as_ref().map(|role| {
                [
                    "role".to_string(),
                    role.to_string(),
                ].join(",")
            }),


            self.refusal.as_ref().map(|refusal| {
                [
                    "refusal".to_string(),
                    refusal.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionStreamResponseDelta value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionStreamResponseDelta {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content: Vec<String>,
            pub function_call: Vec<models::ChatCompletionStreamResponseDeltaFunctionCall>,
            pub tool_calls: Vec<Vec<models::ChatCompletionMessageToolCallChunk>>,
            pub role: Vec<String>,
            pub refusal: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionStreamResponseDelta".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "content" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ChatCompletionStreamResponseDelta".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "function_call" => intermediate_rep.function_call.push(<models::ChatCompletionStreamResponseDeltaFunctionCall as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tool_calls" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatCompletionStreamResponseDelta".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "refusal" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ChatCompletionStreamResponseDelta".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionStreamResponseDelta".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionStreamResponseDelta {
            content: std::result::Result::Err("Nullable types not supported in ChatCompletionStreamResponseDelta".to_string())?,
            function_call: intermediate_rep.function_call.into_iter().next(),
            tool_calls: intermediate_rep.tool_calls.into_iter().next(),
            role: intermediate_rep.role.into_iter().next(),
            refusal: std::result::Result::Err("Nullable types not supported in ChatCompletionStreamResponseDelta".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionStreamResponseDelta> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionStreamResponseDelta>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionStreamResponseDelta>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionStreamResponseDelta - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionStreamResponseDelta> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionStreamResponseDelta as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionStreamResponseDelta - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionStreamResponseDeltaFunctionCall {
    /// The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
    #[serde(rename = "arguments")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub arguments: Option<String>,

    /// The name of the function to call.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}



impl ChatCompletionStreamResponseDeltaFunctionCall {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ChatCompletionStreamResponseDeltaFunctionCall {
        ChatCompletionStreamResponseDeltaFunctionCall {
 arguments: None,
 name: None,
        }
    }
}

/// Converts the ChatCompletionStreamResponseDeltaFunctionCall value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionStreamResponseDeltaFunctionCall {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.arguments.as_ref().map(|arguments| {
                [
                    "arguments".to_string(),
                    arguments.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionStreamResponseDeltaFunctionCall value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionStreamResponseDeltaFunctionCall {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub arguments: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionStreamResponseDeltaFunctionCall".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionStreamResponseDeltaFunctionCall".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionStreamResponseDeltaFunctionCall {
            arguments: intermediate_rep.arguments.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionStreamResponseDeltaFunctionCall> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionStreamResponseDeltaFunctionCall>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionStreamResponseDeltaFunctionCall>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionStreamResponseDeltaFunctionCall - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionStreamResponseDeltaFunctionCall> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionStreamResponseDeltaFunctionCall as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionStreamResponseDeltaFunctionCall - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionTokenLogprob {
    /// The token.
    #[serde(rename = "token")]
          #[validate(custom(function = "check_xss_string"))]
    pub token: String,

    /// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
    #[serde(rename = "logprob")]
    pub logprob: f64,

    /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
    #[serde(rename = "bytes")]
    pub bytes: Nullable<Vec<i32>>,

    /// List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
    #[serde(rename = "top_logprobs")]
          #[validate(nested)]
    pub top_logprobs: Vec<models::ChatCompletionTokenLogprobTopLogprobsInner>,

}



impl ChatCompletionTokenLogprob {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(token: String, logprob: f64, bytes: Nullable<Vec<i32>>, top_logprobs: Vec<models::ChatCompletionTokenLogprobTopLogprobsInner>, ) -> ChatCompletionTokenLogprob {
        ChatCompletionTokenLogprob {
 token,
 logprob,
 bytes,
 top_logprobs,
        }
    }
}

/// Converts the ChatCompletionTokenLogprob value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionTokenLogprob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("token".to_string()),
            Some(self.token.to_string()),


            Some("logprob".to_string()),
            Some(self.logprob.to_string()),


            Some("bytes".to_string()),
            Some(self.bytes.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","))),

            // Skipping top_logprobs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionTokenLogprob value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionTokenLogprob {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub token: Vec<String>,
            pub logprob: Vec<f64>,
            pub bytes: Vec<Vec<i32>>,
            pub top_logprobs: Vec<Vec<models::ChatCompletionTokenLogprobTopLogprobsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionTokenLogprob".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "token" => intermediate_rep.token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "logprob" => intermediate_rep.logprob.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "bytes" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatCompletionTokenLogprob".to_string()),
                    "top_logprobs" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatCompletionTokenLogprob".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionTokenLogprob".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionTokenLogprob {
            token: intermediate_rep.token.into_iter().next().ok_or_else(|| "token missing in ChatCompletionTokenLogprob".to_string())?,
            logprob: intermediate_rep.logprob.into_iter().next().ok_or_else(|| "logprob missing in ChatCompletionTokenLogprob".to_string())?,
            bytes: std::result::Result::Err("Nullable types not supported in ChatCompletionTokenLogprob".to_string())?,
            top_logprobs: intermediate_rep.top_logprobs.into_iter().next().ok_or_else(|| "top_logprobs missing in ChatCompletionTokenLogprob".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionTokenLogprob> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionTokenLogprob>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionTokenLogprob>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionTokenLogprob - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionTokenLogprob> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionTokenLogprob as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionTokenLogprob - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionTokenLogprobTopLogprobsInner {
    /// The token.
    #[serde(rename = "token")]
          #[validate(custom(function = "check_xss_string"))]
    pub token: String,

    /// The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
    #[serde(rename = "logprob")]
    pub logprob: f64,

    /// A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
    #[serde(rename = "bytes")]
    pub bytes: Nullable<Vec<i32>>,

}



impl ChatCompletionTokenLogprobTopLogprobsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(token: String, logprob: f64, bytes: Nullable<Vec<i32>>, ) -> ChatCompletionTokenLogprobTopLogprobsInner {
        ChatCompletionTokenLogprobTopLogprobsInner {
 token,
 logprob,
 bytes,
        }
    }
}

/// Converts the ChatCompletionTokenLogprobTopLogprobsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionTokenLogprobTopLogprobsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("token".to_string()),
            Some(self.token.to_string()),


            Some("logprob".to_string()),
            Some(self.logprob.to_string()),


            Some("bytes".to_string()),
            Some(self.bytes.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","))),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionTokenLogprobTopLogprobsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionTokenLogprobTopLogprobsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub token: Vec<String>,
            pub logprob: Vec<f64>,
            pub bytes: Vec<Vec<i32>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionTokenLogprobTopLogprobsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "token" => intermediate_rep.token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "logprob" => intermediate_rep.logprob.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "bytes" => return std::result::Result::Err("Parsing a container in this style is not supported in ChatCompletionTokenLogprobTopLogprobsInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionTokenLogprobTopLogprobsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionTokenLogprobTopLogprobsInner {
            token: intermediate_rep.token.into_iter().next().ok_or_else(|| "token missing in ChatCompletionTokenLogprobTopLogprobsInner".to_string())?,
            logprob: intermediate_rep.logprob.into_iter().next().ok_or_else(|| "logprob missing in ChatCompletionTokenLogprobTopLogprobsInner".to_string())?,
            bytes: std::result::Result::Err("Nullable types not supported in ChatCompletionTokenLogprobTopLogprobsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionTokenLogprobTopLogprobsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionTokenLogprobTopLogprobsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionTokenLogprobTopLogprobsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionTokenLogprobTopLogprobsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionTokenLogprobTopLogprobsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionTokenLogprobTopLogprobsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionTokenLogprobTopLogprobsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ChatCompletionTool {
    /// The type of the tool. Currently, only `function` is supported.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "function")]
          #[validate(nested)]
    pub function: models::FunctionObject,

}



impl ChatCompletionTool {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, function: models::FunctionObject, ) -> ChatCompletionTool {
        ChatCompletionTool {
 r_type,
 function,
        }
    }
}

/// Converts the ChatCompletionTool value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ChatCompletionTool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionTool value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionTool {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub function: Vec<models::FunctionObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ChatCompletionTool".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::FunctionObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ChatCompletionTool".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ChatCompletionTool {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in ChatCompletionTool".to_string())?,
            function: intermediate_rep.function.into_iter().next().ok_or_else(|| "function missing in ChatCompletionTool".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ChatCompletionTool> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ChatCompletionTool>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ChatCompletionTool>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ChatCompletionTool - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ChatCompletionTool> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ChatCompletionTool as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ChatCompletionTool - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Controls which (if any) tool is called by the model. `none` means the model will not call any tool and instead generates a message. `auto` means the model can pick between generating a message or calling one or more tools. `required` means the model must call one or more tools. Specifying a particular tool via `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool.  `none` is the default when no tools are present. `auto` is the default if tools are present. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum ChatCompletionToolChoiceOption {
    String(String),
    ChatCompletionNamedToolChoice(models::ChatCompletionNamedToolChoice),
}

impl validator::Validate for ChatCompletionToolChoiceOption
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::ChatCompletionNamedToolChoice(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChatCompletionToolChoiceOption value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChatCompletionToolChoiceOption {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for ChatCompletionToolChoiceOption {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<models::ChatCompletionNamedToolChoice> for ChatCompletionToolChoiceOption {
    fn from(value: models::ChatCompletionNamedToolChoice) -> Self {
        Self::ChatCompletionNamedToolChoice(value)
    }
}





/// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum ChunkingStrategyRequestParam {
    AutoChunkingStrategyRequestParam(models::AutoChunkingStrategyRequestParam),
    StaticChunkingStrategyRequestParam(models::StaticChunkingStrategyRequestParam),
}

impl validator::Validate for ChunkingStrategyRequestParam
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::AutoChunkingStrategyRequestParam(v) => v.validate(),
            Self::StaticChunkingStrategyRequestParam(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ChunkingStrategyRequestParam value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ChunkingStrategyRequestParam {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::AutoChunkingStrategyRequestParam> for ChunkingStrategyRequestParam {
    fn from(value: models::AutoChunkingStrategyRequestParam) -> Self {
        Self::AutoChunkingStrategyRequestParam(value)
    }
}
impl From<models::StaticChunkingStrategyRequestParam> for ChunkingStrategyRequestParam {
    fn from(value: models::StaticChunkingStrategyRequestParam) -> Self {
        Self::StaticChunkingStrategyRequestParam(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CompleteUploadRequest {
    /// The ordered list of Part IDs. 
    #[serde(rename = "part_ids")]
          #[validate(custom(function = "check_xss_vec_string"))]
    pub part_ids: Vec<String>,

    /// The optional md5 checksum for the file contents to verify if the bytes uploaded matches what you expect. 
    #[serde(rename = "md5")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub md5: Option<String>,

}



impl CompleteUploadRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(part_ids: Vec<String>, ) -> CompleteUploadRequest {
        CompleteUploadRequest {
 part_ids,
 md5: None,
        }
    }
}

/// Converts the CompleteUploadRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CompleteUploadRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("part_ids".to_string()),
            Some(self.part_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            self.md5.as_ref().map(|md5| {
                [
                    "md5".to_string(),
                    md5.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CompleteUploadRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CompleteUploadRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub part_ids: Vec<Vec<String>>,
            pub md5: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CompleteUploadRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "part_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in CompleteUploadRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "md5" => intermediate_rep.md5.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CompleteUploadRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CompleteUploadRequest {
            part_ids: intermediate_rep.part_ids.into_iter().next().ok_or_else(|| "part_ids missing in CompleteUploadRequest".to_string())?,
            md5: intermediate_rep.md5.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CompleteUploadRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CompleteUploadRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CompleteUploadRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CompleteUploadRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CompleteUploadRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CompleteUploadRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CompleteUploadRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Usage statistics for the completion request.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CompletionUsage {
    /// Number of tokens in the generated completion.
    #[serde(rename = "completion_tokens")]
    pub completion_tokens: i32,

    /// Number of tokens in the prompt.
    #[serde(rename = "prompt_tokens")]
    pub prompt_tokens: i32,

    /// Total number of tokens used in the request (prompt + completion).
    #[serde(rename = "total_tokens")]
    pub total_tokens: i32,

    #[serde(rename = "completion_tokens_details")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub completion_tokens_details: Option<models::CompletionUsageCompletionTokensDetails>,

    #[serde(rename = "prompt_tokens_details")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub prompt_tokens_details: Option<models::CompletionUsagePromptTokensDetails>,

}



impl CompletionUsage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(completion_tokens: i32, prompt_tokens: i32, total_tokens: i32, ) -> CompletionUsage {
        CompletionUsage {
 completion_tokens,
 prompt_tokens,
 total_tokens,
 completion_tokens_details: None,
 prompt_tokens_details: None,
        }
    }
}

/// Converts the CompletionUsage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CompletionUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("completion_tokens".to_string()),
            Some(self.completion_tokens.to_string()),


            Some("prompt_tokens".to_string()),
            Some(self.prompt_tokens.to_string()),


            Some("total_tokens".to_string()),
            Some(self.total_tokens.to_string()),

            // Skipping completion_tokens_details in query parameter serialization

            // Skipping prompt_tokens_details in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CompletionUsage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CompletionUsage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub completion_tokens: Vec<i32>,
            pub prompt_tokens: Vec<i32>,
            pub total_tokens: Vec<i32>,
            pub completion_tokens_details: Vec<models::CompletionUsageCompletionTokensDetails>,
            pub prompt_tokens_details: Vec<models::CompletionUsagePromptTokensDetails>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CompletionUsage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "completion_tokens" => intermediate_rep.completion_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prompt_tokens" => intermediate_rep.prompt_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total_tokens" => intermediate_rep.total_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "completion_tokens_details" => intermediate_rep.completion_tokens_details.push(<models::CompletionUsageCompletionTokensDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prompt_tokens_details" => intermediate_rep.prompt_tokens_details.push(<models::CompletionUsagePromptTokensDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CompletionUsage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CompletionUsage {
            completion_tokens: intermediate_rep.completion_tokens.into_iter().next().ok_or_else(|| "completion_tokens missing in CompletionUsage".to_string())?,
            prompt_tokens: intermediate_rep.prompt_tokens.into_iter().next().ok_or_else(|| "prompt_tokens missing in CompletionUsage".to_string())?,
            total_tokens: intermediate_rep.total_tokens.into_iter().next().ok_or_else(|| "total_tokens missing in CompletionUsage".to_string())?,
            completion_tokens_details: intermediate_rep.completion_tokens_details.into_iter().next(),
            prompt_tokens_details: intermediate_rep.prompt_tokens_details.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CompletionUsage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CompletionUsage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CompletionUsage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CompletionUsage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CompletionUsage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CompletionUsage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CompletionUsage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Breakdown of tokens used in a completion.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CompletionUsageCompletionTokensDetails {
    /// When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion. 
    #[serde(rename = "accepted_prediction_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub accepted_prediction_tokens: Option<i32>,

    /// Audio input tokens generated by the model.
    #[serde(rename = "audio_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audio_tokens: Option<i32>,

    /// Tokens generated by the model for reasoning.
    #[serde(rename = "reasoning_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reasoning_tokens: Option<i32>,

    /// When using Predicted Outputs, the number of tokens in the prediction that did not appear in the completion. However, like reasoning tokens, these tokens are still counted in the total completion tokens for purposes of billing, output, and context window limits. 
    #[serde(rename = "rejected_prediction_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rejected_prediction_tokens: Option<i32>,

}



impl CompletionUsageCompletionTokensDetails {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CompletionUsageCompletionTokensDetails {
        CompletionUsageCompletionTokensDetails {
 accepted_prediction_tokens: None,
 audio_tokens: None,
 reasoning_tokens: None,
 rejected_prediction_tokens: None,
        }
    }
}

/// Converts the CompletionUsageCompletionTokensDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CompletionUsageCompletionTokensDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.accepted_prediction_tokens.as_ref().map(|accepted_prediction_tokens| {
                [
                    "accepted_prediction_tokens".to_string(),
                    accepted_prediction_tokens.to_string(),
                ].join(",")
            }),


            self.audio_tokens.as_ref().map(|audio_tokens| {
                [
                    "audio_tokens".to_string(),
                    audio_tokens.to_string(),
                ].join(",")
            }),


            self.reasoning_tokens.as_ref().map(|reasoning_tokens| {
                [
                    "reasoning_tokens".to_string(),
                    reasoning_tokens.to_string(),
                ].join(",")
            }),


            self.rejected_prediction_tokens.as_ref().map(|rejected_prediction_tokens| {
                [
                    "rejected_prediction_tokens".to_string(),
                    rejected_prediction_tokens.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CompletionUsageCompletionTokensDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CompletionUsageCompletionTokensDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub accepted_prediction_tokens: Vec<i32>,
            pub audio_tokens: Vec<i32>,
            pub reasoning_tokens: Vec<i32>,
            pub rejected_prediction_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CompletionUsageCompletionTokensDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "accepted_prediction_tokens" => intermediate_rep.accepted_prediction_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "audio_tokens" => intermediate_rep.audio_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reasoning_tokens" => intermediate_rep.reasoning_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rejected_prediction_tokens" => intermediate_rep.rejected_prediction_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CompletionUsageCompletionTokensDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CompletionUsageCompletionTokensDetails {
            accepted_prediction_tokens: intermediate_rep.accepted_prediction_tokens.into_iter().next(),
            audio_tokens: intermediate_rep.audio_tokens.into_iter().next(),
            reasoning_tokens: intermediate_rep.reasoning_tokens.into_iter().next(),
            rejected_prediction_tokens: intermediate_rep.rejected_prediction_tokens.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CompletionUsageCompletionTokensDetails> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CompletionUsageCompletionTokensDetails>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CompletionUsageCompletionTokensDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CompletionUsageCompletionTokensDetails - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CompletionUsageCompletionTokensDetails> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CompletionUsageCompletionTokensDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CompletionUsageCompletionTokensDetails - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Breakdown of tokens used in the prompt.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CompletionUsagePromptTokensDetails {
    /// Audio input tokens present in the prompt.
    #[serde(rename = "audio_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audio_tokens: Option<i32>,

    /// Cached tokens present in the prompt.
    #[serde(rename = "cached_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cached_tokens: Option<i32>,

}



impl CompletionUsagePromptTokensDetails {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CompletionUsagePromptTokensDetails {
        CompletionUsagePromptTokensDetails {
 audio_tokens: None,
 cached_tokens: None,
        }
    }
}

/// Converts the CompletionUsagePromptTokensDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CompletionUsagePromptTokensDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.audio_tokens.as_ref().map(|audio_tokens| {
                [
                    "audio_tokens".to_string(),
                    audio_tokens.to_string(),
                ].join(",")
            }),


            self.cached_tokens.as_ref().map(|cached_tokens| {
                [
                    "cached_tokens".to_string(),
                    cached_tokens.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CompletionUsagePromptTokensDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CompletionUsagePromptTokensDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub audio_tokens: Vec<i32>,
            pub cached_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CompletionUsagePromptTokensDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "audio_tokens" => intermediate_rep.audio_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cached_tokens" => intermediate_rep.cached_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CompletionUsagePromptTokensDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CompletionUsagePromptTokensDetails {
            audio_tokens: intermediate_rep.audio_tokens.into_iter().next(),
            cached_tokens: intermediate_rep.cached_tokens.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CompletionUsagePromptTokensDetails> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CompletionUsagePromptTokensDetails>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CompletionUsagePromptTokensDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CompletionUsagePromptTokensDetails - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CompletionUsagePromptTokensDetails> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CompletionUsagePromptTokensDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CompletionUsagePromptTokensDetails - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The aggregated costs details of the specific time bucket.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CostsResult {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "amount")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub amount: Option<models::CostsResultAmount>,

    /// When `group_by=line_item`, this field provides the line item of the grouped costs result.
    #[serde(rename = "line_item")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub line_item: Option<Nullable<String>>,

    /// When `group_by=project_id`, this field provides the project ID of the grouped costs result.
    #[serde(rename = "project_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_id: Option<Nullable<String>>,

}



impl CostsResult {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, ) -> CostsResult {
        CostsResult {
 object,
 amount: None,
 line_item: None,
 project_id: None,
        }
    }
}

/// Converts the CostsResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CostsResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping amount in query parameter serialization


            self.line_item.as_ref().map(|line_item| {
                [
                    "line_item".to_string(),
                    line_item.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.project_id.as_ref().map(|project_id| {
                [
                    "project_id".to_string(),
                    project_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CostsResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CostsResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub amount: Vec<models::CostsResultAmount>,
            pub line_item: Vec<String>,
            pub project_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CostsResult".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "amount" => intermediate_rep.amount.push(<models::CostsResultAmount as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "line_item" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CostsResult".to_string()),
                    "project_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CostsResult".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CostsResult".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CostsResult {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in CostsResult".to_string())?,
            amount: intermediate_rep.amount.into_iter().next(),
            line_item: std::result::Result::Err("Nullable types not supported in CostsResult".to_string())?,
            project_id: std::result::Result::Err("Nullable types not supported in CostsResult".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CostsResult> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CostsResult>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CostsResult>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CostsResult - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CostsResult> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CostsResult as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CostsResult - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The monetary value in its associated currency.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CostsResultAmount {
    /// The numeric value of the cost.
    #[serde(rename = "value")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<f64>,

    /// Lowercase ISO-4217 currency e.g. \"usd\"
    #[serde(rename = "currency")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<String>,

}



impl CostsResultAmount {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CostsResultAmount {
        CostsResultAmount {
 value: None,
 currency: None,
        }
    }
}

/// Converts the CostsResultAmount value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CostsResultAmount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),


            self.currency.as_ref().map(|currency| {
                [
                    "currency".to_string(),
                    currency.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CostsResultAmount value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CostsResultAmount {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<f64>,
            pub currency: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CostsResultAmount".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "currency" => intermediate_rep.currency.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CostsResultAmount".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CostsResultAmount {
            value: intermediate_rep.value.into_iter().next(),
            currency: intermediate_rep.currency.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CostsResultAmount> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CostsResultAmount>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CostsResultAmount>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CostsResultAmount - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CostsResultAmount> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CostsResultAmount as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CostsResultAmount - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateAssistantRequest {
    #[serde(rename = "model")]
          #[validate(nested)]
    pub model: models::CreateAssistantRequestModel,

    /// The name of the assistant. The maximum length is 256 characters. 
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

    /// The description of the assistant. The maximum length is 512 characters. 
    #[serde(rename = "description")]
    #[validate(
            length(max = 512),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

    /// The system instructions that the assistant uses. The maximum length is 256,000 characters. 
    #[serde(rename = "instructions")]
    #[validate(
            length(max = 256000),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instructions: Option<Nullable<String>>,

    /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`. 
    #[serde(rename = "tools")]
    #[validate(
            length(max = 128),
          nested,
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Vec<models::AssistantObjectToolsInner>>,

    #[serde(rename = "tool_resources")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_resources: Option<Nullable<models::CreateAssistantRequestToolResources>>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

    /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
    #[serde(rename = "temperature")]
    #[validate(
            range(min = 0f64, max = 2f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<Nullable<f64>>,

    /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
    #[serde(rename = "top_p")]
    #[validate(
            range(min = 0f64, max = 1f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub top_p: Option<Nullable<f64>>,

    #[serde(rename = "response_format")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_format: Option<models::AssistantsApiResponseFormatOption>,

}



impl CreateAssistantRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(model: models::CreateAssistantRequestModel, ) -> CreateAssistantRequest {
        CreateAssistantRequest {
 model,
 name: None,
 description: None,
 instructions: None,
 tools: None,
 tool_resources: None,
 metadata: None,
 temperature: Some(Nullable::Present(1.0)),
 top_p: Some(Nullable::Present(1.0)),
 response_format: None,
        }
    }
}

/// Converts the CreateAssistantRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateAssistantRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping model in query parameter serialization


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.instructions.as_ref().map(|instructions| {
                [
                    "instructions".to_string(),
                    instructions.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping tools in query parameter serialization

            // Skipping tool_resources in query parameter serialization

            // Skipping metadata in query parameter serialization


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.top_p.as_ref().map(|top_p| {
                [
                    "top_p".to_string(),
                    top_p.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping response_format in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateAssistantRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateAssistantRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub model: Vec<models::CreateAssistantRequestModel>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub instructions: Vec<String>,
            pub tools: Vec<Vec<models::AssistantObjectToolsInner>>,
            pub tool_resources: Vec<models::CreateAssistantRequestToolResources>,
            pub metadata: Vec<crate::types::Object>,
            pub temperature: Vec<f64>,
            pub top_p: Vec<f64>,
            pub response_format: Vec<models::AssistantsApiResponseFormatOption>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateAssistantRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<models::CreateAssistantRequestModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateAssistantRequest".to_string()),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateAssistantRequest".to_string()),
                    "instructions" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateAssistantRequest".to_string()),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateAssistantRequest".to_string()),
                    "tool_resources" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateAssistantRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "temperature" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateAssistantRequest".to_string()),
                    "top_p" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateAssistantRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "response_format" => intermediate_rep.response_format.push(<models::AssistantsApiResponseFormatOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateAssistantRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateAssistantRequest {
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateAssistantRequest".to_string())?,
            name: std::result::Result::Err("Nullable types not supported in CreateAssistantRequest".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in CreateAssistantRequest".to_string())?,
            instructions: std::result::Result::Err("Nullable types not supported in CreateAssistantRequest".to_string())?,
            tools: intermediate_rep.tools.into_iter().next(),
            tool_resources: std::result::Result::Err("Nullable types not supported in CreateAssistantRequest".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next(),
            temperature: std::result::Result::Err("Nullable types not supported in CreateAssistantRequest".to_string())?,
            top_p: std::result::Result::Err("Nullable types not supported in CreateAssistantRequest".to_string())?,
            response_format: intermediate_rep.response_format.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateAssistantRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateAssistantRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateAssistantRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateAssistantRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateAssistantRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateAssistantRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateAssistantRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateAssistantRequestModel {
    String(String),
    String1(String),
}

impl validator::Validate for CreateAssistantRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::String1(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateAssistantRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateAssistantRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}







/// A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateAssistantRequestToolResources {
    #[serde(rename = "code_interpreter")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_interpreter: Option<models::CreateAssistantRequestToolResourcesCodeInterpreter>,

    #[serde(rename = "file_search")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_search: Option<Nullable<models::CreateAssistantRequestToolResourcesFileSearch>>,

}



impl CreateAssistantRequestToolResources {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateAssistantRequestToolResources {
        CreateAssistantRequestToolResources {
 code_interpreter: None,
 file_search: None,
        }
    }
}

/// Converts the CreateAssistantRequestToolResources value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateAssistantRequestToolResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping code_interpreter in query parameter serialization

            // Skipping file_search in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateAssistantRequestToolResources value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateAssistantRequestToolResources {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code_interpreter: Vec<models::CreateAssistantRequestToolResourcesCodeInterpreter>,
            pub file_search: Vec<models::CreateAssistantRequestToolResourcesFileSearch>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateAssistantRequestToolResources".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code_interpreter" => intermediate_rep.code_interpreter.push(<models::CreateAssistantRequestToolResourcesCodeInterpreter as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "file_search" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateAssistantRequestToolResources".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateAssistantRequestToolResources".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateAssistantRequestToolResources {
            code_interpreter: intermediate_rep.code_interpreter.into_iter().next(),
            file_search: std::result::Result::Err("Nullable types not supported in CreateAssistantRequestToolResources".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateAssistantRequestToolResources> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateAssistantRequestToolResources>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateAssistantRequestToolResources>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateAssistantRequestToolResources - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateAssistantRequestToolResources> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateAssistantRequestToolResources as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateAssistantRequestToolResources - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateAssistantRequestToolResourcesCodeInterpreter {
    /// A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool. 
    #[serde(rename = "file_ids")]
    #[validate(
            length(max = 20),
          custom(function = "check_xss_vec_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_ids: Option<Vec<String>>,

}



impl CreateAssistantRequestToolResourcesCodeInterpreter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateAssistantRequestToolResourcesCodeInterpreter {
        CreateAssistantRequestToolResourcesCodeInterpreter {
 file_ids: None,
        }
    }
}

/// Converts the CreateAssistantRequestToolResourcesCodeInterpreter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateAssistantRequestToolResourcesCodeInterpreter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_ids.as_ref().map(|file_ids| {
                [
                    "file_ids".to_string(),
                    file_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateAssistantRequestToolResourcesCodeInterpreter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateAssistantRequestToolResourcesCodeInterpreter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_ids: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateAssistantRequestToolResourcesCodeInterpreter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "file_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateAssistantRequestToolResourcesCodeInterpreter".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateAssistantRequestToolResourcesCodeInterpreter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateAssistantRequestToolResourcesCodeInterpreter {
            file_ids: intermediate_rep.file_ids.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateAssistantRequestToolResourcesCodeInterpreter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateAssistantRequestToolResourcesCodeInterpreter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateAssistantRequestToolResourcesCodeInterpreter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateAssistantRequestToolResourcesCodeInterpreter - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateAssistantRequestToolResourcesCodeInterpreter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateAssistantRequestToolResourcesCodeInterpreter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateAssistantRequestToolResourcesCodeInterpreter - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateAssistantRequestToolResourcesFileSearch {
    /// The [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant. 
    #[serde(rename = "vector_store_ids")]
    #[validate(
            length(max = 1),
          custom(function = "check_xss_vec_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vector_store_ids: Option<Vec<String>>,

    /// A helper to create a [vector store](/docs/api-reference/vector-stores/object) with file_ids and attach it to this assistant. There can be a maximum of 1 vector store attached to the assistant. 
    #[serde(rename = "vector_stores")]
    #[validate(
            length(max = 1),
          nested,
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vector_stores: Option<Vec<models::CreateAssistantRequestToolResourcesFileSearchVectorStoresInner>>,

}



impl CreateAssistantRequestToolResourcesFileSearch {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateAssistantRequestToolResourcesFileSearch {
        CreateAssistantRequestToolResourcesFileSearch {
 vector_store_ids: None,
 vector_stores: None,
        }
    }
}

/// Converts the CreateAssistantRequestToolResourcesFileSearch value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateAssistantRequestToolResourcesFileSearch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.vector_store_ids.as_ref().map(|vector_store_ids| {
                [
                    "vector_store_ids".to_string(),
                    vector_store_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping vector_stores in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateAssistantRequestToolResourcesFileSearch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateAssistantRequestToolResourcesFileSearch {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub vector_store_ids: Vec<Vec<String>>,
            pub vector_stores: Vec<Vec<models::CreateAssistantRequestToolResourcesFileSearchVectorStoresInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateAssistantRequestToolResourcesFileSearch".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "vector_store_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateAssistantRequestToolResourcesFileSearch".to_string()),
                    "vector_stores" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateAssistantRequestToolResourcesFileSearch".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateAssistantRequestToolResourcesFileSearch".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateAssistantRequestToolResourcesFileSearch {
            vector_store_ids: intermediate_rep.vector_store_ids.into_iter().next(),
            vector_stores: intermediate_rep.vector_stores.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateAssistantRequestToolResourcesFileSearch> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateAssistantRequestToolResourcesFileSearch>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateAssistantRequestToolResourcesFileSearch>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateAssistantRequestToolResourcesFileSearch - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateAssistantRequestToolResourcesFileSearch> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateAssistantRequestToolResourcesFileSearch as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateAssistantRequestToolResourcesFileSearch - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateAssistantRequestToolResourcesFileSearchVectorStoresInner {
    /// A list of [file](/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store. 
    #[serde(rename = "file_ids")]
    #[validate(
            length(max = 10000),
          custom(function = "check_xss_vec_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_ids: Option<Vec<String>>,

    #[serde(rename = "chunking_strategy")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub chunking_strategy: Option<models::CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy>,

    /// Set of 16 key-value pairs that can be attached to a vector store. This can be useful for storing additional information about the vector store in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}



impl CreateAssistantRequestToolResourcesFileSearchVectorStoresInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateAssistantRequestToolResourcesFileSearchVectorStoresInner {
        CreateAssistantRequestToolResourcesFileSearchVectorStoresInner {
 file_ids: None,
 chunking_strategy: None,
 metadata: None,
        }
    }
}

/// Converts the CreateAssistantRequestToolResourcesFileSearchVectorStoresInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateAssistantRequestToolResourcesFileSearchVectorStoresInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_ids.as_ref().map(|file_ids| {
                [
                    "file_ids".to_string(),
                    file_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping chunking_strategy in query parameter serialization

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateAssistantRequestToolResourcesFileSearchVectorStoresInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateAssistantRequestToolResourcesFileSearchVectorStoresInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_ids: Vec<Vec<String>>,
            pub chunking_strategy: Vec<models::CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateAssistantRequestToolResourcesFileSearchVectorStoresInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "file_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateAssistantRequestToolResourcesFileSearchVectorStoresInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "chunking_strategy" => intermediate_rep.chunking_strategy.push(<models::CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateAssistantRequestToolResourcesFileSearchVectorStoresInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateAssistantRequestToolResourcesFileSearchVectorStoresInner {
            file_ids: intermediate_rep.file_ids.into_iter().next(),
            chunking_strategy: intermediate_rep.chunking_strategy.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateAssistantRequestToolResourcesFileSearchVectorStoresInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateAssistantRequestToolResourcesFileSearchVectorStoresInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateAssistantRequestToolResourcesFileSearchVectorStoresInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateAssistantRequestToolResourcesFileSearchVectorStoresInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateAssistantRequestToolResourcesFileSearchVectorStoresInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateAssistantRequestToolResourcesFileSearchVectorStoresInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateAssistantRequestToolResourcesFileSearchVectorStoresInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy {
    AutoChunkingStrategy(models::AutoChunkingStrategy),
    StaticChunkingStrategy(models::StaticChunkingStrategy),
}

impl validator::Validate for CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::AutoChunkingStrategy(v) => v.validate(),
            Self::StaticChunkingStrategy(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::AutoChunkingStrategy> for CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy {
    fn from(value: models::AutoChunkingStrategy) -> Self {
        Self::AutoChunkingStrategy(value)
    }
}
impl From<models::StaticChunkingStrategy> for CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy {
    fn from(value: models::StaticChunkingStrategy) -> Self {
        Self::StaticChunkingStrategy(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateBatchRequest {
    /// The ID of an uploaded file that contains requests for the new batch.  See [upload file](/docs/api-reference/files/create) for how to upload a file.  Your input file must be formatted as a [JSONL file](/docs/api-reference/batch/request-input), and must be uploaded with the purpose `batch`. The file can contain up to 50,000 requests, and can be up to 200 MB in size. 
    #[serde(rename = "input_file_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub input_file_id: String,

    /// The endpoint to be used for all requests in the batch. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "endpoint")]
          #[validate(custom(function = "check_xss_string"))]
    pub endpoint: String,

    /// The time frame within which the batch should be processed. Currently only `24h` is supported.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "completion_window")]
          #[validate(custom(function = "check_xss_string"))]
    pub completion_window: String,

    /// Optional custom metadata for the batch.
    #[serde(rename = "metadata")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<Nullable<std::collections::HashMap<String, String>>>,

}



impl CreateBatchRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(input_file_id: String, endpoint: String, completion_window: String, ) -> CreateBatchRequest {
        CreateBatchRequest {
 input_file_id,
 endpoint,
 completion_window,
 metadata: None,
        }
    }
}

/// Converts the CreateBatchRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateBatchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("input_file_id".to_string()),
            Some(self.input_file_id.to_string()),


            Some("endpoint".to_string()),
            Some(self.endpoint.to_string()),


            Some("completion_window".to_string()),
            Some(self.completion_window.to_string()),

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateBatchRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateBatchRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub input_file_id: Vec<String>,
            pub endpoint: Vec<String>,
            pub completion_window: Vec<String>,
            pub metadata: Vec<std::collections::HashMap<String, String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateBatchRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "input_file_id" => intermediate_rep.input_file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "endpoint" => intermediate_rep.endpoint.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "completion_window" => intermediate_rep.completion_window.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateBatchRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateBatchRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateBatchRequest {
            input_file_id: intermediate_rep.input_file_id.into_iter().next().ok_or_else(|| "input_file_id missing in CreateBatchRequest".to_string())?,
            endpoint: intermediate_rep.endpoint.into_iter().next().ok_or_else(|| "endpoint missing in CreateBatchRequest".to_string())?,
            completion_window: intermediate_rep.completion_window.into_iter().next().ok_or_else(|| "completion_window missing in CreateBatchRequest".to_string())?,
            metadata: std::result::Result::Err("Nullable types not supported in CreateBatchRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateBatchRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateBatchRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateBatchRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateBatchRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateBatchRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateBatchRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateBatchRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Represents a chat completion response returned by model, based on the provided input.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionFunctionResponse {
    /// A unique identifier for the chat completion.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
    #[serde(rename = "choices")]
          #[validate(nested)]
    pub choices: Vec<models::CreateChatCompletionFunctionResponseChoicesInner>,

    /// The Unix timestamp (in seconds) of when the chat completion was created.
    #[serde(rename = "created")]
    pub created: i32,

    /// The model used for the chat completion.
    #[serde(rename = "model")]
          #[validate(custom(function = "check_xss_string"))]
    pub model: String,

    /// This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
    #[serde(rename = "system_fingerprint")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub system_fingerprint: Option<String>,

    /// The object type, which is always `chat.completion`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "usage")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub usage: Option<models::CompletionUsage>,

}



impl CreateChatCompletionFunctionResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, choices: Vec<models::CreateChatCompletionFunctionResponseChoicesInner>, created: i32, model: String, object: String, ) -> CreateChatCompletionFunctionResponse {
        CreateChatCompletionFunctionResponse {
 id,
 choices,
 created,
 model,
 system_fingerprint: None,
 object,
 usage: None,
        }
    }
}

/// Converts the CreateChatCompletionFunctionResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionFunctionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),

            // Skipping choices in query parameter serialization


            Some("created".to_string()),
            Some(self.created.to_string()),


            Some("model".to_string()),
            Some(self.model.to_string()),


            self.system_fingerprint.as_ref().map(|system_fingerprint| {
                [
                    "system_fingerprint".to_string(),
                    system_fingerprint.to_string(),
                ].join(",")
            }),


            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping usage in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionFunctionResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionFunctionResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub choices: Vec<Vec<models::CreateChatCompletionFunctionResponseChoicesInner>>,
            pub created: Vec<i32>,
            pub model: Vec<String>,
            pub system_fingerprint: Vec<String>,
            pub object: Vec<String>,
            pub usage: Vec<models::CompletionUsage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionFunctionResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "choices" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionFunctionResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "system_fingerprint" => intermediate_rep.system_fingerprint.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usage" => intermediate_rep.usage.push(<models::CompletionUsage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionFunctionResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionFunctionResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CreateChatCompletionFunctionResponse".to_string())?,
            choices: intermediate_rep.choices.into_iter().next().ok_or_else(|| "choices missing in CreateChatCompletionFunctionResponse".to_string())?,
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "created missing in CreateChatCompletionFunctionResponse".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateChatCompletionFunctionResponse".to_string())?,
            system_fingerprint: intermediate_rep.system_fingerprint.into_iter().next(),
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in CreateChatCompletionFunctionResponse".to_string())?,
            usage: intermediate_rep.usage.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionFunctionResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionFunctionResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionFunctionResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateChatCompletionFunctionResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionFunctionResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionFunctionResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateChatCompletionFunctionResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionFunctionResponseChoicesInner {
    /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, or `function_call` if the model called a function. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "finish_reason")]
          #[validate(custom(function = "check_xss_string"))]
    pub finish_reason: String,

    /// The index of the choice in the list of choices.
    #[serde(rename = "index")]
    pub index: i32,

    #[serde(rename = "message")]
          #[validate(nested)]
    pub message: models::ChatCompletionResponseMessage,

}



impl CreateChatCompletionFunctionResponseChoicesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(finish_reason: String, index: i32, message: models::ChatCompletionResponseMessage, ) -> CreateChatCompletionFunctionResponseChoicesInner {
        CreateChatCompletionFunctionResponseChoicesInner {
 finish_reason,
 index,
 message,
        }
    }
}

/// Converts the CreateChatCompletionFunctionResponseChoicesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionFunctionResponseChoicesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("finish_reason".to_string()),
            Some(self.finish_reason.to_string()),


            Some("index".to_string()),
            Some(self.index.to_string()),

            // Skipping message in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionFunctionResponseChoicesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionFunctionResponseChoicesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub finish_reason: Vec<String>,
            pub index: Vec<i32>,
            pub message: Vec<models::ChatCompletionResponseMessage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionFunctionResponseChoicesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "finish_reason" => intermediate_rep.finish_reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<models::ChatCompletionResponseMessage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionFunctionResponseChoicesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionFunctionResponseChoicesInner {
            finish_reason: intermediate_rep.finish_reason.into_iter().next().ok_or_else(|| "finish_reason missing in CreateChatCompletionFunctionResponseChoicesInner".to_string())?,
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in CreateChatCompletionFunctionResponseChoicesInner".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in CreateChatCompletionFunctionResponseChoicesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionFunctionResponseChoicesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionFunctionResponseChoicesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionFunctionResponseChoicesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateChatCompletionFunctionResponseChoicesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionFunctionResponseChoicesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionFunctionResponseChoicesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateChatCompletionFunctionResponseChoicesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionRequest {
    /// A list of messages comprising the conversation so far. Depending on the [model](/docs/models) you use, different message types (modalities) are supported, like [text](/docs/guides/text-generation), [images](/docs/guides/vision), and [audio](/docs/guides/audio). 
    #[serde(rename = "messages")]
    #[validate(
            length(min = 1),
          nested,
    )]
    pub messages: Vec<models::ChatCompletionRequestMessage>,

    #[serde(rename = "model")]
          #[validate(nested)]
    pub model: models::CreateChatCompletionRequestModel,

    /// Whether or not to store the output of this chat completion request for  use in our [model distillation](/docs/guides/distillation) or [evals](/docs/guides/evals) products. 
    #[serde(rename = "store")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub store: Option<Nullable<bool>>,

    /// **o1 models only**   Constrains effort on reasoning for  [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `low`, `medium`, and `high`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "reasoning_effort")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reasoning_effort: Option<String>,

    /// Developer-defined tags and values used for filtering completions in the [dashboard](https://platform.openai.com/chat-completions). 
    #[serde(rename = "metadata")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<Nullable<std::collections::HashMap<String, String>>>,

    /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim. 
    #[serde(rename = "frequency_penalty")]
    #[validate(
            range(min = -2f64, max = 2f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub frequency_penalty: Option<Nullable<f64>>,

    /// Modify the likelihood of specified tokens appearing in the completion.  Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token. 
    #[serde(rename = "logit_bias")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logit_bias: Option<Nullable<std::collections::HashMap<String, i32>>>,

    /// Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the `content` of `message`. 
    #[serde(rename = "logprobs")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logprobs: Option<Nullable<bool>>,

    /// An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. `logprobs` must be set to `true` if this parameter is used. 
    #[serde(rename = "top_logprobs")]
    #[validate(
            range(min = 0u8, max = 20u8),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub top_logprobs: Option<Nullable<u8>>,

    /// The maximum number of [tokens](/tokenizer) that can be generated in the chat completion. This value can be used to control [costs](https://openai.com/api/pricing/) for text generated via API.  This value is now deprecated in favor of `max_completion_tokens`, and is not compatible with [o1 series models](/docs/guides/reasoning). 
    #[serde(rename = "max_tokens")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_tokens: Option<Nullable<i32>>,

    /// An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and [reasoning tokens](/docs/guides/reasoning). 
    #[serde(rename = "max_completion_tokens")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_completion_tokens: Option<Nullable<i32>>,

    /// How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
    #[serde(rename = "n")]
    #[validate(
            range(min = 1u8, max = 128u8),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub n: Option<Nullable<u8>>,

    /// Output types that you would like the model to generate for this request. Most models are capable of generating text, which is the default:  `[\"text\"]`  The `gpt-4o-audio-preview` model can also be used to [generate audio](/docs/guides/audio). To request that this model generate both text and audio responses, you can use:  `[\"text\", \"audio\"]` 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "modalities")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub modalities: Option<Nullable<Vec<String>>>,

    #[serde(rename = "prediction")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub prediction: Option<Nullable<models::PredictionContent>>,

    #[serde(rename = "audio")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audio: Option<Nullable<models::CreateChatCompletionRequestAudio>>,

    /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics. 
    #[serde(rename = "presence_penalty")]
    #[validate(
            range(min = -2f64, max = 2f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub presence_penalty: Option<Nullable<f64>>,

    #[serde(rename = "response_format")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_format: Option<models::CreateChatCompletionRequestResponseFormat>,

    /// This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result. Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend. 
    #[serde(rename = "seed")]
    #[validate(
            range(min = -9223372036854776000i128, max = 9223372036854776000i128),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seed: Option<Nullable<i128>>,

    /// Specifies the latency tier to use for processing the request. This parameter is relevant for customers subscribed to the scale tier service:    - If set to 'auto', and the Project is Scale tier enabled, the system will utilize scale tier credits until they are exhausted.   - If set to 'auto', and the Project is not Scale tier enabled, the request will be processed using the default service tier with a lower uptime SLA and no latency guarentee.   - If set to 'default', the request will be processed using the default service tier with a lower uptime SLA and no latency guarentee.   - When not set, the default behavior is 'auto'.    When this parameter is set, the response body will include the `service_tier` utilized. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "service_tier")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_tier: Option<Nullable<String>>,

    #[serde(rename = "stop")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop: Option<models::CreateChatCompletionRequestStop>,

    /// If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions). 
    #[serde(rename = "stream")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stream: Option<Nullable<bool>>,

    #[serde(rename = "stream_options")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stream_options: Option<Nullable<models::ChatCompletionStreamOptions>>,

    /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. We generally recommend altering this or `top_p` but not both. 
    #[serde(rename = "temperature")]
    #[validate(
            range(min = 0f64, max = 2f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<Nullable<f64>>,

    /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or `temperature` but not both. 
    #[serde(rename = "top_p")]
    #[validate(
            range(min = 0f64, max = 1f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub top_p: Option<Nullable<f64>>,

    /// A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported. 
    #[serde(rename = "tools")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Vec<models::ChatCompletionTool>>,

    #[serde(rename = "tool_choice")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_choice: Option<models::ChatCompletionToolChoiceOption>,

    /// Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
    #[serde(rename = "parallel_tool_calls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parallel_tool_calls: Option<bool>,

    /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
    #[serde(rename = "user")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

    #[serde(rename = "function_call")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub function_call: Option<models::CreateChatCompletionRequestFunctionCall>,

    /// Deprecated in favor of `tools`.  A list of functions the model may generate JSON inputs for. 
    #[serde(rename = "functions")]
    #[validate(
            length(min = 1, max = 128),
          nested,
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub functions: Option<Vec<models::ChatCompletionFunctions>>,

}



impl CreateChatCompletionRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(messages: Vec<models::ChatCompletionRequestMessage>, model: models::CreateChatCompletionRequestModel, ) -> CreateChatCompletionRequest {
        CreateChatCompletionRequest {
 messages,
 model,
 store: Some(Nullable::Present(false)),
 reasoning_effort: None,
 metadata: None,
 frequency_penalty: Some(Nullable::Present(0.0)),
 logit_bias: None,
 logprobs: Some(Nullable::Present(false)),
 top_logprobs: None,
 max_tokens: None,
 max_completion_tokens: None,
 n: Some(Nullable::Present(1)),
 modalities: None,
 prediction: None,
 audio: None,
 presence_penalty: Some(Nullable::Present(0.0)),
 response_format: None,
 seed: None,
 service_tier: None,
 stop: None,
 stream: Some(Nullable::Present(false)),
 stream_options: None,
 temperature: Some(Nullable::Present(1.0)),
 top_p: Some(Nullable::Present(1.0)),
 tools: None,
 tool_choice: None,
 parallel_tool_calls: Some(true),
 user: None,
 function_call: None,
 functions: None,
        }
    }
}

/// Converts the CreateChatCompletionRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping messages in query parameter serialization

            // Skipping model in query parameter serialization


            self.store.as_ref().map(|store| {
                [
                    "store".to_string(),
                    store.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.reasoning_effort.as_ref().map(|reasoning_effort| {
                [
                    "reasoning_effort".to_string(),
                    reasoning_effort.to_string(),
                ].join(",")
            }),

            // Skipping metadata in query parameter serialization


            self.frequency_penalty.as_ref().map(|frequency_penalty| {
                [
                    "frequency_penalty".to_string(),
                    frequency_penalty.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping logit_bias in query parameter serialization


            self.logprobs.as_ref().map(|logprobs| {
                [
                    "logprobs".to_string(),
                    logprobs.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.top_logprobs.as_ref().map(|top_logprobs| {
                [
                    "top_logprobs".to_string(),
                    top_logprobs.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.max_tokens.as_ref().map(|max_tokens| {
                [
                    "max_tokens".to_string(),
                    max_tokens.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.max_completion_tokens.as_ref().map(|max_completion_tokens| {
                [
                    "max_completion_tokens".to_string(),
                    max_completion_tokens.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.n.as_ref().map(|n| {
                [
                    "n".to_string(),
                    n.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.modalities.as_ref().map(|modalities| {
                [
                    "modalities".to_string(),
                    modalities.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),
                ].join(",")
            }),

            // Skipping prediction in query parameter serialization

            // Skipping audio in query parameter serialization


            self.presence_penalty.as_ref().map(|presence_penalty| {
                [
                    "presence_penalty".to_string(),
                    presence_penalty.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping response_format in query parameter serialization


            self.seed.as_ref().map(|seed| {
                [
                    "seed".to_string(),
                    seed.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.service_tier.as_ref().map(|service_tier| {
                [
                    "service_tier".to_string(),
                    service_tier.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping stop in query parameter serialization


            self.stream.as_ref().map(|stream| {
                [
                    "stream".to_string(),
                    stream.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping stream_options in query parameter serialization


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.top_p.as_ref().map(|top_p| {
                [
                    "top_p".to_string(),
                    top_p.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping tools in query parameter serialization

            // Skipping tool_choice in query parameter serialization


            self.parallel_tool_calls.as_ref().map(|parallel_tool_calls| {
                [
                    "parallel_tool_calls".to_string(),
                    parallel_tool_calls.to_string(),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "user".to_string(),
                    user.to_string(),
                ].join(",")
            }),

            // Skipping function_call in query parameter serialization

            // Skipping functions in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub messages: Vec<Vec<models::ChatCompletionRequestMessage>>,
            pub model: Vec<models::CreateChatCompletionRequestModel>,
            pub store: Vec<bool>,
            pub reasoning_effort: Vec<String>,
            pub metadata: Vec<std::collections::HashMap<String, String>>,
            pub frequency_penalty: Vec<f64>,
            pub logit_bias: Vec<std::collections::HashMap<String, i32>>,
            pub logprobs: Vec<bool>,
            pub top_logprobs: Vec<u8>,
            pub max_tokens: Vec<i32>,
            pub max_completion_tokens: Vec<i32>,
            pub n: Vec<u8>,
            pub modalities: Vec<Vec<String>>,
            pub prediction: Vec<models::PredictionContent>,
            pub audio: Vec<models::CreateChatCompletionRequestAudio>,
            pub presence_penalty: Vec<f64>,
            pub response_format: Vec<models::CreateChatCompletionRequestResponseFormat>,
            pub seed: Vec<i128>,
            pub service_tier: Vec<String>,
            pub stop: Vec<models::CreateChatCompletionRequestStop>,
            pub stream: Vec<bool>,
            pub stream_options: Vec<models::ChatCompletionStreamOptions>,
            pub temperature: Vec<f64>,
            pub top_p: Vec<f64>,
            pub tools: Vec<Vec<models::ChatCompletionTool>>,
            pub tool_choice: Vec<models::ChatCompletionToolChoiceOption>,
            pub parallel_tool_calls: Vec<bool>,
            pub user: Vec<String>,
            pub function_call: Vec<models::CreateChatCompletionRequestFunctionCall>,
            pub functions: Vec<Vec<models::ChatCompletionFunctions>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "messages" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<models::CreateChatCompletionRequestModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "store" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "reasoning_effort" => intermediate_rep.reasoning_effort.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "metadata" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "frequency_penalty" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "logit_bias" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "logprobs" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "top_logprobs" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "max_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "max_completion_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "n" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "modalities" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "prediction" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "audio" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "presence_penalty" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "response_format" => intermediate_rep.response_format.push(<models::CreateChatCompletionRequestResponseFormat as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "seed" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "service_tier" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "stop" => intermediate_rep.stop.push(<models::CreateChatCompletionRequestStop as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "stream" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "stream_options" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "temperature" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "top_p" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionRequest".to_string()),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "tool_choice" => intermediate_rep.tool_choice.push(<models::ChatCompletionToolChoiceOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parallel_tool_calls" => intermediate_rep.parallel_tool_calls.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function_call" => intermediate_rep.function_call.push(<models::CreateChatCompletionRequestFunctionCall as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "functions" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionRequest {
            messages: intermediate_rep.messages.into_iter().next().ok_or_else(|| "messages missing in CreateChatCompletionRequest".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateChatCompletionRequest".to_string())?,
            store: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            reasoning_effort: intermediate_rep.reasoning_effort.into_iter().next(),
            metadata: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            frequency_penalty: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            logit_bias: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            logprobs: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            top_logprobs: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            max_tokens: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            max_completion_tokens: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            n: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            modalities: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            prediction: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            audio: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            presence_penalty: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            response_format: intermediate_rep.response_format.into_iter().next(),
            seed: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            service_tier: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            stop: intermediate_rep.stop.into_iter().next(),
            stream: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            stream_options: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            temperature: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            top_p: std::result::Result::Err("Nullable types not supported in CreateChatCompletionRequest".to_string())?,
            tools: intermediate_rep.tools.into_iter().next(),
            tool_choice: intermediate_rep.tool_choice.into_iter().next(),
            parallel_tool_calls: intermediate_rep.parallel_tool_calls.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
            function_call: intermediate_rep.function_call.into_iter().next(),
            functions: intermediate_rep.functions.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateChatCompletionRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateChatCompletionRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Parameters for audio output. Required when audio output is requested with `modalities: [\"audio\"]`. [Learn more](/docs/guides/audio). 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionRequestAudio {
    /// The voice the model uses to respond. Supported voices are `ash`, `ballad`, `coral`, `sage`, and `verse` (also supported but not recommended are `alloy`, `echo`, and `shimmer`; these voices are less expressive). 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "voice")]
          #[validate(custom(function = "check_xss_string"))]
    pub voice: String,

    /// Specifies the output audio format. Must be one of `wav`, `mp3`, `flac`, `opus`, or `pcm16`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "format")]
          #[validate(custom(function = "check_xss_string"))]
    pub format: String,

}



impl CreateChatCompletionRequestAudio {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(voice: String, format: String, ) -> CreateChatCompletionRequestAudio {
        CreateChatCompletionRequestAudio {
 voice,
 format,
        }
    }
}

/// Converts the CreateChatCompletionRequestAudio value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionRequestAudio {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("voice".to_string()),
            Some(self.voice.to_string()),


            Some("format".to_string()),
            Some(self.format.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionRequestAudio value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionRequestAudio {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub voice: Vec<String>,
            pub format: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionRequestAudio".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "voice" => intermediate_rep.voice.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "format" => intermediate_rep.format.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionRequestAudio".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionRequestAudio {
            voice: intermediate_rep.voice.into_iter().next().ok_or_else(|| "voice missing in CreateChatCompletionRequestAudio".to_string())?,
            format: intermediate_rep.format.into_iter().next().ok_or_else(|| "format missing in CreateChatCompletionRequestAudio".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionRequestAudio> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionRequestAudio>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionRequestAudio>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateChatCompletionRequestAudio - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionRequestAudio> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionRequestAudio as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateChatCompletionRequestAudio - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Deprecated in favor of `tool_choice`.  Controls which (if any) function is called by the model.  `none` means the model will not call a function and instead generates a message.  `auto` means the model can pick between generating a message or calling a function.  Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function.  `none` is the default when no functions are present. `auto` is the default if functions are present. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateChatCompletionRequestFunctionCall {
    String(String),
    ChatCompletionFunctionCallOption(models::ChatCompletionFunctionCallOption),
}

impl validator::Validate for CreateChatCompletionRequestFunctionCall
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::ChatCompletionFunctionCallOption(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionRequestFunctionCall value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionRequestFunctionCall {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for CreateChatCompletionRequestFunctionCall {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<models::ChatCompletionFunctionCallOption> for CreateChatCompletionRequestFunctionCall {
    fn from(value: models::ChatCompletionFunctionCallOption) -> Self {
        Self::ChatCompletionFunctionCallOption(value)
    }
}





/// ID of the model to use. See the [model endpoint compatibility](/docs/models#model-endpoint-compatibility) table for details on which models work with the Chat API.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateChatCompletionRequestModel {
    String(String),
    String1(String),
}

impl validator::Validate for CreateChatCompletionRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::String1(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}







/// An object specifying the format that the model must output.  Setting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).  Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the message the model generates is valid JSON.  **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \"stuck\" request. Also note that the message content may be partially cut off if `finish_reason=\"length\"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateChatCompletionRequestResponseFormat {
    ResponseFormatText(models::ResponseFormatText),
    ResponseFormatJsonObject(models::ResponseFormatJsonObject),
    ResponseFormatJsonSchema(models::ResponseFormatJsonSchema),
}

impl validator::Validate for CreateChatCompletionRequestResponseFormat
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::ResponseFormatText(v) => v.validate(),
            Self::ResponseFormatJsonObject(v) => v.validate(),
            Self::ResponseFormatJsonSchema(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionRequestResponseFormat value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionRequestResponseFormat {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::ResponseFormatText> for CreateChatCompletionRequestResponseFormat {
    fn from(value: models::ResponseFormatText) -> Self {
        Self::ResponseFormatText(value)
    }
}
impl From<models::ResponseFormatJsonObject> for CreateChatCompletionRequestResponseFormat {
    fn from(value: models::ResponseFormatJsonObject) -> Self {
        Self::ResponseFormatJsonObject(value)
    }
}
impl From<models::ResponseFormatJsonSchema> for CreateChatCompletionRequestResponseFormat {
    fn from(value: models::ResponseFormatJsonSchema) -> Self {
        Self::ResponseFormatJsonSchema(value)
    }
}





/// Up to 4 sequences where the API will stop generating further tokens. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateChatCompletionRequestStop {
    String(String),
    VecOfString(Vec<String>),
}

impl validator::Validate for CreateChatCompletionRequestStop
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::VecOfString(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionRequestStop value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionRequestStop {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for CreateChatCompletionRequestStop {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<Vec<String>> for CreateChatCompletionRequestStop {
    fn from(value: Vec<String>) -> Self {
        Self::VecOfString(value)
    }
}





/// Represents a chat completion response returned by model, based on the provided input.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionResponse {
    /// A unique identifier for the chat completion.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// A list of chat completion choices. Can be more than one if `n` is greater than 1.
    #[serde(rename = "choices")]
          #[validate(nested)]
    pub choices: Vec<models::CreateChatCompletionResponseChoicesInner>,

    /// The Unix timestamp (in seconds) of when the chat completion was created.
    #[serde(rename = "created")]
    pub created: i32,

    /// The model used for the chat completion.
    #[serde(rename = "model")]
          #[validate(custom(function = "check_xss_string"))]
    pub model: String,

    /// The service tier used for processing the request. This field is only included if the `service_tier` parameter is specified in the request.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "service_tier")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_tier: Option<Nullable<String>>,

    /// This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
    #[serde(rename = "system_fingerprint")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub system_fingerprint: Option<String>,

    /// The object type, which is always `chat.completion`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "usage")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub usage: Option<models::CompletionUsage>,

}



impl CreateChatCompletionResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, choices: Vec<models::CreateChatCompletionResponseChoicesInner>, created: i32, model: String, object: String, ) -> CreateChatCompletionResponse {
        CreateChatCompletionResponse {
 id,
 choices,
 created,
 model,
 service_tier: None,
 system_fingerprint: None,
 object,
 usage: None,
        }
    }
}

/// Converts the CreateChatCompletionResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),

            // Skipping choices in query parameter serialization


            Some("created".to_string()),
            Some(self.created.to_string()),


            Some("model".to_string()),
            Some(self.model.to_string()),


            self.service_tier.as_ref().map(|service_tier| {
                [
                    "service_tier".to_string(),
                    service_tier.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.system_fingerprint.as_ref().map(|system_fingerprint| {
                [
                    "system_fingerprint".to_string(),
                    system_fingerprint.to_string(),
                ].join(",")
            }),


            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping usage in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub choices: Vec<Vec<models::CreateChatCompletionResponseChoicesInner>>,
            pub created: Vec<i32>,
            pub model: Vec<String>,
            pub service_tier: Vec<String>,
            pub system_fingerprint: Vec<String>,
            pub object: Vec<String>,
            pub usage: Vec<models::CompletionUsage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "choices" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "service_tier" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "system_fingerprint" => intermediate_rep.system_fingerprint.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usage" => intermediate_rep.usage.push(<models::CompletionUsage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CreateChatCompletionResponse".to_string())?,
            choices: intermediate_rep.choices.into_iter().next().ok_or_else(|| "choices missing in CreateChatCompletionResponse".to_string())?,
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "created missing in CreateChatCompletionResponse".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateChatCompletionResponse".to_string())?,
            service_tier: std::result::Result::Err("Nullable types not supported in CreateChatCompletionResponse".to_string())?,
            system_fingerprint: intermediate_rep.system_fingerprint.into_iter().next(),
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in CreateChatCompletionResponse".to_string())?,
            usage: intermediate_rep.usage.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateChatCompletionResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateChatCompletionResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionResponseChoicesInner {
    /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "finish_reason")]
          #[validate(custom(function = "check_xss_string"))]
    pub finish_reason: String,

    /// The index of the choice in the list of choices.
    #[serde(rename = "index")]
    pub index: i32,

    #[serde(rename = "message")]
          #[validate(nested)]
    pub message: models::ChatCompletionResponseMessage,

    #[serde(rename = "logprobs")]
    pub logprobs: Nullable<models::CreateChatCompletionResponseChoicesInnerLogprobs>,

}



impl CreateChatCompletionResponseChoicesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(finish_reason: String, index: i32, message: models::ChatCompletionResponseMessage, logprobs: Nullable<models::CreateChatCompletionResponseChoicesInnerLogprobs>, ) -> CreateChatCompletionResponseChoicesInner {
        CreateChatCompletionResponseChoicesInner {
 finish_reason,
 index,
 message,
 logprobs,
        }
    }
}

/// Converts the CreateChatCompletionResponseChoicesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionResponseChoicesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("finish_reason".to_string()),
            Some(self.finish_reason.to_string()),


            Some("index".to_string()),
            Some(self.index.to_string()),

            // Skipping message in query parameter serialization

            // Skipping logprobs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionResponseChoicesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionResponseChoicesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub finish_reason: Vec<String>,
            pub index: Vec<i32>,
            pub message: Vec<models::ChatCompletionResponseMessage>,
            pub logprobs: Vec<models::CreateChatCompletionResponseChoicesInnerLogprobs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionResponseChoicesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "finish_reason" => intermediate_rep.finish_reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<models::ChatCompletionResponseMessage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "logprobs" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionResponseChoicesInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionResponseChoicesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionResponseChoicesInner {
            finish_reason: intermediate_rep.finish_reason.into_iter().next().ok_or_else(|| "finish_reason missing in CreateChatCompletionResponseChoicesInner".to_string())?,
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in CreateChatCompletionResponseChoicesInner".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in CreateChatCompletionResponseChoicesInner".to_string())?,
            logprobs: std::result::Result::Err("Nullable types not supported in CreateChatCompletionResponseChoicesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionResponseChoicesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionResponseChoicesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionResponseChoicesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateChatCompletionResponseChoicesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionResponseChoicesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionResponseChoicesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateChatCompletionResponseChoicesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Log probability information for the choice.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionResponseChoicesInnerLogprobs {
    /// A list of message content tokens with log probability information.
    #[serde(rename = "content")]
    pub content: Nullable<Vec<models::ChatCompletionTokenLogprob>>,

    /// A list of message refusal tokens with log probability information.
    #[serde(rename = "refusal")]
    pub refusal: Nullable<Vec<models::ChatCompletionTokenLogprob>>,

}



impl CreateChatCompletionResponseChoicesInnerLogprobs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(content: Nullable<Vec<models::ChatCompletionTokenLogprob>>, refusal: Nullable<Vec<models::ChatCompletionTokenLogprob>>, ) -> CreateChatCompletionResponseChoicesInnerLogprobs {
        CreateChatCompletionResponseChoicesInnerLogprobs {
 content,
 refusal,
        }
    }
}

/// Converts the CreateChatCompletionResponseChoicesInnerLogprobs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionResponseChoicesInnerLogprobs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping content in query parameter serialization

            // Skipping refusal in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionResponseChoicesInnerLogprobs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionResponseChoicesInnerLogprobs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content: Vec<Vec<models::ChatCompletionTokenLogprob>>,
            pub refusal: Vec<Vec<models::ChatCompletionTokenLogprob>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionResponseChoicesInnerLogprobs".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "content" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionResponseChoicesInnerLogprobs".to_string()),
                    "refusal" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionResponseChoicesInnerLogprobs".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionResponseChoicesInnerLogprobs".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionResponseChoicesInnerLogprobs {
            content: std::result::Result::Err("Nullable types not supported in CreateChatCompletionResponseChoicesInnerLogprobs".to_string())?,
            refusal: std::result::Result::Err("Nullable types not supported in CreateChatCompletionResponseChoicesInnerLogprobs".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionResponseChoicesInnerLogprobs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionResponseChoicesInnerLogprobs>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionResponseChoicesInnerLogprobs>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateChatCompletionResponseChoicesInnerLogprobs - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionResponseChoicesInnerLogprobs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionResponseChoicesInnerLogprobs as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateChatCompletionResponseChoicesInnerLogprobs - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionStreamResponse {
    /// A unique identifier for the chat completion. Each chunk has the same ID.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the last chunk if you set `stream_options: {\"include_usage\": true}`. 
    #[serde(rename = "choices")]
          #[validate(nested)]
    pub choices: Vec<models::CreateChatCompletionStreamResponseChoicesInner>,

    /// The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
    #[serde(rename = "created")]
    pub created: i32,

    /// The model to generate the completion.
    #[serde(rename = "model")]
          #[validate(custom(function = "check_xss_string"))]
    pub model: String,

    /// The service tier used for processing the request. This field is only included if the `service_tier` parameter is specified in the request.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "service_tier")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_tier: Option<Nullable<String>>,

    /// This fingerprint represents the backend configuration that the model runs with. Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
    #[serde(rename = "system_fingerprint")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub system_fingerprint: Option<String>,

    /// The object type, which is always `chat.completion.chunk`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "usage")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub usage: Option<Nullable<models::CreateChatCompletionStreamResponseUsage>>,

}



impl CreateChatCompletionStreamResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, choices: Vec<models::CreateChatCompletionStreamResponseChoicesInner>, created: i32, model: String, object: String, ) -> CreateChatCompletionStreamResponse {
        CreateChatCompletionStreamResponse {
 id,
 choices,
 created,
 model,
 service_tier: None,
 system_fingerprint: None,
 object,
 usage: None,
        }
    }
}

/// Converts the CreateChatCompletionStreamResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionStreamResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),

            // Skipping choices in query parameter serialization


            Some("created".to_string()),
            Some(self.created.to_string()),


            Some("model".to_string()),
            Some(self.model.to_string()),


            self.service_tier.as_ref().map(|service_tier| {
                [
                    "service_tier".to_string(),
                    service_tier.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.system_fingerprint.as_ref().map(|system_fingerprint| {
                [
                    "system_fingerprint".to_string(),
                    system_fingerprint.to_string(),
                ].join(",")
            }),


            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping usage in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionStreamResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionStreamResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub choices: Vec<Vec<models::CreateChatCompletionStreamResponseChoicesInner>>,
            pub created: Vec<i32>,
            pub model: Vec<String>,
            pub service_tier: Vec<String>,
            pub system_fingerprint: Vec<String>,
            pub object: Vec<String>,
            pub usage: Vec<models::CreateChatCompletionStreamResponseUsage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionStreamResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "choices" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateChatCompletionStreamResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "service_tier" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionStreamResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "system_fingerprint" => intermediate_rep.system_fingerprint.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "usage" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionStreamResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionStreamResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionStreamResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CreateChatCompletionStreamResponse".to_string())?,
            choices: intermediate_rep.choices.into_iter().next().ok_or_else(|| "choices missing in CreateChatCompletionStreamResponse".to_string())?,
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "created missing in CreateChatCompletionStreamResponse".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateChatCompletionStreamResponse".to_string())?,
            service_tier: std::result::Result::Err("Nullable types not supported in CreateChatCompletionStreamResponse".to_string())?,
            system_fingerprint: intermediate_rep.system_fingerprint.into_iter().next(),
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in CreateChatCompletionStreamResponse".to_string())?,
            usage: std::result::Result::Err("Nullable types not supported in CreateChatCompletionStreamResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionStreamResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionStreamResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionStreamResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateChatCompletionStreamResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionStreamResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionStreamResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateChatCompletionStreamResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionStreamResponseChoicesInner {
    #[serde(rename = "delta")]
          #[validate(nested)]
    pub delta: models::ChatCompletionStreamResponseDelta,

    #[serde(rename = "logprobs")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logprobs: Option<Nullable<models::CreateChatCompletionResponseChoicesInnerLogprobs>>,

    /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "finish_reason")]
    pub finish_reason: Nullable<String>,

    /// The index of the choice in the list of choices.
    #[serde(rename = "index")]
    pub index: i32,

}



impl CreateChatCompletionStreamResponseChoicesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(delta: models::ChatCompletionStreamResponseDelta, finish_reason: Nullable<String>, index: i32, ) -> CreateChatCompletionStreamResponseChoicesInner {
        CreateChatCompletionStreamResponseChoicesInner {
 delta,
 logprobs: None,
 finish_reason,
 index,
        }
    }
}

/// Converts the CreateChatCompletionStreamResponseChoicesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionStreamResponseChoicesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping delta in query parameter serialization

            // Skipping logprobs in query parameter serialization


            Some("finish_reason".to_string()),
            Some(self.finish_reason.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("index".to_string()),
            Some(self.index.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionStreamResponseChoicesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionStreamResponseChoicesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub delta: Vec<models::ChatCompletionStreamResponseDelta>,
            pub logprobs: Vec<models::CreateChatCompletionResponseChoicesInnerLogprobs>,
            pub finish_reason: Vec<String>,
            pub index: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionStreamResponseChoicesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "delta" => intermediate_rep.delta.push(<models::ChatCompletionStreamResponseDelta as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "logprobs" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionStreamResponseChoicesInner".to_string()),
                    "finish_reason" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateChatCompletionStreamResponseChoicesInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionStreamResponseChoicesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionStreamResponseChoicesInner {
            delta: intermediate_rep.delta.into_iter().next().ok_or_else(|| "delta missing in CreateChatCompletionStreamResponseChoicesInner".to_string())?,
            logprobs: std::result::Result::Err("Nullable types not supported in CreateChatCompletionStreamResponseChoicesInner".to_string())?,
            finish_reason: std::result::Result::Err("Nullable types not supported in CreateChatCompletionStreamResponseChoicesInner".to_string())?,
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in CreateChatCompletionStreamResponseChoicesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionStreamResponseChoicesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionStreamResponseChoicesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionStreamResponseChoicesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateChatCompletionStreamResponseChoicesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionStreamResponseChoicesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionStreamResponseChoicesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateChatCompletionStreamResponseChoicesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// An optional field that will only be present when you set `stream_options: {\"include_usage\": true}` in your request. When present, it contains a null value except for the last chunk which contains the token usage statistics for the entire request. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateChatCompletionStreamResponseUsage {
    /// Number of tokens in the generated completion.
    #[serde(rename = "completion_tokens")]
    pub completion_tokens: i32,

    /// Number of tokens in the prompt.
    #[serde(rename = "prompt_tokens")]
    pub prompt_tokens: i32,

    /// Total number of tokens used in the request (prompt + completion).
    #[serde(rename = "total_tokens")]
    pub total_tokens: i32,

}



impl CreateChatCompletionStreamResponseUsage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(completion_tokens: i32, prompt_tokens: i32, total_tokens: i32, ) -> CreateChatCompletionStreamResponseUsage {
        CreateChatCompletionStreamResponseUsage {
 completion_tokens,
 prompt_tokens,
 total_tokens,
        }
    }
}

/// Converts the CreateChatCompletionStreamResponseUsage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateChatCompletionStreamResponseUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("completion_tokens".to_string()),
            Some(self.completion_tokens.to_string()),


            Some("prompt_tokens".to_string()),
            Some(self.prompt_tokens.to_string()),


            Some("total_tokens".to_string()),
            Some(self.total_tokens.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateChatCompletionStreamResponseUsage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateChatCompletionStreamResponseUsage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub completion_tokens: Vec<i32>,
            pub prompt_tokens: Vec<i32>,
            pub total_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateChatCompletionStreamResponseUsage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "completion_tokens" => intermediate_rep.completion_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prompt_tokens" => intermediate_rep.prompt_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total_tokens" => intermediate_rep.total_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateChatCompletionStreamResponseUsage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateChatCompletionStreamResponseUsage {
            completion_tokens: intermediate_rep.completion_tokens.into_iter().next().ok_or_else(|| "completion_tokens missing in CreateChatCompletionStreamResponseUsage".to_string())?,
            prompt_tokens: intermediate_rep.prompt_tokens.into_iter().next().ok_or_else(|| "prompt_tokens missing in CreateChatCompletionStreamResponseUsage".to_string())?,
            total_tokens: intermediate_rep.total_tokens.into_iter().next().ok_or_else(|| "total_tokens missing in CreateChatCompletionStreamResponseUsage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateChatCompletionStreamResponseUsage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateChatCompletionStreamResponseUsage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateChatCompletionStreamResponseUsage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateChatCompletionStreamResponseUsage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateChatCompletionStreamResponseUsage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateChatCompletionStreamResponseUsage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateChatCompletionStreamResponseUsage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateCompletionRequest {
    #[serde(rename = "model")]
          #[validate(nested)]
    pub model: models::CreateCompletionRequestModel,

    #[serde(rename = "prompt")]
    pub prompt: Nullable<models::CreateCompletionRequestPrompt>,

    /// Generates `best_of` completions server-side and returns the \"best\" (the one with the highest log probability per token). Results cannot be streamed.  When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return  `best_of` must be greater than `n`.  **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`. 
    #[serde(rename = "best_of")]
    #[validate(
            range(min = 0u8, max = 20u8),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub best_of: Option<Nullable<u8>>,

    /// Echo back the prompt in addition to the completion 
    #[serde(rename = "echo")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub echo: Option<Nullable<bool>>,

    /// Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.  [See more information about frequency and presence penalties.](/docs/guides/text-generation) 
    #[serde(rename = "frequency_penalty")]
    #[validate(
            range(min = -2f64, max = 2f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub frequency_penalty: Option<Nullable<f64>>,

    /// Modify the likelihood of specified tokens appearing in the completion.  Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.  As an example, you can pass `{\"50256\": -100}` to prevent the <|endoftext|> token from being generated. 
    #[serde(rename = "logit_bias")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logit_bias: Option<Nullable<std::collections::HashMap<String, i32>>>,

    /// Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.  The maximum value for `logprobs` is 5. 
    #[serde(rename = "logprobs")]
    #[validate(
            range(min = 0u8, max = 5u8),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logprobs: Option<Nullable<u8>>,

    /// The maximum number of [tokens](/tokenizer) that can be generated in the completion.  The token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. 
    #[serde(rename = "max_tokens")]
    #[validate(
            range(min = 0u32),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_tokens: Option<Nullable<u32>>,

    /// How many completions to generate for each prompt.  **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`. 
    #[serde(rename = "n")]
    #[validate(
            range(min = 1u8, max = 128u8),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub n: Option<Nullable<u8>>,

    /// Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.  [See more information about frequency and presence penalties.](/docs/guides/text-generation) 
    #[serde(rename = "presence_penalty")]
    #[validate(
            range(min = -2f64, max = 2f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub presence_penalty: Option<Nullable<f64>>,

    /// If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.  Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend. 
    #[serde(rename = "seed")]
    #[validate(
            range(min = -9223372036854776000i128, max = 9223372036854776000i128),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seed: Option<Nullable<i128>>,

    #[serde(rename = "stop")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop: Option<Nullable<models::CreateCompletionRequestStop>>,

    /// Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions). 
    #[serde(rename = "stream")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stream: Option<Nullable<bool>>,

    #[serde(rename = "stream_options")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stream_options: Option<Nullable<models::ChatCompletionStreamOptions>>,

    /// The suffix that comes after a completion of inserted text.  This parameter is only supported for `gpt-3.5-turbo-instruct`. 
    #[serde(rename = "suffix")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub suffix: Option<Nullable<String>>,

    /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or `top_p` but not both. 
    #[serde(rename = "temperature")]
    #[validate(
            range(min = 0f64, max = 2f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<Nullable<f64>>,

    /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or `temperature` but not both. 
    #[serde(rename = "top_p")]
    #[validate(
            range(min = 0f64, max = 1f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub top_p: Option<Nullable<f64>>,

    /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
    #[serde(rename = "user")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

}



impl CreateCompletionRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(model: models::CreateCompletionRequestModel, prompt: Nullable<models::CreateCompletionRequestPrompt>, ) -> CreateCompletionRequest {
        CreateCompletionRequest {
 model,
 prompt,
 best_of: Some(Nullable::Present(1)),
 echo: Some(Nullable::Present(false)),
 frequency_penalty: Some(Nullable::Present(0.0)),
 logit_bias: None,
 logprobs: None,
 max_tokens: Some(Nullable::Present(16)),
 n: Some(Nullable::Present(1)),
 presence_penalty: Some(Nullable::Present(0.0)),
 seed: None,
 stop: None,
 stream: Some(Nullable::Present(false)),
 stream_options: None,
 suffix: None,
 temperature: Some(Nullable::Present(1.0)),
 top_p: Some(Nullable::Present(1.0)),
 user: None,
        }
    }
}

/// Converts the CreateCompletionRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateCompletionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping model in query parameter serialization

            // Skipping prompt in query parameter serialization


            self.best_of.as_ref().map(|best_of| {
                [
                    "best_of".to_string(),
                    best_of.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.echo.as_ref().map(|echo| {
                [
                    "echo".to_string(),
                    echo.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.frequency_penalty.as_ref().map(|frequency_penalty| {
                [
                    "frequency_penalty".to_string(),
                    frequency_penalty.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping logit_bias in query parameter serialization


            self.logprobs.as_ref().map(|logprobs| {
                [
                    "logprobs".to_string(),
                    logprobs.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.max_tokens.as_ref().map(|max_tokens| {
                [
                    "max_tokens".to_string(),
                    max_tokens.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.n.as_ref().map(|n| {
                [
                    "n".to_string(),
                    n.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.presence_penalty.as_ref().map(|presence_penalty| {
                [
                    "presence_penalty".to_string(),
                    presence_penalty.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.seed.as_ref().map(|seed| {
                [
                    "seed".to_string(),
                    seed.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping stop in query parameter serialization


            self.stream.as_ref().map(|stream| {
                [
                    "stream".to_string(),
                    stream.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping stream_options in query parameter serialization


            self.suffix.as_ref().map(|suffix| {
                [
                    "suffix".to_string(),
                    suffix.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.top_p.as_ref().map(|top_p| {
                [
                    "top_p".to_string(),
                    top_p.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "user".to_string(),
                    user.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateCompletionRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateCompletionRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub model: Vec<models::CreateCompletionRequestModel>,
            pub prompt: Vec<models::CreateCompletionRequestPrompt>,
            pub best_of: Vec<u8>,
            pub echo: Vec<bool>,
            pub frequency_penalty: Vec<f64>,
            pub logit_bias: Vec<std::collections::HashMap<String, i32>>,
            pub logprobs: Vec<u8>,
            pub max_tokens: Vec<u32>,
            pub n: Vec<u8>,
            pub presence_penalty: Vec<f64>,
            pub seed: Vec<i128>,
            pub stop: Vec<models::CreateCompletionRequestStop>,
            pub stream: Vec<bool>,
            pub stream_options: Vec<models::ChatCompletionStreamOptions>,
            pub suffix: Vec<String>,
            pub temperature: Vec<f64>,
            pub top_p: Vec<f64>,
            pub user: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateCompletionRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<models::CreateCompletionRequestModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "prompt" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "best_of" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "echo" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "frequency_penalty" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "logit_bias" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateCompletionRequest".to_string()),
                    "logprobs" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "max_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "n" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "presence_penalty" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "seed" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "stop" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "stream" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "stream_options" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "suffix" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "temperature" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    "top_p" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateCompletionRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateCompletionRequest {
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateCompletionRequest".to_string())?,
            prompt: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            best_of: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            echo: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            frequency_penalty: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            logit_bias: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            logprobs: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            max_tokens: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            n: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            presence_penalty: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            seed: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            stop: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            stream: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            stream_options: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            suffix: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            temperature: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            top_p: std::result::Result::Err("Nullable types not supported in CreateCompletionRequest".to_string())?,
            user: intermediate_rep.user.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateCompletionRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateCompletionRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateCompletionRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateCompletionRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateCompletionRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateCompletionRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateCompletionRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateCompletionRequestModel {
    String(String),
    String1(String),
}

impl validator::Validate for CreateCompletionRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::String1(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateCompletionRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateCompletionRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}







/// The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.  Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateCompletionRequestPrompt {
    String(String),
    VecOfString(Vec<String>),
    VecOfi32(Vec<i32>),
    VecOfVecOfi32(Vec<Vec<i32>>),
}

impl validator::Validate for CreateCompletionRequestPrompt
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::VecOfString(_) => std::result::Result::Ok(()),
            Self::VecOfi32(_) => std::result::Result::Ok(()),
            Self::VecOfVecOfi32(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateCompletionRequestPrompt value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateCompletionRequestPrompt {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for CreateCompletionRequestPrompt {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<Vec<String>> for CreateCompletionRequestPrompt {
    fn from(value: Vec<String>) -> Self {
        Self::VecOfString(value)
    }
}
impl From<Vec<i32>> for CreateCompletionRequestPrompt {
    fn from(value: Vec<i32>) -> Self {
        Self::VecOfi32(value)
    }
}
impl From<Vec<Vec<i32>>> for CreateCompletionRequestPrompt {
    fn from(value: Vec<Vec<i32>>) -> Self {
        Self::VecOfVecOfi32(value)
    }
}





/// Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateCompletionRequestStop {
    String(String),
    VecOfString(Vec<String>),
}

impl validator::Validate for CreateCompletionRequestStop
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::VecOfString(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateCompletionRequestStop value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateCompletionRequestStop {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for CreateCompletionRequestStop {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<Vec<String>> for CreateCompletionRequestStop {
    fn from(value: Vec<String>) -> Self {
        Self::VecOfString(value)
    }
}





/// Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape (unlike the chat endpoint). 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateCompletionResponse {
    /// A unique identifier for the completion.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The list of completion choices the model generated for the input prompt.
    #[serde(rename = "choices")]
          #[validate(nested)]
    pub choices: Vec<models::CreateCompletionResponseChoicesInner>,

    /// The Unix timestamp (in seconds) of when the completion was created.
    #[serde(rename = "created")]
    pub created: i32,

    /// The model used for completion.
    #[serde(rename = "model")]
          #[validate(custom(function = "check_xss_string"))]
    pub model: String,

    /// This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
    #[serde(rename = "system_fingerprint")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub system_fingerprint: Option<String>,

    /// The object type, which is always \"text_completion\"
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "usage")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub usage: Option<models::CompletionUsage>,

}



impl CreateCompletionResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, choices: Vec<models::CreateCompletionResponseChoicesInner>, created: i32, model: String, object: String, ) -> CreateCompletionResponse {
        CreateCompletionResponse {
 id,
 choices,
 created,
 model,
 system_fingerprint: None,
 object,
 usage: None,
        }
    }
}

/// Converts the CreateCompletionResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateCompletionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),

            // Skipping choices in query parameter serialization


            Some("created".to_string()),
            Some(self.created.to_string()),


            Some("model".to_string()),
            Some(self.model.to_string()),


            self.system_fingerprint.as_ref().map(|system_fingerprint| {
                [
                    "system_fingerprint".to_string(),
                    system_fingerprint.to_string(),
                ].join(",")
            }),


            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping usage in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateCompletionResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateCompletionResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub choices: Vec<Vec<models::CreateCompletionResponseChoicesInner>>,
            pub created: Vec<i32>,
            pub model: Vec<String>,
            pub system_fingerprint: Vec<String>,
            pub object: Vec<String>,
            pub usage: Vec<models::CompletionUsage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateCompletionResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "choices" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateCompletionResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "system_fingerprint" => intermediate_rep.system_fingerprint.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usage" => intermediate_rep.usage.push(<models::CompletionUsage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateCompletionResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateCompletionResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CreateCompletionResponse".to_string())?,
            choices: intermediate_rep.choices.into_iter().next().ok_or_else(|| "choices missing in CreateCompletionResponse".to_string())?,
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "created missing in CreateCompletionResponse".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateCompletionResponse".to_string())?,
            system_fingerprint: intermediate_rep.system_fingerprint.into_iter().next(),
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in CreateCompletionResponse".to_string())?,
            usage: intermediate_rep.usage.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateCompletionResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateCompletionResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateCompletionResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateCompletionResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateCompletionResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateCompletionResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateCompletionResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateCompletionResponseChoicesInner {
    /// The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, or `content_filter` if content was omitted due to a flag from our content filters. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "finish_reason")]
          #[validate(custom(function = "check_xss_string"))]
    pub finish_reason: String,

    #[serde(rename = "index")]
    pub index: i32,

    #[serde(rename = "logprobs")]
    pub logprobs: Nullable<models::CreateCompletionResponseChoicesInnerLogprobs>,

    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    pub text: String,

}



impl CreateCompletionResponseChoicesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(finish_reason: String, index: i32, logprobs: Nullable<models::CreateCompletionResponseChoicesInnerLogprobs>, text: String, ) -> CreateCompletionResponseChoicesInner {
        CreateCompletionResponseChoicesInner {
 finish_reason,
 index,
 logprobs,
 text,
        }
    }
}

/// Converts the CreateCompletionResponseChoicesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateCompletionResponseChoicesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("finish_reason".to_string()),
            Some(self.finish_reason.to_string()),


            Some("index".to_string()),
            Some(self.index.to_string()),

            // Skipping logprobs in query parameter serialization


            Some("text".to_string()),
            Some(self.text.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateCompletionResponseChoicesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateCompletionResponseChoicesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub finish_reason: Vec<String>,
            pub index: Vec<i32>,
            pub logprobs: Vec<models::CreateCompletionResponseChoicesInnerLogprobs>,
            pub text: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateCompletionResponseChoicesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "finish_reason" => intermediate_rep.finish_reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "logprobs" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateCompletionResponseChoicesInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateCompletionResponseChoicesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateCompletionResponseChoicesInner {
            finish_reason: intermediate_rep.finish_reason.into_iter().next().ok_or_else(|| "finish_reason missing in CreateCompletionResponseChoicesInner".to_string())?,
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in CreateCompletionResponseChoicesInner".to_string())?,
            logprobs: std::result::Result::Err("Nullable types not supported in CreateCompletionResponseChoicesInner".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in CreateCompletionResponseChoicesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateCompletionResponseChoicesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateCompletionResponseChoicesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateCompletionResponseChoicesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateCompletionResponseChoicesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateCompletionResponseChoicesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateCompletionResponseChoicesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateCompletionResponseChoicesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateCompletionResponseChoicesInnerLogprobs {
    #[serde(rename = "text_offset")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text_offset: Option<Vec<i32>>,

    #[serde(rename = "token_logprobs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_logprobs: Option<Vec<f64>>,

    #[serde(rename = "tokens")]
          #[validate(custom(function = "check_xss_vec_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tokens: Option<Vec<String>>,

    #[serde(rename = "top_logprobs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub top_logprobs: Option<Vec<std::collections::HashMap<String, f64>>>,

}



impl CreateCompletionResponseChoicesInnerLogprobs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateCompletionResponseChoicesInnerLogprobs {
        CreateCompletionResponseChoicesInnerLogprobs {
 text_offset: None,
 token_logprobs: None,
 tokens: None,
 top_logprobs: None,
        }
    }
}

/// Converts the CreateCompletionResponseChoicesInnerLogprobs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateCompletionResponseChoicesInnerLogprobs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.text_offset.as_ref().map(|text_offset| {
                [
                    "text_offset".to_string(),
                    text_offset.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.token_logprobs.as_ref().map(|token_logprobs| {
                [
                    "token_logprobs".to_string(),
                    token_logprobs.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.tokens.as_ref().map(|tokens| {
                [
                    "tokens".to_string(),
                    tokens.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping top_logprobs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateCompletionResponseChoicesInnerLogprobs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateCompletionResponseChoicesInnerLogprobs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub text_offset: Vec<Vec<i32>>,
            pub token_logprobs: Vec<Vec<f64>>,
            pub tokens: Vec<Vec<String>>,
            pub top_logprobs: Vec<Vec<std::collections::HashMap<String, f64>>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateCompletionResponseChoicesInnerLogprobs".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "text_offset" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateCompletionResponseChoicesInnerLogprobs".to_string()),
                    "token_logprobs" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateCompletionResponseChoicesInnerLogprobs".to_string()),
                    "tokens" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateCompletionResponseChoicesInnerLogprobs".to_string()),
                    "top_logprobs" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateCompletionResponseChoicesInnerLogprobs".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateCompletionResponseChoicesInnerLogprobs".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateCompletionResponseChoicesInnerLogprobs {
            text_offset: intermediate_rep.text_offset.into_iter().next(),
            token_logprobs: intermediate_rep.token_logprobs.into_iter().next(),
            tokens: intermediate_rep.tokens.into_iter().next(),
            top_logprobs: intermediate_rep.top_logprobs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateCompletionResponseChoicesInnerLogprobs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateCompletionResponseChoicesInnerLogprobs>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateCompletionResponseChoicesInnerLogprobs>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateCompletionResponseChoicesInnerLogprobs - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateCompletionResponseChoicesInnerLogprobs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateCompletionResponseChoicesInnerLogprobs as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateCompletionResponseChoicesInnerLogprobs - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateEmbeddingRequest {
    #[serde(rename = "input")]
          #[validate(nested)]
    pub input: models::CreateEmbeddingRequestInput,

    #[serde(rename = "model")]
          #[validate(nested)]
    pub model: models::CreateEmbeddingRequestModel,

    /// The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "encoding_format")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub encoding_format: Option<String>,

    /// The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models. 
    #[serde(rename = "dimensions")]
    #[validate(
            range(min = 1u32),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dimensions: Option<u32>,

    /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
    #[serde(rename = "user")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

}



impl CreateEmbeddingRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(input: models::CreateEmbeddingRequestInput, model: models::CreateEmbeddingRequestModel, ) -> CreateEmbeddingRequest {
        CreateEmbeddingRequest {
 input,
 model,
 encoding_format: None,
 dimensions: None,
 user: None,
        }
    }
}

/// Converts the CreateEmbeddingRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateEmbeddingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping input in query parameter serialization

            // Skipping model in query parameter serialization


            self.encoding_format.as_ref().map(|encoding_format| {
                [
                    "encoding_format".to_string(),
                    encoding_format.to_string(),
                ].join(",")
            }),


            self.dimensions.as_ref().map(|dimensions| {
                [
                    "dimensions".to_string(),
                    dimensions.to_string(),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "user".to_string(),
                    user.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateEmbeddingRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateEmbeddingRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub input: Vec<models::CreateEmbeddingRequestInput>,
            pub model: Vec<models::CreateEmbeddingRequestModel>,
            pub encoding_format: Vec<String>,
            pub dimensions: Vec<u32>,
            pub user: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateEmbeddingRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "input" => intermediate_rep.input.push(<models::CreateEmbeddingRequestInput as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<models::CreateEmbeddingRequestModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "encoding_format" => intermediate_rep.encoding_format.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dimensions" => intermediate_rep.dimensions.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateEmbeddingRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateEmbeddingRequest {
            input: intermediate_rep.input.into_iter().next().ok_or_else(|| "input missing in CreateEmbeddingRequest".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateEmbeddingRequest".to_string())?,
            encoding_format: intermediate_rep.encoding_format.into_iter().next(),
            dimensions: intermediate_rep.dimensions.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateEmbeddingRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateEmbeddingRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateEmbeddingRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateEmbeddingRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateEmbeddingRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateEmbeddingRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateEmbeddingRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateEmbeddingRequestInput {
    String(String),
    VecOfString(Vec<String>),
    VecOfi32(Vec<i32>),
    VecOfVecOfi32(Vec<Vec<i32>>),
}

impl validator::Validate for CreateEmbeddingRequestInput
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::VecOfString(_) => std::result::Result::Ok(()),
            Self::VecOfi32(_) => std::result::Result::Ok(()),
            Self::VecOfVecOfi32(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateEmbeddingRequestInput value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateEmbeddingRequestInput {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for CreateEmbeddingRequestInput {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<Vec<String>> for CreateEmbeddingRequestInput {
    fn from(value: Vec<String>) -> Self {
        Self::VecOfString(value)
    }
}
impl From<Vec<i32>> for CreateEmbeddingRequestInput {
    fn from(value: Vec<i32>) -> Self {
        Self::VecOfi32(value)
    }
}
impl From<Vec<Vec<i32>>> for CreateEmbeddingRequestInput {
    fn from(value: Vec<Vec<i32>>) -> Self {
        Self::VecOfVecOfi32(value)
    }
}





/// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateEmbeddingRequestModel {
    String(String),
    String1(String),
}

impl validator::Validate for CreateEmbeddingRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::String1(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateEmbeddingRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateEmbeddingRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateEmbeddingResponse {
    /// The list of embeddings generated by the model.
    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::Embedding>,

    /// The name of the model used to generate the embedding.
    #[serde(rename = "model")]
          #[validate(custom(function = "check_xss_string"))]
    pub model: String,

    /// The object type, which is always \"list\".
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "usage")]
          #[validate(nested)]
    pub usage: models::CreateEmbeddingResponseUsage,

}



impl CreateEmbeddingResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(data: Vec<models::Embedding>, model: String, object: String, usage: models::CreateEmbeddingResponseUsage, ) -> CreateEmbeddingResponse {
        CreateEmbeddingResponse {
 data,
 model,
 object,
 usage,
        }
    }
}

/// Converts the CreateEmbeddingResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateEmbeddingResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization


            Some("model".to_string()),
            Some(self.model.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping usage in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateEmbeddingResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateEmbeddingResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<Vec<models::Embedding>>,
            pub model: Vec<String>,
            pub object: Vec<String>,
            pub usage: Vec<models::CreateEmbeddingResponseUsage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateEmbeddingResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateEmbeddingResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usage" => intermediate_rep.usage.push(<models::CreateEmbeddingResponseUsage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateEmbeddingResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateEmbeddingResponse {
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in CreateEmbeddingResponse".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateEmbeddingResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in CreateEmbeddingResponse".to_string())?,
            usage: intermediate_rep.usage.into_iter().next().ok_or_else(|| "usage missing in CreateEmbeddingResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateEmbeddingResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateEmbeddingResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateEmbeddingResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateEmbeddingResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateEmbeddingResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateEmbeddingResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateEmbeddingResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The usage information for the request.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateEmbeddingResponseUsage {
    /// The number of tokens used by the prompt.
    #[serde(rename = "prompt_tokens")]
    pub prompt_tokens: i32,

    /// The total number of tokens used by the request.
    #[serde(rename = "total_tokens")]
    pub total_tokens: i32,

}



impl CreateEmbeddingResponseUsage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(prompt_tokens: i32, total_tokens: i32, ) -> CreateEmbeddingResponseUsage {
        CreateEmbeddingResponseUsage {
 prompt_tokens,
 total_tokens,
        }
    }
}

/// Converts the CreateEmbeddingResponseUsage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateEmbeddingResponseUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("prompt_tokens".to_string()),
            Some(self.prompt_tokens.to_string()),


            Some("total_tokens".to_string()),
            Some(self.total_tokens.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateEmbeddingResponseUsage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateEmbeddingResponseUsage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub prompt_tokens: Vec<i32>,
            pub total_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateEmbeddingResponseUsage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "prompt_tokens" => intermediate_rep.prompt_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total_tokens" => intermediate_rep.total_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateEmbeddingResponseUsage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateEmbeddingResponseUsage {
            prompt_tokens: intermediate_rep.prompt_tokens.into_iter().next().ok_or_else(|| "prompt_tokens missing in CreateEmbeddingResponseUsage".to_string())?,
            total_tokens: intermediate_rep.total_tokens.into_iter().next().ok_or_else(|| "total_tokens missing in CreateEmbeddingResponseUsage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateEmbeddingResponseUsage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateEmbeddingResponseUsage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateEmbeddingResponseUsage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateEmbeddingResponseUsage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateEmbeddingResponseUsage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateEmbeddingResponseUsage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateEmbeddingResponseUsage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateFineTuningJobRequest {
    #[serde(rename = "model")]
          #[validate(nested)]
    pub model: models::CreateFineTuningJobRequestModel,

    /// The ID of an uploaded file that contains training data.  See [upload file](/docs/api-reference/files/create) for how to upload a file.  Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.  The contents of the file should differ depending on if the model uses the [chat](/docs/api-reference/fine-tuning/chat-input), [completions](/docs/api-reference/fine-tuning/completions-input) format, or if the fine-tuning method uses the [preference](/docs/api-reference/fine-tuning/preference-input) format.  See the [fine-tuning guide](/docs/guides/fine-tuning) for more details. 
    #[serde(rename = "training_file")]
          #[validate(custom(function = "check_xss_string"))]
    pub training_file: String,

    #[serde(rename = "hyperparameters")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hyperparameters: Option<models::CreateFineTuningJobRequestHyperparameters>,

    /// A string of up to 64 characters that will be added to your fine-tuned model name.  For example, a `suffix` of \"custom-model-name\" would produce a model name like `ft:gpt-4o-mini:openai:custom-model-name:7p4lURel`. 
    #[serde(rename = "suffix")]
    #[validate(
            length(min = 1, max = 64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub suffix: Option<Nullable<String>>,

    /// The ID of an uploaded file that contains validation data.  If you provide this file, the data is used to generate validation metrics periodically during fine-tuning. These metrics can be viewed in the fine-tuning results file. The same data should not be present in both train and validation files.  Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.  See the [fine-tuning guide](/docs/guides/fine-tuning) for more details. 
    #[serde(rename = "validation_file")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub validation_file: Option<Nullable<String>>,

    /// A list of integrations to enable for your fine-tuning job.
    #[serde(rename = "integrations")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub integrations: Option<Nullable<Vec<models::CreateFineTuningJobRequestIntegrationsInner>>>,

    /// The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases. If a seed is not specified, one will be generated for you. 
    #[serde(rename = "seed")]
    #[validate(
            range(min = 0u32, max = 2147483647u32),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seed: Option<Nullable<u32>>,

    #[serde(rename = "method")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub method: Option<models::FineTuneMethod>,

}



impl CreateFineTuningJobRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(model: models::CreateFineTuningJobRequestModel, training_file: String, ) -> CreateFineTuningJobRequest {
        CreateFineTuningJobRequest {
 model,
 training_file,
 hyperparameters: None,
 suffix: None,
 validation_file: None,
 integrations: None,
 seed: None,
 method: None,
        }
    }
}

/// Converts the CreateFineTuningJobRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateFineTuningJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping model in query parameter serialization


            Some("training_file".to_string()),
            Some(self.training_file.to_string()),

            // Skipping hyperparameters in query parameter serialization


            self.suffix.as_ref().map(|suffix| {
                [
                    "suffix".to_string(),
                    suffix.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.validation_file.as_ref().map(|validation_file| {
                [
                    "validation_file".to_string(),
                    validation_file.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping integrations in query parameter serialization


            self.seed.as_ref().map(|seed| {
                [
                    "seed".to_string(),
                    seed.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping method in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub model: Vec<models::CreateFineTuningJobRequestModel>,
            pub training_file: Vec<String>,
            pub hyperparameters: Vec<models::CreateFineTuningJobRequestHyperparameters>,
            pub suffix: Vec<String>,
            pub validation_file: Vec<String>,
            pub integrations: Vec<Vec<models::CreateFineTuningJobRequestIntegrationsInner>>,
            pub seed: Vec<u32>,
            pub method: Vec<models::FineTuneMethod>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateFineTuningJobRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<models::CreateFineTuningJobRequestModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "training_file" => intermediate_rep.training_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hyperparameters" => intermediate_rep.hyperparameters.push(<models::CreateFineTuningJobRequestHyperparameters as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "suffix" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateFineTuningJobRequest".to_string()),
                    "validation_file" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateFineTuningJobRequest".to_string()),
                    "integrations" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateFineTuningJobRequest".to_string()),
                    "seed" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateFineTuningJobRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "method" => intermediate_rep.method.push(<models::FineTuneMethod as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateFineTuningJobRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateFineTuningJobRequest {
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateFineTuningJobRequest".to_string())?,
            training_file: intermediate_rep.training_file.into_iter().next().ok_or_else(|| "training_file missing in CreateFineTuningJobRequest".to_string())?,
            hyperparameters: intermediate_rep.hyperparameters.into_iter().next(),
            suffix: std::result::Result::Err("Nullable types not supported in CreateFineTuningJobRequest".to_string())?,
            validation_file: std::result::Result::Err("Nullable types not supported in CreateFineTuningJobRequest".to_string())?,
            integrations: std::result::Result::Err("Nullable types not supported in CreateFineTuningJobRequest".to_string())?,
            seed: std::result::Result::Err("Nullable types not supported in CreateFineTuningJobRequest".to_string())?,
            method: intermediate_rep.method.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateFineTuningJobRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateFineTuningJobRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateFineTuningJobRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateFineTuningJobRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateFineTuningJobRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateFineTuningJobRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateFineTuningJobRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The hyperparameters used for the fine-tuning job. This value is now deprecated in favor of `method`, and should be passed in under the `method` parameter. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateFineTuningJobRequestHyperparameters {
    #[serde(rename = "batch_size")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub batch_size: Option<models::CreateFineTuningJobRequestHyperparametersBatchSize>,

    #[serde(rename = "learning_rate_multiplier")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub learning_rate_multiplier: Option<models::CreateFineTuningJobRequestHyperparametersLearningRateMultiplier>,

    #[serde(rename = "n_epochs")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub n_epochs: Option<models::CreateFineTuningJobRequestHyperparametersNEpochs>,

}



impl CreateFineTuningJobRequestHyperparameters {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateFineTuningJobRequestHyperparameters {
        CreateFineTuningJobRequestHyperparameters {
 batch_size: None,
 learning_rate_multiplier: None,
 n_epochs: None,
        }
    }
}

/// Converts the CreateFineTuningJobRequestHyperparameters value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateFineTuningJobRequestHyperparameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping batch_size in query parameter serialization

            // Skipping learning_rate_multiplier in query parameter serialization

            // Skipping n_epochs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequestHyperparameters value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequestHyperparameters {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub batch_size: Vec<models::CreateFineTuningJobRequestHyperparametersBatchSize>,
            pub learning_rate_multiplier: Vec<models::CreateFineTuningJobRequestHyperparametersLearningRateMultiplier>,
            pub n_epochs: Vec<models::CreateFineTuningJobRequestHyperparametersNEpochs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateFineTuningJobRequestHyperparameters".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "batch_size" => intermediate_rep.batch_size.push(<models::CreateFineTuningJobRequestHyperparametersBatchSize as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "learning_rate_multiplier" => intermediate_rep.learning_rate_multiplier.push(<models::CreateFineTuningJobRequestHyperparametersLearningRateMultiplier as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n_epochs" => intermediate_rep.n_epochs.push(<models::CreateFineTuningJobRequestHyperparametersNEpochs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateFineTuningJobRequestHyperparameters".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateFineTuningJobRequestHyperparameters {
            batch_size: intermediate_rep.batch_size.into_iter().next(),
            learning_rate_multiplier: intermediate_rep.learning_rate_multiplier.into_iter().next(),
            n_epochs: intermediate_rep.n_epochs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateFineTuningJobRequestHyperparameters> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateFineTuningJobRequestHyperparameters>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateFineTuningJobRequestHyperparameters>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateFineTuningJobRequestHyperparameters - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateFineTuningJobRequestHyperparameters> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateFineTuningJobRequestHyperparameters as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateFineTuningJobRequestHyperparameters - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateFineTuningJobRequestHyperparametersBatchSize {
    String(String),
    I32(i32),
}

impl validator::Validate for CreateFineTuningJobRequestHyperparametersBatchSize
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::I32(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequestHyperparametersBatchSize value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequestHyperparametersBatchSize {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for CreateFineTuningJobRequestHyperparametersBatchSize {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<i32> for CreateFineTuningJobRequestHyperparametersBatchSize {
    fn from(value: i32) -> Self {
        Self::I32(value)
    }
}





/// Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateFineTuningJobRequestHyperparametersLearningRateMultiplier {
    String(String),
    F64(f64),
}

impl validator::Validate for CreateFineTuningJobRequestHyperparametersLearningRateMultiplier
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::F64(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequestHyperparametersLearningRateMultiplier value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequestHyperparametersLearningRateMultiplier {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for CreateFineTuningJobRequestHyperparametersLearningRateMultiplier {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<f64> for CreateFineTuningJobRequestHyperparametersLearningRateMultiplier {
    fn from(value: f64) -> Self {
        Self::F64(value)
    }
}





/// The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateFineTuningJobRequestHyperparametersNEpochs {
    String(String),
    I32(i32),
}

impl validator::Validate for CreateFineTuningJobRequestHyperparametersNEpochs
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::I32(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequestHyperparametersNEpochs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequestHyperparametersNEpochs {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for CreateFineTuningJobRequestHyperparametersNEpochs {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<i32> for CreateFineTuningJobRequestHyperparametersNEpochs {
    fn from(value: i32) -> Self {
        Self::I32(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateFineTuningJobRequestIntegrationsInner {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "wandb")]
          #[validate(nested)]
    pub wandb: models::CreateFineTuningJobRequestIntegrationsInnerWandb,

}



impl CreateFineTuningJobRequestIntegrationsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, wandb: models::CreateFineTuningJobRequestIntegrationsInnerWandb, ) -> CreateFineTuningJobRequestIntegrationsInner {
        CreateFineTuningJobRequestIntegrationsInner {
 r_type,
 wandb,
        }
    }
}

/// Converts the CreateFineTuningJobRequestIntegrationsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateFineTuningJobRequestIntegrationsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping wandb in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequestIntegrationsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequestIntegrationsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub wandb: Vec<models::CreateFineTuningJobRequestIntegrationsInnerWandb>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateFineTuningJobRequestIntegrationsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "wandb" => intermediate_rep.wandb.push(<models::CreateFineTuningJobRequestIntegrationsInnerWandb as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateFineTuningJobRequestIntegrationsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateFineTuningJobRequestIntegrationsInner {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in CreateFineTuningJobRequestIntegrationsInner".to_string())?,
            wandb: intermediate_rep.wandb.into_iter().next().ok_or_else(|| "wandb missing in CreateFineTuningJobRequestIntegrationsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateFineTuningJobRequestIntegrationsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateFineTuningJobRequestIntegrationsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateFineTuningJobRequestIntegrationsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The settings for your integration with Weights and Biases. This payload specifies the project that metrics will be sent to. Optionally, you can set an explicit display name for your run, add tags to your run, and set a default entity (team, username, etc) to be associated with your run. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateFineTuningJobRequestIntegrationsInnerWandb {
    /// The name of the project that the new run will be created under. 
    #[serde(rename = "project")]
          #[validate(custom(function = "check_xss_string"))]
    pub project: String,

    /// A display name to set for the run. If not set, we will use the Job ID as the name. 
    #[serde(rename = "name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

    /// The entity to use for the run. This allows you to set the team or username of the WandB user that you would like associated with the run. If not set, the default entity for the registered WandB API key is used. 
    #[serde(rename = "entity")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub entity: Option<Nullable<String>>,

    /// A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some default tags are generated by OpenAI: \"openai/finetune\", \"openai/{base-model}\", \"openai/{ftjob-abcdef}\". 
    #[serde(rename = "tags")]
          #[validate(custom(function = "check_xss_vec_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<Vec<String>>,

}



impl CreateFineTuningJobRequestIntegrationsInnerWandb {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(project: String, ) -> CreateFineTuningJobRequestIntegrationsInnerWandb {
        CreateFineTuningJobRequestIntegrationsInnerWandb {
 project,
 name: None,
 entity: None,
 tags: None,
        }
    }
}

/// Converts the CreateFineTuningJobRequestIntegrationsInnerWandb value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateFineTuningJobRequestIntegrationsInnerWandb {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("project".to_string()),
            Some(self.project.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.entity.as_ref().map(|entity| {
                [
                    "entity".to_string(),
                    entity.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.tags.as_ref().map(|tags| {
                [
                    "tags".to_string(),
                    tags.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequestIntegrationsInnerWandb value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequestIntegrationsInnerWandb {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub project: Vec<String>,
            pub name: Vec<String>,
            pub entity: Vec<String>,
            pub tags: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateFineTuningJobRequestIntegrationsInnerWandb".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "project" => intermediate_rep.project.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateFineTuningJobRequestIntegrationsInnerWandb".to_string()),
                    "entity" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateFineTuningJobRequestIntegrationsInnerWandb".to_string()),
                    "tags" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateFineTuningJobRequestIntegrationsInnerWandb".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateFineTuningJobRequestIntegrationsInnerWandb".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateFineTuningJobRequestIntegrationsInnerWandb {
            project: intermediate_rep.project.into_iter().next().ok_or_else(|| "project missing in CreateFineTuningJobRequestIntegrationsInnerWandb".to_string())?,
            name: std::result::Result::Err("Nullable types not supported in CreateFineTuningJobRequestIntegrationsInnerWandb".to_string())?,
            entity: std::result::Result::Err("Nullable types not supported in CreateFineTuningJobRequestIntegrationsInnerWandb".to_string())?,
            tags: intermediate_rep.tags.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInnerWandb> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInnerWandb>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInnerWandb>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateFineTuningJobRequestIntegrationsInnerWandb - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateFineTuningJobRequestIntegrationsInnerWandb> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateFineTuningJobRequestIntegrationsInnerWandb as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateFineTuningJobRequestIntegrationsInnerWandb - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The name of the model to fine-tune. You can select one of the [supported models](/docs/guides/fine-tuning#which-models-can-be-fine-tuned). 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateFineTuningJobRequestModel {
    String(String),
    String1(String),
}

impl validator::Validate for CreateFineTuningJobRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::String1(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateFineTuningJobRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateFineTuningJobRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}







/// The model to use for image generation. Only `dall-e-2` is supported at this time.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateImageEditRequestModel {
    String(String),
    String1(String),
}

impl validator::Validate for CreateImageEditRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::String1(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateImageEditRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateImageEditRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateImageRequest {
    /// A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
    #[serde(rename = "prompt")]
          #[validate(custom(function = "check_xss_string"))]
    pub prompt: String,

    #[serde(rename = "model")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<Nullable<models::CreateImageRequestModel>>,

    /// The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
    #[serde(rename = "n")]
    #[validate(
            range(min = 1u8, max = 10u8),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub n: Option<Nullable<u8>>,

    /// The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "quality")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quality: Option<String>,

    /// The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "response_format")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_format: Option<Nullable<String>>,

    /// The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "size")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<Nullable<String>>,

    /// The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "style")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub style: Option<Nullable<String>>,

    /// A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
    #[serde(rename = "user")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,

}



impl CreateImageRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(prompt: String, ) -> CreateImageRequest {
        CreateImageRequest {
 prompt,
 model: None,
 n: Some(Nullable::Present(1)),
 quality: None,
 response_format: None,
 size: None,
 style: None,
 user: None,
        }
    }
}

/// Converts the CreateImageRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateImageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("prompt".to_string()),
            Some(self.prompt.to_string()),

            // Skipping model in query parameter serialization


            self.n.as_ref().map(|n| {
                [
                    "n".to_string(),
                    n.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.quality.as_ref().map(|quality| {
                [
                    "quality".to_string(),
                    quality.to_string(),
                ].join(",")
            }),


            self.response_format.as_ref().map(|response_format| {
                [
                    "response_format".to_string(),
                    response_format.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.style.as_ref().map(|style| {
                [
                    "style".to_string(),
                    style.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.user.as_ref().map(|user| {
                [
                    "user".to_string(),
                    user.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateImageRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateImageRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub prompt: Vec<String>,
            pub model: Vec<models::CreateImageRequestModel>,
            pub n: Vec<u8>,
            pub quality: Vec<String>,
            pub response_format: Vec<String>,
            pub size: Vec<String>,
            pub style: Vec<String>,
            pub user: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateImageRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "prompt" => intermediate_rep.prompt.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "model" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateImageRequest".to_string()),
                    "n" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateImageRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "quality" => intermediate_rep.quality.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "response_format" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateImageRequest".to_string()),
                    "size" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateImageRequest".to_string()),
                    "style" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateImageRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateImageRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateImageRequest {
            prompt: intermediate_rep.prompt.into_iter().next().ok_or_else(|| "prompt missing in CreateImageRequest".to_string())?,
            model: std::result::Result::Err("Nullable types not supported in CreateImageRequest".to_string())?,
            n: std::result::Result::Err("Nullable types not supported in CreateImageRequest".to_string())?,
            quality: intermediate_rep.quality.into_iter().next(),
            response_format: std::result::Result::Err("Nullable types not supported in CreateImageRequest".to_string())?,
            size: std::result::Result::Err("Nullable types not supported in CreateImageRequest".to_string())?,
            style: std::result::Result::Err("Nullable types not supported in CreateImageRequest".to_string())?,
            user: intermediate_rep.user.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateImageRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateImageRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateImageRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateImageRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateImageRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateImageRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateImageRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The model to use for image generation.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateImageRequestModel {
    String(String),
    String1(String),
}

impl validator::Validate for CreateImageRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::String1(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateImageRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateImageRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateMessageRequest {
    /// The role of the entity that is creating the message. Allowed values include: - `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages. - `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    #[serde(rename = "content")]
          #[validate(nested)]
    pub content: models::CreateMessageRequestContent,

    /// A list of files attached to the message, and the tools they should be added to.
    #[serde(rename = "attachments")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attachments: Option<Nullable<Vec<models::CreateMessageRequestAttachmentsInner>>>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}



impl CreateMessageRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(role: String, content: models::CreateMessageRequestContent, ) -> CreateMessageRequest {
        CreateMessageRequest {
 role,
 content,
 attachments: None,
 metadata: None,
        }
    }
}

/// Converts the CreateMessageRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateMessageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("role".to_string()),
            Some(self.role.to_string()),

            // Skipping content in query parameter serialization

            // Skipping attachments in query parameter serialization

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateMessageRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateMessageRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role: Vec<String>,
            pub content: Vec<models::CreateMessageRequestContent>,
            pub attachments: Vec<Vec<models::CreateMessageRequestAttachmentsInner>>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateMessageRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content" => intermediate_rep.content.push(<models::CreateMessageRequestContent as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "attachments" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateMessageRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateMessageRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateMessageRequest {
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in CreateMessageRequest".to_string())?,
            content: intermediate_rep.content.into_iter().next().ok_or_else(|| "content missing in CreateMessageRequest".to_string())?,
            attachments: std::result::Result::Err("Nullable types not supported in CreateMessageRequest".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateMessageRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateMessageRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateMessageRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateMessageRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateMessageRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateMessageRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateMessageRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateMessageRequestAttachmentsInner {
    /// The ID of the file to attach to the message.
    #[serde(rename = "file_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_id: Option<String>,

    /// The tools to add this file to.
    #[serde(rename = "tools")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Vec<models::CreateMessageRequestAttachmentsInnerToolsInner>>,

}



impl CreateMessageRequestAttachmentsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateMessageRequestAttachmentsInner {
        CreateMessageRequestAttachmentsInner {
 file_id: None,
 tools: None,
        }
    }
}

/// Converts the CreateMessageRequestAttachmentsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateMessageRequestAttachmentsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_id.as_ref().map(|file_id| {
                [
                    "file_id".to_string(),
                    file_id.to_string(),
                ].join(",")
            }),

            // Skipping tools in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateMessageRequestAttachmentsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateMessageRequestAttachmentsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
            pub tools: Vec<Vec<models::CreateMessageRequestAttachmentsInnerToolsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateMessageRequestAttachmentsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateMessageRequestAttachmentsInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateMessageRequestAttachmentsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateMessageRequestAttachmentsInner {
            file_id: intermediate_rep.file_id.into_iter().next(),
            tools: intermediate_rep.tools.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateMessageRequestAttachmentsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateMessageRequestAttachmentsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateMessageRequestAttachmentsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateMessageRequestAttachmentsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateMessageRequestAttachmentsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateMessageRequestAttachmentsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateMessageRequestAttachmentsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateMessageRequestAttachmentsInnerToolsInner {
    AssistantToolsCode(models::AssistantToolsCode),
    AssistantToolsFileSearchTypeOnly(models::AssistantToolsFileSearchTypeOnly),
}

impl validator::Validate for CreateMessageRequestAttachmentsInnerToolsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::AssistantToolsCode(v) => v.validate(),
            Self::AssistantToolsFileSearchTypeOnly(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateMessageRequestAttachmentsInnerToolsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateMessageRequestAttachmentsInnerToolsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::AssistantToolsCode> for CreateMessageRequestAttachmentsInnerToolsInner {
    fn from(value: models::AssistantToolsCode) -> Self {
        Self::AssistantToolsCode(value)
    }
}
impl From<models::AssistantToolsFileSearchTypeOnly> for CreateMessageRequestAttachmentsInnerToolsInner {
    fn from(value: models::AssistantToolsFileSearchTypeOnly) -> Self {
        Self::AssistantToolsFileSearchTypeOnly(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateMessageRequestContent {
    String(String),
    VecOfArrayOfContentPartsInner(Vec<models::ArrayOfContentPartsInner>),
}

impl validator::Validate for CreateMessageRequestContent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::VecOfArrayOfContentPartsInner(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateMessageRequestContent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateMessageRequestContent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for CreateMessageRequestContent {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<Vec<models::ArrayOfContentPartsInner>> for CreateMessageRequestContent {
    fn from(value: Vec<models::ArrayOfContentPartsInner>) -> Self {
        Self::VecOfArrayOfContentPartsInner(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateModerationRequest {
    #[serde(rename = "input")]
          #[validate(nested)]
    pub input: models::CreateModerationRequestInput,

    #[serde(rename = "model")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<models::CreateModerationRequestModel>,

}



impl CreateModerationRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(input: models::CreateModerationRequestInput, ) -> CreateModerationRequest {
        CreateModerationRequest {
 input,
 model: None,
        }
    }
}

/// Converts the CreateModerationRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateModerationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping input in query parameter serialization

            // Skipping model in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub input: Vec<models::CreateModerationRequestInput>,
            pub model: Vec<models::CreateModerationRequestModel>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateModerationRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "input" => intermediate_rep.input.push(<models::CreateModerationRequestInput as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<models::CreateModerationRequestModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateModerationRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateModerationRequest {
            input: intermediate_rep.input.into_iter().next().ok_or_else(|| "input missing in CreateModerationRequest".to_string())?,
            model: intermediate_rep.model.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateModerationRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateModerationRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateModerationRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateModerationRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateModerationRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateModerationRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateModerationRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Input (or inputs) to classify. Can be a single string, an array of strings, or an array of multi-modal input objects similar to other models. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateModerationRequestInput {
    String(String),
    VecOfString(Vec<String>),
    VecOfCreateModerationRequestInputOneOfInner(Vec<models::CreateModerationRequestInputOneOfInner>),
}

impl validator::Validate for CreateModerationRequestInput
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::VecOfString(_) => std::result::Result::Ok(()),
            Self::VecOfCreateModerationRequestInputOneOfInner(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationRequestInput value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationRequestInput {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for CreateModerationRequestInput {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<Vec<String>> for CreateModerationRequestInput {
    fn from(value: Vec<String>) -> Self {
        Self::VecOfString(value)
    }
}
impl From<Vec<models::CreateModerationRequestInputOneOfInner>> for CreateModerationRequestInput {
    fn from(value: Vec<models::CreateModerationRequestInputOneOfInner>) -> Self {
        Self::VecOfCreateModerationRequestInputOneOfInner(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateModerationRequestInputOneOfInner {
    CreateModerationRequestInputOneOfInnerOneOf(models::CreateModerationRequestInputOneOfInnerOneOf),
    CreateModerationRequestInputOneOfInnerOneOf1(models::CreateModerationRequestInputOneOfInnerOneOf1),
}

impl validator::Validate for CreateModerationRequestInputOneOfInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::CreateModerationRequestInputOneOfInnerOneOf(v) => v.validate(),
            Self::CreateModerationRequestInputOneOfInnerOneOf1(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationRequestInputOneOfInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationRequestInputOneOfInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::CreateModerationRequestInputOneOfInnerOneOf> for CreateModerationRequestInputOneOfInner {
    fn from(value: models::CreateModerationRequestInputOneOfInnerOneOf) -> Self {
        Self::CreateModerationRequestInputOneOfInnerOneOf(value)
    }
}
impl From<models::CreateModerationRequestInputOneOfInnerOneOf1> for CreateModerationRequestInputOneOfInner {
    fn from(value: models::CreateModerationRequestInputOneOfInnerOneOf1) -> Self {
        Self::CreateModerationRequestInputOneOfInnerOneOf1(value)
    }
}





/// An object describing an image to classify.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateModerationRequestInputOneOfInnerOneOf {
    /// Always `image_url`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "image_url")]
          #[validate(nested)]
    pub image_url: models::CreateModerationRequestInputOneOfInnerOneOfImageUrl,

}



impl CreateModerationRequestInputOneOfInnerOneOf {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, image_url: models::CreateModerationRequestInputOneOfInnerOneOfImageUrl, ) -> CreateModerationRequestInputOneOfInnerOneOf {
        CreateModerationRequestInputOneOfInnerOneOf {
 r_type,
 image_url,
        }
    }
}

/// Converts the CreateModerationRequestInputOneOfInnerOneOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateModerationRequestInputOneOfInnerOneOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping image_url in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationRequestInputOneOfInnerOneOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationRequestInputOneOfInnerOneOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub image_url: Vec<models::CreateModerationRequestInputOneOfInnerOneOfImageUrl>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateModerationRequestInputOneOfInnerOneOf".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_url" => intermediate_rep.image_url.push(<models::CreateModerationRequestInputOneOfInnerOneOfImageUrl as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateModerationRequestInputOneOfInnerOneOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateModerationRequestInputOneOfInnerOneOf {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in CreateModerationRequestInputOneOfInnerOneOf".to_string())?,
            image_url: intermediate_rep.image_url.into_iter().next().ok_or_else(|| "image_url missing in CreateModerationRequestInputOneOfInnerOneOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateModerationRequestInputOneOfInnerOneOf> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateModerationRequestInputOneOfInnerOneOf>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateModerationRequestInputOneOfInnerOneOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateModerationRequestInputOneOfInnerOneOf - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateModerationRequestInputOneOfInnerOneOf> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateModerationRequestInputOneOfInnerOneOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateModerationRequestInputOneOfInnerOneOf - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// An object describing text to classify.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateModerationRequestInputOneOfInnerOneOf1 {
    /// Always `text`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// A string of text to classify.
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    pub text: String,

}



impl CreateModerationRequestInputOneOfInnerOneOf1 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, text: String, ) -> CreateModerationRequestInputOneOfInnerOneOf1 {
        CreateModerationRequestInputOneOfInnerOneOf1 {
 r_type,
 text,
        }
    }
}

/// Converts the CreateModerationRequestInputOneOfInnerOneOf1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateModerationRequestInputOneOfInnerOneOf1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationRequestInputOneOfInnerOneOf1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationRequestInputOneOfInnerOneOf1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub text: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateModerationRequestInputOneOfInnerOneOf1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateModerationRequestInputOneOfInnerOneOf1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateModerationRequestInputOneOfInnerOneOf1 {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in CreateModerationRequestInputOneOfInnerOneOf1".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in CreateModerationRequestInputOneOfInnerOneOf1".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateModerationRequestInputOneOfInnerOneOf1> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateModerationRequestInputOneOfInnerOneOf1>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateModerationRequestInputOneOfInnerOneOf1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateModerationRequestInputOneOfInnerOneOf1 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateModerationRequestInputOneOfInnerOneOf1> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateModerationRequestInputOneOfInnerOneOf1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateModerationRequestInputOneOfInnerOneOf1 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Contains either an image URL or a data URL for a base64 encoded image.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateModerationRequestInputOneOfInnerOneOfImageUrl {
    /// Either a URL of the image or the base64 encoded image data.
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl CreateModerationRequestInputOneOfInnerOneOfImageUrl {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(url: String, ) -> CreateModerationRequestInputOneOfInnerOneOfImageUrl {
        CreateModerationRequestInputOneOfInnerOneOfImageUrl {
 url,
        }
    }
}

/// Converts the CreateModerationRequestInputOneOfInnerOneOfImageUrl value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateModerationRequestInputOneOfInnerOneOfImageUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationRequestInputOneOfInnerOneOfImageUrl value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationRequestInputOneOfInnerOneOfImageUrl {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateModerationRequestInputOneOfInnerOneOfImageUrl".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateModerationRequestInputOneOfInnerOneOfImageUrl".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateModerationRequestInputOneOfInnerOneOfImageUrl {
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in CreateModerationRequestInputOneOfInnerOneOfImageUrl".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateModerationRequestInputOneOfInnerOneOfImageUrl> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateModerationRequestInputOneOfInnerOneOfImageUrl>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateModerationRequestInputOneOfInnerOneOfImageUrl>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateModerationRequestInputOneOfInnerOneOfImageUrl - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateModerationRequestInputOneOfInnerOneOfImageUrl> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateModerationRequestInputOneOfInnerOneOfImageUrl as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateModerationRequestInputOneOfInnerOneOfImageUrl - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The content moderation model you would like to use. Learn more in [the moderation guide](/docs/guides/moderation), and learn about available models [here](/docs/models#moderation). 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateModerationRequestModel {
    String(String),
    String1(String),
}

impl validator::Validate for CreateModerationRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::String1(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}







/// Represents if a given text input is potentially harmful.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateModerationResponse {
    /// The unique identifier for the moderation request.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The model used to generate the moderation results.
    #[serde(rename = "model")]
          #[validate(custom(function = "check_xss_string"))]
    pub model: String,

    /// A list of moderation objects.
    #[serde(rename = "results")]
          #[validate(nested)]
    pub results: Vec<models::CreateModerationResponseResultsInner>,

}



impl CreateModerationResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, model: String, results: Vec<models::CreateModerationResponseResultsInner>, ) -> CreateModerationResponse {
        CreateModerationResponse {
 id,
 model,
 results,
        }
    }
}

/// Converts the CreateModerationResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateModerationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("model".to_string()),
            Some(self.model.to_string()),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub model: Vec<String>,
            pub results: Vec<Vec<models::CreateModerationResponseResultsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateModerationResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateModerationResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateModerationResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateModerationResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CreateModerationResponse".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateModerationResponse".to_string())?,
            results: intermediate_rep.results.into_iter().next().ok_or_else(|| "results missing in CreateModerationResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateModerationResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateModerationResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateModerationResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateModerationResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateModerationResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateModerationResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateModerationResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateModerationResponseResultsInner {
    /// Whether any of the below categories are flagged.
    #[serde(rename = "flagged")]
    pub flagged: bool,

    #[serde(rename = "categories")]
          #[validate(nested)]
    pub categories: models::CreateModerationResponseResultsInnerCategories,

    #[serde(rename = "category_scores")]
          #[validate(nested)]
    pub category_scores: models::CreateModerationResponseResultsInnerCategoryScores,

    #[serde(rename = "category_applied_input_types")]
          #[validate(nested)]
    pub category_applied_input_types: models::CreateModerationResponseResultsInnerCategoryAppliedInputTypes,

}



impl CreateModerationResponseResultsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(flagged: bool, categories: models::CreateModerationResponseResultsInnerCategories, category_scores: models::CreateModerationResponseResultsInnerCategoryScores, category_applied_input_types: models::CreateModerationResponseResultsInnerCategoryAppliedInputTypes, ) -> CreateModerationResponseResultsInner {
        CreateModerationResponseResultsInner {
 flagged,
 categories,
 category_scores,
 category_applied_input_types,
        }
    }
}

/// Converts the CreateModerationResponseResultsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateModerationResponseResultsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("flagged".to_string()),
            Some(self.flagged.to_string()),

            // Skipping categories in query parameter serialization

            // Skipping category_scores in query parameter serialization

            // Skipping category_applied_input_types in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationResponseResultsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationResponseResultsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub flagged: Vec<bool>,
            pub categories: Vec<models::CreateModerationResponseResultsInnerCategories>,
            pub category_scores: Vec<models::CreateModerationResponseResultsInnerCategoryScores>,
            pub category_applied_input_types: Vec<models::CreateModerationResponseResultsInnerCategoryAppliedInputTypes>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateModerationResponseResultsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "flagged" => intermediate_rep.flagged.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "categories" => intermediate_rep.categories.push(<models::CreateModerationResponseResultsInnerCategories as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "category_scores" => intermediate_rep.category_scores.push(<models::CreateModerationResponseResultsInnerCategoryScores as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "category_applied_input_types" => intermediate_rep.category_applied_input_types.push(<models::CreateModerationResponseResultsInnerCategoryAppliedInputTypes as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateModerationResponseResultsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateModerationResponseResultsInner {
            flagged: intermediate_rep.flagged.into_iter().next().ok_or_else(|| "flagged missing in CreateModerationResponseResultsInner".to_string())?,
            categories: intermediate_rep.categories.into_iter().next().ok_or_else(|| "categories missing in CreateModerationResponseResultsInner".to_string())?,
            category_scores: intermediate_rep.category_scores.into_iter().next().ok_or_else(|| "category_scores missing in CreateModerationResponseResultsInner".to_string())?,
            category_applied_input_types: intermediate_rep.category_applied_input_types.into_iter().next().ok_or_else(|| "category_applied_input_types missing in CreateModerationResponseResultsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateModerationResponseResultsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateModerationResponseResultsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateModerationResponseResultsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateModerationResponseResultsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateModerationResponseResultsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateModerationResponseResultsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateModerationResponseResultsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A list of the categories, and whether they are flagged or not.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateModerationResponseResultsInnerCategories {
    /// Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
    #[serde(rename = "hate")]
    pub hate: bool,

    /// Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
    #[serde(rename = "hate/threatening")]
    pub hate_slash_threatening: bool,

    /// Content that expresses, incites, or promotes harassing language towards any target.
    #[serde(rename = "harassment")]
    pub harassment: bool,

    /// Harassment content that also includes violence or serious harm towards any target.
    #[serde(rename = "harassment/threatening")]
    pub harassment_slash_threatening: bool,

    /// Content that includes instructions or advice that facilitate the planning or execution of wrongdoing, or that gives advice or instruction on how to commit illicit acts. For example, \"how to shoplift\" would fit this category.
    #[serde(rename = "illicit")]
    pub illicit: bool,

    /// Content that includes instructions or advice that facilitate the planning or execution of wrongdoing that also includes violence, or that gives advice or instruction on the procurement of any weapon.
    #[serde(rename = "illicit/violent")]
    pub illicit_slash_violent: bool,

    /// Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
    #[serde(rename = "self-harm")]
    pub self_harm: bool,

    /// Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
    #[serde(rename = "self-harm/intent")]
    pub self_harm_slash_intent: bool,

    /// Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
    #[serde(rename = "self-harm/instructions")]
    pub self_harm_slash_instructions: bool,

    /// Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
    #[serde(rename = "sexual")]
    pub sexual: bool,

    /// Sexual content that includes an individual who is under 18 years old.
    #[serde(rename = "sexual/minors")]
    pub sexual_slash_minors: bool,

    /// Content that depicts death, violence, or physical injury.
    #[serde(rename = "violence")]
    pub violence: bool,

    /// Content that depicts death, violence, or physical injury in graphic detail.
    #[serde(rename = "violence/graphic")]
    pub violence_slash_graphic: bool,

}



impl CreateModerationResponseResultsInnerCategories {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(hate: bool, hate_slash_threatening: bool, harassment: bool, harassment_slash_threatening: bool, illicit: bool, illicit_slash_violent: bool, self_harm: bool, self_harm_slash_intent: bool, self_harm_slash_instructions: bool, sexual: bool, sexual_slash_minors: bool, violence: bool, violence_slash_graphic: bool, ) -> CreateModerationResponseResultsInnerCategories {
        CreateModerationResponseResultsInnerCategories {
 hate,
 hate_slash_threatening,
 harassment,
 harassment_slash_threatening,
 illicit,
 illicit_slash_violent,
 self_harm,
 self_harm_slash_intent,
 self_harm_slash_instructions,
 sexual,
 sexual_slash_minors,
 violence,
 violence_slash_graphic,
        }
    }
}

/// Converts the CreateModerationResponseResultsInnerCategories value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateModerationResponseResultsInnerCategories {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("hate".to_string()),
            Some(self.hate.to_string()),


            Some("hate/threatening".to_string()),
            Some(self.hate_slash_threatening.to_string()),


            Some("harassment".to_string()),
            Some(self.harassment.to_string()),


            Some("harassment/threatening".to_string()),
            Some(self.harassment_slash_threatening.to_string()),


            Some("illicit".to_string()),
            Some(self.illicit.to_string()),


            Some("illicit/violent".to_string()),
            Some(self.illicit_slash_violent.to_string()),


            Some("self-harm".to_string()),
            Some(self.self_harm.to_string()),


            Some("self-harm/intent".to_string()),
            Some(self.self_harm_slash_intent.to_string()),


            Some("self-harm/instructions".to_string()),
            Some(self.self_harm_slash_instructions.to_string()),


            Some("sexual".to_string()),
            Some(self.sexual.to_string()),


            Some("sexual/minors".to_string()),
            Some(self.sexual_slash_minors.to_string()),


            Some("violence".to_string()),
            Some(self.violence.to_string()),


            Some("violence/graphic".to_string()),
            Some(self.violence_slash_graphic.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationResponseResultsInnerCategories value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationResponseResultsInnerCategories {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hate: Vec<bool>,
            pub hate_slash_threatening: Vec<bool>,
            pub harassment: Vec<bool>,
            pub harassment_slash_threatening: Vec<bool>,
            pub illicit: Vec<bool>,
            pub illicit_slash_violent: Vec<bool>,
            pub self_harm: Vec<bool>,
            pub self_harm_slash_intent: Vec<bool>,
            pub self_harm_slash_instructions: Vec<bool>,
            pub sexual: Vec<bool>,
            pub sexual_slash_minors: Vec<bool>,
            pub violence: Vec<bool>,
            pub violence_slash_graphic: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateModerationResponseResultsInnerCategories".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "hate" => intermediate_rep.hate.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hate/threatening" => intermediate_rep.hate_slash_threatening.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "harassment" => intermediate_rep.harassment.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "harassment/threatening" => intermediate_rep.harassment_slash_threatening.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "illicit" => intermediate_rep.illicit.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "illicit/violent" => intermediate_rep.illicit_slash_violent.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "self-harm" => intermediate_rep.self_harm.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "self-harm/intent" => intermediate_rep.self_harm_slash_intent.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "self-harm/instructions" => intermediate_rep.self_harm_slash_instructions.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sexual" => intermediate_rep.sexual.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sexual/minors" => intermediate_rep.sexual_slash_minors.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "violence" => intermediate_rep.violence.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "violence/graphic" => intermediate_rep.violence_slash_graphic.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateModerationResponseResultsInnerCategories".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateModerationResponseResultsInnerCategories {
            hate: intermediate_rep.hate.into_iter().next().ok_or_else(|| "hate missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            hate_slash_threatening: intermediate_rep.hate_slash_threatening.into_iter().next().ok_or_else(|| "hate/threatening missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            harassment: intermediate_rep.harassment.into_iter().next().ok_or_else(|| "harassment missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            harassment_slash_threatening: intermediate_rep.harassment_slash_threatening.into_iter().next().ok_or_else(|| "harassment/threatening missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            illicit: intermediate_rep.illicit.into_iter().next().ok_or_else(|| "illicit missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            illicit_slash_violent: intermediate_rep.illicit_slash_violent.into_iter().next().ok_or_else(|| "illicit/violent missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            self_harm: intermediate_rep.self_harm.into_iter().next().ok_or_else(|| "self-harm missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            self_harm_slash_intent: intermediate_rep.self_harm_slash_intent.into_iter().next().ok_or_else(|| "self-harm/intent missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            self_harm_slash_instructions: intermediate_rep.self_harm_slash_instructions.into_iter().next().ok_or_else(|| "self-harm/instructions missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            sexual: intermediate_rep.sexual.into_iter().next().ok_or_else(|| "sexual missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            sexual_slash_minors: intermediate_rep.sexual_slash_minors.into_iter().next().ok_or_else(|| "sexual/minors missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            violence: intermediate_rep.violence.into_iter().next().ok_or_else(|| "violence missing in CreateModerationResponseResultsInnerCategories".to_string())?,
            violence_slash_graphic: intermediate_rep.violence_slash_graphic.into_iter().next().ok_or_else(|| "violence/graphic missing in CreateModerationResponseResultsInnerCategories".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateModerationResponseResultsInnerCategories> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateModerationResponseResultsInnerCategories>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateModerationResponseResultsInnerCategories>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateModerationResponseResultsInnerCategories - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateModerationResponseResultsInnerCategories> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateModerationResponseResultsInnerCategories as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateModerationResponseResultsInnerCategories - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A list of the categories along with the input type(s) that the score applies to.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateModerationResponseResultsInnerCategoryAppliedInputTypes {
    /// The applied input type(s) for the category 'hate'.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "hate")]
          #[validate(custom(function = "check_xss_vec_string"))]
    pub hate: Vec<String>,

    /// The applied input type(s) for the category 'hate/threatening'.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "hate/threatening")]
          #[validate(custom(function = "check_xss_vec_string"))]
    pub hate_slash_threatening: Vec<String>,

    /// The applied input type(s) for the category 'harassment'.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "harassment")]
          #[validate(custom(function = "check_xss_vec_string"))]
    pub harassment: Vec<String>,

    /// The applied input type(s) for the category 'harassment/threatening'.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "harassment/threatening")]
          #[validate(custom(function = "check_xss_vec_string"))]
    pub harassment_slash_threatening: Vec<String>,

    /// The applied input type(s) for the category 'illicit'.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "illicit")]
          #[validate(custom(function = "check_xss_vec_string"))]
    pub illicit: Vec<String>,

    /// The applied input type(s) for the category 'illicit/violent'.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "illicit/violent")]
          #[validate(custom(function = "check_xss_vec_string"))]
    pub illicit_slash_violent: Vec<String>,

    /// The applied input type(s) for the category 'self-harm'.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "self-harm")]
          #[validate(custom(function = "check_xss_vec_string"))]
    pub self_harm: Vec<String>,

    /// The applied input type(s) for the category 'self-harm/intent'.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "self-harm/intent")]
          #[validate(custom(function = "check_xss_vec_string"))]
    pub self_harm_slash_intent: Vec<String>,

    /// The applied input type(s) for the category 'self-harm/instructions'.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "self-harm/instructions")]
          #[validate(custom(function = "check_xss_vec_string"))]
    pub self_harm_slash_instructions: Vec<String>,

    /// The applied input type(s) for the category 'sexual'.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "sexual")]
          #[validate(custom(function = "check_xss_vec_string"))]
    pub sexual: Vec<String>,

    /// The applied input type(s) for the category 'sexual/minors'.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "sexual/minors")]
          #[validate(custom(function = "check_xss_vec_string"))]
    pub sexual_slash_minors: Vec<String>,

    /// The applied input type(s) for the category 'violence'.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "violence")]
          #[validate(custom(function = "check_xss_vec_string"))]
    pub violence: Vec<String>,

    /// The applied input type(s) for the category 'violence/graphic'.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "violence/graphic")]
          #[validate(custom(function = "check_xss_vec_string"))]
    pub violence_slash_graphic: Vec<String>,

}



impl CreateModerationResponseResultsInnerCategoryAppliedInputTypes {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(hate: Vec<String>, hate_slash_threatening: Vec<String>, harassment: Vec<String>, harassment_slash_threatening: Vec<String>, illicit: Vec<String>, illicit_slash_violent: Vec<String>, self_harm: Vec<String>, self_harm_slash_intent: Vec<String>, self_harm_slash_instructions: Vec<String>, sexual: Vec<String>, sexual_slash_minors: Vec<String>, violence: Vec<String>, violence_slash_graphic: Vec<String>, ) -> CreateModerationResponseResultsInnerCategoryAppliedInputTypes {
        CreateModerationResponseResultsInnerCategoryAppliedInputTypes {
 hate,
 hate_slash_threatening,
 harassment,
 harassment_slash_threatening,
 illicit,
 illicit_slash_violent,
 self_harm,
 self_harm_slash_intent,
 self_harm_slash_instructions,
 sexual,
 sexual_slash_minors,
 violence,
 violence_slash_graphic,
        }
    }
}

/// Converts the CreateModerationResponseResultsInnerCategoryAppliedInputTypes value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateModerationResponseResultsInnerCategoryAppliedInputTypes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("hate".to_string()),
            Some(self.hate.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("hate/threatening".to_string()),
            Some(self.hate_slash_threatening.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("harassment".to_string()),
            Some(self.harassment.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("harassment/threatening".to_string()),
            Some(self.harassment_slash_threatening.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("illicit".to_string()),
            Some(self.illicit.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("illicit/violent".to_string()),
            Some(self.illicit_slash_violent.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("self-harm".to_string()),
            Some(self.self_harm.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("self-harm/intent".to_string()),
            Some(self.self_harm_slash_intent.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("self-harm/instructions".to_string()),
            Some(self.self_harm_slash_instructions.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("sexual".to_string()),
            Some(self.sexual.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("sexual/minors".to_string()),
            Some(self.sexual_slash_minors.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("violence".to_string()),
            Some(self.violence.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("violence/graphic".to_string()),
            Some(self.violence_slash_graphic.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationResponseResultsInnerCategoryAppliedInputTypes value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationResponseResultsInnerCategoryAppliedInputTypes {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hate: Vec<Vec<String>>,
            pub hate_slash_threatening: Vec<Vec<String>>,
            pub harassment: Vec<Vec<String>>,
            pub harassment_slash_threatening: Vec<Vec<String>>,
            pub illicit: Vec<Vec<String>>,
            pub illicit_slash_violent: Vec<Vec<String>>,
            pub self_harm: Vec<Vec<String>>,
            pub self_harm_slash_intent: Vec<Vec<String>>,
            pub self_harm_slash_instructions: Vec<Vec<String>>,
            pub sexual: Vec<Vec<String>>,
            pub sexual_slash_minors: Vec<Vec<String>>,
            pub violence: Vec<Vec<String>>,
            pub violence_slash_graphic: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "hate" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string()),
                    "hate/threatening" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string()),
                    "harassment" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string()),
                    "harassment/threatening" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string()),
                    "illicit" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string()),
                    "illicit/violent" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string()),
                    "self-harm" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string()),
                    "self-harm/intent" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string()),
                    "self-harm/instructions" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string()),
                    "sexual" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string()),
                    "sexual/minors" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string()),
                    "violence" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string()),
                    "violence/graphic" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateModerationResponseResultsInnerCategoryAppliedInputTypes {
            hate: intermediate_rep.hate.into_iter().next().ok_or_else(|| "hate missing in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string())?,
            hate_slash_threatening: intermediate_rep.hate_slash_threatening.into_iter().next().ok_or_else(|| "hate/threatening missing in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string())?,
            harassment: intermediate_rep.harassment.into_iter().next().ok_or_else(|| "harassment missing in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string())?,
            harassment_slash_threatening: intermediate_rep.harassment_slash_threatening.into_iter().next().ok_or_else(|| "harassment/threatening missing in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string())?,
            illicit: intermediate_rep.illicit.into_iter().next().ok_or_else(|| "illicit missing in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string())?,
            illicit_slash_violent: intermediate_rep.illicit_slash_violent.into_iter().next().ok_or_else(|| "illicit/violent missing in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string())?,
            self_harm: intermediate_rep.self_harm.into_iter().next().ok_or_else(|| "self-harm missing in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string())?,
            self_harm_slash_intent: intermediate_rep.self_harm_slash_intent.into_iter().next().ok_or_else(|| "self-harm/intent missing in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string())?,
            self_harm_slash_instructions: intermediate_rep.self_harm_slash_instructions.into_iter().next().ok_or_else(|| "self-harm/instructions missing in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string())?,
            sexual: intermediate_rep.sexual.into_iter().next().ok_or_else(|| "sexual missing in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string())?,
            sexual_slash_minors: intermediate_rep.sexual_slash_minors.into_iter().next().ok_or_else(|| "sexual/minors missing in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string())?,
            violence: intermediate_rep.violence.into_iter().next().ok_or_else(|| "violence missing in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string())?,
            violence_slash_graphic: intermediate_rep.violence_slash_graphic.into_iter().next().ok_or_else(|| "violence/graphic missing in CreateModerationResponseResultsInnerCategoryAppliedInputTypes".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateModerationResponseResultsInnerCategoryAppliedInputTypes> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateModerationResponseResultsInnerCategoryAppliedInputTypes>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateModerationResponseResultsInnerCategoryAppliedInputTypes>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateModerationResponseResultsInnerCategoryAppliedInputTypes - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateModerationResponseResultsInnerCategoryAppliedInputTypes> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateModerationResponseResultsInnerCategoryAppliedInputTypes as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateModerationResponseResultsInnerCategoryAppliedInputTypes - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A list of the categories along with their scores as predicted by model.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateModerationResponseResultsInnerCategoryScores {
    /// The score for the category 'hate'.
    #[serde(rename = "hate")]
    pub hate: f64,

    /// The score for the category 'hate/threatening'.
    #[serde(rename = "hate/threatening")]
    pub hate_slash_threatening: f64,

    /// The score for the category 'harassment'.
    #[serde(rename = "harassment")]
    pub harassment: f64,

    /// The score for the category 'harassment/threatening'.
    #[serde(rename = "harassment/threatening")]
    pub harassment_slash_threatening: f64,

    /// The score for the category 'illicit'.
    #[serde(rename = "illicit")]
    pub illicit: f64,

    /// The score for the category 'illicit/violent'.
    #[serde(rename = "illicit/violent")]
    pub illicit_slash_violent: f64,

    /// The score for the category 'self-harm'.
    #[serde(rename = "self-harm")]
    pub self_harm: f64,

    /// The score for the category 'self-harm/intent'.
    #[serde(rename = "self-harm/intent")]
    pub self_harm_slash_intent: f64,

    /// The score for the category 'self-harm/instructions'.
    #[serde(rename = "self-harm/instructions")]
    pub self_harm_slash_instructions: f64,

    /// The score for the category 'sexual'.
    #[serde(rename = "sexual")]
    pub sexual: f64,

    /// The score for the category 'sexual/minors'.
    #[serde(rename = "sexual/minors")]
    pub sexual_slash_minors: f64,

    /// The score for the category 'violence'.
    #[serde(rename = "violence")]
    pub violence: f64,

    /// The score for the category 'violence/graphic'.
    #[serde(rename = "violence/graphic")]
    pub violence_slash_graphic: f64,

}



impl CreateModerationResponseResultsInnerCategoryScores {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(hate: f64, hate_slash_threatening: f64, harassment: f64, harassment_slash_threatening: f64, illicit: f64, illicit_slash_violent: f64, self_harm: f64, self_harm_slash_intent: f64, self_harm_slash_instructions: f64, sexual: f64, sexual_slash_minors: f64, violence: f64, violence_slash_graphic: f64, ) -> CreateModerationResponseResultsInnerCategoryScores {
        CreateModerationResponseResultsInnerCategoryScores {
 hate,
 hate_slash_threatening,
 harassment,
 harassment_slash_threatening,
 illicit,
 illicit_slash_violent,
 self_harm,
 self_harm_slash_intent,
 self_harm_slash_instructions,
 sexual,
 sexual_slash_minors,
 violence,
 violence_slash_graphic,
        }
    }
}

/// Converts the CreateModerationResponseResultsInnerCategoryScores value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateModerationResponseResultsInnerCategoryScores {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("hate".to_string()),
            Some(self.hate.to_string()),


            Some("hate/threatening".to_string()),
            Some(self.hate_slash_threatening.to_string()),


            Some("harassment".to_string()),
            Some(self.harassment.to_string()),


            Some("harassment/threatening".to_string()),
            Some(self.harassment_slash_threatening.to_string()),


            Some("illicit".to_string()),
            Some(self.illicit.to_string()),


            Some("illicit/violent".to_string()),
            Some(self.illicit_slash_violent.to_string()),


            Some("self-harm".to_string()),
            Some(self.self_harm.to_string()),


            Some("self-harm/intent".to_string()),
            Some(self.self_harm_slash_intent.to_string()),


            Some("self-harm/instructions".to_string()),
            Some(self.self_harm_slash_instructions.to_string()),


            Some("sexual".to_string()),
            Some(self.sexual.to_string()),


            Some("sexual/minors".to_string()),
            Some(self.sexual_slash_minors.to_string()),


            Some("violence".to_string()),
            Some(self.violence.to_string()),


            Some("violence/graphic".to_string()),
            Some(self.violence_slash_graphic.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateModerationResponseResultsInnerCategoryScores value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateModerationResponseResultsInnerCategoryScores {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hate: Vec<f64>,
            pub hate_slash_threatening: Vec<f64>,
            pub harassment: Vec<f64>,
            pub harassment_slash_threatening: Vec<f64>,
            pub illicit: Vec<f64>,
            pub illicit_slash_violent: Vec<f64>,
            pub self_harm: Vec<f64>,
            pub self_harm_slash_intent: Vec<f64>,
            pub self_harm_slash_instructions: Vec<f64>,
            pub sexual: Vec<f64>,
            pub sexual_slash_minors: Vec<f64>,
            pub violence: Vec<f64>,
            pub violence_slash_graphic: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateModerationResponseResultsInnerCategoryScores".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "hate" => intermediate_rep.hate.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hate/threatening" => intermediate_rep.hate_slash_threatening.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "harassment" => intermediate_rep.harassment.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "harassment/threatening" => intermediate_rep.harassment_slash_threatening.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "illicit" => intermediate_rep.illicit.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "illicit/violent" => intermediate_rep.illicit_slash_violent.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "self-harm" => intermediate_rep.self_harm.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "self-harm/intent" => intermediate_rep.self_harm_slash_intent.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "self-harm/instructions" => intermediate_rep.self_harm_slash_instructions.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sexual" => intermediate_rep.sexual.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sexual/minors" => intermediate_rep.sexual_slash_minors.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "violence" => intermediate_rep.violence.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "violence/graphic" => intermediate_rep.violence_slash_graphic.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateModerationResponseResultsInnerCategoryScores".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateModerationResponseResultsInnerCategoryScores {
            hate: intermediate_rep.hate.into_iter().next().ok_or_else(|| "hate missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            hate_slash_threatening: intermediate_rep.hate_slash_threatening.into_iter().next().ok_or_else(|| "hate/threatening missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            harassment: intermediate_rep.harassment.into_iter().next().ok_or_else(|| "harassment missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            harassment_slash_threatening: intermediate_rep.harassment_slash_threatening.into_iter().next().ok_or_else(|| "harassment/threatening missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            illicit: intermediate_rep.illicit.into_iter().next().ok_or_else(|| "illicit missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            illicit_slash_violent: intermediate_rep.illicit_slash_violent.into_iter().next().ok_or_else(|| "illicit/violent missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            self_harm: intermediate_rep.self_harm.into_iter().next().ok_or_else(|| "self-harm missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            self_harm_slash_intent: intermediate_rep.self_harm_slash_intent.into_iter().next().ok_or_else(|| "self-harm/intent missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            self_harm_slash_instructions: intermediate_rep.self_harm_slash_instructions.into_iter().next().ok_or_else(|| "self-harm/instructions missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            sexual: intermediate_rep.sexual.into_iter().next().ok_or_else(|| "sexual missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            sexual_slash_minors: intermediate_rep.sexual_slash_minors.into_iter().next().ok_or_else(|| "sexual/minors missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            violence: intermediate_rep.violence.into_iter().next().ok_or_else(|| "violence missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
            violence_slash_graphic: intermediate_rep.violence_slash_graphic.into_iter().next().ok_or_else(|| "violence/graphic missing in CreateModerationResponseResultsInnerCategoryScores".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateModerationResponseResultsInnerCategoryScores> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateModerationResponseResultsInnerCategoryScores>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateModerationResponseResultsInnerCategoryScores>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateModerationResponseResultsInnerCategoryScores - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateModerationResponseResultsInnerCategoryScores> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateModerationResponseResultsInnerCategoryScores as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateModerationResponseResultsInnerCategoryScores - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateRunRequest {
    /// The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
    #[serde(rename = "assistant_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub assistant_id: String,

    #[serde(rename = "model")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<Nullable<models::CreateRunRequestModel>>,

    /// Overrides the [instructions](/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis.
    #[serde(rename = "instructions")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instructions: Option<Nullable<String>>,

    /// Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.
    #[serde(rename = "additional_instructions")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_instructions: Option<Nullable<String>>,

    /// Adds additional messages to the thread before creating the run.
    #[serde(rename = "additional_messages")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_messages: Option<Nullable<Vec<models::CreateMessageRequest>>>,

    /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
    #[serde(rename = "tools")]
    #[validate(
            length(max = 20),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Nullable<Vec<models::AssistantObjectToolsInner>>>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

    /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
    #[serde(rename = "temperature")]
    #[validate(
            range(min = 0f64, max = 2f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<Nullable<f64>>,

    /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
    #[serde(rename = "top_p")]
    #[validate(
            range(min = 0f64, max = 1f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub top_p: Option<Nullable<f64>>,

    /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message. 
    #[serde(rename = "stream")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stream: Option<Nullable<bool>>,

    /// The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info. 
    #[serde(rename = "max_prompt_tokens")]
    #[validate(
            range(min = 256u32),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_prompt_tokens: Option<Nullable<u32>>,

    /// The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info. 
    #[serde(rename = "max_completion_tokens")]
    #[validate(
            range(min = 256u32),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_completion_tokens: Option<Nullable<u32>>,

    #[serde(rename = "truncation_strategy")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub truncation_strategy: Option<models::TruncationObject>,

    #[serde(rename = "tool_choice")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_choice: Option<models::AssistantsApiToolChoiceOption>,

    /// Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
    #[serde(rename = "parallel_tool_calls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parallel_tool_calls: Option<bool>,

    #[serde(rename = "response_format")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_format: Option<models::AssistantsApiResponseFormatOption>,

}



impl CreateRunRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(assistant_id: String, ) -> CreateRunRequest {
        CreateRunRequest {
 assistant_id,
 model: None,
 instructions: None,
 additional_instructions: None,
 additional_messages: None,
 tools: None,
 metadata: None,
 temperature: Some(Nullable::Present(1.0)),
 top_p: Some(Nullable::Present(1.0)),
 stream: None,
 max_prompt_tokens: None,
 max_completion_tokens: None,
 truncation_strategy: None,
 tool_choice: None,
 parallel_tool_calls: Some(true),
 response_format: None,
        }
    }
}

/// Converts the CreateRunRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateRunRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("assistant_id".to_string()),
            Some(self.assistant_id.to_string()),

            // Skipping model in query parameter serialization


            self.instructions.as_ref().map(|instructions| {
                [
                    "instructions".to_string(),
                    instructions.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.additional_instructions.as_ref().map(|additional_instructions| {
                [
                    "additional_instructions".to_string(),
                    additional_instructions.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping additional_messages in query parameter serialization

            // Skipping tools in query parameter serialization

            // Skipping metadata in query parameter serialization


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.top_p.as_ref().map(|top_p| {
                [
                    "top_p".to_string(),
                    top_p.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.stream.as_ref().map(|stream| {
                [
                    "stream".to_string(),
                    stream.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.max_prompt_tokens.as_ref().map(|max_prompt_tokens| {
                [
                    "max_prompt_tokens".to_string(),
                    max_prompt_tokens.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.max_completion_tokens.as_ref().map(|max_completion_tokens| {
                [
                    "max_completion_tokens".to_string(),
                    max_completion_tokens.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping truncation_strategy in query parameter serialization

            // Skipping tool_choice in query parameter serialization


            self.parallel_tool_calls.as_ref().map(|parallel_tool_calls| {
                [
                    "parallel_tool_calls".to_string(),
                    parallel_tool_calls.to_string(),
                ].join(",")
            }),

            // Skipping response_format in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateRunRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateRunRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub assistant_id: Vec<String>,
            pub model: Vec<models::CreateRunRequestModel>,
            pub instructions: Vec<String>,
            pub additional_instructions: Vec<String>,
            pub additional_messages: Vec<Vec<models::CreateMessageRequest>>,
            pub tools: Vec<Vec<models::AssistantObjectToolsInner>>,
            pub metadata: Vec<crate::types::Object>,
            pub temperature: Vec<f64>,
            pub top_p: Vec<f64>,
            pub stream: Vec<bool>,
            pub max_prompt_tokens: Vec<u32>,
            pub max_completion_tokens: Vec<u32>,
            pub truncation_strategy: Vec<models::TruncationObject>,
            pub tool_choice: Vec<models::AssistantsApiToolChoiceOption>,
            pub parallel_tool_calls: Vec<bool>,
            pub response_format: Vec<models::AssistantsApiResponseFormatOption>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateRunRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "assistant_id" => intermediate_rep.assistant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "model" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateRunRequest".to_string()),
                    "instructions" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateRunRequest".to_string()),
                    "additional_instructions" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateRunRequest".to_string()),
                    "additional_messages" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateRunRequest".to_string()),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateRunRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "temperature" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateRunRequest".to_string()),
                    "top_p" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateRunRequest".to_string()),
                    "stream" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateRunRequest".to_string()),
                    "max_prompt_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateRunRequest".to_string()),
                    "max_completion_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateRunRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "truncation_strategy" => intermediate_rep.truncation_strategy.push(<models::TruncationObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tool_choice" => intermediate_rep.tool_choice.push(<models::AssistantsApiToolChoiceOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parallel_tool_calls" => intermediate_rep.parallel_tool_calls.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_format" => intermediate_rep.response_format.push(<models::AssistantsApiResponseFormatOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateRunRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateRunRequest {
            assistant_id: intermediate_rep.assistant_id.into_iter().next().ok_or_else(|| "assistant_id missing in CreateRunRequest".to_string())?,
            model: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            instructions: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            additional_instructions: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            additional_messages: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            tools: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next(),
            temperature: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            top_p: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            stream: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            max_prompt_tokens: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            max_completion_tokens: std::result::Result::Err("Nullable types not supported in CreateRunRequest".to_string())?,
            truncation_strategy: intermediate_rep.truncation_strategy.into_iter().next(),
            tool_choice: intermediate_rep.tool_choice.into_iter().next(),
            parallel_tool_calls: intermediate_rep.parallel_tool_calls.into_iter().next(),
            response_format: intermediate_rep.response_format.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateRunRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateRunRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateRunRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateRunRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateRunRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateRunRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateRunRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The ID of the [Model](/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateRunRequestModel {
    String(String),
    String1(String),
}

impl validator::Validate for CreateRunRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::String1(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateRunRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateRunRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateSpeechRequest {
    #[serde(rename = "model")]
          #[validate(nested)]
    pub model: models::CreateSpeechRequestModel,

    /// The text to generate audio for. The maximum length is 4096 characters.
    #[serde(rename = "input")]
    #[validate(
            length(max = 4096),
          custom(function = "check_xss_string"),
    )]
    pub input: String,

    /// The voice to use when generating the audio. Supported voices are `alloy`, `echo`, `fable`, `onyx`, `nova`, and `shimmer`. Previews of the voices are available in the [Text to speech guide](/docs/guides/text-to-speech#voice-options).
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "voice")]
          #[validate(custom(function = "check_xss_string"))]
    pub voice: String,

    /// The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "response_format")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_format: Option<String>,

    /// The speed of the generated audio. Select a value from `0.25` to `4.0`. `1.0` is the default.
    #[serde(rename = "speed")]
    #[validate(
            range(min = 0.25f64, max = 4f64),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub speed: Option<f64>,

}



impl CreateSpeechRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(model: models::CreateSpeechRequestModel, input: String, voice: String, ) -> CreateSpeechRequest {
        CreateSpeechRequest {
 model,
 input,
 voice,
 response_format: None,
 speed: Some(1.0),
        }
    }
}

/// Converts the CreateSpeechRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateSpeechRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping model in query parameter serialization


            Some("input".to_string()),
            Some(self.input.to_string()),


            Some("voice".to_string()),
            Some(self.voice.to_string()),


            self.response_format.as_ref().map(|response_format| {
                [
                    "response_format".to_string(),
                    response_format.to_string(),
                ].join(",")
            }),


            self.speed.as_ref().map(|speed| {
                [
                    "speed".to_string(),
                    speed.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateSpeechRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateSpeechRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub model: Vec<models::CreateSpeechRequestModel>,
            pub input: Vec<String>,
            pub voice: Vec<String>,
            pub response_format: Vec<String>,
            pub speed: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateSpeechRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<models::CreateSpeechRequestModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input" => intermediate_rep.input.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "voice" => intermediate_rep.voice.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_format" => intermediate_rep.response_format.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "speed" => intermediate_rep.speed.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateSpeechRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateSpeechRequest {
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in CreateSpeechRequest".to_string())?,
            input: intermediate_rep.input.into_iter().next().ok_or_else(|| "input missing in CreateSpeechRequest".to_string())?,
            voice: intermediate_rep.voice.into_iter().next().ok_or_else(|| "voice missing in CreateSpeechRequest".to_string())?,
            response_format: intermediate_rep.response_format.into_iter().next(),
            speed: intermediate_rep.speed.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateSpeechRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateSpeechRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateSpeechRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateSpeechRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateSpeechRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateSpeechRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateSpeechRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// One of the available [TTS models](/docs/models#tts): `tts-1` or `tts-1-hd` 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateSpeechRequestModel {
    String(String),
    String1(String),
}

impl validator::Validate for CreateSpeechRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::String1(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateSpeechRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateSpeechRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateThreadAndRunRequest {
    /// The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
    #[serde(rename = "assistant_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub assistant_id: String,

    #[serde(rename = "thread")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub thread: Option<models::CreateThreadRequest>,

    #[serde(rename = "model")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<Nullable<models::CreateRunRequestModel>>,

    /// Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.
    #[serde(rename = "instructions")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instructions: Option<Nullable<String>>,

    /// Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
    #[serde(rename = "tools")]
    #[validate(
            length(max = 20),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Nullable<Vec<models::CreateThreadAndRunRequestToolsInner>>>,

    #[serde(rename = "tool_resources")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_resources: Option<Nullable<models::CreateThreadAndRunRequestToolResources>>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

    /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
    #[serde(rename = "temperature")]
    #[validate(
            range(min = 0f64, max = 2f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<Nullable<f64>>,

    /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
    #[serde(rename = "top_p")]
    #[validate(
            range(min = 0f64, max = 1f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub top_p: Option<Nullable<f64>>,

    /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message. 
    #[serde(rename = "stream")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stream: Option<Nullable<bool>>,

    /// The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info. 
    #[serde(rename = "max_prompt_tokens")]
    #[validate(
            range(min = 256u32),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_prompt_tokens: Option<Nullable<u32>>,

    /// The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info. 
    #[serde(rename = "max_completion_tokens")]
    #[validate(
            range(min = 256u32),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_completion_tokens: Option<Nullable<u32>>,

    #[serde(rename = "truncation_strategy")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub truncation_strategy: Option<models::TruncationObject>,

    #[serde(rename = "tool_choice")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_choice: Option<models::AssistantsApiToolChoiceOption>,

    /// Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
    #[serde(rename = "parallel_tool_calls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parallel_tool_calls: Option<bool>,

    #[serde(rename = "response_format")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_format: Option<models::AssistantsApiResponseFormatOption>,

}



impl CreateThreadAndRunRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(assistant_id: String, ) -> CreateThreadAndRunRequest {
        CreateThreadAndRunRequest {
 assistant_id,
 thread: None,
 model: None,
 instructions: None,
 tools: None,
 tool_resources: None,
 metadata: None,
 temperature: Some(Nullable::Present(1.0)),
 top_p: Some(Nullable::Present(1.0)),
 stream: None,
 max_prompt_tokens: None,
 max_completion_tokens: None,
 truncation_strategy: None,
 tool_choice: None,
 parallel_tool_calls: Some(true),
 response_format: None,
        }
    }
}

/// Converts the CreateThreadAndRunRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateThreadAndRunRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("assistant_id".to_string()),
            Some(self.assistant_id.to_string()),

            // Skipping thread in query parameter serialization

            // Skipping model in query parameter serialization


            self.instructions.as_ref().map(|instructions| {
                [
                    "instructions".to_string(),
                    instructions.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping tools in query parameter serialization

            // Skipping tool_resources in query parameter serialization

            // Skipping metadata in query parameter serialization


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.top_p.as_ref().map(|top_p| {
                [
                    "top_p".to_string(),
                    top_p.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.stream.as_ref().map(|stream| {
                [
                    "stream".to_string(),
                    stream.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.max_prompt_tokens.as_ref().map(|max_prompt_tokens| {
                [
                    "max_prompt_tokens".to_string(),
                    max_prompt_tokens.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.max_completion_tokens.as_ref().map(|max_completion_tokens| {
                [
                    "max_completion_tokens".to_string(),
                    max_completion_tokens.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping truncation_strategy in query parameter serialization

            // Skipping tool_choice in query parameter serialization


            self.parallel_tool_calls.as_ref().map(|parallel_tool_calls| {
                [
                    "parallel_tool_calls".to_string(),
                    parallel_tool_calls.to_string(),
                ].join(",")
            }),

            // Skipping response_format in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateThreadAndRunRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateThreadAndRunRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub assistant_id: Vec<String>,
            pub thread: Vec<models::CreateThreadRequest>,
            pub model: Vec<models::CreateRunRequestModel>,
            pub instructions: Vec<String>,
            pub tools: Vec<Vec<models::CreateThreadAndRunRequestToolsInner>>,
            pub tool_resources: Vec<models::CreateThreadAndRunRequestToolResources>,
            pub metadata: Vec<crate::types::Object>,
            pub temperature: Vec<f64>,
            pub top_p: Vec<f64>,
            pub stream: Vec<bool>,
            pub max_prompt_tokens: Vec<u32>,
            pub max_completion_tokens: Vec<u32>,
            pub truncation_strategy: Vec<models::TruncationObject>,
            pub tool_choice: Vec<models::AssistantsApiToolChoiceOption>,
            pub parallel_tool_calls: Vec<bool>,
            pub response_format: Vec<models::AssistantsApiResponseFormatOption>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateThreadAndRunRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "assistant_id" => intermediate_rep.assistant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "thread" => intermediate_rep.thread.push(<models::CreateThreadRequest as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "model" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    "instructions" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    "tool_resources" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "temperature" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    "top_p" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    "stream" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    "max_prompt_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    "max_completion_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadAndRunRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "truncation_strategy" => intermediate_rep.truncation_strategy.push(<models::TruncationObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tool_choice" => intermediate_rep.tool_choice.push(<models::AssistantsApiToolChoiceOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parallel_tool_calls" => intermediate_rep.parallel_tool_calls.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_format" => intermediate_rep.response_format.push(<models::AssistantsApiResponseFormatOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateThreadAndRunRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateThreadAndRunRequest {
            assistant_id: intermediate_rep.assistant_id.into_iter().next().ok_or_else(|| "assistant_id missing in CreateThreadAndRunRequest".to_string())?,
            thread: intermediate_rep.thread.into_iter().next(),
            model: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            instructions: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            tools: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            tool_resources: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next(),
            temperature: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            top_p: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            stream: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            max_prompt_tokens: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            max_completion_tokens: std::result::Result::Err("Nullable types not supported in CreateThreadAndRunRequest".to_string())?,
            truncation_strategy: intermediate_rep.truncation_strategy.into_iter().next(),
            tool_choice: intermediate_rep.tool_choice.into_iter().next(),
            parallel_tool_calls: intermediate_rep.parallel_tool_calls.into_iter().next(),
            response_format: intermediate_rep.response_format.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateThreadAndRunRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateThreadAndRunRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateThreadAndRunRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateThreadAndRunRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateThreadAndRunRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateThreadAndRunRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateThreadAndRunRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateThreadAndRunRequestToolResources {
    #[serde(rename = "code_interpreter")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_interpreter: Option<models::CreateAssistantRequestToolResourcesCodeInterpreter>,

    #[serde(rename = "file_search")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_search: Option<models::AssistantObjectToolResourcesFileSearch>,

}



impl CreateThreadAndRunRequestToolResources {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateThreadAndRunRequestToolResources {
        CreateThreadAndRunRequestToolResources {
 code_interpreter: None,
 file_search: None,
        }
    }
}

/// Converts the CreateThreadAndRunRequestToolResources value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateThreadAndRunRequestToolResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping code_interpreter in query parameter serialization

            // Skipping file_search in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateThreadAndRunRequestToolResources value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateThreadAndRunRequestToolResources {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code_interpreter: Vec<models::CreateAssistantRequestToolResourcesCodeInterpreter>,
            pub file_search: Vec<models::AssistantObjectToolResourcesFileSearch>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateThreadAndRunRequestToolResources".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code_interpreter" => intermediate_rep.code_interpreter.push(<models::CreateAssistantRequestToolResourcesCodeInterpreter as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_search" => intermediate_rep.file_search.push(<models::AssistantObjectToolResourcesFileSearch as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateThreadAndRunRequestToolResources".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateThreadAndRunRequestToolResources {
            code_interpreter: intermediate_rep.code_interpreter.into_iter().next(),
            file_search: intermediate_rep.file_search.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateThreadAndRunRequestToolResources> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateThreadAndRunRequestToolResources>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateThreadAndRunRequestToolResources>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateThreadAndRunRequestToolResources - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateThreadAndRunRequestToolResources> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateThreadAndRunRequestToolResources as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateThreadAndRunRequestToolResources - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateThreadAndRunRequestToolsInner {
    AssistantToolsCode(models::AssistantToolsCode),
    AssistantToolsFileSearch(models::AssistantToolsFileSearch),
    AssistantToolsFunction(models::AssistantToolsFunction),
}

impl validator::Validate for CreateThreadAndRunRequestToolsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::AssistantToolsCode(v) => v.validate(),
            Self::AssistantToolsFileSearch(v) => v.validate(),
            Self::AssistantToolsFunction(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateThreadAndRunRequestToolsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateThreadAndRunRequestToolsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::AssistantToolsCode> for CreateThreadAndRunRequestToolsInner {
    fn from(value: models::AssistantToolsCode) -> Self {
        Self::AssistantToolsCode(value)
    }
}
impl From<models::AssistantToolsFileSearch> for CreateThreadAndRunRequestToolsInner {
    fn from(value: models::AssistantToolsFileSearch) -> Self {
        Self::AssistantToolsFileSearch(value)
    }
}
impl From<models::AssistantToolsFunction> for CreateThreadAndRunRequestToolsInner {
    fn from(value: models::AssistantToolsFunction) -> Self {
        Self::AssistantToolsFunction(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateThreadRequest {
    /// A list of [messages](/docs/api-reference/messages) to start the thread with.
    #[serde(rename = "messages")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub messages: Option<Vec<models::CreateMessageRequest>>,

    #[serde(rename = "tool_resources")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_resources: Option<Nullable<models::CreateThreadRequestToolResources>>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}



impl CreateThreadRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateThreadRequest {
        CreateThreadRequest {
 messages: None,
 tool_resources: None,
 metadata: None,
        }
    }
}

/// Converts the CreateThreadRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateThreadRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping messages in query parameter serialization

            // Skipping tool_resources in query parameter serialization

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateThreadRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateThreadRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub messages: Vec<Vec<models::CreateMessageRequest>>,
            pub tool_resources: Vec<models::CreateThreadRequestToolResources>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateThreadRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "messages" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateThreadRequest".to_string()),
                    "tool_resources" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateThreadRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateThreadRequest {
            messages: intermediate_rep.messages.into_iter().next(),
            tool_resources: std::result::Result::Err("Nullable types not supported in CreateThreadRequest".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateThreadRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateThreadRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateThreadRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateThreadRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateThreadRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateThreadRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateThreadRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateThreadRequestToolResources {
    #[serde(rename = "code_interpreter")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_interpreter: Option<models::CreateAssistantRequestToolResourcesCodeInterpreter>,

    #[serde(rename = "file_search")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_search: Option<Nullable<models::CreateThreadRequestToolResourcesFileSearch>>,

}



impl CreateThreadRequestToolResources {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateThreadRequestToolResources {
        CreateThreadRequestToolResources {
 code_interpreter: None,
 file_search: None,
        }
    }
}

/// Converts the CreateThreadRequestToolResources value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateThreadRequestToolResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping code_interpreter in query parameter serialization

            // Skipping file_search in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateThreadRequestToolResources value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateThreadRequestToolResources {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code_interpreter: Vec<models::CreateAssistantRequestToolResourcesCodeInterpreter>,
            pub file_search: Vec<models::CreateThreadRequestToolResourcesFileSearch>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateThreadRequestToolResources".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code_interpreter" => intermediate_rep.code_interpreter.push(<models::CreateAssistantRequestToolResourcesCodeInterpreter as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "file_search" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CreateThreadRequestToolResources".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateThreadRequestToolResources".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateThreadRequestToolResources {
            code_interpreter: intermediate_rep.code_interpreter.into_iter().next(),
            file_search: std::result::Result::Err("Nullable types not supported in CreateThreadRequestToolResources".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateThreadRequestToolResources> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateThreadRequestToolResources>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateThreadRequestToolResources>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateThreadRequestToolResources - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateThreadRequestToolResources> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateThreadRequestToolResources as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateThreadRequestToolResources - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateThreadRequestToolResourcesFileSearch {
    /// The [vector store](/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread. 
    #[serde(rename = "vector_store_ids")]
    #[validate(
            length(max = 1),
          custom(function = "check_xss_vec_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vector_store_ids: Option<Vec<String>>,

    /// A helper to create a [vector store](/docs/api-reference/vector-stores/object) with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the thread. 
    #[serde(rename = "vector_stores")]
    #[validate(
            length(max = 1),
          nested,
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vector_stores: Option<Vec<models::CreateThreadRequestToolResourcesFileSearchVectorStoresInner>>,

}



impl CreateThreadRequestToolResourcesFileSearch {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateThreadRequestToolResourcesFileSearch {
        CreateThreadRequestToolResourcesFileSearch {
 vector_store_ids: None,
 vector_stores: None,
        }
    }
}

/// Converts the CreateThreadRequestToolResourcesFileSearch value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateThreadRequestToolResourcesFileSearch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.vector_store_ids.as_ref().map(|vector_store_ids| {
                [
                    "vector_store_ids".to_string(),
                    vector_store_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping vector_stores in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateThreadRequestToolResourcesFileSearch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateThreadRequestToolResourcesFileSearch {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub vector_store_ids: Vec<Vec<String>>,
            pub vector_stores: Vec<Vec<models::CreateThreadRequestToolResourcesFileSearchVectorStoresInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateThreadRequestToolResourcesFileSearch".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "vector_store_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateThreadRequestToolResourcesFileSearch".to_string()),
                    "vector_stores" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateThreadRequestToolResourcesFileSearch".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateThreadRequestToolResourcesFileSearch".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateThreadRequestToolResourcesFileSearch {
            vector_store_ids: intermediate_rep.vector_store_ids.into_iter().next(),
            vector_stores: intermediate_rep.vector_stores.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateThreadRequestToolResourcesFileSearch> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateThreadRequestToolResourcesFileSearch>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateThreadRequestToolResourcesFileSearch>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateThreadRequestToolResourcesFileSearch - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateThreadRequestToolResourcesFileSearch> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateThreadRequestToolResourcesFileSearch as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateThreadRequestToolResourcesFileSearch - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateThreadRequestToolResourcesFileSearchVectorStoresInner {
    /// A list of [file](/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store. 
    #[serde(rename = "file_ids")]
    #[validate(
            length(max = 10000),
          custom(function = "check_xss_vec_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_ids: Option<Vec<String>>,

    #[serde(rename = "chunking_strategy")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub chunking_strategy: Option<models::CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy>,

    /// Set of 16 key-value pairs that can be attached to a vector store. This can be useful for storing additional information about the vector store in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}



impl CreateThreadRequestToolResourcesFileSearchVectorStoresInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateThreadRequestToolResourcesFileSearchVectorStoresInner {
        CreateThreadRequestToolResourcesFileSearchVectorStoresInner {
 file_ids: None,
 chunking_strategy: None,
 metadata: None,
        }
    }
}

/// Converts the CreateThreadRequestToolResourcesFileSearchVectorStoresInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateThreadRequestToolResourcesFileSearchVectorStoresInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_ids.as_ref().map(|file_ids| {
                [
                    "file_ids".to_string(),
                    file_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping chunking_strategy in query parameter serialization

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateThreadRequestToolResourcesFileSearchVectorStoresInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateThreadRequestToolResourcesFileSearchVectorStoresInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_ids: Vec<Vec<String>>,
            pub chunking_strategy: Vec<models::CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateThreadRequestToolResourcesFileSearchVectorStoresInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "file_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateThreadRequestToolResourcesFileSearchVectorStoresInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "chunking_strategy" => intermediate_rep.chunking_strategy.push(<models::CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateThreadRequestToolResourcesFileSearchVectorStoresInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateThreadRequestToolResourcesFileSearchVectorStoresInner {
            file_ids: intermediate_rep.file_ids.into_iter().next(),
            chunking_strategy: intermediate_rep.chunking_strategy.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateThreadRequestToolResourcesFileSearchVectorStoresInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateThreadRequestToolResourcesFileSearchVectorStoresInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateThreadRequestToolResourcesFileSearchVectorStoresInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateThreadRequestToolResourcesFileSearchVectorStoresInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateThreadRequestToolResourcesFileSearchVectorStoresInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateThreadRequestToolResourcesFileSearchVectorStoresInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateThreadRequestToolResourcesFileSearchVectorStoresInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateTranscription200Response {
    CreateTranscriptionResponseJson(models::CreateTranscriptionResponseJson),
    CreateTranscriptionResponseVerboseJson(models::CreateTranscriptionResponseVerboseJson),
}

impl validator::Validate for CreateTranscription200Response
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::CreateTranscriptionResponseJson(v) => v.validate(),
            Self::CreateTranscriptionResponseVerboseJson(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTranscription200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTranscription200Response {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::CreateTranscriptionResponseJson> for CreateTranscription200Response {
    fn from(value: models::CreateTranscriptionResponseJson) -> Self {
        Self::CreateTranscriptionResponseJson(value)
    }
}
impl From<models::CreateTranscriptionResponseVerboseJson> for CreateTranscription200Response {
    fn from(value: models::CreateTranscriptionResponseVerboseJson) -> Self {
        Self::CreateTranscriptionResponseVerboseJson(value)
    }
}





/// ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateTranscriptionRequestModel {
    String(String),
    String1(String),
}

impl validator::Validate for CreateTranscriptionRequestModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::String1(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTranscriptionRequestModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTranscriptionRequestModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}







/// Represents a transcription response returned by model, based on the provided input.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateTranscriptionResponseJson {
    /// The transcribed text.
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    pub text: String,

}



impl CreateTranscriptionResponseJson {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(text: String, ) -> CreateTranscriptionResponseJson {
        CreateTranscriptionResponseJson {
 text,
        }
    }
}

/// Converts the CreateTranscriptionResponseJson value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateTranscriptionResponseJson {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("text".to_string()),
            Some(self.text.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTranscriptionResponseJson value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTranscriptionResponseJson {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub text: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateTranscriptionResponseJson".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateTranscriptionResponseJson".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateTranscriptionResponseJson {
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in CreateTranscriptionResponseJson".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateTranscriptionResponseJson> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateTranscriptionResponseJson>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateTranscriptionResponseJson>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateTranscriptionResponseJson - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateTranscriptionResponseJson> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateTranscriptionResponseJson as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateTranscriptionResponseJson - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Represents a verbose json transcription response returned by model, based on the provided input.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateTranscriptionResponseVerboseJson {
    /// The language of the input audio.
    #[serde(rename = "language")]
          #[validate(custom(function = "check_xss_string"))]
    pub language: String,

    /// The duration of the input audio.
    #[serde(rename = "duration")]
          #[validate(custom(function = "check_xss_string"))]
    pub duration: String,

    /// The transcribed text.
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    pub text: String,

    /// Extracted words and their corresponding timestamps.
    #[serde(rename = "words")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub words: Option<Vec<models::TranscriptionWord>>,

    /// Segments of the transcribed text and their corresponding details.
    #[serde(rename = "segments")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub segments: Option<Vec<models::TranscriptionSegment>>,

}



impl CreateTranscriptionResponseVerboseJson {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(language: String, duration: String, text: String, ) -> CreateTranscriptionResponseVerboseJson {
        CreateTranscriptionResponseVerboseJson {
 language,
 duration,
 text,
 words: None,
 segments: None,
        }
    }
}

/// Converts the CreateTranscriptionResponseVerboseJson value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateTranscriptionResponseVerboseJson {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("language".to_string()),
            Some(self.language.to_string()),


            Some("duration".to_string()),
            Some(self.duration.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),

            // Skipping words in query parameter serialization

            // Skipping segments in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTranscriptionResponseVerboseJson value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTranscriptionResponseVerboseJson {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub language: Vec<String>,
            pub duration: Vec<String>,
            pub text: Vec<String>,
            pub words: Vec<Vec<models::TranscriptionWord>>,
            pub segments: Vec<Vec<models::TranscriptionSegment>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateTranscriptionResponseVerboseJson".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "duration" => intermediate_rep.duration.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "words" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateTranscriptionResponseVerboseJson".to_string()),
                    "segments" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateTranscriptionResponseVerboseJson".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateTranscriptionResponseVerboseJson".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateTranscriptionResponseVerboseJson {
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in CreateTranscriptionResponseVerboseJson".to_string())?,
            duration: intermediate_rep.duration.into_iter().next().ok_or_else(|| "duration missing in CreateTranscriptionResponseVerboseJson".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in CreateTranscriptionResponseVerboseJson".to_string())?,
            words: intermediate_rep.words.into_iter().next(),
            segments: intermediate_rep.segments.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateTranscriptionResponseVerboseJson> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateTranscriptionResponseVerboseJson>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateTranscriptionResponseVerboseJson>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateTranscriptionResponseVerboseJson - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateTranscriptionResponseVerboseJson> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateTranscriptionResponseVerboseJson as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateTranscriptionResponseVerboseJson - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateTranslation200Response {
    CreateTranslationResponseJson(models::CreateTranslationResponseJson),
    CreateTranslationResponseVerboseJson(models::CreateTranslationResponseVerboseJson),
}

impl validator::Validate for CreateTranslation200Response
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::CreateTranslationResponseJson(v) => v.validate(),
            Self::CreateTranslationResponseVerboseJson(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTranslation200Response value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTranslation200Response {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::CreateTranslationResponseJson> for CreateTranslation200Response {
    fn from(value: models::CreateTranslationResponseJson) -> Self {
        Self::CreateTranslationResponseJson(value)
    }
}
impl From<models::CreateTranslationResponseVerboseJson> for CreateTranslation200Response {
    fn from(value: models::CreateTranslationResponseVerboseJson) -> Self {
        Self::CreateTranslationResponseVerboseJson(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateTranslationResponseJson {
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    pub text: String,

}



impl CreateTranslationResponseJson {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(text: String, ) -> CreateTranslationResponseJson {
        CreateTranslationResponseJson {
 text,
        }
    }
}

/// Converts the CreateTranslationResponseJson value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateTranslationResponseJson {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("text".to_string()),
            Some(self.text.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTranslationResponseJson value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTranslationResponseJson {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub text: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateTranslationResponseJson".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateTranslationResponseJson".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateTranslationResponseJson {
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in CreateTranslationResponseJson".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateTranslationResponseJson> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateTranslationResponseJson>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateTranslationResponseJson>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateTranslationResponseJson - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateTranslationResponseJson> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateTranslationResponseJson as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateTranslationResponseJson - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateTranslationResponseVerboseJson {
    /// The language of the output translation (always `english`).
    #[serde(rename = "language")]
          #[validate(custom(function = "check_xss_string"))]
    pub language: String,

    /// The duration of the input audio.
    #[serde(rename = "duration")]
          #[validate(custom(function = "check_xss_string"))]
    pub duration: String,

    /// The translated text.
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    pub text: String,

    /// Segments of the translated text and their corresponding details.
    #[serde(rename = "segments")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub segments: Option<Vec<models::TranscriptionSegment>>,

}



impl CreateTranslationResponseVerboseJson {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(language: String, duration: String, text: String, ) -> CreateTranslationResponseVerboseJson {
        CreateTranslationResponseVerboseJson {
 language,
 duration,
 text,
 segments: None,
        }
    }
}

/// Converts the CreateTranslationResponseVerboseJson value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateTranslationResponseVerboseJson {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("language".to_string()),
            Some(self.language.to_string()),


            Some("duration".to_string()),
            Some(self.duration.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),

            // Skipping segments in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateTranslationResponseVerboseJson value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateTranslationResponseVerboseJson {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub language: Vec<String>,
            pub duration: Vec<String>,
            pub text: Vec<String>,
            pub segments: Vec<Vec<models::TranscriptionSegment>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateTranslationResponseVerboseJson".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "duration" => intermediate_rep.duration.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "segments" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateTranslationResponseVerboseJson".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateTranslationResponseVerboseJson".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateTranslationResponseVerboseJson {
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in CreateTranslationResponseVerboseJson".to_string())?,
            duration: intermediate_rep.duration.into_iter().next().ok_or_else(|| "duration missing in CreateTranslationResponseVerboseJson".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in CreateTranslationResponseVerboseJson".to_string())?,
            segments: intermediate_rep.segments.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateTranslationResponseVerboseJson> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateTranslationResponseVerboseJson>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateTranslationResponseVerboseJson>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateTranslationResponseVerboseJson - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateTranslationResponseVerboseJson> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateTranslationResponseVerboseJson as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateTranslationResponseVerboseJson - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateUploadRequest {
    /// The name of the file to upload. 
    #[serde(rename = "filename")]
          #[validate(custom(function = "check_xss_string"))]
    pub filename: String,

    /// The intended purpose of the uploaded file.  See the [documentation on File purposes](/docs/api-reference/files/create#files-create-purpose). 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "purpose")]
          #[validate(custom(function = "check_xss_string"))]
    pub purpose: String,

    /// The number of bytes in the file you are uploading. 
    #[serde(rename = "bytes")]
    pub bytes: i32,

    /// The MIME type of the file.  This must fall within the supported MIME types for your file purpose. See the supported MIME types for assistants and vision. 
    #[serde(rename = "mime_type")]
          #[validate(custom(function = "check_xss_string"))]
    pub mime_type: String,

}



impl CreateUploadRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(filename: String, purpose: String, bytes: i32, mime_type: String, ) -> CreateUploadRequest {
        CreateUploadRequest {
 filename,
 purpose,
 bytes,
 mime_type,
        }
    }
}

/// Converts the CreateUploadRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateUploadRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("filename".to_string()),
            Some(self.filename.to_string()),


            Some("purpose".to_string()),
            Some(self.purpose.to_string()),


            Some("bytes".to_string()),
            Some(self.bytes.to_string()),


            Some("mime_type".to_string()),
            Some(self.mime_type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateUploadRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateUploadRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub filename: Vec<String>,
            pub purpose: Vec<String>,
            pub bytes: Vec<i32>,
            pub mime_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateUploadRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "filename" => intermediate_rep.filename.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "purpose" => intermediate_rep.purpose.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "bytes" => intermediate_rep.bytes.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "mime_type" => intermediate_rep.mime_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateUploadRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateUploadRequest {
            filename: intermediate_rep.filename.into_iter().next().ok_or_else(|| "filename missing in CreateUploadRequest".to_string())?,
            purpose: intermediate_rep.purpose.into_iter().next().ok_or_else(|| "purpose missing in CreateUploadRequest".to_string())?,
            bytes: intermediate_rep.bytes.into_iter().next().ok_or_else(|| "bytes missing in CreateUploadRequest".to_string())?,
            mime_type: intermediate_rep.mime_type.into_iter().next().ok_or_else(|| "mime_type missing in CreateUploadRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateUploadRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateUploadRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateUploadRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateUploadRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateUploadRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateUploadRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateUploadRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateVectorStoreFileBatchRequest {
    /// A list of [File](/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
    #[serde(rename = "file_ids")]
    #[validate(
            length(min = 1, max = 500),
          custom(function = "check_xss_vec_string"),
    )]
    pub file_ids: Vec<String>,

    #[serde(rename = "chunking_strategy")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub chunking_strategy: Option<models::ChunkingStrategyRequestParam>,

}



impl CreateVectorStoreFileBatchRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(file_ids: Vec<String>, ) -> CreateVectorStoreFileBatchRequest {
        CreateVectorStoreFileBatchRequest {
 file_ids,
 chunking_strategy: None,
        }
    }
}

/// Converts the CreateVectorStoreFileBatchRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateVectorStoreFileBatchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("file_ids".to_string()),
            Some(self.file_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping chunking_strategy in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateVectorStoreFileBatchRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateVectorStoreFileBatchRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_ids: Vec<Vec<String>>,
            pub chunking_strategy: Vec<models::ChunkingStrategyRequestParam>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateVectorStoreFileBatchRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "file_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateVectorStoreFileBatchRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "chunking_strategy" => intermediate_rep.chunking_strategy.push(<models::ChunkingStrategyRequestParam as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateVectorStoreFileBatchRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateVectorStoreFileBatchRequest {
            file_ids: intermediate_rep.file_ids.into_iter().next().ok_or_else(|| "file_ids missing in CreateVectorStoreFileBatchRequest".to_string())?,
            chunking_strategy: intermediate_rep.chunking_strategy.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateVectorStoreFileBatchRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateVectorStoreFileBatchRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateVectorStoreFileBatchRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateVectorStoreFileBatchRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateVectorStoreFileBatchRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateVectorStoreFileBatchRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateVectorStoreFileBatchRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateVectorStoreFileRequest {
    /// A [File](/docs/api-reference/files) ID that the vector store should use. Useful for tools like `file_search` that can access files.
    #[serde(rename = "file_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub file_id: String,

    #[serde(rename = "chunking_strategy")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub chunking_strategy: Option<models::ChunkingStrategyRequestParam>,

}



impl CreateVectorStoreFileRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(file_id: String, ) -> CreateVectorStoreFileRequest {
        CreateVectorStoreFileRequest {
 file_id,
 chunking_strategy: None,
        }
    }
}

/// Converts the CreateVectorStoreFileRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateVectorStoreFileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("file_id".to_string()),
            Some(self.file_id.to_string()),

            // Skipping chunking_strategy in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateVectorStoreFileRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateVectorStoreFileRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
            pub chunking_strategy: Vec<models::ChunkingStrategyRequestParam>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateVectorStoreFileRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "chunking_strategy" => intermediate_rep.chunking_strategy.push(<models::ChunkingStrategyRequestParam as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateVectorStoreFileRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateVectorStoreFileRequest {
            file_id: intermediate_rep.file_id.into_iter().next().ok_or_else(|| "file_id missing in CreateVectorStoreFileRequest".to_string())?,
            chunking_strategy: intermediate_rep.chunking_strategy.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateVectorStoreFileRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateVectorStoreFileRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateVectorStoreFileRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateVectorStoreFileRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateVectorStoreFileRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateVectorStoreFileRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateVectorStoreFileRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CreateVectorStoreRequest {
    /// A list of [File](/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
    #[serde(rename = "file_ids")]
    #[validate(
            length(max = 500),
          custom(function = "check_xss_vec_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_ids: Option<Vec<String>>,

    /// The name of the vector store.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "expires_after")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_after: Option<models::VectorStoreExpirationAfter>,

    #[serde(rename = "chunking_strategy")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub chunking_strategy: Option<models::CreateVectorStoreRequestChunkingStrategy>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}



impl CreateVectorStoreRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> CreateVectorStoreRequest {
        CreateVectorStoreRequest {
 file_ids: None,
 name: None,
 expires_after: None,
 chunking_strategy: None,
 metadata: None,
        }
    }
}

/// Converts the CreateVectorStoreRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CreateVectorStoreRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_ids.as_ref().map(|file_ids| {
                [
                    "file_ids".to_string(),
                    file_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping expires_after in query parameter serialization

            // Skipping chunking_strategy in query parameter serialization

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateVectorStoreRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateVectorStoreRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_ids: Vec<Vec<String>>,
            pub name: Vec<String>,
            pub expires_after: Vec<models::VectorStoreExpirationAfter>,
            pub chunking_strategy: Vec<models::CreateVectorStoreRequestChunkingStrategy>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CreateVectorStoreRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "file_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in CreateVectorStoreRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expires_after" => intermediate_rep.expires_after.push(<models::VectorStoreExpirationAfter as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "chunking_strategy" => intermediate_rep.chunking_strategy.push(<models::CreateVectorStoreRequestChunkingStrategy as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CreateVectorStoreRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CreateVectorStoreRequest {
            file_ids: intermediate_rep.file_ids.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            expires_after: intermediate_rep.expires_after.into_iter().next(),
            chunking_strategy: intermediate_rep.chunking_strategy.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CreateVectorStoreRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CreateVectorStoreRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CreateVectorStoreRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CreateVectorStoreRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CreateVectorStoreRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CreateVectorStoreRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CreateVectorStoreRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy. Only applicable if `file_ids` is non-empty.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum CreateVectorStoreRequestChunkingStrategy {
    AutoChunkingStrategyRequestParam(models::AutoChunkingStrategyRequestParam),
    StaticChunkingStrategyRequestParam(models::StaticChunkingStrategyRequestParam),
}

impl validator::Validate for CreateVectorStoreRequestChunkingStrategy
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::AutoChunkingStrategyRequestParam(v) => v.validate(),
            Self::StaticChunkingStrategyRequestParam(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CreateVectorStoreRequestChunkingStrategy value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CreateVectorStoreRequestChunkingStrategy {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::AutoChunkingStrategyRequestParam> for CreateVectorStoreRequestChunkingStrategy {
    fn from(value: models::AutoChunkingStrategyRequestParam) -> Self {
        Self::AutoChunkingStrategyRequestParam(value)
    }
}
impl From<models::StaticChunkingStrategyRequestParam> for CreateVectorStoreRequestChunkingStrategy {
    fn from(value: models::StaticChunkingStrategyRequestParam) -> Self {
        Self::StaticChunkingStrategyRequestParam(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DefaultProjectErrorResponse {
    #[serde(rename = "code")]
    pub code: i32,

    #[serde(rename = "message")]
          #[validate(custom(function = "check_xss_string"))]
    pub message: String,

}



impl DefaultProjectErrorResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(code: i32, message: String, ) -> DefaultProjectErrorResponse {
        DefaultProjectErrorResponse {
 code,
 message,
        }
    }
}

/// Converts the DefaultProjectErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DefaultProjectErrorResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("code".to_string()),
            Some(self.code.to_string()),


            Some("message".to_string()),
            Some(self.message.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DefaultProjectErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DefaultProjectErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<i32>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DefaultProjectErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DefaultProjectErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DefaultProjectErrorResponse {
            code: intermediate_rep.code.into_iter().next().ok_or_else(|| "code missing in DefaultProjectErrorResponse".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in DefaultProjectErrorResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DefaultProjectErrorResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DefaultProjectErrorResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DefaultProjectErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for DefaultProjectErrorResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DefaultProjectErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DefaultProjectErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into DefaultProjectErrorResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteAssistantResponse {
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

}



impl DeleteAssistantResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, deleted: bool, object: String, ) -> DeleteAssistantResponse {
        DeleteAssistantResponse {
 id,
 deleted,
 object,
        }
    }
}

/// Converts the DeleteAssistantResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeleteAssistantResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteAssistantResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteAssistantResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteAssistantResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteAssistantResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteAssistantResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in DeleteAssistantResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in DeleteAssistantResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in DeleteAssistantResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteAssistantResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteAssistantResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteAssistantResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for DeleteAssistantResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeleteAssistantResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteAssistantResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into DeleteAssistantResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteFileResponse {
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

}



impl DeleteFileResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, deleted: bool, ) -> DeleteFileResponse {
        DeleteFileResponse {
 id,
 object,
 deleted,
        }
    }
}

/// Converts the DeleteFileResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeleteFileResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteFileResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteFileResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub deleted: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteFileResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteFileResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteFileResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in DeleteFileResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in DeleteFileResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in DeleteFileResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteFileResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteFileResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteFileResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for DeleteFileResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeleteFileResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteFileResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into DeleteFileResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteMessageResponse {
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

}



impl DeleteMessageResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, deleted: bool, object: String, ) -> DeleteMessageResponse {
        DeleteMessageResponse {
 id,
 deleted,
 object,
        }
    }
}

/// Converts the DeleteMessageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeleteMessageResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteMessageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteMessageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteMessageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteMessageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteMessageResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in DeleteMessageResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in DeleteMessageResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in DeleteMessageResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteMessageResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteMessageResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteMessageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for DeleteMessageResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeleteMessageResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteMessageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into DeleteMessageResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteModelResponse {
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

}



impl DeleteModelResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, deleted: bool, object: String, ) -> DeleteModelResponse {
        DeleteModelResponse {
 id,
 deleted,
 object,
        }
    }
}

/// Converts the DeleteModelResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeleteModelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteModelResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteModelResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteModelResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteModelResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteModelResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in DeleteModelResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in DeleteModelResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in DeleteModelResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteModelResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteModelResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteModelResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for DeleteModelResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeleteModelResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteModelResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into DeleteModelResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteThreadResponse {
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

}



impl DeleteThreadResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, deleted: bool, object: String, ) -> DeleteThreadResponse {
        DeleteThreadResponse {
 id,
 deleted,
 object,
        }
    }
}

/// Converts the DeleteThreadResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeleteThreadResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteThreadResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteThreadResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteThreadResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteThreadResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteThreadResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in DeleteThreadResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in DeleteThreadResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in DeleteThreadResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteThreadResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteThreadResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteThreadResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for DeleteThreadResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeleteThreadResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteThreadResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into DeleteThreadResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteVectorStoreFileResponse {
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

}



impl DeleteVectorStoreFileResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, deleted: bool, object: String, ) -> DeleteVectorStoreFileResponse {
        DeleteVectorStoreFileResponse {
 id,
 deleted,
 object,
        }
    }
}

/// Converts the DeleteVectorStoreFileResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeleteVectorStoreFileResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteVectorStoreFileResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteVectorStoreFileResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteVectorStoreFileResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteVectorStoreFileResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteVectorStoreFileResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in DeleteVectorStoreFileResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in DeleteVectorStoreFileResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in DeleteVectorStoreFileResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteVectorStoreFileResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteVectorStoreFileResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteVectorStoreFileResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for DeleteVectorStoreFileResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeleteVectorStoreFileResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteVectorStoreFileResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into DeleteVectorStoreFileResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DeleteVectorStoreResponse {
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

}



impl DeleteVectorStoreResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, deleted: bool, object: String, ) -> DeleteVectorStoreResponse {
        DeleteVectorStoreResponse {
 id,
 deleted,
 object,
        }
    }
}

/// Converts the DeleteVectorStoreResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DeleteVectorStoreResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DeleteVectorStoreResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DeleteVectorStoreResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DeleteVectorStoreResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DeleteVectorStoreResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DeleteVectorStoreResponse {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in DeleteVectorStoreResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in DeleteVectorStoreResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in DeleteVectorStoreResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DeleteVectorStoreResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DeleteVectorStoreResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DeleteVectorStoreResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for DeleteVectorStoreResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DeleteVectorStoreResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DeleteVectorStoreResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into DeleteVectorStoreResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a stream ends.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct DoneEvent {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "data")]
          #[validate(custom(function = "check_xss_string"))]
    pub data: String,

}



impl DoneEvent {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: String, ) -> DoneEvent {
        DoneEvent {
 event,
 data,
        }
    }
}

/// Converts the DoneEvent value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for DoneEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),


            Some("data".to_string()),
            Some(self.data.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a DoneEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for DoneEvent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing DoneEvent".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing DoneEvent".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(DoneEvent {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in DoneEvent".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in DoneEvent".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<DoneEvent> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<DoneEvent>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<DoneEvent>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for DoneEvent - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<DoneEvent> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <DoneEvent as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into DoneEvent - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Represents an embedding vector returned by embedding endpoint. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Embedding {
    /// The index of the embedding in the list of embeddings.
    #[serde(rename = "index")]
    pub index: i32,

    /// The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](/docs/guides/embeddings). 
    #[serde(rename = "embedding")]
    pub embedding: Vec<f64>,

    /// The object type, which is always \"embedding\".
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

}



impl Embedding {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, embedding: Vec<f64>, object: String, ) -> Embedding {
        Embedding {
 index,
 embedding,
 object,
        }
    }
}

/// Converts the Embedding value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Embedding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("embedding".to_string()),
            Some(self.embedding.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Embedding value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Embedding {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub embedding: Vec<Vec<f64>>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Embedding".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "embedding" => return std::result::Result::Err("Parsing a container in this style is not supported in Embedding".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Embedding".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Embedding {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in Embedding".to_string())?,
            embedding: intermediate_rep.embedding.into_iter().next().ok_or_else(|| "embedding missing in Embedding".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in Embedding".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Embedding> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Embedding>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Embedding>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for Embedding - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Embedding> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Embedding as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into Embedding - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Error {
    #[serde(rename = "code")]
    pub code: Nullable<String>,

    #[serde(rename = "message")]
          #[validate(custom(function = "check_xss_string"))]
    pub message: String,

    #[serde(rename = "param")]
    pub param: Nullable<String>,

    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

}



impl Error {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(code: Nullable<String>, message: String, param: Nullable<String>, r_type: String, ) -> Error {
        Error {
 code,
 message,
 param,
 r_type,
        }
    }
}

/// Converts the Error value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("code".to_string()),
            Some(self.code.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("message".to_string()),
            Some(self.message.to_string()),


            Some("param".to_string()),
            Some(self.param.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Error value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Error {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<String>,
            pub message: Vec<String>,
            pub param: Vec<String>,
            pub r_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Error".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "code" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Error".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "param" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Error".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Error".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Error {
            code: std::result::Result::Err("Nullable types not supported in Error".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in Error".to_string())?,
            param: std::result::Result::Err("Nullable types not supported in Error".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in Error".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Error> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Error>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Error>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for Error - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Error> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Error as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into Error - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when an [error](/docs/guides/error-codes#api-errors) occurs. This can happen due to an internal server error or a timeout.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ErrorEvent {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::Error,

}



impl ErrorEvent {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::Error, ) -> ErrorEvent {
        ErrorEvent {
 event,
 data,
        }
    }
}

/// Converts the ErrorEvent value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ErrorEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ErrorEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ErrorEvent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::Error>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ErrorEvent".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::Error as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ErrorEvent".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ErrorEvent {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in ErrorEvent".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ErrorEvent".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ErrorEvent> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ErrorEvent>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ErrorEvent>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ErrorEvent - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ErrorEvent> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ErrorEvent as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ErrorEvent - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ErrorResponse {
    #[serde(rename = "error")]
          #[validate(nested)]
    pub error: models::Error,

}



impl ErrorResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(error: models::Error, ) -> ErrorResponse {
        ErrorResponse {
 error,
        }
    }
}

/// Converts the ErrorResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ErrorResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping error in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ErrorResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ErrorResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub error: Vec<models::Error>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ErrorResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(<models::Error as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ErrorResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ErrorResponse {
            error: intermediate_rep.error.into_iter().next().ok_or_else(|| "error missing in ErrorResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ErrorResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ErrorResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ErrorResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ErrorResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ErrorResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ErrorResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ErrorResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The ranking options for the file search. If not specified, the file search tool will use the `auto` ranker and a score_threshold of 0.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FileSearchRankingOptions {
    /// The ranker to use for the file search. If not specified will use the `auto` ranker.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "ranker")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ranker: Option<String>,

    /// The score threshold for the file search. All values must be a floating point number between 0 and 1.
    #[serde(rename = "score_threshold")]
    #[validate(
            range(min = 0f64, max = 1f64),
    )]
    pub score_threshold: f64,

}



impl FileSearchRankingOptions {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(score_threshold: f64, ) -> FileSearchRankingOptions {
        FileSearchRankingOptions {
 ranker: None,
 score_threshold,
        }
    }
}

/// Converts the FileSearchRankingOptions value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FileSearchRankingOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.ranker.as_ref().map(|ranker| {
                [
                    "ranker".to_string(),
                    ranker.to_string(),
                ].join(",")
            }),


            Some("score_threshold".to_string()),
            Some(self.score_threshold.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FileSearchRankingOptions value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FileSearchRankingOptions {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ranker: Vec<String>,
            pub score_threshold: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FileSearchRankingOptions".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ranker" => intermediate_rep.ranker.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "score_threshold" => intermediate_rep.score_threshold.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FileSearchRankingOptions".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FileSearchRankingOptions {
            ranker: intermediate_rep.ranker.into_iter().next(),
            score_threshold: intermediate_rep.score_threshold.into_iter().next().ok_or_else(|| "score_threshold missing in FileSearchRankingOptions".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FileSearchRankingOptions> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FileSearchRankingOptions>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FileSearchRankingOptions>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FileSearchRankingOptions - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FileSearchRankingOptions> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FileSearchRankingOptions as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FileSearchRankingOptions - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuneChatCompletionRequestAssistantMessage {
    #[serde(rename = "content")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<Nullable<models::ChatCompletionRequestAssistantMessageContent>>,

    /// The refusal message by the assistant.
    #[serde(rename = "refusal")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub refusal: Option<Nullable<String>>,

    /// The role of the messages author, in this case `assistant`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "audio")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audio: Option<Nullable<models::ChatCompletionRequestAssistantMessageAudio>>,

    /// The tool calls generated by the model, such as function calls.
    #[serde(rename = "tool_calls")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_calls: Option<Vec<models::ChatCompletionMessageToolCall>>,

    #[serde(rename = "function_call")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub function_call: Option<Nullable<models::ChatCompletionRequestAssistantMessageFunctionCall>>,

    /// Controls whether the assistant message is trained against (0 or 1)
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "weight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight: Option<i32>,

}



impl FineTuneChatCompletionRequestAssistantMessage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(role: String, ) -> FineTuneChatCompletionRequestAssistantMessage {
        FineTuneChatCompletionRequestAssistantMessage {
 content: None,
 refusal: None,
 role,
 name: None,
 audio: None,
 tool_calls: None,
 function_call: None,
 weight: None,
        }
    }
}

/// Converts the FineTuneChatCompletionRequestAssistantMessage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuneChatCompletionRequestAssistantMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping content in query parameter serialization


            self.refusal.as_ref().map(|refusal| {
                [
                    "refusal".to_string(),
                    refusal.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            Some("role".to_string()),
            Some(self.role.to_string()),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),

            // Skipping audio in query parameter serialization

            // Skipping tool_calls in query parameter serialization

            // Skipping function_call in query parameter serialization


            self.weight.as_ref().map(|weight| {
                [
                    "weight".to_string(),
                    weight.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuneChatCompletionRequestAssistantMessage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuneChatCompletionRequestAssistantMessage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub content: Vec<models::ChatCompletionRequestAssistantMessageContent>,
            pub refusal: Vec<String>,
            pub role: Vec<String>,
            pub name: Vec<String>,
            pub audio: Vec<models::ChatCompletionRequestAssistantMessageAudio>,
            pub tool_calls: Vec<Vec<models::ChatCompletionMessageToolCall>>,
            pub function_call: Vec<models::ChatCompletionRequestAssistantMessageFunctionCall>,
            pub weight: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuneChatCompletionRequestAssistantMessage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "content" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuneChatCompletionRequestAssistantMessage".to_string()),
                    "refusal" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuneChatCompletionRequestAssistantMessage".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "audio" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuneChatCompletionRequestAssistantMessage".to_string()),
                    "tool_calls" => return std::result::Result::Err("Parsing a container in this style is not supported in FineTuneChatCompletionRequestAssistantMessage".to_string()),
                    "function_call" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuneChatCompletionRequestAssistantMessage".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "weight" => intermediate_rep.weight.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuneChatCompletionRequestAssistantMessage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuneChatCompletionRequestAssistantMessage {
            content: std::result::Result::Err("Nullable types not supported in FineTuneChatCompletionRequestAssistantMessage".to_string())?,
            refusal: std::result::Result::Err("Nullable types not supported in FineTuneChatCompletionRequestAssistantMessage".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in FineTuneChatCompletionRequestAssistantMessage".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            audio: std::result::Result::Err("Nullable types not supported in FineTuneChatCompletionRequestAssistantMessage".to_string())?,
            tool_calls: intermediate_rep.tool_calls.into_iter().next(),
            function_call: std::result::Result::Err("Nullable types not supported in FineTuneChatCompletionRequestAssistantMessage".to_string())?,
            weight: intermediate_rep.weight.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuneChatCompletionRequestAssistantMessage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuneChatCompletionRequestAssistantMessage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuneChatCompletionRequestAssistantMessage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTuneChatCompletionRequestAssistantMessage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuneChatCompletionRequestAssistantMessage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuneChatCompletionRequestAssistantMessage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTuneChatCompletionRequestAssistantMessage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The per-line training example of a fine-tuning input file for chat models using the supervised method.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuneChatRequestInput {
    #[serde(rename = "messages")]
    #[validate(
            length(min = 1),
          nested,
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub messages: Option<Vec<models::FineTuneChatRequestInputMessagesInner>>,

    /// A list of tools the model may generate JSON inputs for.
    #[serde(rename = "tools")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Vec<models::ChatCompletionTool>>,

    /// Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
    #[serde(rename = "parallel_tool_calls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parallel_tool_calls: Option<bool>,

    /// A list of functions the model may generate JSON inputs for.
    #[serde(rename = "functions")]
    #[validate(
            length(min = 1, max = 128),
          nested,
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub functions: Option<Vec<models::ChatCompletionFunctions>>,

}



impl FineTuneChatRequestInput {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FineTuneChatRequestInput {
        FineTuneChatRequestInput {
 messages: None,
 tools: None,
 parallel_tool_calls: Some(true),
 functions: None,
        }
    }
}

/// Converts the FineTuneChatRequestInput value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuneChatRequestInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping messages in query parameter serialization

            // Skipping tools in query parameter serialization


            self.parallel_tool_calls.as_ref().map(|parallel_tool_calls| {
                [
                    "parallel_tool_calls".to_string(),
                    parallel_tool_calls.to_string(),
                ].join(",")
            }),

            // Skipping functions in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuneChatRequestInput value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuneChatRequestInput {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub messages: Vec<Vec<models::FineTuneChatRequestInputMessagesInner>>,
            pub tools: Vec<Vec<models::ChatCompletionTool>>,
            pub parallel_tool_calls: Vec<bool>,
            pub functions: Vec<Vec<models::ChatCompletionFunctions>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuneChatRequestInput".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "messages" => return std::result::Result::Err("Parsing a container in this style is not supported in FineTuneChatRequestInput".to_string()),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in FineTuneChatRequestInput".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "parallel_tool_calls" => intermediate_rep.parallel_tool_calls.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "functions" => return std::result::Result::Err("Parsing a container in this style is not supported in FineTuneChatRequestInput".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuneChatRequestInput".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuneChatRequestInput {
            messages: intermediate_rep.messages.into_iter().next(),
            tools: intermediate_rep.tools.into_iter().next(),
            parallel_tool_calls: intermediate_rep.parallel_tool_calls.into_iter().next(),
            functions: intermediate_rep.functions.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuneChatRequestInput> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuneChatRequestInput>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuneChatRequestInput>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTuneChatRequestInput - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuneChatRequestInput> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuneChatRequestInput as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTuneChatRequestInput - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum FineTuneChatRequestInputMessagesInner {
    ChatCompletionRequestSystemMessage(models::ChatCompletionRequestSystemMessage),
    ChatCompletionRequestUserMessage(models::ChatCompletionRequestUserMessage),
    FineTuneChatCompletionRequestAssistantMessage(models::FineTuneChatCompletionRequestAssistantMessage),
    ChatCompletionRequestToolMessage(models::ChatCompletionRequestToolMessage),
    ChatCompletionRequestFunctionMessage(models::ChatCompletionRequestFunctionMessage),
}

impl validator::Validate for FineTuneChatRequestInputMessagesInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::ChatCompletionRequestSystemMessage(v) => v.validate(),
            Self::ChatCompletionRequestUserMessage(v) => v.validate(),
            Self::FineTuneChatCompletionRequestAssistantMessage(v) => v.validate(),
            Self::ChatCompletionRequestToolMessage(v) => v.validate(),
            Self::ChatCompletionRequestFunctionMessage(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuneChatRequestInputMessagesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuneChatRequestInputMessagesInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::ChatCompletionRequestSystemMessage> for FineTuneChatRequestInputMessagesInner {
    fn from(value: models::ChatCompletionRequestSystemMessage) -> Self {
        Self::ChatCompletionRequestSystemMessage(value)
    }
}
impl From<models::ChatCompletionRequestUserMessage> for FineTuneChatRequestInputMessagesInner {
    fn from(value: models::ChatCompletionRequestUserMessage) -> Self {
        Self::ChatCompletionRequestUserMessage(value)
    }
}
impl From<models::FineTuneChatCompletionRequestAssistantMessage> for FineTuneChatRequestInputMessagesInner {
    fn from(value: models::FineTuneChatCompletionRequestAssistantMessage) -> Self {
        Self::FineTuneChatCompletionRequestAssistantMessage(value)
    }
}
impl From<models::ChatCompletionRequestToolMessage> for FineTuneChatRequestInputMessagesInner {
    fn from(value: models::ChatCompletionRequestToolMessage) -> Self {
        Self::ChatCompletionRequestToolMessage(value)
    }
}
impl From<models::ChatCompletionRequestFunctionMessage> for FineTuneChatRequestInputMessagesInner {
    fn from(value: models::ChatCompletionRequestFunctionMessage) -> Self {
        Self::ChatCompletionRequestFunctionMessage(value)
    }
}





/// The per-line training example of a fine-tuning input file for completions models
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuneCompletionRequestInput {
    /// The input prompt for this training example.
    #[serde(rename = "prompt")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub prompt: Option<String>,

    /// The desired completion for this training example.
    #[serde(rename = "completion")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub completion: Option<String>,

}



impl FineTuneCompletionRequestInput {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FineTuneCompletionRequestInput {
        FineTuneCompletionRequestInput {
 prompt: None,
 completion: None,
        }
    }
}

/// Converts the FineTuneCompletionRequestInput value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuneCompletionRequestInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.prompt.as_ref().map(|prompt| {
                [
                    "prompt".to_string(),
                    prompt.to_string(),
                ].join(",")
            }),


            self.completion.as_ref().map(|completion| {
                [
                    "completion".to_string(),
                    completion.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuneCompletionRequestInput value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuneCompletionRequestInput {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub prompt: Vec<String>,
            pub completion: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuneCompletionRequestInput".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "prompt" => intermediate_rep.prompt.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "completion" => intermediate_rep.completion.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuneCompletionRequestInput".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuneCompletionRequestInput {
            prompt: intermediate_rep.prompt.into_iter().next(),
            completion: intermediate_rep.completion.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuneCompletionRequestInput> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuneCompletionRequestInput>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuneCompletionRequestInput>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTuneCompletionRequestInput - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuneCompletionRequestInput> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuneCompletionRequestInput as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTuneCompletionRequestInput - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Configuration for the DPO fine-tuning method.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuneDpoMethod {
    #[serde(rename = "hyperparameters")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hyperparameters: Option<models::FineTuneDpoMethodHyperparameters>,

}



impl FineTuneDpoMethod {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FineTuneDpoMethod {
        FineTuneDpoMethod {
 hyperparameters: None,
        }
    }
}

/// Converts the FineTuneDpoMethod value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuneDpoMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping hyperparameters in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuneDpoMethod value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuneDpoMethod {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hyperparameters: Vec<models::FineTuneDpoMethodHyperparameters>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuneDpoMethod".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "hyperparameters" => intermediate_rep.hyperparameters.push(<models::FineTuneDpoMethodHyperparameters as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuneDpoMethod".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuneDpoMethod {
            hyperparameters: intermediate_rep.hyperparameters.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuneDpoMethod> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuneDpoMethod>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuneDpoMethod>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTuneDpoMethod - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuneDpoMethod> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuneDpoMethod as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTuneDpoMethod - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The hyperparameters used for the fine-tuning job.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuneDpoMethodHyperparameters {
    #[serde(rename = "beta")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub beta: Option<models::FineTuneDpoMethodHyperparametersBeta>,

    #[serde(rename = "batch_size")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub batch_size: Option<models::FineTuneDpoMethodHyperparametersBatchSize>,

    #[serde(rename = "learning_rate_multiplier")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub learning_rate_multiplier: Option<models::FineTuneDpoMethodHyperparametersLearningRateMultiplier>,

    #[serde(rename = "n_epochs")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub n_epochs: Option<models::FineTuneDpoMethodHyperparametersNEpochs>,

}



impl FineTuneDpoMethodHyperparameters {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FineTuneDpoMethodHyperparameters {
        FineTuneDpoMethodHyperparameters {
 beta: None,
 batch_size: None,
 learning_rate_multiplier: None,
 n_epochs: None,
        }
    }
}

/// Converts the FineTuneDpoMethodHyperparameters value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuneDpoMethodHyperparameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping beta in query parameter serialization

            // Skipping batch_size in query parameter serialization

            // Skipping learning_rate_multiplier in query parameter serialization

            // Skipping n_epochs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuneDpoMethodHyperparameters value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuneDpoMethodHyperparameters {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub beta: Vec<models::FineTuneDpoMethodHyperparametersBeta>,
            pub batch_size: Vec<models::FineTuneDpoMethodHyperparametersBatchSize>,
            pub learning_rate_multiplier: Vec<models::FineTuneDpoMethodHyperparametersLearningRateMultiplier>,
            pub n_epochs: Vec<models::FineTuneDpoMethodHyperparametersNEpochs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuneDpoMethodHyperparameters".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "beta" => intermediate_rep.beta.push(<models::FineTuneDpoMethodHyperparametersBeta as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "batch_size" => intermediate_rep.batch_size.push(<models::FineTuneDpoMethodHyperparametersBatchSize as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "learning_rate_multiplier" => intermediate_rep.learning_rate_multiplier.push(<models::FineTuneDpoMethodHyperparametersLearningRateMultiplier as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n_epochs" => intermediate_rep.n_epochs.push(<models::FineTuneDpoMethodHyperparametersNEpochs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuneDpoMethodHyperparameters".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuneDpoMethodHyperparameters {
            beta: intermediate_rep.beta.into_iter().next(),
            batch_size: intermediate_rep.batch_size.into_iter().next(),
            learning_rate_multiplier: intermediate_rep.learning_rate_multiplier.into_iter().next(),
            n_epochs: intermediate_rep.n_epochs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuneDpoMethodHyperparameters> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuneDpoMethodHyperparameters>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuneDpoMethodHyperparameters>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTuneDpoMethodHyperparameters - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuneDpoMethodHyperparameters> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuneDpoMethodHyperparameters as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTuneDpoMethodHyperparameters - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum FineTuneDpoMethodHyperparametersBatchSize {
    String(String),
    I32(i32),
}

impl validator::Validate for FineTuneDpoMethodHyperparametersBatchSize
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::I32(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuneDpoMethodHyperparametersBatchSize value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuneDpoMethodHyperparametersBatchSize {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for FineTuneDpoMethodHyperparametersBatchSize {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<i32> for FineTuneDpoMethodHyperparametersBatchSize {
    fn from(value: i32) -> Self {
        Self::I32(value)
    }
}





/// The beta value for the DPO method. A higher beta value will increase the weight of the penalty between the policy and reference model. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum FineTuneDpoMethodHyperparametersBeta {
    String(String),
    F64(f64),
}

impl validator::Validate for FineTuneDpoMethodHyperparametersBeta
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::F64(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuneDpoMethodHyperparametersBeta value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuneDpoMethodHyperparametersBeta {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for FineTuneDpoMethodHyperparametersBeta {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<f64> for FineTuneDpoMethodHyperparametersBeta {
    fn from(value: f64) -> Self {
        Self::F64(value)
    }
}





/// Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum FineTuneDpoMethodHyperparametersLearningRateMultiplier {
    String(String),
    F64(f64),
}

impl validator::Validate for FineTuneDpoMethodHyperparametersLearningRateMultiplier
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::F64(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuneDpoMethodHyperparametersLearningRateMultiplier value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuneDpoMethodHyperparametersLearningRateMultiplier {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for FineTuneDpoMethodHyperparametersLearningRateMultiplier {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<f64> for FineTuneDpoMethodHyperparametersLearningRateMultiplier {
    fn from(value: f64) -> Self {
        Self::F64(value)
    }
}





/// The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum FineTuneDpoMethodHyperparametersNEpochs {
    String(String),
    I32(i32),
}

impl validator::Validate for FineTuneDpoMethodHyperparametersNEpochs
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::I32(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuneDpoMethodHyperparametersNEpochs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuneDpoMethodHyperparametersNEpochs {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for FineTuneDpoMethodHyperparametersNEpochs {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<i32> for FineTuneDpoMethodHyperparametersNEpochs {
    fn from(value: i32) -> Self {
        Self::I32(value)
    }
}





/// The method used for fine-tuning.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuneMethod {
    /// The type of method. Is either `supervised` or `dpo`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    #[serde(rename = "supervised")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub supervised: Option<models::FineTuneSupervisedMethod>,

    #[serde(rename = "dpo")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dpo: Option<models::FineTuneDpoMethod>,

}



impl FineTuneMethod {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FineTuneMethod {
        FineTuneMethod {
 r_type: None,
 supervised: None,
 dpo: None,
        }
    }
}

/// Converts the FineTuneMethod value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuneMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),

            // Skipping supervised in query parameter serialization

            // Skipping dpo in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuneMethod value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuneMethod {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub supervised: Vec<models::FineTuneSupervisedMethod>,
            pub dpo: Vec<models::FineTuneDpoMethod>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuneMethod".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "supervised" => intermediate_rep.supervised.push(<models::FineTuneSupervisedMethod as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "dpo" => intermediate_rep.dpo.push(<models::FineTuneDpoMethod as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuneMethod".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuneMethod {
            r_type: intermediate_rep.r_type.into_iter().next(),
            supervised: intermediate_rep.supervised.into_iter().next(),
            dpo: intermediate_rep.dpo.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuneMethod> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuneMethod>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuneMethod>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTuneMethod - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuneMethod> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuneMethod as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTuneMethod - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The per-line training example of a fine-tuning input file for chat models using the dpo method.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTunePreferenceRequestInput {
    #[serde(rename = "input")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub input: Option<models::FineTunePreferenceRequestInputInput>,

    /// The preferred completion message for the output.
    #[serde(rename = "preferred_completion")]
    #[validate(
            length(max = 1),
          nested,
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferred_completion: Option<Vec<models::FineTunePreferenceRequestInputPreferredCompletionInner>>,

    /// The non-preferred completion message for the output.
    #[serde(rename = "non_preferred_completion")]
    #[validate(
            length(max = 1),
          nested,
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub non_preferred_completion: Option<Vec<models::FineTunePreferenceRequestInputPreferredCompletionInner>>,

}



impl FineTunePreferenceRequestInput {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FineTunePreferenceRequestInput {
        FineTunePreferenceRequestInput {
 input: None,
 preferred_completion: None,
 non_preferred_completion: None,
        }
    }
}

/// Converts the FineTunePreferenceRequestInput value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTunePreferenceRequestInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping input in query parameter serialization

            // Skipping preferred_completion in query parameter serialization

            // Skipping non_preferred_completion in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTunePreferenceRequestInput value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTunePreferenceRequestInput {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub input: Vec<models::FineTunePreferenceRequestInputInput>,
            pub preferred_completion: Vec<Vec<models::FineTunePreferenceRequestInputPreferredCompletionInner>>,
            pub non_preferred_completion: Vec<Vec<models::FineTunePreferenceRequestInputPreferredCompletionInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTunePreferenceRequestInput".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "input" => intermediate_rep.input.push(<models::FineTunePreferenceRequestInputInput as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "preferred_completion" => return std::result::Result::Err("Parsing a container in this style is not supported in FineTunePreferenceRequestInput".to_string()),
                    "non_preferred_completion" => return std::result::Result::Err("Parsing a container in this style is not supported in FineTunePreferenceRequestInput".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTunePreferenceRequestInput".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTunePreferenceRequestInput {
            input: intermediate_rep.input.into_iter().next(),
            preferred_completion: intermediate_rep.preferred_completion.into_iter().next(),
            non_preferred_completion: intermediate_rep.non_preferred_completion.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTunePreferenceRequestInput> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTunePreferenceRequestInput>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTunePreferenceRequestInput>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTunePreferenceRequestInput - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTunePreferenceRequestInput> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTunePreferenceRequestInput as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTunePreferenceRequestInput - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTunePreferenceRequestInputInput {
    #[serde(rename = "messages")]
    #[validate(
            length(min = 1),
          nested,
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub messages: Option<Vec<models::FineTuneChatRequestInputMessagesInner>>,

    /// A list of tools the model may generate JSON inputs for.
    #[serde(rename = "tools")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Vec<models::ChatCompletionTool>>,

    /// Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
    #[serde(rename = "parallel_tool_calls")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parallel_tool_calls: Option<bool>,

}



impl FineTunePreferenceRequestInputInput {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FineTunePreferenceRequestInputInput {
        FineTunePreferenceRequestInputInput {
 messages: None,
 tools: None,
 parallel_tool_calls: Some(true),
        }
    }
}

/// Converts the FineTunePreferenceRequestInputInput value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTunePreferenceRequestInputInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping messages in query parameter serialization

            // Skipping tools in query parameter serialization


            self.parallel_tool_calls.as_ref().map(|parallel_tool_calls| {
                [
                    "parallel_tool_calls".to_string(),
                    parallel_tool_calls.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTunePreferenceRequestInputInput value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTunePreferenceRequestInputInput {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub messages: Vec<Vec<models::FineTuneChatRequestInputMessagesInner>>,
            pub tools: Vec<Vec<models::ChatCompletionTool>>,
            pub parallel_tool_calls: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTunePreferenceRequestInputInput".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "messages" => return std::result::Result::Err("Parsing a container in this style is not supported in FineTunePreferenceRequestInputInput".to_string()),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in FineTunePreferenceRequestInputInput".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "parallel_tool_calls" => intermediate_rep.parallel_tool_calls.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTunePreferenceRequestInputInput".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTunePreferenceRequestInputInput {
            messages: intermediate_rep.messages.into_iter().next(),
            tools: intermediate_rep.tools.into_iter().next(),
            parallel_tool_calls: intermediate_rep.parallel_tool_calls.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTunePreferenceRequestInputInput> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTunePreferenceRequestInputInput>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTunePreferenceRequestInputInput>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTunePreferenceRequestInputInput - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTunePreferenceRequestInputInput> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTunePreferenceRequestInputInput as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTunePreferenceRequestInputInput - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum FineTunePreferenceRequestInputPreferredCompletionInner {
    ChatCompletionRequestAssistantMessage(models::ChatCompletionRequestAssistantMessage),
}

impl validator::Validate for FineTunePreferenceRequestInputPreferredCompletionInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::ChatCompletionRequestAssistantMessage(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTunePreferenceRequestInputPreferredCompletionInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTunePreferenceRequestInputPreferredCompletionInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::ChatCompletionRequestAssistantMessage> for FineTunePreferenceRequestInputPreferredCompletionInner {
    fn from(value: models::ChatCompletionRequestAssistantMessage) -> Self {
        Self::ChatCompletionRequestAssistantMessage(value)
    }
}





/// Configuration for the supervised fine-tuning method.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuneSupervisedMethod {
    #[serde(rename = "hyperparameters")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hyperparameters: Option<models::FineTuneSupervisedMethodHyperparameters>,

}



impl FineTuneSupervisedMethod {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FineTuneSupervisedMethod {
        FineTuneSupervisedMethod {
 hyperparameters: None,
        }
    }
}

/// Converts the FineTuneSupervisedMethod value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuneSupervisedMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping hyperparameters in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuneSupervisedMethod value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuneSupervisedMethod {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub hyperparameters: Vec<models::FineTuneSupervisedMethodHyperparameters>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuneSupervisedMethod".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "hyperparameters" => intermediate_rep.hyperparameters.push(<models::FineTuneSupervisedMethodHyperparameters as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuneSupervisedMethod".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuneSupervisedMethod {
            hyperparameters: intermediate_rep.hyperparameters.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuneSupervisedMethod> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuneSupervisedMethod>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuneSupervisedMethod>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTuneSupervisedMethod - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuneSupervisedMethod> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuneSupervisedMethod as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTuneSupervisedMethod - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The hyperparameters used for the fine-tuning job.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuneSupervisedMethodHyperparameters {
    #[serde(rename = "batch_size")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub batch_size: Option<models::FineTuneDpoMethodHyperparametersBatchSize>,

    #[serde(rename = "learning_rate_multiplier")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub learning_rate_multiplier: Option<models::FineTuneDpoMethodHyperparametersLearningRateMultiplier>,

    #[serde(rename = "n_epochs")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub n_epochs: Option<models::FineTuneDpoMethodHyperparametersNEpochs>,

}



impl FineTuneSupervisedMethodHyperparameters {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FineTuneSupervisedMethodHyperparameters {
        FineTuneSupervisedMethodHyperparameters {
 batch_size: None,
 learning_rate_multiplier: None,
 n_epochs: None,
        }
    }
}

/// Converts the FineTuneSupervisedMethodHyperparameters value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuneSupervisedMethodHyperparameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping batch_size in query parameter serialization

            // Skipping learning_rate_multiplier in query parameter serialization

            // Skipping n_epochs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuneSupervisedMethodHyperparameters value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuneSupervisedMethodHyperparameters {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub batch_size: Vec<models::FineTuneDpoMethodHyperparametersBatchSize>,
            pub learning_rate_multiplier: Vec<models::FineTuneDpoMethodHyperparametersLearningRateMultiplier>,
            pub n_epochs: Vec<models::FineTuneDpoMethodHyperparametersNEpochs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuneSupervisedMethodHyperparameters".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "batch_size" => intermediate_rep.batch_size.push(<models::FineTuneDpoMethodHyperparametersBatchSize as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "learning_rate_multiplier" => intermediate_rep.learning_rate_multiplier.push(<models::FineTuneDpoMethodHyperparametersLearningRateMultiplier as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n_epochs" => intermediate_rep.n_epochs.push(<models::FineTuneDpoMethodHyperparametersNEpochs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuneSupervisedMethodHyperparameters".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuneSupervisedMethodHyperparameters {
            batch_size: intermediate_rep.batch_size.into_iter().next(),
            learning_rate_multiplier: intermediate_rep.learning_rate_multiplier.into_iter().next(),
            n_epochs: intermediate_rep.n_epochs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuneSupervisedMethodHyperparameters> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuneSupervisedMethodHyperparameters>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuneSupervisedMethodHyperparameters>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTuneSupervisedMethodHyperparameters - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuneSupervisedMethodHyperparameters> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuneSupervisedMethodHyperparameters as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTuneSupervisedMethodHyperparameters - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuningIntegration {
    /// The type of the integration being enabled for the fine-tuning job
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "wandb")]
          #[validate(nested)]
    pub wandb: models::CreateFineTuningJobRequestIntegrationsInnerWandb,

}



impl FineTuningIntegration {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, wandb: models::CreateFineTuningJobRequestIntegrationsInnerWandb, ) -> FineTuningIntegration {
        FineTuningIntegration {
 r_type,
 wandb,
        }
    }
}

/// Converts the FineTuningIntegration value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuningIntegration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping wandb in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningIntegration value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningIntegration {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub wandb: Vec<models::CreateFineTuningJobRequestIntegrationsInnerWandb>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuningIntegration".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "wandb" => intermediate_rep.wandb.push(<models::CreateFineTuningJobRequestIntegrationsInnerWandb as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuningIntegration".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuningIntegration {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in FineTuningIntegration".to_string())?,
            wandb: intermediate_rep.wandb.into_iter().next().ok_or_else(|| "wandb missing in FineTuningIntegration".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuningIntegration> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuningIntegration>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuningIntegration>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTuningIntegration - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuningIntegration> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuningIntegration as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTuningIntegration - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The `fine_tuning.job` object represents a fine-tuning job that has been created through the API. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuningJob {
    /// The object identifier, which can be referenced in the API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    #[serde(rename = "error")]
    pub error: Nullable<models::FineTuningJobError>,

    /// The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
    #[serde(rename = "fine_tuned_model")]
    pub fine_tuned_model: Nullable<String>,

    /// The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
    #[serde(rename = "finished_at")]
    pub finished_at: Nullable<i32>,

    #[serde(rename = "hyperparameters")]
          #[validate(nested)]
    pub hyperparameters: models::FineTuningJobHyperparameters,

    /// The base model that is being fine-tuned.
    #[serde(rename = "model")]
          #[validate(custom(function = "check_xss_string"))]
    pub model: String,

    /// The object type, which is always \"fine_tuning.job\".
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The organization that owns the fine-tuning job.
    #[serde(rename = "organization_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub organization_id: String,

    /// The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](/docs/api-reference/files/retrieve-contents).
    #[serde(rename = "result_files")]
          #[validate(custom(function = "check_xss_vec_string"))]
    pub result_files: Vec<String>,

    /// The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
          #[validate(custom(function = "check_xss_string"))]
    pub status: String,

    /// The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
    #[serde(rename = "trained_tokens")]
    pub trained_tokens: Nullable<i32>,

    /// The file ID used for training. You can retrieve the training data with the [Files API](/docs/api-reference/files/retrieve-contents).
    #[serde(rename = "training_file")]
          #[validate(custom(function = "check_xss_string"))]
    pub training_file: String,

    /// The file ID used for validation. You can retrieve the validation results with the [Files API](/docs/api-reference/files/retrieve-contents).
    #[serde(rename = "validation_file")]
    pub validation_file: Nullable<String>,

    /// A list of integrations to enable for this fine-tuning job.
    #[serde(rename = "integrations")]
    #[validate(
            length(max = 5),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub integrations: Option<Nullable<Vec<models::FineTuningJobIntegrationsInner>>>,

    /// The seed used for the fine-tuning job.
    #[serde(rename = "seed")]
    pub seed: i32,

    /// The Unix timestamp (in seconds) for when the fine-tuning job is estimated to finish. The value will be null if the fine-tuning job is not running.
    #[serde(rename = "estimated_finish")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub estimated_finish: Option<Nullable<i32>>,

    #[serde(rename = "method")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub method: Option<models::FineTuneMethod>,

}



impl FineTuningJob {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, created_at: i32, error: Nullable<models::FineTuningJobError>, fine_tuned_model: Nullable<String>, finished_at: Nullable<i32>, hyperparameters: models::FineTuningJobHyperparameters, model: String, object: String, organization_id: String, result_files: Vec<String>, status: String, trained_tokens: Nullable<i32>, training_file: String, validation_file: Nullable<String>, seed: i32, ) -> FineTuningJob {
        FineTuningJob {
 id,
 created_at,
 error,
 fine_tuned_model,
 finished_at,
 hyperparameters,
 model,
 object,
 organization_id,
 result_files,
 status,
 trained_tokens,
 training_file,
 validation_file,
 integrations: None,
 seed,
 estimated_finish: None,
 method: None,
        }
    }
}

/// Converts the FineTuningJob value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuningJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),

            // Skipping error in query parameter serialization


            Some("fine_tuned_model".to_string()),
            Some(self.fine_tuned_model.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("finished_at".to_string()),
            Some(self.finished_at.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping hyperparameters in query parameter serialization


            Some("model".to_string()),
            Some(self.model.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("organization_id".to_string()),
            Some(self.organization_id.to_string()),


            Some("result_files".to_string()),
            Some(self.result_files.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("status".to_string()),
            Some(self.status.to_string()),


            Some("trained_tokens".to_string()),
            Some(self.trained_tokens.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("training_file".to_string()),
            Some(self.training_file.to_string()),


            Some("validation_file".to_string()),
            Some(self.validation_file.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping integrations in query parameter serialization


            Some("seed".to_string()),
            Some(self.seed.to_string()),


            self.estimated_finish.as_ref().map(|estimated_finish| {
                [
                    "estimated_finish".to_string(),
                    estimated_finish.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping method in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningJob value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningJob {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub created_at: Vec<i32>,
            pub error: Vec<models::FineTuningJobError>,
            pub fine_tuned_model: Vec<String>,
            pub finished_at: Vec<i32>,
            pub hyperparameters: Vec<models::FineTuningJobHyperparameters>,
            pub model: Vec<String>,
            pub object: Vec<String>,
            pub organization_id: Vec<String>,
            pub result_files: Vec<Vec<String>>,
            pub status: Vec<String>,
            pub trained_tokens: Vec<i32>,
            pub training_file: Vec<String>,
            pub validation_file: Vec<String>,
            pub integrations: Vec<Vec<models::FineTuningJobIntegrationsInner>>,
            pub seed: Vec<i32>,
            pub estimated_finish: Vec<i32>,
            pub method: Vec<models::FineTuneMethod>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuningJob".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "error" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuningJob".to_string()),
                    "fine_tuned_model" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuningJob".to_string()),
                    "finished_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuningJob".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "hyperparameters" => intermediate_rep.hyperparameters.push(<models::FineTuningJobHyperparameters as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "organization_id" => intermediate_rep.organization_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "result_files" => return std::result::Result::Err("Parsing a container in this style is not supported in FineTuningJob".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "trained_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuningJob".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "training_file" => intermediate_rep.training_file.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "validation_file" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuningJob".to_string()),
                    "integrations" => return std::result::Result::Err("Parsing a container in this style is not supported in FineTuningJob".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "seed" => intermediate_rep.seed.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "estimated_finish" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuningJob".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "method" => intermediate_rep.method.push(<models::FineTuneMethod as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuningJob".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuningJob {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in FineTuningJob".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in FineTuningJob".to_string())?,
            error: std::result::Result::Err("Nullable types not supported in FineTuningJob".to_string())?,
            fine_tuned_model: std::result::Result::Err("Nullable types not supported in FineTuningJob".to_string())?,
            finished_at: std::result::Result::Err("Nullable types not supported in FineTuningJob".to_string())?,
            hyperparameters: intermediate_rep.hyperparameters.into_iter().next().ok_or_else(|| "hyperparameters missing in FineTuningJob".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in FineTuningJob".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in FineTuningJob".to_string())?,
            organization_id: intermediate_rep.organization_id.into_iter().next().ok_or_else(|| "organization_id missing in FineTuningJob".to_string())?,
            result_files: intermediate_rep.result_files.into_iter().next().ok_or_else(|| "result_files missing in FineTuningJob".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in FineTuningJob".to_string())?,
            trained_tokens: std::result::Result::Err("Nullable types not supported in FineTuningJob".to_string())?,
            training_file: intermediate_rep.training_file.into_iter().next().ok_or_else(|| "training_file missing in FineTuningJob".to_string())?,
            validation_file: std::result::Result::Err("Nullable types not supported in FineTuningJob".to_string())?,
            integrations: std::result::Result::Err("Nullable types not supported in FineTuningJob".to_string())?,
            seed: intermediate_rep.seed.into_iter().next().ok_or_else(|| "seed missing in FineTuningJob".to_string())?,
            estimated_finish: std::result::Result::Err("Nullable types not supported in FineTuningJob".to_string())?,
            method: intermediate_rep.method.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuningJob> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuningJob>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuningJob>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTuningJob - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuningJob> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuningJob as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTuningJob - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The `fine_tuning.job.checkpoint` object represents a model checkpoint for a fine-tuning job that is ready to use. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuningJobCheckpoint {
    /// The checkpoint identifier, which can be referenced in the API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The Unix timestamp (in seconds) for when the checkpoint was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    /// The name of the fine-tuned checkpoint model that is created.
    #[serde(rename = "fine_tuned_model_checkpoint")]
          #[validate(custom(function = "check_xss_string"))]
    pub fine_tuned_model_checkpoint: String,

    /// The step number that the checkpoint was created at.
    #[serde(rename = "step_number")]
    pub step_number: i32,

    #[serde(rename = "metrics")]
          #[validate(nested)]
    pub metrics: models::FineTuningJobCheckpointMetrics,

    /// The name of the fine-tuning job that this checkpoint was created from.
    #[serde(rename = "fine_tuning_job_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub fine_tuning_job_id: String,

    /// The object type, which is always \"fine_tuning.job.checkpoint\".
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

}



impl FineTuningJobCheckpoint {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, created_at: i32, fine_tuned_model_checkpoint: String, step_number: i32, metrics: models::FineTuningJobCheckpointMetrics, fine_tuning_job_id: String, object: String, ) -> FineTuningJobCheckpoint {
        FineTuningJobCheckpoint {
 id,
 created_at,
 fine_tuned_model_checkpoint,
 step_number,
 metrics,
 fine_tuning_job_id,
 object,
        }
    }
}

/// Converts the FineTuningJobCheckpoint value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuningJobCheckpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("fine_tuned_model_checkpoint".to_string()),
            Some(self.fine_tuned_model_checkpoint.to_string()),


            Some("step_number".to_string()),
            Some(self.step_number.to_string()),

            // Skipping metrics in query parameter serialization


            Some("fine_tuning_job_id".to_string()),
            Some(self.fine_tuning_job_id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningJobCheckpoint value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningJobCheckpoint {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub created_at: Vec<i32>,
            pub fine_tuned_model_checkpoint: Vec<String>,
            pub step_number: Vec<i32>,
            pub metrics: Vec<models::FineTuningJobCheckpointMetrics>,
            pub fine_tuning_job_id: Vec<String>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuningJobCheckpoint".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fine_tuned_model_checkpoint" => intermediate_rep.fine_tuned_model_checkpoint.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "step_number" => intermediate_rep.step_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metrics" => intermediate_rep.metrics.push(<models::FineTuningJobCheckpointMetrics as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "fine_tuning_job_id" => intermediate_rep.fine_tuning_job_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuningJobCheckpoint".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuningJobCheckpoint {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in FineTuningJobCheckpoint".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in FineTuningJobCheckpoint".to_string())?,
            fine_tuned_model_checkpoint: intermediate_rep.fine_tuned_model_checkpoint.into_iter().next().ok_or_else(|| "fine_tuned_model_checkpoint missing in FineTuningJobCheckpoint".to_string())?,
            step_number: intermediate_rep.step_number.into_iter().next().ok_or_else(|| "step_number missing in FineTuningJobCheckpoint".to_string())?,
            metrics: intermediate_rep.metrics.into_iter().next().ok_or_else(|| "metrics missing in FineTuningJobCheckpoint".to_string())?,
            fine_tuning_job_id: intermediate_rep.fine_tuning_job_id.into_iter().next().ok_or_else(|| "fine_tuning_job_id missing in FineTuningJobCheckpoint".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in FineTuningJobCheckpoint".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuningJobCheckpoint> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuningJobCheckpoint>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuningJobCheckpoint>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTuningJobCheckpoint - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuningJobCheckpoint> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuningJobCheckpoint as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTuningJobCheckpoint - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Metrics at the step number during the fine-tuning job.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuningJobCheckpointMetrics {
    #[serde(rename = "step")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub step: Option<f64>,

    #[serde(rename = "train_loss")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub train_loss: Option<f64>,

    #[serde(rename = "train_mean_token_accuracy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub train_mean_token_accuracy: Option<f64>,

    #[serde(rename = "valid_loss")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub valid_loss: Option<f64>,

    #[serde(rename = "valid_mean_token_accuracy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub valid_mean_token_accuracy: Option<f64>,

    #[serde(rename = "full_valid_loss")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_valid_loss: Option<f64>,

    #[serde(rename = "full_valid_mean_token_accuracy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_valid_mean_token_accuracy: Option<f64>,

}



impl FineTuningJobCheckpointMetrics {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FineTuningJobCheckpointMetrics {
        FineTuningJobCheckpointMetrics {
 step: None,
 train_loss: None,
 train_mean_token_accuracy: None,
 valid_loss: None,
 valid_mean_token_accuracy: None,
 full_valid_loss: None,
 full_valid_mean_token_accuracy: None,
        }
    }
}

/// Converts the FineTuningJobCheckpointMetrics value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuningJobCheckpointMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.step.as_ref().map(|step| {
                [
                    "step".to_string(),
                    step.to_string(),
                ].join(",")
            }),


            self.train_loss.as_ref().map(|train_loss| {
                [
                    "train_loss".to_string(),
                    train_loss.to_string(),
                ].join(",")
            }),


            self.train_mean_token_accuracy.as_ref().map(|train_mean_token_accuracy| {
                [
                    "train_mean_token_accuracy".to_string(),
                    train_mean_token_accuracy.to_string(),
                ].join(",")
            }),


            self.valid_loss.as_ref().map(|valid_loss| {
                [
                    "valid_loss".to_string(),
                    valid_loss.to_string(),
                ].join(",")
            }),


            self.valid_mean_token_accuracy.as_ref().map(|valid_mean_token_accuracy| {
                [
                    "valid_mean_token_accuracy".to_string(),
                    valid_mean_token_accuracy.to_string(),
                ].join(",")
            }),


            self.full_valid_loss.as_ref().map(|full_valid_loss| {
                [
                    "full_valid_loss".to_string(),
                    full_valid_loss.to_string(),
                ].join(",")
            }),


            self.full_valid_mean_token_accuracy.as_ref().map(|full_valid_mean_token_accuracy| {
                [
                    "full_valid_mean_token_accuracy".to_string(),
                    full_valid_mean_token_accuracy.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningJobCheckpointMetrics value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningJobCheckpointMetrics {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub step: Vec<f64>,
            pub train_loss: Vec<f64>,
            pub train_mean_token_accuracy: Vec<f64>,
            pub valid_loss: Vec<f64>,
            pub valid_mean_token_accuracy: Vec<f64>,
            pub full_valid_loss: Vec<f64>,
            pub full_valid_mean_token_accuracy: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuningJobCheckpointMetrics".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "step" => intermediate_rep.step.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "train_loss" => intermediate_rep.train_loss.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "train_mean_token_accuracy" => intermediate_rep.train_mean_token_accuracy.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "valid_loss" => intermediate_rep.valid_loss.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "valid_mean_token_accuracy" => intermediate_rep.valid_mean_token_accuracy.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "full_valid_loss" => intermediate_rep.full_valid_loss.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "full_valid_mean_token_accuracy" => intermediate_rep.full_valid_mean_token_accuracy.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuningJobCheckpointMetrics".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuningJobCheckpointMetrics {
            step: intermediate_rep.step.into_iter().next(),
            train_loss: intermediate_rep.train_loss.into_iter().next(),
            train_mean_token_accuracy: intermediate_rep.train_mean_token_accuracy.into_iter().next(),
            valid_loss: intermediate_rep.valid_loss.into_iter().next(),
            valid_mean_token_accuracy: intermediate_rep.valid_mean_token_accuracy.into_iter().next(),
            full_valid_loss: intermediate_rep.full_valid_loss.into_iter().next(),
            full_valid_mean_token_accuracy: intermediate_rep.full_valid_mean_token_accuracy.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuningJobCheckpointMetrics> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuningJobCheckpointMetrics>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuningJobCheckpointMetrics>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTuningJobCheckpointMetrics - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuningJobCheckpointMetrics> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuningJobCheckpointMetrics as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTuningJobCheckpointMetrics - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuningJobError {
    /// A machine-readable error code.
    #[serde(rename = "code")]
          #[validate(custom(function = "check_xss_string"))]
    pub code: String,

    /// A human-readable error message.
    #[serde(rename = "message")]
          #[validate(custom(function = "check_xss_string"))]
    pub message: String,

    /// The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
    #[serde(rename = "param")]
    pub param: Nullable<String>,

}



impl FineTuningJobError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(code: String, message: String, param: Nullable<String>, ) -> FineTuningJobError {
        FineTuningJobError {
 code,
 message,
 param,
        }
    }
}

/// Converts the FineTuningJobError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuningJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("code".to_string()),
            Some(self.code.to_string()),


            Some("message".to_string()),
            Some(self.message.to_string()),


            Some("param".to_string()),
            Some(self.param.as_ref().map_or("null".to_string(), |x| x.to_string())),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningJobError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningJobError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<String>,
            pub message: Vec<String>,
            pub param: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuningJobError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "param" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FineTuningJobError".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuningJobError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuningJobError {
            code: intermediate_rep.code.into_iter().next().ok_or_else(|| "code missing in FineTuningJobError".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in FineTuningJobError".to_string())?,
            param: std::result::Result::Err("Nullable types not supported in FineTuningJobError".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuningJobError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuningJobError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuningJobError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTuningJobError - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuningJobError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuningJobError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTuningJobError - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Fine-tuning job event object
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuningJobEvent {
    /// The object type, which is always \"fine_tuning.job.event\".
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The object identifier.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The Unix timestamp (in seconds) for when the fine-tuning job was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    /// The log level of the event.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "level")]
          #[validate(custom(function = "check_xss_string"))]
    pub level: String,

    /// The message of the event.
    #[serde(rename = "message")]
          #[validate(custom(function = "check_xss_string"))]
    pub message: String,

    /// The type of event.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    /// The data associated with the event.
    #[serde(rename = "data")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data: Option<crate::types::Object>,

}



impl FineTuningJobEvent {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, id: String, created_at: i32, level: String, message: String, ) -> FineTuningJobEvent {
        FineTuningJobEvent {
 object,
 id,
 created_at,
 level,
 message,
 r_type: None,
 data: None,
        }
    }
}

/// Converts the FineTuningJobEvent value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuningJobEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("level".to_string()),
            Some(self.level.to_string()),


            Some("message".to_string()),
            Some(self.message.to_string()),


            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningJobEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningJobEvent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub id: Vec<String>,
            pub created_at: Vec<i32>,
            pub level: Vec<String>,
            pub message: Vec<String>,
            pub r_type: Vec<String>,
            pub data: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuningJobEvent".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "level" => intermediate_rep.level.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuningJobEvent".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuningJobEvent {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in FineTuningJobEvent".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in FineTuningJobEvent".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in FineTuningJobEvent".to_string())?,
            level: intermediate_rep.level.into_iter().next().ok_or_else(|| "level missing in FineTuningJobEvent".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in FineTuningJobEvent".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next(),
            data: intermediate_rep.data.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuningJobEvent> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuningJobEvent>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuningJobEvent>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTuningJobEvent - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuningJobEvent> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuningJobEvent as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTuningJobEvent - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The hyperparameters used for the fine-tuning job. This value will only be returned when running `supervised` jobs.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FineTuningJobHyperparameters {
    #[serde(rename = "batch_size")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub batch_size: Option<models::CreateFineTuningJobRequestHyperparametersBatchSize>,

    #[serde(rename = "learning_rate_multiplier")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub learning_rate_multiplier: Option<models::CreateFineTuningJobRequestHyperparametersLearningRateMultiplier>,

    #[serde(rename = "n_epochs")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub n_epochs: Option<models::CreateFineTuningJobRequestHyperparametersNEpochs>,

}



impl FineTuningJobHyperparameters {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> FineTuningJobHyperparameters {
        FineTuningJobHyperparameters {
 batch_size: None,
 learning_rate_multiplier: None,
 n_epochs: None,
        }
    }
}

/// Converts the FineTuningJobHyperparameters value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FineTuningJobHyperparameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping batch_size in query parameter serialization

            // Skipping learning_rate_multiplier in query parameter serialization

            // Skipping n_epochs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningJobHyperparameters value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningJobHyperparameters {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub batch_size: Vec<models::CreateFineTuningJobRequestHyperparametersBatchSize>,
            pub learning_rate_multiplier: Vec<models::CreateFineTuningJobRequestHyperparametersLearningRateMultiplier>,
            pub n_epochs: Vec<models::CreateFineTuningJobRequestHyperparametersNEpochs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FineTuningJobHyperparameters".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "batch_size" => intermediate_rep.batch_size.push(<models::CreateFineTuningJobRequestHyperparametersBatchSize as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "learning_rate_multiplier" => intermediate_rep.learning_rate_multiplier.push(<models::CreateFineTuningJobRequestHyperparametersLearningRateMultiplier as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "n_epochs" => intermediate_rep.n_epochs.push(<models::CreateFineTuningJobRequestHyperparametersNEpochs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FineTuningJobHyperparameters".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FineTuningJobHyperparameters {
            batch_size: intermediate_rep.batch_size.into_iter().next(),
            learning_rate_multiplier: intermediate_rep.learning_rate_multiplier.into_iter().next(),
            n_epochs: intermediate_rep.n_epochs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FineTuningJobHyperparameters> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FineTuningJobHyperparameters>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FineTuningJobHyperparameters>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FineTuningJobHyperparameters - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FineTuningJobHyperparameters> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FineTuningJobHyperparameters as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FineTuningJobHyperparameters - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum FineTuningJobIntegrationsInner {
    FineTuningIntegration(models::FineTuningIntegration),
}

impl validator::Validate for FineTuningJobIntegrationsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::FineTuningIntegration(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FineTuningJobIntegrationsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FineTuningJobIntegrationsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::FineTuningIntegration> for FineTuningJobIntegrationsInner {
    fn from(value: models::FineTuningIntegration) -> Self {
        Self::FineTuningIntegration(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FunctionObject {
    /// A description of what the function does, used by the model to choose when and how to call the function.
    #[serde(rename = "description")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    /// The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.   Omitting `parameters` defines a function with an empty parameter list.
    #[serde(rename = "parameters")]
          #[validate(custom(function = "check_xss_map"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<std::collections::HashMap<String, crate::types::Object>>,

    /// Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Learn more about Structured Outputs in the [function calling guide](docs/guides/function-calling).
    #[serde(rename = "strict")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub strict: Option<Nullable<bool>>,

}



impl FunctionObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> FunctionObject {
        FunctionObject {
 description: None,
 name,
 parameters: None,
 strict: Some(Nullable::Present(false)),
        }
    }
}

/// Converts the FunctionObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for FunctionObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping parameters in query parameter serialization
            // Skipping parameters in query parameter serialization


            self.strict.as_ref().map(|strict| {
                [
                    "strict".to_string(),
                    strict.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FunctionObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FunctionObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub name: Vec<String>,
            pub parameters: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub strict: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FunctionObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "parameters" => return std::result::Result::Err("Parsing a container in this style is not supported in FunctionObject".to_string()),
                    "strict" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FunctionObject".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing FunctionObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FunctionObject {
            description: intermediate_rep.description.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in FunctionObject".to_string())?,
            parameters: intermediate_rep.parameters.into_iter().next(),
            strict: std::result::Result::Err("Nullable types not supported in FunctionObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FunctionObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<FunctionObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FunctionObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for FunctionObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<FunctionObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FunctionObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into FunctionObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Represents the url or the content of an image generated by the OpenAI API.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Image {
    /// The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
    #[serde(rename = "b64_json")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub b64_json: Option<String>,

    /// The URL of the generated image, if `response_format` is `url` (default).
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,

    /// The prompt that was used to generate the image, if there was any revision to the prompt.
    #[serde(rename = "revised_prompt")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub revised_prompt: Option<String>,

}



impl Image {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Image {
        Image {
 b64_json: None,
 url: None,
 revised_prompt: None,
        }
    }
}

/// Converts the Image value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Image {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.b64_json.as_ref().map(|b64_json| {
                [
                    "b64_json".to_string(),
                    b64_json.to_string(),
                ].join(",")
            }),


            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.to_string(),
                ].join(",")
            }),


            self.revised_prompt.as_ref().map(|revised_prompt| {
                [
                    "revised_prompt".to_string(),
                    revised_prompt.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Image value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Image {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub b64_json: Vec<String>,
            pub url: Vec<String>,
            pub revised_prompt: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Image".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "b64_json" => intermediate_rep.b64_json.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "revised_prompt" => intermediate_rep.revised_prompt.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Image".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Image {
            b64_json: intermediate_rep.b64_json.into_iter().next(),
            url: intermediate_rep.url.into_iter().next(),
            revised_prompt: intermediate_rep.revised_prompt.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Image> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Image>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Image>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for Image - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Image> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Image as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into Image - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImagesResponse {
    #[serde(rename = "created")]
    pub created: i32,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::Image>,

}



impl ImagesResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(created: i32, data: Vec<models::Image>, ) -> ImagesResponse {
        ImagesResponse {
 created,
 data,
        }
    }
}

/// Converts the ImagesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ImagesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("created".to_string()),
            Some(self.created.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImagesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImagesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub created: Vec<i32>,
            pub data: Vec<Vec<models::Image>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImagesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ImagesResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImagesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImagesResponse {
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "created missing in ImagesResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ImagesResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImagesResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ImagesResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImagesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ImagesResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ImagesResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImagesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ImagesResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Represents an individual `invite` to the organization.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Invite {
    /// The object type, which is always `organization.invite`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The identifier, which can be referenced in API endpoints
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The email address of the individual to whom the invite was sent
    #[serde(rename = "email")]
          #[validate(custom(function = "check_xss_string"))]
    pub email: String,

    /// `owner` or `reader`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    /// `accepted`,`expired`, or `pending`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
          #[validate(custom(function = "check_xss_string"))]
    pub status: String,

    /// The Unix timestamp (in seconds) of when the invite was sent.
    #[serde(rename = "invited_at")]
    pub invited_at: i32,

    /// The Unix timestamp (in seconds) of when the invite expires.
    #[serde(rename = "expires_at")]
    pub expires_at: i32,

    /// The Unix timestamp (in seconds) of when the invite was accepted.
    #[serde(rename = "accepted_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub accepted_at: Option<i32>,

    /// The projects that were granted membership upon acceptance of the invite.
    #[serde(rename = "projects")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects: Option<Vec<models::InviteProjectsInner>>,

}



impl Invite {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, id: String, email: String, role: String, status: String, invited_at: i32, expires_at: i32, ) -> Invite {
        Invite {
 object,
 id,
 email,
 role,
 status,
 invited_at,
 expires_at,
 accepted_at: None,
 projects: None,
        }
    }
}

/// Converts the Invite value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Invite {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("email".to_string()),
            Some(self.email.to_string()),


            Some("role".to_string()),
            Some(self.role.to_string()),


            Some("status".to_string()),
            Some(self.status.to_string()),


            Some("invited_at".to_string()),
            Some(self.invited_at.to_string()),


            Some("expires_at".to_string()),
            Some(self.expires_at.to_string()),


            self.accepted_at.as_ref().map(|accepted_at| {
                [
                    "accepted_at".to_string(),
                    accepted_at.to_string(),
                ].join(",")
            }),

            // Skipping projects in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Invite value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Invite {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub id: Vec<String>,
            pub email: Vec<String>,
            pub role: Vec<String>,
            pub status: Vec<String>,
            pub invited_at: Vec<i32>,
            pub expires_at: Vec<i32>,
            pub accepted_at: Vec<i32>,
            pub projects: Vec<Vec<models::InviteProjectsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Invite".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "invited_at" => intermediate_rep.invited_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expires_at" => intermediate_rep.expires_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "accepted_at" => intermediate_rep.accepted_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "projects" => return std::result::Result::Err("Parsing a container in this style is not supported in Invite".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Invite".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Invite {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in Invite".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in Invite".to_string())?,
            email: intermediate_rep.email.into_iter().next().ok_or_else(|| "email missing in Invite".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in Invite".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in Invite".to_string())?,
            invited_at: intermediate_rep.invited_at.into_iter().next().ok_or_else(|| "invited_at missing in Invite".to_string())?,
            expires_at: intermediate_rep.expires_at.into_iter().next().ok_or_else(|| "expires_at missing in Invite".to_string())?,
            accepted_at: intermediate_rep.accepted_at.into_iter().next(),
            projects: intermediate_rep.projects.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Invite> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Invite>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Invite>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for Invite - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Invite> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Invite as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into Invite - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InviteDeleteResponse {
    /// The object type, which is always `organization.invite.deleted`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

}



impl InviteDeleteResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, id: String, deleted: bool, ) -> InviteDeleteResponse {
        InviteDeleteResponse {
 object,
 id,
 deleted,
        }
    }
}

/// Converts the InviteDeleteResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InviteDeleteResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InviteDeleteResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InviteDeleteResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InviteDeleteResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InviteDeleteResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InviteDeleteResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in InviteDeleteResponse".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in InviteDeleteResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in InviteDeleteResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InviteDeleteResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InviteDeleteResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InviteDeleteResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for InviteDeleteResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InviteDeleteResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InviteDeleteResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into InviteDeleteResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InviteListResponse {
    /// The object type, which is always `list`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::Invite>,

    /// The first `invite_id` in the retrieved `list`
    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub first_id: Option<String>,

    /// The last `invite_id` in the retrieved `list`
    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_id: Option<String>,

    /// The `has_more` property is used for pagination to indicate there are additional results.
    #[serde(rename = "has_more")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_more: Option<bool>,

}



impl InviteListResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::Invite>, ) -> InviteListResponse {
        InviteListResponse {
 object,
 data,
 first_id: None,
 last_id: None,
 has_more: None,
        }
    }
}

/// Converts the InviteListResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InviteListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            self.first_id.as_ref().map(|first_id| {
                [
                    "first_id".to_string(),
                    first_id.to_string(),
                ].join(",")
            }),


            self.last_id.as_ref().map(|last_id| {
                [
                    "last_id".to_string(),
                    last_id.to_string(),
                ].join(",")
            }),


            self.has_more.as_ref().map(|has_more| {
                [
                    "has_more".to_string(),
                    has_more.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InviteListResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InviteListResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::Invite>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InviteListResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in InviteListResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InviteListResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InviteListResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in InviteListResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in InviteListResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next(),
            last_id: intermediate_rep.last_id.into_iter().next(),
            has_more: intermediate_rep.has_more.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InviteListResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InviteListResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InviteListResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for InviteListResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InviteListResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InviteListResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into InviteListResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InviteProjectsInner {
    /// Project's public ID
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Project membership role
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,

}



impl InviteProjectsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> InviteProjectsInner {
        InviteProjectsInner {
 id: None,
 role: None,
        }
    }
}

/// Converts the InviteProjectsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InviteProjectsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.role.as_ref().map(|role| {
                [
                    "role".to_string(),
                    role.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InviteProjectsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InviteProjectsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub role: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InviteProjectsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InviteProjectsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InviteProjectsInner {
            id: intermediate_rep.id.into_iter().next(),
            role: intermediate_rep.role.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InviteProjectsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InviteProjectsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InviteProjectsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for InviteProjectsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InviteProjectsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InviteProjectsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into InviteProjectsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InviteRequest {
    /// Send an email to this address
    #[serde(rename = "email")]
          #[validate(custom(function = "check_xss_string"))]
    pub email: String,

    /// `owner` or `reader`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    /// An array of projects to which membership is granted at the same time the org invite is accepted. If omitted, the user will be invited to the default project for compatibility with legacy behavior.
    #[serde(rename = "projects")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects: Option<Vec<models::InviteRequestProjectsInner>>,

}



impl InviteRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(email: String, role: String, ) -> InviteRequest {
        InviteRequest {
 email,
 role,
 projects: None,
        }
    }
}

/// Converts the InviteRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InviteRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("email".to_string()),
            Some(self.email.to_string()),


            Some("role".to_string()),
            Some(self.role.to_string()),

            // Skipping projects in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InviteRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InviteRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub email: Vec<String>,
            pub role: Vec<String>,
            pub projects: Vec<Vec<models::InviteRequestProjectsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InviteRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "projects" => return std::result::Result::Err("Parsing a container in this style is not supported in InviteRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing InviteRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InviteRequest {
            email: intermediate_rep.email.into_iter().next().ok_or_else(|| "email missing in InviteRequest".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in InviteRequest".to_string())?,
            projects: intermediate_rep.projects.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InviteRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InviteRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InviteRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for InviteRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InviteRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InviteRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into InviteRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct InviteRequestProjectsInner {
    /// Project's public ID
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// Project membership role
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

}



impl InviteRequestProjectsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, role: String, ) -> InviteRequestProjectsInner {
        InviteRequestProjectsInner {
 id,
 role,
        }
    }
}

/// Converts the InviteRequestProjectsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for InviteRequestProjectsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("role".to_string()),
            Some(self.role.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a InviteRequestProjectsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for InviteRequestProjectsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub role: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing InviteRequestProjectsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing InviteRequestProjectsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(InviteRequestProjectsInner {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in InviteRequestProjectsInner".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in InviteRequestProjectsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<InviteRequestProjectsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<InviteRequestProjectsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<InviteRequestProjectsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for InviteRequestProjectsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<InviteRequestProjectsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <InviteRequestProjectsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into InviteRequestProjectsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListAssistantsResponse {
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::AssistantObject>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub first_id: String,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl ListAssistantsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::AssistantObject>, first_id: String, last_id: String, has_more: bool, ) -> ListAssistantsResponse {
        ListAssistantsResponse {
 object,
 data,
 first_id,
 last_id,
 has_more,
        }
    }
}

/// Converts the ListAssistantsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListAssistantsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListAssistantsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListAssistantsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::AssistantObject>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListAssistantsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListAssistantsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListAssistantsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListAssistantsResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListAssistantsResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListAssistantsResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListAssistantsResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListAssistantsResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListAssistantsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListAssistantsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListAssistantsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListAssistantsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ListAssistantsResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListAssistantsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListAssistantsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ListAssistantsResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListAuditLogsEffectiveAtParameter {
    /// Return only events whose `effective_at` (Unix seconds) is greater than this value.
    #[serde(rename = "gt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gt: Option<i32>,

    /// Return only events whose `effective_at` (Unix seconds) is greater than or equal to this value.
    #[serde(rename = "gte")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gte: Option<i32>,

    /// Return only events whose `effective_at` (Unix seconds) is less than this value.
    #[serde(rename = "lt")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lt: Option<i32>,

    /// Return only events whose `effective_at` (Unix seconds) is less than or equal to this value.
    #[serde(rename = "lte")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lte: Option<i32>,

}



impl ListAuditLogsEffectiveAtParameter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ListAuditLogsEffectiveAtParameter {
        ListAuditLogsEffectiveAtParameter {
 gt: None,
 gte: None,
 lt: None,
 lte: None,
        }
    }
}

/// Converts the ListAuditLogsEffectiveAtParameter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListAuditLogsEffectiveAtParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.gt.as_ref().map(|gt| {
                [
                    "gt".to_string(),
                    gt.to_string(),
                ].join(",")
            }),


            self.gte.as_ref().map(|gte| {
                [
                    "gte".to_string(),
                    gte.to_string(),
                ].join(",")
            }),


            self.lt.as_ref().map(|lt| {
                [
                    "lt".to_string(),
                    lt.to_string(),
                ].join(",")
            }),


            self.lte.as_ref().map(|lte| {
                [
                    "lte".to_string(),
                    lte.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListAuditLogsEffectiveAtParameter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListAuditLogsEffectiveAtParameter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub gt: Vec<i32>,
            pub gte: Vec<i32>,
            pub lt: Vec<i32>,
            pub lte: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListAuditLogsEffectiveAtParameter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "gt" => intermediate_rep.gt.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gte" => intermediate_rep.gte.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lt" => intermediate_rep.lt.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "lte" => intermediate_rep.lte.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListAuditLogsEffectiveAtParameter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListAuditLogsEffectiveAtParameter {
            gt: intermediate_rep.gt.into_iter().next(),
            gte: intermediate_rep.gte.into_iter().next(),
            lt: intermediate_rep.lt.into_iter().next(),
            lte: intermediate_rep.lte.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListAuditLogsEffectiveAtParameter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListAuditLogsEffectiveAtParameter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListAuditLogsEffectiveAtParameter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ListAuditLogsEffectiveAtParameter - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListAuditLogsEffectiveAtParameter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListAuditLogsEffectiveAtParameter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ListAuditLogsEffectiveAtParameter - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListAuditLogsResponse {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::AuditLog>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub first_id: String,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl ListAuditLogsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::AuditLog>, first_id: String, last_id: String, has_more: bool, ) -> ListAuditLogsResponse {
        ListAuditLogsResponse {
 object,
 data,
 first_id,
 last_id,
 has_more,
        }
    }
}

/// Converts the ListAuditLogsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListAuditLogsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListAuditLogsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListAuditLogsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::AuditLog>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListAuditLogsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListAuditLogsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListAuditLogsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListAuditLogsResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListAuditLogsResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListAuditLogsResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListAuditLogsResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListAuditLogsResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListAuditLogsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListAuditLogsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListAuditLogsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListAuditLogsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ListAuditLogsResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListAuditLogsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListAuditLogsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ListAuditLogsResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListBatchesResponse {
    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::Batch>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub first_id: Option<String>,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_id: Option<String>,

    #[serde(rename = "has_more")]
    pub has_more: bool,

    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

}



impl ListBatchesResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(data: Vec<models::Batch>, has_more: bool, object: String, ) -> ListBatchesResponse {
        ListBatchesResponse {
 data,
 first_id: None,
 last_id: None,
 has_more,
 object,
        }
    }
}

/// Converts the ListBatchesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListBatchesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization


            self.first_id.as_ref().map(|first_id| {
                [
                    "first_id".to_string(),
                    first_id.to_string(),
                ].join(",")
            }),


            self.last_id.as_ref().map(|last_id| {
                [
                    "last_id".to_string(),
                    last_id.to_string(),
                ].join(",")
            }),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListBatchesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListBatchesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<Vec<models::Batch>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListBatchesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListBatchesResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListBatchesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListBatchesResponse {
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListBatchesResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next(),
            last_id: intermediate_rep.last_id.into_iter().next(),
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListBatchesResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListBatchesResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListBatchesResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListBatchesResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListBatchesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ListBatchesResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListBatchesResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListBatchesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ListBatchesResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListFilesResponse {
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::OpenAiFile>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub first_id: String,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl ListFilesResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::OpenAiFile>, first_id: String, last_id: String, has_more: bool, ) -> ListFilesResponse {
        ListFilesResponse {
 object,
 data,
 first_id,
 last_id,
 has_more,
        }
    }
}

/// Converts the ListFilesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListFilesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListFilesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListFilesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::OpenAiFile>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListFilesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListFilesResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListFilesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListFilesResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListFilesResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListFilesResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListFilesResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListFilesResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListFilesResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListFilesResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListFilesResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListFilesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ListFilesResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListFilesResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListFilesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ListFilesResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListFineTuningJobCheckpointsResponse {
    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::FineTuningJobCheckpoint>,

    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "first_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub first_id: Option<Nullable<String>>,

    #[serde(rename = "last_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_id: Option<Nullable<String>>,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl ListFineTuningJobCheckpointsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(data: Vec<models::FineTuningJobCheckpoint>, object: String, has_more: bool, ) -> ListFineTuningJobCheckpointsResponse {
        ListFineTuningJobCheckpointsResponse {
 data,
 object,
 first_id: None,
 last_id: None,
 has_more,
        }
    }
}

/// Converts the ListFineTuningJobCheckpointsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListFineTuningJobCheckpointsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization


            Some("object".to_string()),
            Some(self.object.to_string()),


            self.first_id.as_ref().map(|first_id| {
                [
                    "first_id".to_string(),
                    first_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.last_id.as_ref().map(|last_id| {
                [
                    "last_id".to_string(),
                    last_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListFineTuningJobCheckpointsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListFineTuningJobCheckpointsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<Vec<models::FineTuningJobCheckpoint>>,
            pub object: Vec<String>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListFineTuningJobCheckpointsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListFineTuningJobCheckpointsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "first_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ListFineTuningJobCheckpointsResponse".to_string()),
                    "last_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ListFineTuningJobCheckpointsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListFineTuningJobCheckpointsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListFineTuningJobCheckpointsResponse {
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListFineTuningJobCheckpointsResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListFineTuningJobCheckpointsResponse".to_string())?,
            first_id: std::result::Result::Err("Nullable types not supported in ListFineTuningJobCheckpointsResponse".to_string())?,
            last_id: std::result::Result::Err("Nullable types not supported in ListFineTuningJobCheckpointsResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListFineTuningJobCheckpointsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListFineTuningJobCheckpointsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListFineTuningJobCheckpointsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListFineTuningJobCheckpointsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ListFineTuningJobCheckpointsResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListFineTuningJobCheckpointsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListFineTuningJobCheckpointsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ListFineTuningJobCheckpointsResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListFineTuningJobEventsResponse {
    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::FineTuningJobEvent>,

    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

}



impl ListFineTuningJobEventsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(data: Vec<models::FineTuningJobEvent>, object: String, ) -> ListFineTuningJobEventsResponse {
        ListFineTuningJobEventsResponse {
 data,
 object,
        }
    }
}

/// Converts the ListFineTuningJobEventsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListFineTuningJobEventsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListFineTuningJobEventsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListFineTuningJobEventsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<Vec<models::FineTuningJobEvent>>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListFineTuningJobEventsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListFineTuningJobEventsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListFineTuningJobEventsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListFineTuningJobEventsResponse {
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListFineTuningJobEventsResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListFineTuningJobEventsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListFineTuningJobEventsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListFineTuningJobEventsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListFineTuningJobEventsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ListFineTuningJobEventsResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListFineTuningJobEventsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListFineTuningJobEventsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ListFineTuningJobEventsResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListMessagesResponse {
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::MessageObject>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub first_id: String,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl ListMessagesResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::MessageObject>, first_id: String, last_id: String, has_more: bool, ) -> ListMessagesResponse {
        ListMessagesResponse {
 object,
 data,
 first_id,
 last_id,
 has_more,
        }
    }
}

/// Converts the ListMessagesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListMessagesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListMessagesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListMessagesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::MessageObject>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListMessagesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListMessagesResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListMessagesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListMessagesResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListMessagesResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListMessagesResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListMessagesResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListMessagesResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListMessagesResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListMessagesResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListMessagesResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListMessagesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ListMessagesResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListMessagesResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListMessagesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ListMessagesResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListModelsResponse {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::Model>,

}



impl ListModelsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::Model>, ) -> ListModelsResponse {
        ListModelsResponse {
 object,
 data,
        }
    }
}

/// Converts the ListModelsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListModelsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListModelsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListModelsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::Model>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListModelsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListModelsResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListModelsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListModelsResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListModelsResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListModelsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListModelsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListModelsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListModelsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ListModelsResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListModelsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListModelsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ListModelsResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListPaginatedFineTuningJobsResponse {
    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::FineTuningJob>,

    #[serde(rename = "has_more")]
    pub has_more: bool,

    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

}



impl ListPaginatedFineTuningJobsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(data: Vec<models::FineTuningJob>, has_more: bool, object: String, ) -> ListPaginatedFineTuningJobsResponse {
        ListPaginatedFineTuningJobsResponse {
 data,
 has_more,
 object,
        }
    }
}

/// Converts the ListPaginatedFineTuningJobsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListPaginatedFineTuningJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping data in query parameter serialization


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListPaginatedFineTuningJobsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListPaginatedFineTuningJobsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub data: Vec<Vec<models::FineTuningJob>>,
            pub has_more: Vec<bool>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListPaginatedFineTuningJobsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListPaginatedFineTuningJobsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListPaginatedFineTuningJobsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListPaginatedFineTuningJobsResponse {
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListPaginatedFineTuningJobsResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListPaginatedFineTuningJobsResponse".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListPaginatedFineTuningJobsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListPaginatedFineTuningJobsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListPaginatedFineTuningJobsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListPaginatedFineTuningJobsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ListPaginatedFineTuningJobsResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListPaginatedFineTuningJobsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListPaginatedFineTuningJobsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ListPaginatedFineTuningJobsResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListRunStepsResponse {
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::RunStepObject>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub first_id: String,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl ListRunStepsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::RunStepObject>, first_id: String, last_id: String, has_more: bool, ) -> ListRunStepsResponse {
        ListRunStepsResponse {
 object,
 data,
 first_id,
 last_id,
 has_more,
        }
    }
}

/// Converts the ListRunStepsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListRunStepsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListRunStepsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListRunStepsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::RunStepObject>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListRunStepsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListRunStepsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListRunStepsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListRunStepsResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListRunStepsResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListRunStepsResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListRunStepsResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListRunStepsResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListRunStepsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListRunStepsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListRunStepsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListRunStepsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ListRunStepsResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListRunStepsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListRunStepsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ListRunStepsResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListRunsResponse {
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::RunObject>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub first_id: String,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl ListRunsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::RunObject>, first_id: String, last_id: String, has_more: bool, ) -> ListRunsResponse {
        ListRunsResponse {
 object,
 data,
 first_id,
 last_id,
 has_more,
        }
    }
}

/// Converts the ListRunsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListRunsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListRunsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListRunsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::RunObject>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListRunsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListRunsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListRunsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListRunsResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListRunsResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListRunsResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListRunsResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListRunsResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListRunsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListRunsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListRunsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListRunsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ListRunsResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListRunsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListRunsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ListRunsResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListThreadsResponse {
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::ThreadObject>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub first_id: String,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl ListThreadsResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::ThreadObject>, first_id: String, last_id: String, has_more: bool, ) -> ListThreadsResponse {
        ListThreadsResponse {
 object,
 data,
 first_id,
 last_id,
 has_more,
        }
    }
}

/// Converts the ListThreadsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListThreadsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListThreadsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListThreadsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::ThreadObject>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListThreadsResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListThreadsResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListThreadsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListThreadsResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListThreadsResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListThreadsResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListThreadsResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListThreadsResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListThreadsResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListThreadsResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListThreadsResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListThreadsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ListThreadsResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListThreadsResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListThreadsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ListThreadsResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListVectorStoreFilesResponse {
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::VectorStoreFileObject>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub first_id: String,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl ListVectorStoreFilesResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::VectorStoreFileObject>, first_id: String, last_id: String, has_more: bool, ) -> ListVectorStoreFilesResponse {
        ListVectorStoreFilesResponse {
 object,
 data,
 first_id,
 last_id,
 has_more,
        }
    }
}

/// Converts the ListVectorStoreFilesResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListVectorStoreFilesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListVectorStoreFilesResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListVectorStoreFilesResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::VectorStoreFileObject>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListVectorStoreFilesResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListVectorStoreFilesResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListVectorStoreFilesResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListVectorStoreFilesResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListVectorStoreFilesResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListVectorStoreFilesResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListVectorStoreFilesResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListVectorStoreFilesResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListVectorStoreFilesResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListVectorStoreFilesResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListVectorStoreFilesResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListVectorStoreFilesResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ListVectorStoreFilesResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListVectorStoreFilesResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListVectorStoreFilesResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ListVectorStoreFilesResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ListVectorStoresResponse {
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::VectorStoreObject>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub first_id: String,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl ListVectorStoresResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::VectorStoreObject>, first_id: String, last_id: String, has_more: bool, ) -> ListVectorStoresResponse {
        ListVectorStoresResponse {
 object,
 data,
 first_id,
 last_id,
 has_more,
        }
    }
}

/// Converts the ListVectorStoresResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ListVectorStoresResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ListVectorStoresResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ListVectorStoresResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::VectorStoreObject>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ListVectorStoresResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ListVectorStoresResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ListVectorStoresResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ListVectorStoresResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ListVectorStoresResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ListVectorStoresResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ListVectorStoresResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ListVectorStoresResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ListVectorStoresResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ListVectorStoresResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ListVectorStoresResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ListVectorStoresResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ListVectorStoresResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ListVectorStoresResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ListVectorStoresResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ListVectorStoresResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// References an image [File](/docs/api-reference/files) in the content of a message.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentImageFileObject {
    /// Always `image_file`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "image_file")]
          #[validate(nested)]
    pub image_file: models::MessageContentImageFileObjectImageFile,

}



impl MessageContentImageFileObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, image_file: models::MessageContentImageFileObjectImageFile, ) -> MessageContentImageFileObject {
        MessageContentImageFileObject {
 r_type,
 image_file,
        }
    }
}

/// Converts the MessageContentImageFileObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentImageFileObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping image_file in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentImageFileObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentImageFileObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub image_file: Vec<models::MessageContentImageFileObjectImageFile>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentImageFileObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_file" => intermediate_rep.image_file.push(<models::MessageContentImageFileObjectImageFile as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentImageFileObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentImageFileObject {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in MessageContentImageFileObject".to_string())?,
            image_file: intermediate_rep.image_file.into_iter().next().ok_or_else(|| "image_file missing in MessageContentImageFileObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentImageFileObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentImageFileObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentImageFileObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageContentImageFileObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentImageFileObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentImageFileObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageContentImageFileObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentImageFileObjectImageFile {
    /// The [File](/docs/api-reference/files) ID of the image in the message content. Set `purpose=\"vision\"` when uploading the File if you need to later display the file content.
    #[serde(rename = "file_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub file_id: String,

    /// Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "detail")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub detail: Option<String>,

}



impl MessageContentImageFileObjectImageFile {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(file_id: String, ) -> MessageContentImageFileObjectImageFile {
        MessageContentImageFileObjectImageFile {
 file_id,
 detail: None,
        }
    }
}

/// Converts the MessageContentImageFileObjectImageFile value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentImageFileObjectImageFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("file_id".to_string()),
            Some(self.file_id.to_string()),


            self.detail.as_ref().map(|detail| {
                [
                    "detail".to_string(),
                    detail.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentImageFileObjectImageFile value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentImageFileObjectImageFile {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
            pub detail: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentImageFileObjectImageFile".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "detail" => intermediate_rep.detail.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentImageFileObjectImageFile".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentImageFileObjectImageFile {
            file_id: intermediate_rep.file_id.into_iter().next().ok_or_else(|| "file_id missing in MessageContentImageFileObjectImageFile".to_string())?,
            detail: intermediate_rep.detail.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentImageFileObjectImageFile> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentImageFileObjectImageFile>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentImageFileObjectImageFile>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageContentImageFileObjectImageFile - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentImageFileObjectImageFile> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentImageFileObjectImageFile as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageContentImageFileObjectImageFile - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// References an image URL in the content of a message.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentImageUrlObject {
    /// The type of the content part.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "image_url")]
          #[validate(nested)]
    pub image_url: models::MessageContentImageUrlObjectImageUrl,

}



impl MessageContentImageUrlObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, image_url: models::MessageContentImageUrlObjectImageUrl, ) -> MessageContentImageUrlObject {
        MessageContentImageUrlObject {
 r_type,
 image_url,
        }
    }
}

/// Converts the MessageContentImageUrlObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentImageUrlObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping image_url in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentImageUrlObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentImageUrlObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub image_url: Vec<models::MessageContentImageUrlObjectImageUrl>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentImageUrlObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_url" => intermediate_rep.image_url.push(<models::MessageContentImageUrlObjectImageUrl as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentImageUrlObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentImageUrlObject {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in MessageContentImageUrlObject".to_string())?,
            image_url: intermediate_rep.image_url.into_iter().next().ok_or_else(|| "image_url missing in MessageContentImageUrlObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentImageUrlObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentImageUrlObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentImageUrlObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageContentImageUrlObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentImageUrlObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentImageUrlObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageContentImageUrlObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentImageUrlObjectImageUrl {
    /// The external URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp.
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

    /// Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`. Default value is `auto`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "detail")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub detail: Option<String>,

}



impl MessageContentImageUrlObjectImageUrl {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(url: String, ) -> MessageContentImageUrlObjectImageUrl {
        MessageContentImageUrlObjectImageUrl {
 url,
 detail: None,
        }
    }
}

/// Converts the MessageContentImageUrlObjectImageUrl value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentImageUrlObjectImageUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("url".to_string()),
            Some(self.url.to_string()),


            self.detail.as_ref().map(|detail| {
                [
                    "detail".to_string(),
                    detail.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentImageUrlObjectImageUrl value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentImageUrlObjectImageUrl {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
            pub detail: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentImageUrlObjectImageUrl".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "detail" => intermediate_rep.detail.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentImageUrlObjectImageUrl".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentImageUrlObjectImageUrl {
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in MessageContentImageUrlObjectImageUrl".to_string())?,
            detail: intermediate_rep.detail.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentImageUrlObjectImageUrl> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentImageUrlObjectImageUrl>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentImageUrlObjectImageUrl>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageContentImageUrlObjectImageUrl - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentImageUrlObjectImageUrl> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentImageUrlObjectImageUrl as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageContentImageUrlObjectImageUrl - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The refusal content generated by the assistant.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentRefusalObject {
    /// Always `refusal`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "refusal")]
          #[validate(custom(function = "check_xss_string"))]
    pub refusal: String,

}



impl MessageContentRefusalObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, refusal: String, ) -> MessageContentRefusalObject {
        MessageContentRefusalObject {
 r_type,
 refusal,
        }
    }
}

/// Converts the MessageContentRefusalObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentRefusalObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("refusal".to_string()),
            Some(self.refusal.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentRefusalObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentRefusalObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub refusal: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentRefusalObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "refusal" => intermediate_rep.refusal.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentRefusalObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentRefusalObject {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in MessageContentRefusalObject".to_string())?,
            refusal: intermediate_rep.refusal.into_iter().next().ok_or_else(|| "refusal missing in MessageContentRefusalObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentRefusalObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentRefusalObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentRefusalObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageContentRefusalObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentRefusalObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentRefusalObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageContentRefusalObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"file_search\" tool to search files.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentTextAnnotationsFileCitationObject {
    /// Always `file_citation`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The text in the message content that needs to be replaced.
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    pub text: String,

    #[serde(rename = "file_citation")]
          #[validate(nested)]
    pub file_citation: models::MessageContentTextAnnotationsFileCitationObjectFileCitation,

    #[serde(rename = "start_index")]
    #[validate(
            range(min = 0u32),
    )]
    pub start_index: u32,

    #[serde(rename = "end_index")]
    #[validate(
            range(min = 0u32),
    )]
    pub end_index: u32,

}



impl MessageContentTextAnnotationsFileCitationObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, text: String, file_citation: models::MessageContentTextAnnotationsFileCitationObjectFileCitation, start_index: u32, end_index: u32, ) -> MessageContentTextAnnotationsFileCitationObject {
        MessageContentTextAnnotationsFileCitationObject {
 r_type,
 text,
 file_citation,
 start_index,
 end_index,
        }
    }
}

/// Converts the MessageContentTextAnnotationsFileCitationObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentTextAnnotationsFileCitationObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),

            // Skipping file_citation in query parameter serialization


            Some("start_index".to_string()),
            Some(self.start_index.to_string()),


            Some("end_index".to_string()),
            Some(self.end_index.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentTextAnnotationsFileCitationObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentTextAnnotationsFileCitationObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub text: Vec<String>,
            pub file_citation: Vec<models::MessageContentTextAnnotationsFileCitationObjectFileCitation>,
            pub start_index: Vec<u32>,
            pub end_index: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentTextAnnotationsFileCitationObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_citation" => intermediate_rep.file_citation.push(<models::MessageContentTextAnnotationsFileCitationObjectFileCitation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start_index" => intermediate_rep.start_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_index" => intermediate_rep.end_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentTextAnnotationsFileCitationObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentTextAnnotationsFileCitationObject {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in MessageContentTextAnnotationsFileCitationObject".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in MessageContentTextAnnotationsFileCitationObject".to_string())?,
            file_citation: intermediate_rep.file_citation.into_iter().next().ok_or_else(|| "file_citation missing in MessageContentTextAnnotationsFileCitationObject".to_string())?,
            start_index: intermediate_rep.start_index.into_iter().next().ok_or_else(|| "start_index missing in MessageContentTextAnnotationsFileCitationObject".to_string())?,
            end_index: intermediate_rep.end_index.into_iter().next().ok_or_else(|| "end_index missing in MessageContentTextAnnotationsFileCitationObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageContentTextAnnotationsFileCitationObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentTextAnnotationsFileCitationObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageContentTextAnnotationsFileCitationObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentTextAnnotationsFileCitationObjectFileCitation {
    /// The ID of the specific File the citation is from.
    #[serde(rename = "file_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub file_id: String,

}



impl MessageContentTextAnnotationsFileCitationObjectFileCitation {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(file_id: String, ) -> MessageContentTextAnnotationsFileCitationObjectFileCitation {
        MessageContentTextAnnotationsFileCitationObjectFileCitation {
 file_id,
        }
    }
}

/// Converts the MessageContentTextAnnotationsFileCitationObjectFileCitation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentTextAnnotationsFileCitationObjectFileCitation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("file_id".to_string()),
            Some(self.file_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentTextAnnotationsFileCitationObjectFileCitation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentTextAnnotationsFileCitationObjectFileCitation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentTextAnnotationsFileCitationObjectFileCitation".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentTextAnnotationsFileCitationObjectFileCitation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentTextAnnotationsFileCitationObjectFileCitation {
            file_id: intermediate_rep.file_id.into_iter().next().ok_or_else(|| "file_id missing in MessageContentTextAnnotationsFileCitationObjectFileCitation".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObjectFileCitation> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObjectFileCitation>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObjectFileCitation>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageContentTextAnnotationsFileCitationObjectFileCitation - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentTextAnnotationsFileCitationObjectFileCitation> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentTextAnnotationsFileCitationObjectFileCitation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageContentTextAnnotationsFileCitationObjectFileCitation - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A URL for the file that's generated when the assistant used the `code_interpreter` tool to generate a file.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentTextAnnotationsFilePathObject {
    /// Always `file_path`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The text in the message content that needs to be replaced.
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    pub text: String,

    #[serde(rename = "file_path")]
          #[validate(nested)]
    pub file_path: models::MessageContentTextAnnotationsFilePathObjectFilePath,

    #[serde(rename = "start_index")]
    #[validate(
            range(min = 0u32),
    )]
    pub start_index: u32,

    #[serde(rename = "end_index")]
    #[validate(
            range(min = 0u32),
    )]
    pub end_index: u32,

}



impl MessageContentTextAnnotationsFilePathObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, text: String, file_path: models::MessageContentTextAnnotationsFilePathObjectFilePath, start_index: u32, end_index: u32, ) -> MessageContentTextAnnotationsFilePathObject {
        MessageContentTextAnnotationsFilePathObject {
 r_type,
 text,
 file_path,
 start_index,
 end_index,
        }
    }
}

/// Converts the MessageContentTextAnnotationsFilePathObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentTextAnnotationsFilePathObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),

            // Skipping file_path in query parameter serialization


            Some("start_index".to_string()),
            Some(self.start_index.to_string()),


            Some("end_index".to_string()),
            Some(self.end_index.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentTextAnnotationsFilePathObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentTextAnnotationsFilePathObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub text: Vec<String>,
            pub file_path: Vec<models::MessageContentTextAnnotationsFilePathObjectFilePath>,
            pub start_index: Vec<u32>,
            pub end_index: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentTextAnnotationsFilePathObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_path" => intermediate_rep.file_path.push(<models::MessageContentTextAnnotationsFilePathObjectFilePath as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start_index" => intermediate_rep.start_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_index" => intermediate_rep.end_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentTextAnnotationsFilePathObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentTextAnnotationsFilePathObject {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in MessageContentTextAnnotationsFilePathObject".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in MessageContentTextAnnotationsFilePathObject".to_string())?,
            file_path: intermediate_rep.file_path.into_iter().next().ok_or_else(|| "file_path missing in MessageContentTextAnnotationsFilePathObject".to_string())?,
            start_index: intermediate_rep.start_index.into_iter().next().ok_or_else(|| "start_index missing in MessageContentTextAnnotationsFilePathObject".to_string())?,
            end_index: intermediate_rep.end_index.into_iter().next().ok_or_else(|| "end_index missing in MessageContentTextAnnotationsFilePathObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageContentTextAnnotationsFilePathObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentTextAnnotationsFilePathObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageContentTextAnnotationsFilePathObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentTextAnnotationsFilePathObjectFilePath {
    /// The ID of the file that was generated.
    #[serde(rename = "file_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub file_id: String,

}



impl MessageContentTextAnnotationsFilePathObjectFilePath {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(file_id: String, ) -> MessageContentTextAnnotationsFilePathObjectFilePath {
        MessageContentTextAnnotationsFilePathObjectFilePath {
 file_id,
        }
    }
}

/// Converts the MessageContentTextAnnotationsFilePathObjectFilePath value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentTextAnnotationsFilePathObjectFilePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("file_id".to_string()),
            Some(self.file_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentTextAnnotationsFilePathObjectFilePath value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentTextAnnotationsFilePathObjectFilePath {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentTextAnnotationsFilePathObjectFilePath".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentTextAnnotationsFilePathObjectFilePath".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentTextAnnotationsFilePathObjectFilePath {
            file_id: intermediate_rep.file_id.into_iter().next().ok_or_else(|| "file_id missing in MessageContentTextAnnotationsFilePathObjectFilePath".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObjectFilePath> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObjectFilePath>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObjectFilePath>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageContentTextAnnotationsFilePathObjectFilePath - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentTextAnnotationsFilePathObjectFilePath> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentTextAnnotationsFilePathObjectFilePath as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageContentTextAnnotationsFilePathObjectFilePath - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The text content that is part of a message.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentTextObject {
    /// Always `text`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "text")]
          #[validate(nested)]
    pub text: models::MessageContentTextObjectText,

}



impl MessageContentTextObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, text: models::MessageContentTextObjectText, ) -> MessageContentTextObject {
        MessageContentTextObject {
 r_type,
 text,
        }
    }
}

/// Converts the MessageContentTextObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentTextObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping text in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentTextObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentTextObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub text: Vec<models::MessageContentTextObjectText>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentTextObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<models::MessageContentTextObjectText as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentTextObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentTextObject {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in MessageContentTextObject".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in MessageContentTextObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentTextObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentTextObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentTextObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageContentTextObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentTextObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentTextObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageContentTextObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageContentTextObjectText {
    /// The data that makes up the text.
    #[serde(rename = "value")]
          #[validate(custom(function = "check_xss_string"))]
    pub value: String,

    #[serde(rename = "annotations")]
          #[validate(nested)]
    pub annotations: Vec<models::MessageContentTextObjectTextAnnotationsInner>,

}



impl MessageContentTextObjectText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(value: String, annotations: Vec<models::MessageContentTextObjectTextAnnotationsInner>, ) -> MessageContentTextObjectText {
        MessageContentTextObjectText {
 value,
 annotations,
        }
    }
}

/// Converts the MessageContentTextObjectText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageContentTextObjectText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("value".to_string()),
            Some(self.value.to_string()),

            // Skipping annotations in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentTextObjectText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentTextObjectText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<String>,
            pub annotations: Vec<Vec<models::MessageContentTextObjectTextAnnotationsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageContentTextObjectText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in MessageContentTextObjectText".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageContentTextObjectText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageContentTextObjectText {
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in MessageContentTextObjectText".to_string())?,
            annotations: intermediate_rep.annotations.into_iter().next().ok_or_else(|| "annotations missing in MessageContentTextObjectText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageContentTextObjectText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageContentTextObjectText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageContentTextObjectText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageContentTextObjectText - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageContentTextObjectText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageContentTextObjectText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageContentTextObjectText - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum MessageContentTextObjectTextAnnotationsInner {
    MessageContentTextAnnotationsFileCitationObject(models::MessageContentTextAnnotationsFileCitationObject),
    MessageContentTextAnnotationsFilePathObject(models::MessageContentTextAnnotationsFilePathObject),
}

impl validator::Validate for MessageContentTextObjectTextAnnotationsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::MessageContentTextAnnotationsFileCitationObject(v) => v.validate(),
            Self::MessageContentTextAnnotationsFilePathObject(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageContentTextObjectTextAnnotationsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageContentTextObjectTextAnnotationsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::MessageContentTextAnnotationsFileCitationObject> for MessageContentTextObjectTextAnnotationsInner {
    fn from(value: models::MessageContentTextAnnotationsFileCitationObject) -> Self {
        Self::MessageContentTextAnnotationsFileCitationObject(value)
    }
}
impl From<models::MessageContentTextAnnotationsFilePathObject> for MessageContentTextObjectTextAnnotationsInner {
    fn from(value: models::MessageContentTextAnnotationsFilePathObject) -> Self {
        Self::MessageContentTextAnnotationsFilePathObject(value)
    }
}





/// References an image [File](/docs/api-reference/files) in the content of a message.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentImageFileObject {
    /// The index of the content part in the message.
    #[serde(rename = "index")]
    pub index: i32,

    /// Always `image_file`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "image_file")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_file: Option<models::MessageDeltaContentImageFileObjectImageFile>,

}



impl MessageDeltaContentImageFileObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r_type: String, ) -> MessageDeltaContentImageFileObject {
        MessageDeltaContentImageFileObject {
 index,
 r_type,
 image_file: None,
        }
    }
}

/// Converts the MessageDeltaContentImageFileObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentImageFileObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping image_file in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentImageFileObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentImageFileObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub r_type: Vec<String>,
            pub image_file: Vec<models::MessageDeltaContentImageFileObjectImageFile>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentImageFileObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_file" => intermediate_rep.image_file.push(<models::MessageDeltaContentImageFileObjectImageFile as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentImageFileObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentImageFileObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in MessageDeltaContentImageFileObject".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in MessageDeltaContentImageFileObject".to_string())?,
            image_file: intermediate_rep.image_file.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentImageFileObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentImageFileObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentImageFileObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageDeltaContentImageFileObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentImageFileObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentImageFileObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageDeltaContentImageFileObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentImageFileObjectImageFile {
    /// The [File](/docs/api-reference/files) ID of the image in the message content. Set `purpose=\"vision\"` when uploading the File if you need to later display the file content.
    #[serde(rename = "file_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_id: Option<String>,

    /// Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "detail")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub detail: Option<String>,

}



impl MessageDeltaContentImageFileObjectImageFile {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MessageDeltaContentImageFileObjectImageFile {
        MessageDeltaContentImageFileObjectImageFile {
 file_id: None,
 detail: None,
        }
    }
}

/// Converts the MessageDeltaContentImageFileObjectImageFile value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentImageFileObjectImageFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_id.as_ref().map(|file_id| {
                [
                    "file_id".to_string(),
                    file_id.to_string(),
                ].join(",")
            }),


            self.detail.as_ref().map(|detail| {
                [
                    "detail".to_string(),
                    detail.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentImageFileObjectImageFile value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentImageFileObjectImageFile {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
            pub detail: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentImageFileObjectImageFile".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "detail" => intermediate_rep.detail.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentImageFileObjectImageFile".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentImageFileObjectImageFile {
            file_id: intermediate_rep.file_id.into_iter().next(),
            detail: intermediate_rep.detail.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentImageFileObjectImageFile> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentImageFileObjectImageFile>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentImageFileObjectImageFile>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageDeltaContentImageFileObjectImageFile - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentImageFileObjectImageFile> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentImageFileObjectImageFile as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageDeltaContentImageFileObjectImageFile - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// References an image URL in the content of a message.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentImageUrlObject {
    /// The index of the content part in the message.
    #[serde(rename = "index")]
    pub index: i32,

    /// Always `image_url`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "image_url")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_url: Option<models::MessageDeltaContentImageUrlObjectImageUrl>,

}



impl MessageDeltaContentImageUrlObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r_type: String, ) -> MessageDeltaContentImageUrlObject {
        MessageDeltaContentImageUrlObject {
 index,
 r_type,
 image_url: None,
        }
    }
}

/// Converts the MessageDeltaContentImageUrlObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentImageUrlObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping image_url in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentImageUrlObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentImageUrlObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub r_type: Vec<String>,
            pub image_url: Vec<models::MessageDeltaContentImageUrlObjectImageUrl>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentImageUrlObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image_url" => intermediate_rep.image_url.push(<models::MessageDeltaContentImageUrlObjectImageUrl as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentImageUrlObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentImageUrlObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in MessageDeltaContentImageUrlObject".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in MessageDeltaContentImageUrlObject".to_string())?,
            image_url: intermediate_rep.image_url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentImageUrlObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentImageUrlObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentImageUrlObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageDeltaContentImageUrlObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentImageUrlObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentImageUrlObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageDeltaContentImageUrlObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentImageUrlObjectImageUrl {
    /// The URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp.
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,

    /// Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "detail")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub detail: Option<String>,

}



impl MessageDeltaContentImageUrlObjectImageUrl {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MessageDeltaContentImageUrlObjectImageUrl {
        MessageDeltaContentImageUrlObjectImageUrl {
 url: None,
 detail: None,
        }
    }
}

/// Converts the MessageDeltaContentImageUrlObjectImageUrl value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentImageUrlObjectImageUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.to_string(),
                ].join(",")
            }),


            self.detail.as_ref().map(|detail| {
                [
                    "detail".to_string(),
                    detail.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentImageUrlObjectImageUrl value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentImageUrlObjectImageUrl {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
            pub detail: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentImageUrlObjectImageUrl".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "detail" => intermediate_rep.detail.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentImageUrlObjectImageUrl".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentImageUrlObjectImageUrl {
            url: intermediate_rep.url.into_iter().next(),
            detail: intermediate_rep.detail.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentImageUrlObjectImageUrl> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentImageUrlObjectImageUrl>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentImageUrlObjectImageUrl>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageDeltaContentImageUrlObjectImageUrl - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentImageUrlObjectImageUrl> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentImageUrlObjectImageUrl as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageDeltaContentImageUrlObjectImageUrl - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The refusal content that is part of a message.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentRefusalObject {
    /// The index of the refusal part in the message.
    #[serde(rename = "index")]
    pub index: i32,

    /// Always `refusal`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "refusal")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub refusal: Option<String>,

}



impl MessageDeltaContentRefusalObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r_type: String, ) -> MessageDeltaContentRefusalObject {
        MessageDeltaContentRefusalObject {
 index,
 r_type,
 refusal: None,
        }
    }
}

/// Converts the MessageDeltaContentRefusalObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentRefusalObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            self.refusal.as_ref().map(|refusal| {
                [
                    "refusal".to_string(),
                    refusal.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentRefusalObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentRefusalObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub r_type: Vec<String>,
            pub refusal: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentRefusalObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "refusal" => intermediate_rep.refusal.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentRefusalObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentRefusalObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in MessageDeltaContentRefusalObject".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in MessageDeltaContentRefusalObject".to_string())?,
            refusal: intermediate_rep.refusal.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentRefusalObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentRefusalObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentRefusalObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageDeltaContentRefusalObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentRefusalObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentRefusalObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageDeltaContentRefusalObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"file_search\" tool to search files.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentTextAnnotationsFileCitationObject {
    /// The index of the annotation in the text content part.
    #[serde(rename = "index")]
    pub index: i32,

    /// Always `file_citation`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The text in the message content that needs to be replaced.
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,

    #[serde(rename = "file_citation")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_citation: Option<models::MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation>,

    #[serde(rename = "start_index")]
    #[validate(
            range(min = 0u32),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_index: Option<u32>,

    #[serde(rename = "end_index")]
    #[validate(
            range(min = 0u32),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_index: Option<u32>,

}



impl MessageDeltaContentTextAnnotationsFileCitationObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r_type: String, ) -> MessageDeltaContentTextAnnotationsFileCitationObject {
        MessageDeltaContentTextAnnotationsFileCitationObject {
 index,
 r_type,
 text: None,
 file_citation: None,
 start_index: None,
 end_index: None,
        }
    }
}

/// Converts the MessageDeltaContentTextAnnotationsFileCitationObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentTextAnnotationsFileCitationObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            self.text.as_ref().map(|text| {
                [
                    "text".to_string(),
                    text.to_string(),
                ].join(",")
            }),

            // Skipping file_citation in query parameter serialization


            self.start_index.as_ref().map(|start_index| {
                [
                    "start_index".to_string(),
                    start_index.to_string(),
                ].join(",")
            }),


            self.end_index.as_ref().map(|end_index| {
                [
                    "end_index".to_string(),
                    end_index.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentTextAnnotationsFileCitationObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentTextAnnotationsFileCitationObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub r_type: Vec<String>,
            pub text: Vec<String>,
            pub file_citation: Vec<models::MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation>,
            pub start_index: Vec<u32>,
            pub end_index: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentTextAnnotationsFileCitationObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_citation" => intermediate_rep.file_citation.push(<models::MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start_index" => intermediate_rep.start_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_index" => intermediate_rep.end_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentTextAnnotationsFileCitationObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentTextAnnotationsFileCitationObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in MessageDeltaContentTextAnnotationsFileCitationObject".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in MessageDeltaContentTextAnnotationsFileCitationObject".to_string())?,
            text: intermediate_rep.text.into_iter().next(),
            file_citation: intermediate_rep.file_citation.into_iter().next(),
            start_index: intermediate_rep.start_index.into_iter().next(),
            end_index: intermediate_rep.end_index.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageDeltaContentTextAnnotationsFileCitationObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentTextAnnotationsFileCitationObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageDeltaContentTextAnnotationsFileCitationObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
    /// The ID of the specific File the citation is from.
    #[serde(rename = "file_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_id: Option<String>,

    /// The specific quote in the file.
    #[serde(rename = "quote")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub quote: Option<String>,

}



impl MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
        MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
 file_id: None,
 quote: None,
        }
    }
}

/// Converts the MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_id.as_ref().map(|file_id| {
                [
                    "file_id".to_string(),
                    file_id.to_string(),
                ].join(",")
            }),


            self.quote.as_ref().map(|quote| {
                [
                    "quote".to_string(),
                    quote.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
            pub quote: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "quote" => intermediate_rep.quote.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
            file_id: intermediate_rep.file_id.into_iter().next(),
            quote: intermediate_rep.quote.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A URL for the file that's generated when the assistant used the `code_interpreter` tool to generate a file.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentTextAnnotationsFilePathObject {
    /// The index of the annotation in the text content part.
    #[serde(rename = "index")]
    pub index: i32,

    /// Always `file_path`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The text in the message content that needs to be replaced.
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,

    #[serde(rename = "file_path")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_path: Option<models::MessageDeltaContentTextAnnotationsFilePathObjectFilePath>,

    #[serde(rename = "start_index")]
    #[validate(
            range(min = 0u32),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_index: Option<u32>,

    #[serde(rename = "end_index")]
    #[validate(
            range(min = 0u32),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_index: Option<u32>,

}



impl MessageDeltaContentTextAnnotationsFilePathObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r_type: String, ) -> MessageDeltaContentTextAnnotationsFilePathObject {
        MessageDeltaContentTextAnnotationsFilePathObject {
 index,
 r_type,
 text: None,
 file_path: None,
 start_index: None,
 end_index: None,
        }
    }
}

/// Converts the MessageDeltaContentTextAnnotationsFilePathObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentTextAnnotationsFilePathObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            self.text.as_ref().map(|text| {
                [
                    "text".to_string(),
                    text.to_string(),
                ].join(",")
            }),

            // Skipping file_path in query parameter serialization


            self.start_index.as_ref().map(|start_index| {
                [
                    "start_index".to_string(),
                    start_index.to_string(),
                ].join(",")
            }),


            self.end_index.as_ref().map(|end_index| {
                [
                    "end_index".to_string(),
                    end_index.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentTextAnnotationsFilePathObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentTextAnnotationsFilePathObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub r_type: Vec<String>,
            pub text: Vec<String>,
            pub file_path: Vec<models::MessageDeltaContentTextAnnotationsFilePathObjectFilePath>,
            pub start_index: Vec<u32>,
            pub end_index: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentTextAnnotationsFilePathObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_path" => intermediate_rep.file_path.push(<models::MessageDeltaContentTextAnnotationsFilePathObjectFilePath as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start_index" => intermediate_rep.start_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_index" => intermediate_rep.end_index.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentTextAnnotationsFilePathObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentTextAnnotationsFilePathObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in MessageDeltaContentTextAnnotationsFilePathObject".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in MessageDeltaContentTextAnnotationsFilePathObject".to_string())?,
            text: intermediate_rep.text.into_iter().next(),
            file_path: intermediate_rep.file_path.into_iter().next(),
            start_index: intermediate_rep.start_index.into_iter().next(),
            end_index: intermediate_rep.end_index.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageDeltaContentTextAnnotationsFilePathObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentTextAnnotationsFilePathObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageDeltaContentTextAnnotationsFilePathObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
    /// The ID of the file that was generated.
    #[serde(rename = "file_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_id: Option<String>,

}



impl MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
        MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
 file_id: None,
        }
    }
}

/// Converts the MessageDeltaContentTextAnnotationsFilePathObjectFilePath value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_id.as_ref().map(|file_id| {
                [
                    "file_id".to_string(),
                    file_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentTextAnnotationsFilePathObjectFilePath value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentTextAnnotationsFilePathObjectFilePath".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentTextAnnotationsFilePathObjectFilePath".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
            file_id: intermediate_rep.file_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObjectFilePath> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObjectFilePath>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObjectFilePath>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageDeltaContentTextAnnotationsFilePathObjectFilePath - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentTextAnnotationsFilePathObjectFilePath> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentTextAnnotationsFilePathObjectFilePath as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageDeltaContentTextAnnotationsFilePathObjectFilePath - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The text content that is part of a message.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentTextObject {
    /// The index of the content part in the message.
    #[serde(rename = "index")]
    pub index: i32,

    /// Always `text`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "text")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<models::MessageDeltaContentTextObjectText>,

}



impl MessageDeltaContentTextObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r_type: String, ) -> MessageDeltaContentTextObject {
        MessageDeltaContentTextObject {
 index,
 r_type,
 text: None,
        }
    }
}

/// Converts the MessageDeltaContentTextObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentTextObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping text in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentTextObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentTextObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub r_type: Vec<String>,
            pub text: Vec<models::MessageDeltaContentTextObjectText>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentTextObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<models::MessageDeltaContentTextObjectText as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentTextObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentTextObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in MessageDeltaContentTextObject".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in MessageDeltaContentTextObject".to_string())?,
            text: intermediate_rep.text.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentTextObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentTextObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentTextObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageDeltaContentTextObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentTextObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentTextObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageDeltaContentTextObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaContentTextObjectText {
    /// The data that makes up the text.
    #[serde(rename = "value")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,

    #[serde(rename = "annotations")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<Vec<models::MessageDeltaContentTextObjectTextAnnotationsInner>>,

}



impl MessageDeltaContentTextObjectText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MessageDeltaContentTextObjectText {
        MessageDeltaContentTextObjectText {
 value: None,
 annotations: None,
        }
    }
}

/// Converts the MessageDeltaContentTextObjectText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaContentTextObjectText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),

            // Skipping annotations in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentTextObjectText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentTextObjectText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<String>,
            pub annotations: Vec<Vec<models::MessageDeltaContentTextObjectTextAnnotationsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaContentTextObjectText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "annotations" => return std::result::Result::Err("Parsing a container in this style is not supported in MessageDeltaContentTextObjectText".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaContentTextObjectText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaContentTextObjectText {
            value: intermediate_rep.value.into_iter().next(),
            annotations: intermediate_rep.annotations.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaContentTextObjectText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaContentTextObjectText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaContentTextObjectText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageDeltaContentTextObjectText - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaContentTextObjectText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaContentTextObjectText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageDeltaContentTextObjectText - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum MessageDeltaContentTextObjectTextAnnotationsInner {
    MessageDeltaContentTextAnnotationsFileCitationObject(models::MessageDeltaContentTextAnnotationsFileCitationObject),
    MessageDeltaContentTextAnnotationsFilePathObject(models::MessageDeltaContentTextAnnotationsFilePathObject),
}

impl validator::Validate for MessageDeltaContentTextObjectTextAnnotationsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::MessageDeltaContentTextAnnotationsFileCitationObject(v) => v.validate(),
            Self::MessageDeltaContentTextAnnotationsFilePathObject(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaContentTextObjectTextAnnotationsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaContentTextObjectTextAnnotationsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::MessageDeltaContentTextAnnotationsFileCitationObject> for MessageDeltaContentTextObjectTextAnnotationsInner {
    fn from(value: models::MessageDeltaContentTextAnnotationsFileCitationObject) -> Self {
        Self::MessageDeltaContentTextAnnotationsFileCitationObject(value)
    }
}
impl From<models::MessageDeltaContentTextAnnotationsFilePathObject> for MessageDeltaContentTextObjectTextAnnotationsInner {
    fn from(value: models::MessageDeltaContentTextAnnotationsFilePathObject) -> Self {
        Self::MessageDeltaContentTextAnnotationsFilePathObject(value)
    }
}





/// Represents a message delta i.e. any changed fields on a message during streaming. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaObject {
    /// The identifier of the message, which can be referenced in API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The object type, which is always `thread.message.delta`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "delta")]
          #[validate(nested)]
    pub delta: models::MessageDeltaObjectDelta,

}



impl MessageDeltaObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, delta: models::MessageDeltaObjectDelta, ) -> MessageDeltaObject {
        MessageDeltaObject {
 id,
 object,
 delta,
        }
    }
}

/// Converts the MessageDeltaObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping delta in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub delta: Vec<models::MessageDeltaObjectDelta>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "delta" => intermediate_rep.delta.push(<models::MessageDeltaObjectDelta as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in MessageDeltaObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in MessageDeltaObject".to_string())?,
            delta: intermediate_rep.delta.into_iter().next().ok_or_else(|| "delta missing in MessageDeltaObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageDeltaObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageDeltaObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The delta containing the fields that have changed on the Message.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageDeltaObjectDelta {
    /// The entity that produced the message. One of `user` or `assistant`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,

    /// The content of the message in array of text and/or images.
    #[serde(rename = "content")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<Vec<models::MessageDeltaObjectDeltaContentInner>>,

}



impl MessageDeltaObjectDelta {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> MessageDeltaObjectDelta {
        MessageDeltaObjectDelta {
 role: None,
 content: None,
        }
    }
}

/// Converts the MessageDeltaObjectDelta value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageDeltaObjectDelta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.role.as_ref().map(|role| {
                [
                    "role".to_string(),
                    role.to_string(),
                ].join(",")
            }),

            // Skipping content in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaObjectDelta value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaObjectDelta {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role: Vec<String>,
            pub content: Vec<Vec<models::MessageDeltaObjectDeltaContentInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageDeltaObjectDelta".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "content" => return std::result::Result::Err("Parsing a container in this style is not supported in MessageDeltaObjectDelta".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageDeltaObjectDelta".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageDeltaObjectDelta {
            role: intermediate_rep.role.into_iter().next(),
            content: intermediate_rep.content.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageDeltaObjectDelta> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageDeltaObjectDelta>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageDeltaObjectDelta>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageDeltaObjectDelta - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageDeltaObjectDelta> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageDeltaObjectDelta as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageDeltaObjectDelta - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum MessageDeltaObjectDeltaContentInner {
    MessageDeltaContentImageFileObject(models::MessageDeltaContentImageFileObject),
    MessageDeltaContentTextObject(models::MessageDeltaContentTextObject),
    MessageDeltaContentRefusalObject(models::MessageDeltaContentRefusalObject),
    MessageDeltaContentImageUrlObject(models::MessageDeltaContentImageUrlObject),
}

impl validator::Validate for MessageDeltaObjectDeltaContentInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::MessageDeltaContentImageFileObject(v) => v.validate(),
            Self::MessageDeltaContentTextObject(v) => v.validate(),
            Self::MessageDeltaContentRefusalObject(v) => v.validate(),
            Self::MessageDeltaContentImageUrlObject(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageDeltaObjectDeltaContentInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageDeltaObjectDeltaContentInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::MessageDeltaContentImageFileObject> for MessageDeltaObjectDeltaContentInner {
    fn from(value: models::MessageDeltaContentImageFileObject) -> Self {
        Self::MessageDeltaContentImageFileObject(value)
    }
}
impl From<models::MessageDeltaContentTextObject> for MessageDeltaObjectDeltaContentInner {
    fn from(value: models::MessageDeltaContentTextObject) -> Self {
        Self::MessageDeltaContentTextObject(value)
    }
}
impl From<models::MessageDeltaContentRefusalObject> for MessageDeltaObjectDeltaContentInner {
    fn from(value: models::MessageDeltaContentRefusalObject) -> Self {
        Self::MessageDeltaContentRefusalObject(value)
    }
}
impl From<models::MessageDeltaContentImageUrlObject> for MessageDeltaObjectDeltaContentInner {
    fn from(value: models::MessageDeltaContentImageUrlObject) -> Self {
        Self::MessageDeltaContentImageUrlObject(value)
    }
}





/// Represents a message within a [thread](/docs/api-reference/threads).
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageObject {
    /// The identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The object type, which is always `thread.message`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The Unix timestamp (in seconds) for when the message was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    /// The [thread](/docs/api-reference/threads) ID that this message belongs to.
    #[serde(rename = "thread_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub thread_id: String,

    /// The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
          #[validate(custom(function = "check_xss_string"))]
    pub status: String,

    #[serde(rename = "incomplete_details")]
    pub incomplete_details: Nullable<models::MessageObjectIncompleteDetails>,

    /// The Unix timestamp (in seconds) for when the message was completed.
    #[serde(rename = "completed_at")]
    pub completed_at: Nullable<i32>,

    /// The Unix timestamp (in seconds) for when the message was marked as incomplete.
    #[serde(rename = "incomplete_at")]
    pub incomplete_at: Nullable<i32>,

    /// The entity that produced the message. One of `user` or `assistant`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    /// The content of the message in array of text and/or images.
    #[serde(rename = "content")]
          #[validate(nested)]
    pub content: Vec<models::MessageObjectContentInner>,

    /// If applicable, the ID of the [assistant](/docs/api-reference/assistants) that authored this message.
    #[serde(rename = "assistant_id")]
    pub assistant_id: Nullable<String>,

    /// The ID of the [run](/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints.
    #[serde(rename = "run_id")]
    pub run_id: Nullable<String>,

    /// A list of files attached to the message, and the tools they were added to.
    #[serde(rename = "attachments")]
    pub attachments: Nullable<Vec<models::CreateMessageRequestAttachmentsInner>>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    pub metadata: crate::types::Object,

}



impl MessageObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, created_at: i32, thread_id: String, status: String, incomplete_details: Nullable<models::MessageObjectIncompleteDetails>, completed_at: Nullable<i32>, incomplete_at: Nullable<i32>, role: String, content: Vec<models::MessageObjectContentInner>, assistant_id: Nullable<String>, run_id: Nullable<String>, attachments: Nullable<Vec<models::CreateMessageRequestAttachmentsInner>>, metadata: crate::types::Object, ) -> MessageObject {
        MessageObject {
 id,
 object,
 created_at,
 thread_id,
 status,
 incomplete_details,
 completed_at,
 incomplete_at,
 role,
 content,
 assistant_id,
 run_id,
 attachments,
 metadata,
        }
    }
}

/// Converts the MessageObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("thread_id".to_string()),
            Some(self.thread_id.to_string()),


            Some("status".to_string()),
            Some(self.status.to_string()),

            // Skipping incomplete_details in query parameter serialization


            Some("completed_at".to_string()),
            Some(self.completed_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("incomplete_at".to_string()),
            Some(self.incomplete_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("role".to_string()),
            Some(self.role.to_string()),

            // Skipping content in query parameter serialization


            Some("assistant_id".to_string()),
            Some(self.assistant_id.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("run_id".to_string()),
            Some(self.run_id.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping attachments in query parameter serialization

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub created_at: Vec<i32>,
            pub thread_id: Vec<String>,
            pub status: Vec<String>,
            pub incomplete_details: Vec<models::MessageObjectIncompleteDetails>,
            pub completed_at: Vec<i32>,
            pub incomplete_at: Vec<i32>,
            pub role: Vec<String>,
            pub content: Vec<Vec<models::MessageObjectContentInner>>,
            pub assistant_id: Vec<String>,
            pub run_id: Vec<String>,
            pub attachments: Vec<Vec<models::CreateMessageRequestAttachmentsInner>>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "thread_id" => intermediate_rep.thread_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "incomplete_details" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MessageObject".to_string()),
                    "completed_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MessageObject".to_string()),
                    "incomplete_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MessageObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "content" => return std::result::Result::Err("Parsing a container in this style is not supported in MessageObject".to_string()),
                    "assistant_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MessageObject".to_string()),
                    "run_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MessageObject".to_string()),
                    "attachments" => return std::result::Result::Err("Parsing a container in this style is not supported in MessageObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in MessageObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in MessageObject".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in MessageObject".to_string())?,
            thread_id: intermediate_rep.thread_id.into_iter().next().ok_or_else(|| "thread_id missing in MessageObject".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in MessageObject".to_string())?,
            incomplete_details: std::result::Result::Err("Nullable types not supported in MessageObject".to_string())?,
            completed_at: std::result::Result::Err("Nullable types not supported in MessageObject".to_string())?,
            incomplete_at: std::result::Result::Err("Nullable types not supported in MessageObject".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in MessageObject".to_string())?,
            content: intermediate_rep.content.into_iter().next().ok_or_else(|| "content missing in MessageObject".to_string())?,
            assistant_id: std::result::Result::Err("Nullable types not supported in MessageObject".to_string())?,
            run_id: std::result::Result::Err("Nullable types not supported in MessageObject".to_string())?,
            attachments: std::result::Result::Err("Nullable types not supported in MessageObject".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next().ok_or_else(|| "metadata missing in MessageObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum MessageObjectContentInner {
    MessageContentImageFileObject(models::MessageContentImageFileObject),
    MessageContentImageUrlObject(models::MessageContentImageUrlObject),
    MessageContentTextObject(models::MessageContentTextObject),
    MessageContentRefusalObject(models::MessageContentRefusalObject),
}

impl validator::Validate for MessageObjectContentInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::MessageContentImageFileObject(v) => v.validate(),
            Self::MessageContentImageUrlObject(v) => v.validate(),
            Self::MessageContentTextObject(v) => v.validate(),
            Self::MessageContentRefusalObject(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageObjectContentInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageObjectContentInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::MessageContentImageFileObject> for MessageObjectContentInner {
    fn from(value: models::MessageContentImageFileObject) -> Self {
        Self::MessageContentImageFileObject(value)
    }
}
impl From<models::MessageContentImageUrlObject> for MessageObjectContentInner {
    fn from(value: models::MessageContentImageUrlObject) -> Self {
        Self::MessageContentImageUrlObject(value)
    }
}
impl From<models::MessageContentTextObject> for MessageObjectContentInner {
    fn from(value: models::MessageContentTextObject) -> Self {
        Self::MessageContentTextObject(value)
    }
}
impl From<models::MessageContentRefusalObject> for MessageObjectContentInner {
    fn from(value: models::MessageContentRefusalObject) -> Self {
        Self::MessageContentRefusalObject(value)
    }
}





/// On an incomplete message, details about why the message is incomplete.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageObjectIncompleteDetails {
    /// The reason the message is incomplete.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "reason")]
          #[validate(custom(function = "check_xss_string"))]
    pub reason: String,

}



impl MessageObjectIncompleteDetails {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(reason: String, ) -> MessageObjectIncompleteDetails {
        MessageObjectIncompleteDetails {
 reason,
        }
    }
}

/// Converts the MessageObjectIncompleteDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageObjectIncompleteDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("reason".to_string()),
            Some(self.reason.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageObjectIncompleteDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageObjectIncompleteDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub reason: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageObjectIncompleteDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageObjectIncompleteDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageObjectIncompleteDetails {
            reason: intermediate_rep.reason.into_iter().next().ok_or_else(|| "reason missing in MessageObjectIncompleteDetails".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageObjectIncompleteDetails> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageObjectIncompleteDetails>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageObjectIncompleteDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageObjectIncompleteDetails - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageObjectIncompleteDetails> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageObjectIncompleteDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageObjectIncompleteDetails - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The text content that is part of a message.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageRequestContentTextObject {
    /// Always `text`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// Text content to be sent to the model
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    pub text: String,

}



impl MessageRequestContentTextObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, text: String, ) -> MessageRequestContentTextObject {
        MessageRequestContentTextObject {
 r_type,
 text,
        }
    }
}

/// Converts the MessageRequestContentTextObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageRequestContentTextObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageRequestContentTextObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageRequestContentTextObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub text: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageRequestContentTextObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageRequestContentTextObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageRequestContentTextObject {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in MessageRequestContentTextObject".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in MessageRequestContentTextObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageRequestContentTextObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageRequestContentTextObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageRequestContentTextObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageRequestContentTextObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageRequestContentTextObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageRequestContentTextObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageRequestContentTextObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum MessageStreamEvent {
    MessageStreamEventOneOf(models::MessageStreamEventOneOf),
    MessageStreamEventOneOf1(models::MessageStreamEventOneOf1),
    MessageStreamEventOneOf2(models::MessageStreamEventOneOf2),
    MessageStreamEventOneOf3(models::MessageStreamEventOneOf3),
    MessageStreamEventOneOf4(models::MessageStreamEventOneOf4),
}

impl validator::Validate for MessageStreamEvent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::MessageStreamEventOneOf(v) => v.validate(),
            Self::MessageStreamEventOneOf1(v) => v.validate(),
            Self::MessageStreamEventOneOf2(v) => v.validate(),
            Self::MessageStreamEventOneOf3(v) => v.validate(),
            Self::MessageStreamEventOneOf4(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageStreamEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageStreamEvent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::MessageStreamEventOneOf> for MessageStreamEvent {
    fn from(value: models::MessageStreamEventOneOf) -> Self {
        Self::MessageStreamEventOneOf(value)
    }
}
impl From<models::MessageStreamEventOneOf1> for MessageStreamEvent {
    fn from(value: models::MessageStreamEventOneOf1) -> Self {
        Self::MessageStreamEventOneOf1(value)
    }
}
impl From<models::MessageStreamEventOneOf2> for MessageStreamEvent {
    fn from(value: models::MessageStreamEventOneOf2) -> Self {
        Self::MessageStreamEventOneOf2(value)
    }
}
impl From<models::MessageStreamEventOneOf3> for MessageStreamEvent {
    fn from(value: models::MessageStreamEventOneOf3) -> Self {
        Self::MessageStreamEventOneOf3(value)
    }
}
impl From<models::MessageStreamEventOneOf4> for MessageStreamEvent {
    fn from(value: models::MessageStreamEventOneOf4) -> Self {
        Self::MessageStreamEventOneOf4(value)
    }
}





/// Occurs when a [message](/docs/api-reference/messages/object) is created.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageStreamEventOneOf {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::MessageObject,

}



impl MessageStreamEventOneOf {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::MessageObject, ) -> MessageStreamEventOneOf {
        MessageStreamEventOneOf {
 event,
 data,
        }
    }
}

/// Converts the MessageStreamEventOneOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageStreamEventOneOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageStreamEventOneOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageStreamEventOneOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::MessageObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageStreamEventOneOf".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::MessageObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageStreamEventOneOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageStreamEventOneOf {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in MessageStreamEventOneOf".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in MessageStreamEventOneOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageStreamEventOneOf> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageStreamEventOneOf>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageStreamEventOneOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageStreamEventOneOf - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageStreamEventOneOf> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageStreamEventOneOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageStreamEventOneOf - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [message](/docs/api-reference/messages/object) moves to an `in_progress` state.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageStreamEventOneOf1 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::MessageObject,

}



impl MessageStreamEventOneOf1 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::MessageObject, ) -> MessageStreamEventOneOf1 {
        MessageStreamEventOneOf1 {
 event,
 data,
        }
    }
}

/// Converts the MessageStreamEventOneOf1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageStreamEventOneOf1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageStreamEventOneOf1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageStreamEventOneOf1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::MessageObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageStreamEventOneOf1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::MessageObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageStreamEventOneOf1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageStreamEventOneOf1 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in MessageStreamEventOneOf1".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in MessageStreamEventOneOf1".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageStreamEventOneOf1> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageStreamEventOneOf1>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageStreamEventOneOf1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageStreamEventOneOf1 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageStreamEventOneOf1> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageStreamEventOneOf1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageStreamEventOneOf1 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when parts of a [Message](/docs/api-reference/messages/object) are being streamed.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageStreamEventOneOf2 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::MessageDeltaObject,

}



impl MessageStreamEventOneOf2 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::MessageDeltaObject, ) -> MessageStreamEventOneOf2 {
        MessageStreamEventOneOf2 {
 event,
 data,
        }
    }
}

/// Converts the MessageStreamEventOneOf2 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageStreamEventOneOf2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageStreamEventOneOf2 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageStreamEventOneOf2 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::MessageDeltaObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageStreamEventOneOf2".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::MessageDeltaObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageStreamEventOneOf2".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageStreamEventOneOf2 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in MessageStreamEventOneOf2".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in MessageStreamEventOneOf2".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageStreamEventOneOf2> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageStreamEventOneOf2>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageStreamEventOneOf2>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageStreamEventOneOf2 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageStreamEventOneOf2> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageStreamEventOneOf2 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageStreamEventOneOf2 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [message](/docs/api-reference/messages/object) is completed.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageStreamEventOneOf3 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::MessageObject,

}



impl MessageStreamEventOneOf3 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::MessageObject, ) -> MessageStreamEventOneOf3 {
        MessageStreamEventOneOf3 {
 event,
 data,
        }
    }
}

/// Converts the MessageStreamEventOneOf3 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageStreamEventOneOf3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageStreamEventOneOf3 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageStreamEventOneOf3 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::MessageObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageStreamEventOneOf3".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::MessageObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageStreamEventOneOf3".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageStreamEventOneOf3 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in MessageStreamEventOneOf3".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in MessageStreamEventOneOf3".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageStreamEventOneOf3> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageStreamEventOneOf3>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageStreamEventOneOf3>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageStreamEventOneOf3 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageStreamEventOneOf3> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageStreamEventOneOf3 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageStreamEventOneOf3 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [message](/docs/api-reference/messages/object) ends before it is completed.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MessageStreamEventOneOf4 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::MessageObject,

}



impl MessageStreamEventOneOf4 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::MessageObject, ) -> MessageStreamEventOneOf4 {
        MessageStreamEventOneOf4 {
 event,
 data,
        }
    }
}

/// Converts the MessageStreamEventOneOf4 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MessageStreamEventOneOf4 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MessageStreamEventOneOf4 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MessageStreamEventOneOf4 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::MessageObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MessageStreamEventOneOf4".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::MessageObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MessageStreamEventOneOf4".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MessageStreamEventOneOf4 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in MessageStreamEventOneOf4".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in MessageStreamEventOneOf4".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MessageStreamEventOneOf4> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MessageStreamEventOneOf4>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MessageStreamEventOneOf4>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MessageStreamEventOneOf4 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MessageStreamEventOneOf4> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MessageStreamEventOneOf4 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MessageStreamEventOneOf4 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Describes an OpenAI model offering that can be used with the API.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Model {
    /// The model identifier, which can be referenced in the API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The Unix timestamp (in seconds) when the model was created.
    #[serde(rename = "created")]
    pub created: i32,

    /// The object type, which is always \"model\".
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The organization that owns the model.
    #[serde(rename = "owned_by")]
          #[validate(custom(function = "check_xss_string"))]
    pub owned_by: String,

}



impl Model {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, created: i32, object: String, owned_by: String, ) -> Model {
        Model {
 id,
 created,
 object,
 owned_by,
        }
    }
}

/// Converts the Model value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Model {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("created".to_string()),
            Some(self.created.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("owned_by".to_string()),
            Some(self.owned_by.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Model value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Model {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub created: Vec<i32>,
            pub object: Vec<String>,
            pub owned_by: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Model".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created" => intermediate_rep.created.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "owned_by" => intermediate_rep.owned_by.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Model".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Model {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in Model".to_string())?,
            created: intermediate_rep.created.into_iter().next().ok_or_else(|| "created missing in Model".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in Model".to_string())?,
            owned_by: intermediate_rep.owned_by.into_iter().next().ok_or_else(|| "owned_by missing in Model".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Model> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Model>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Model>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for Model - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Model> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Model as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into Model - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModifyAssistantRequest {
    #[serde(rename = "model")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<String>,

    /// The name of the assistant. The maximum length is 256 characters. 
    #[serde(rename = "name")]
    #[validate(
            length(max = 256),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

    /// The description of the assistant. The maximum length is 512 characters. 
    #[serde(rename = "description")]
    #[validate(
            length(max = 512),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Nullable<String>>,

    /// The system instructions that the assistant uses. The maximum length is 256,000 characters. 
    #[serde(rename = "instructions")]
    #[validate(
            length(max = 256000),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instructions: Option<Nullable<String>>,

    /// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`. 
    #[serde(rename = "tools")]
    #[validate(
            length(max = 128),
          nested,
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Vec<models::AssistantObjectToolsInner>>,

    #[serde(rename = "tool_resources")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_resources: Option<Nullable<models::ModifyAssistantRequestToolResources>>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

    /// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
    #[serde(rename = "temperature")]
    #[validate(
            range(min = 0f64, max = 2f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<Nullable<f64>>,

    /// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
    #[serde(rename = "top_p")]
    #[validate(
            range(min = 0f64, max = 1f64),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub top_p: Option<Nullable<f64>>,

    #[serde(rename = "response_format")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_format: Option<models::AssistantsApiResponseFormatOption>,

}



impl ModifyAssistantRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ModifyAssistantRequest {
        ModifyAssistantRequest {
 model: None,
 name: None,
 description: None,
 instructions: None,
 tools: None,
 tool_resources: None,
 metadata: None,
 temperature: Some(Nullable::Present(1.0)),
 top_p: Some(Nullable::Present(1.0)),
 response_format: None,
        }
    }
}

/// Converts the ModifyAssistantRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ModifyAssistantRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.model.as_ref().map(|model| {
                [
                    "model".to_string(),
                    model.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.instructions.as_ref().map(|instructions| {
                [
                    "instructions".to_string(),
                    instructions.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping tools in query parameter serialization

            // Skipping tool_resources in query parameter serialization

            // Skipping metadata in query parameter serialization


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.top_p.as_ref().map(|top_p| {
                [
                    "top_p".to_string(),
                    top_p.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping response_format in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModifyAssistantRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModifyAssistantRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub model: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub instructions: Vec<String>,
            pub tools: Vec<Vec<models::AssistantObjectToolsInner>>,
            pub tool_resources: Vec<models::ModifyAssistantRequestToolResources>,
            pub metadata: Vec<crate::types::Object>,
            pub temperature: Vec<f64>,
            pub top_p: Vec<f64>,
            pub response_format: Vec<models::AssistantsApiResponseFormatOption>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModifyAssistantRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ModifyAssistantRequest".to_string()),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ModifyAssistantRequest".to_string()),
                    "instructions" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ModifyAssistantRequest".to_string()),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in ModifyAssistantRequest".to_string()),
                    "tool_resources" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ModifyAssistantRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "temperature" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ModifyAssistantRequest".to_string()),
                    "top_p" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ModifyAssistantRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "response_format" => intermediate_rep.response_format.push(<models::AssistantsApiResponseFormatOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModifyAssistantRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModifyAssistantRequest {
            model: intermediate_rep.model.into_iter().next(),
            name: std::result::Result::Err("Nullable types not supported in ModifyAssistantRequest".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in ModifyAssistantRequest".to_string())?,
            instructions: std::result::Result::Err("Nullable types not supported in ModifyAssistantRequest".to_string())?,
            tools: intermediate_rep.tools.into_iter().next(),
            tool_resources: std::result::Result::Err("Nullable types not supported in ModifyAssistantRequest".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next(),
            temperature: std::result::Result::Err("Nullable types not supported in ModifyAssistantRequest".to_string())?,
            top_p: std::result::Result::Err("Nullable types not supported in ModifyAssistantRequest".to_string())?,
            response_format: intermediate_rep.response_format.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModifyAssistantRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ModifyAssistantRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModifyAssistantRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ModifyAssistantRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ModifyAssistantRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModifyAssistantRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ModifyAssistantRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModifyAssistantRequestToolResources {
    #[serde(rename = "code_interpreter")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_interpreter: Option<models::ModifyAssistantRequestToolResourcesCodeInterpreter>,

    #[serde(rename = "file_search")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_search: Option<models::ModifyAssistantRequestToolResourcesFileSearch>,

}



impl ModifyAssistantRequestToolResources {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ModifyAssistantRequestToolResources {
        ModifyAssistantRequestToolResources {
 code_interpreter: None,
 file_search: None,
        }
    }
}

/// Converts the ModifyAssistantRequestToolResources value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ModifyAssistantRequestToolResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping code_interpreter in query parameter serialization

            // Skipping file_search in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModifyAssistantRequestToolResources value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModifyAssistantRequestToolResources {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code_interpreter: Vec<models::ModifyAssistantRequestToolResourcesCodeInterpreter>,
            pub file_search: Vec<models::ModifyAssistantRequestToolResourcesFileSearch>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModifyAssistantRequestToolResources".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code_interpreter" => intermediate_rep.code_interpreter.push(<models::ModifyAssistantRequestToolResourcesCodeInterpreter as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_search" => intermediate_rep.file_search.push(<models::ModifyAssistantRequestToolResourcesFileSearch as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModifyAssistantRequestToolResources".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModifyAssistantRequestToolResources {
            code_interpreter: intermediate_rep.code_interpreter.into_iter().next(),
            file_search: intermediate_rep.file_search.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModifyAssistantRequestToolResources> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ModifyAssistantRequestToolResources>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModifyAssistantRequestToolResources>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ModifyAssistantRequestToolResources - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ModifyAssistantRequestToolResources> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModifyAssistantRequestToolResources as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ModifyAssistantRequestToolResources - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModifyAssistantRequestToolResourcesCodeInterpreter {
    /// Overrides the list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool. 
    #[serde(rename = "file_ids")]
    #[validate(
            length(max = 20),
          custom(function = "check_xss_vec_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_ids: Option<Vec<String>>,

}



impl ModifyAssistantRequestToolResourcesCodeInterpreter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ModifyAssistantRequestToolResourcesCodeInterpreter {
        ModifyAssistantRequestToolResourcesCodeInterpreter {
 file_ids: None,
        }
    }
}

/// Converts the ModifyAssistantRequestToolResourcesCodeInterpreter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ModifyAssistantRequestToolResourcesCodeInterpreter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_ids.as_ref().map(|file_ids| {
                [
                    "file_ids".to_string(),
                    file_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModifyAssistantRequestToolResourcesCodeInterpreter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModifyAssistantRequestToolResourcesCodeInterpreter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_ids: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModifyAssistantRequestToolResourcesCodeInterpreter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "file_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in ModifyAssistantRequestToolResourcesCodeInterpreter".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModifyAssistantRequestToolResourcesCodeInterpreter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModifyAssistantRequestToolResourcesCodeInterpreter {
            file_ids: intermediate_rep.file_ids.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModifyAssistantRequestToolResourcesCodeInterpreter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ModifyAssistantRequestToolResourcesCodeInterpreter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModifyAssistantRequestToolResourcesCodeInterpreter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ModifyAssistantRequestToolResourcesCodeInterpreter - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ModifyAssistantRequestToolResourcesCodeInterpreter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModifyAssistantRequestToolResourcesCodeInterpreter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ModifyAssistantRequestToolResourcesCodeInterpreter - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModifyAssistantRequestToolResourcesFileSearch {
    /// Overrides the [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant. 
    #[serde(rename = "vector_store_ids")]
    #[validate(
            length(max = 1),
          custom(function = "check_xss_vec_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vector_store_ids: Option<Vec<String>>,

}



impl ModifyAssistantRequestToolResourcesFileSearch {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ModifyAssistantRequestToolResourcesFileSearch {
        ModifyAssistantRequestToolResourcesFileSearch {
 vector_store_ids: None,
        }
    }
}

/// Converts the ModifyAssistantRequestToolResourcesFileSearch value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ModifyAssistantRequestToolResourcesFileSearch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.vector_store_ids.as_ref().map(|vector_store_ids| {
                [
                    "vector_store_ids".to_string(),
                    vector_store_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModifyAssistantRequestToolResourcesFileSearch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModifyAssistantRequestToolResourcesFileSearch {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub vector_store_ids: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModifyAssistantRequestToolResourcesFileSearch".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "vector_store_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in ModifyAssistantRequestToolResourcesFileSearch".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModifyAssistantRequestToolResourcesFileSearch".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModifyAssistantRequestToolResourcesFileSearch {
            vector_store_ids: intermediate_rep.vector_store_ids.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModifyAssistantRequestToolResourcesFileSearch> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ModifyAssistantRequestToolResourcesFileSearch>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModifyAssistantRequestToolResourcesFileSearch>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ModifyAssistantRequestToolResourcesFileSearch - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ModifyAssistantRequestToolResourcesFileSearch> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModifyAssistantRequestToolResourcesFileSearch as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ModifyAssistantRequestToolResourcesFileSearch - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModifyMessageRequest {
    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}



impl ModifyMessageRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ModifyMessageRequest {
        ModifyMessageRequest {
 metadata: None,
        }
    }
}

/// Converts the ModifyMessageRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ModifyMessageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModifyMessageRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModifyMessageRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModifyMessageRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModifyMessageRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModifyMessageRequest {
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModifyMessageRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ModifyMessageRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModifyMessageRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ModifyMessageRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ModifyMessageRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModifyMessageRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ModifyMessageRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModifyRunRequest {
    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}



impl ModifyRunRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ModifyRunRequest {
        ModifyRunRequest {
 metadata: None,
        }
    }
}

/// Converts the ModifyRunRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ModifyRunRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModifyRunRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModifyRunRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModifyRunRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModifyRunRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModifyRunRequest {
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModifyRunRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ModifyRunRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModifyRunRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ModifyRunRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ModifyRunRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModifyRunRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ModifyRunRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModifyThreadRequest {
    #[serde(rename = "tool_resources")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_resources: Option<Nullable<models::ModifyThreadRequestToolResources>>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}



impl ModifyThreadRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ModifyThreadRequest {
        ModifyThreadRequest {
 tool_resources: None,
 metadata: None,
        }
    }
}

/// Converts the ModifyThreadRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ModifyThreadRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping tool_resources in query parameter serialization

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModifyThreadRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModifyThreadRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tool_resources: Vec<models::ModifyThreadRequestToolResources>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModifyThreadRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "tool_resources" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ModifyThreadRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModifyThreadRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModifyThreadRequest {
            tool_resources: std::result::Result::Err("Nullable types not supported in ModifyThreadRequest".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModifyThreadRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ModifyThreadRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModifyThreadRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ModifyThreadRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ModifyThreadRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModifyThreadRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ModifyThreadRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModifyThreadRequestToolResources {
    #[serde(rename = "code_interpreter")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_interpreter: Option<models::CreateAssistantRequestToolResourcesCodeInterpreter>,

    #[serde(rename = "file_search")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_search: Option<models::ModifyThreadRequestToolResourcesFileSearch>,

}



impl ModifyThreadRequestToolResources {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ModifyThreadRequestToolResources {
        ModifyThreadRequestToolResources {
 code_interpreter: None,
 file_search: None,
        }
    }
}

/// Converts the ModifyThreadRequestToolResources value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ModifyThreadRequestToolResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping code_interpreter in query parameter serialization

            // Skipping file_search in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModifyThreadRequestToolResources value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModifyThreadRequestToolResources {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code_interpreter: Vec<models::CreateAssistantRequestToolResourcesCodeInterpreter>,
            pub file_search: Vec<models::ModifyThreadRequestToolResourcesFileSearch>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModifyThreadRequestToolResources".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code_interpreter" => intermediate_rep.code_interpreter.push(<models::CreateAssistantRequestToolResourcesCodeInterpreter as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_search" => intermediate_rep.file_search.push(<models::ModifyThreadRequestToolResourcesFileSearch as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModifyThreadRequestToolResources".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModifyThreadRequestToolResources {
            code_interpreter: intermediate_rep.code_interpreter.into_iter().next(),
            file_search: intermediate_rep.file_search.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModifyThreadRequestToolResources> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ModifyThreadRequestToolResources>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModifyThreadRequestToolResources>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ModifyThreadRequestToolResources - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ModifyThreadRequestToolResources> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModifyThreadRequestToolResources as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ModifyThreadRequestToolResources - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ModifyThreadRequestToolResourcesFileSearch {
    /// The [vector store](/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread. 
    #[serde(rename = "vector_store_ids")]
    #[validate(
            length(max = 1),
          custom(function = "check_xss_vec_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub vector_store_ids: Option<Vec<String>>,

}



impl ModifyThreadRequestToolResourcesFileSearch {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ModifyThreadRequestToolResourcesFileSearch {
        ModifyThreadRequestToolResourcesFileSearch {
 vector_store_ids: None,
        }
    }
}

/// Converts the ModifyThreadRequestToolResourcesFileSearch value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ModifyThreadRequestToolResourcesFileSearch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.vector_store_ids.as_ref().map(|vector_store_ids| {
                [
                    "vector_store_ids".to_string(),
                    vector_store_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ModifyThreadRequestToolResourcesFileSearch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ModifyThreadRequestToolResourcesFileSearch {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub vector_store_ids: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ModifyThreadRequestToolResourcesFileSearch".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "vector_store_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in ModifyThreadRequestToolResourcesFileSearch".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ModifyThreadRequestToolResourcesFileSearch".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ModifyThreadRequestToolResourcesFileSearch {
            vector_store_ids: intermediate_rep.vector_store_ids.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ModifyThreadRequestToolResourcesFileSearch> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ModifyThreadRequestToolResourcesFileSearch>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ModifyThreadRequestToolResourcesFileSearch>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ModifyThreadRequestToolResourcesFileSearch - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ModifyThreadRequestToolResourcesFileSearch> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ModifyThreadRequestToolResourcesFileSearch as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ModifyThreadRequestToolResourcesFileSearch - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The `File` object represents a document that has been uploaded to OpenAI.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OpenAiFile {
    /// The file identifier, which can be referenced in the API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The size of the file, in bytes.
    #[serde(rename = "bytes")]
    pub bytes: i32,

    /// The Unix timestamp (in seconds) for when the file was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    /// The name of the file.
    #[serde(rename = "filename")]
          #[validate(custom(function = "check_xss_string"))]
    pub filename: String,

    /// The object type, which is always `file`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The intended purpose of the file. Supported values are `assistants`, `assistants_output`, `batch`, `batch_output`, `fine-tune`, `fine-tune-results` and `vision`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "purpose")]
          #[validate(custom(function = "check_xss_string"))]
    pub purpose: String,

    /// Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
          #[validate(custom(function = "check_xss_string"))]
    pub status: String,

    /// Deprecated. For details on why a fine-tuning training file failed validation, see the `error` field on `fine_tuning.job`.
    #[serde(rename = "status_details")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status_details: Option<String>,

}



impl OpenAiFile {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, bytes: i32, created_at: i32, filename: String, object: String, purpose: String, status: String, ) -> OpenAiFile {
        OpenAiFile {
 id,
 bytes,
 created_at,
 filename,
 object,
 purpose,
 status,
 status_details: None,
        }
    }
}

/// Converts the OpenAiFile value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OpenAiFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("bytes".to_string()),
            Some(self.bytes.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("filename".to_string()),
            Some(self.filename.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("purpose".to_string()),
            Some(self.purpose.to_string()),


            Some("status".to_string()),
            Some(self.status.to_string()),


            self.status_details.as_ref().map(|status_details| {
                [
                    "status_details".to_string(),
                    status_details.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OpenAiFile value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OpenAiFile {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub bytes: Vec<i32>,
            pub created_at: Vec<i32>,
            pub filename: Vec<String>,
            pub object: Vec<String>,
            pub purpose: Vec<String>,
            pub status: Vec<String>,
            pub status_details: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OpenAiFile".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "bytes" => intermediate_rep.bytes.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "filename" => intermediate_rep.filename.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "purpose" => intermediate_rep.purpose.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status_details" => intermediate_rep.status_details.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OpenAiFile".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OpenAiFile {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in OpenAiFile".to_string())?,
            bytes: intermediate_rep.bytes.into_iter().next().ok_or_else(|| "bytes missing in OpenAiFile".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in OpenAiFile".to_string())?,
            filename: intermediate_rep.filename.into_iter().next().ok_or_else(|| "filename missing in OpenAiFile".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in OpenAiFile".to_string())?,
            purpose: intermediate_rep.purpose.into_iter().next().ok_or_else(|| "purpose missing in OpenAiFile".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in OpenAiFile".to_string())?,
            status_details: intermediate_rep.status_details.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OpenAiFile> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OpenAiFile>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OpenAiFile>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for OpenAiFile - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OpenAiFile> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OpenAiFile as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into OpenAiFile - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// This is returned when the chunking strategy is unknown. Typically, this is because the file was indexed before the `chunking_strategy` concept was introduced in the API.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OtherChunkingStrategyResponseParam {
    /// Always `other`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

}



impl OtherChunkingStrategyResponseParam {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> OtherChunkingStrategyResponseParam {
        OtherChunkingStrategyResponseParam {
 r_type,
        }
    }
}

/// Converts the OtherChunkingStrategyResponseParam value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for OtherChunkingStrategyResponseParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OtherChunkingStrategyResponseParam value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OtherChunkingStrategyResponseParam {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OtherChunkingStrategyResponseParam".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OtherChunkingStrategyResponseParam".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OtherChunkingStrategyResponseParam {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in OtherChunkingStrategyResponseParam".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OtherChunkingStrategyResponseParam> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<OtherChunkingStrategyResponseParam>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OtherChunkingStrategyResponseParam>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for OtherChunkingStrategyResponseParam - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<OtherChunkingStrategyResponseParam> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OtherChunkingStrategyResponseParam as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into OtherChunkingStrategyResponseParam - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
#[derive(Debug, Clone, PartialEq, PartialOrd,  serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ParallelToolCalls(pub bool);

impl validator::Validate for ParallelToolCalls {
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {

        std::result::Result::Ok(())
    }
}

impl std::convert::From<bool> for ParallelToolCalls {
    fn from(x: bool) -> Self {
        ParallelToolCalls(x)
    }
}

impl std::convert::From<ParallelToolCalls> for bool {
    fn from(x: ParallelToolCalls) -> Self {
        x.0
    }
}

impl std::ops::Deref for ParallelToolCalls {
    type Target = bool;
    fn deref(&self) -> &bool {
        &self.0
    }
}

impl std::ops::DerefMut for ParallelToolCalls {
    fn deref_mut(&mut self) -> &mut bool {
        &mut self.0
    }
}



/// Static predicted output content, such as the content of a text file that is being regenerated. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PredictionContent {
    /// The type of the predicted content you want to provide. This type is currently always `content`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "content")]
          #[validate(nested)]
    pub content: models::PredictionContentContent,

}



impl PredictionContent {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, content: models::PredictionContentContent, ) -> PredictionContent {
        PredictionContent {
 r_type,
 content,
        }
    }
}

/// Converts the PredictionContent value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PredictionContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping content in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PredictionContent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PredictionContent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub content: Vec<models::PredictionContentContent>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PredictionContent".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content" => intermediate_rep.content.push(<models::PredictionContentContent as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PredictionContent".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PredictionContent {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in PredictionContent".to_string())?,
            content: intermediate_rep.content.into_iter().next().ok_or_else(|| "content missing in PredictionContent".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PredictionContent> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PredictionContent>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PredictionContent>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PredictionContent - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PredictionContent> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PredictionContent as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PredictionContent - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The content that should be matched when generating a model response. If generated tokens would match this content, the entire model response can be returned much more quickly. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum PredictionContentContent {
    String(String),
    VecOfChatCompletionRequestMessageContentPartText(Vec<models::ChatCompletionRequestMessageContentPartText>),
}

impl validator::Validate for PredictionContentContent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::VecOfChatCompletionRequestMessageContentPartText(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PredictionContentContent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PredictionContentContent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<String> for PredictionContentContent {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}
impl From<Vec<models::ChatCompletionRequestMessageContentPartText>> for PredictionContentContent {
    fn from(value: Vec<models::ChatCompletionRequestMessageContentPartText>) -> Self {
        Self::VecOfChatCompletionRequestMessageContentPartText(value)
    }
}





/// Represents an individual project.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Project {
    /// The identifier, which can be referenced in API endpoints
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The object type, which is always `organization.project`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The name of the project. This appears in reporting.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    /// The Unix timestamp (in seconds) of when the project was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    /// The Unix timestamp (in seconds) of when the project was archived or `null`.
    #[serde(rename = "archived_at")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived_at: Option<Nullable<i32>>,

    /// `active` or `archived`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
          #[validate(custom(function = "check_xss_string"))]
    pub status: String,

}



impl Project {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, name: String, created_at: i32, status: String, ) -> Project {
        Project {
 id,
 object,
 name,
 created_at,
 archived_at: None,
 status,
        }
    }
}

/// Converts the Project value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Project {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            self.archived_at.as_ref().map(|archived_at| {
                [
                    "archived_at".to_string(),
                    archived_at.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            Some("status".to_string()),
            Some(self.status.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Project value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Project {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub name: Vec<String>,
            pub created_at: Vec<i32>,
            pub archived_at: Vec<i32>,
            pub status: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Project".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "archived_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Project".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Project".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Project {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in Project".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in Project".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in Project".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in Project".to_string())?,
            archived_at: std::result::Result::Err("Nullable types not supported in Project".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in Project".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Project> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Project>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Project>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for Project - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Project> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Project as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into Project - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Represents an individual API key in a project.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectApiKey {
    /// The object type, which is always `organization.project.api_key`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The redacted value of the API key
    #[serde(rename = "redacted_value")]
          #[validate(custom(function = "check_xss_string"))]
    pub redacted_value: String,

    /// The name of the API key
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    /// The Unix timestamp (in seconds) of when the API key was created
    #[serde(rename = "created_at")]
    pub created_at: i32,

    /// The identifier, which can be referenced in API endpoints
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    #[serde(rename = "owner")]
          #[validate(nested)]
    pub owner: models::ProjectApiKeyOwner,

}



impl ProjectApiKey {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, redacted_value: String, name: String, created_at: i32, id: String, owner: models::ProjectApiKeyOwner, ) -> ProjectApiKey {
        ProjectApiKey {
 object,
 redacted_value,
 name,
 created_at,
 id,
 owner,
        }
    }
}

/// Converts the ProjectApiKey value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectApiKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("redacted_value".to_string()),
            Some(self.redacted_value.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),

            // Skipping owner in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectApiKey value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectApiKey {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub redacted_value: Vec<String>,
            pub name: Vec<String>,
            pub created_at: Vec<i32>,
            pub id: Vec<String>,
            pub owner: Vec<models::ProjectApiKeyOwner>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectApiKey".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "redacted_value" => intermediate_rep.redacted_value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "owner" => intermediate_rep.owner.push(<models::ProjectApiKeyOwner as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectApiKey".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectApiKey {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ProjectApiKey".to_string())?,
            redacted_value: intermediate_rep.redacted_value.into_iter().next().ok_or_else(|| "redacted_value missing in ProjectApiKey".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ProjectApiKey".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in ProjectApiKey".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ProjectApiKey".to_string())?,
            owner: intermediate_rep.owner.into_iter().next().ok_or_else(|| "owner missing in ProjectApiKey".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectApiKey> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectApiKey>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectApiKey>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectApiKey - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectApiKey> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectApiKey as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectApiKey - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectApiKeyDeleteResponse {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

}



impl ProjectApiKeyDeleteResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, id: String, deleted: bool, ) -> ProjectApiKeyDeleteResponse {
        ProjectApiKeyDeleteResponse {
 object,
 id,
 deleted,
        }
    }
}

/// Converts the ProjectApiKeyDeleteResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectApiKeyDeleteResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectApiKeyDeleteResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectApiKeyDeleteResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectApiKeyDeleteResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectApiKeyDeleteResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectApiKeyDeleteResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ProjectApiKeyDeleteResponse".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ProjectApiKeyDeleteResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in ProjectApiKeyDeleteResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectApiKeyDeleteResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectApiKeyDeleteResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectApiKeyDeleteResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectApiKeyDeleteResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectApiKeyDeleteResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectApiKeyDeleteResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectApiKeyDeleteResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectApiKeyListResponse {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::ProjectApiKey>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub first_id: String,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl ProjectApiKeyListResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::ProjectApiKey>, first_id: String, last_id: String, has_more: bool, ) -> ProjectApiKeyListResponse {
        ProjectApiKeyListResponse {
 object,
 data,
 first_id,
 last_id,
 has_more,
        }
    }
}

/// Converts the ProjectApiKeyListResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectApiKeyListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectApiKeyListResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectApiKeyListResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::ProjectApiKey>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectApiKeyListResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ProjectApiKeyListResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectApiKeyListResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectApiKeyListResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ProjectApiKeyListResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ProjectApiKeyListResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ProjectApiKeyListResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ProjectApiKeyListResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ProjectApiKeyListResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectApiKeyListResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectApiKeyListResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectApiKeyListResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectApiKeyListResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectApiKeyListResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectApiKeyListResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectApiKeyListResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectApiKeyOwner {
    /// `user` or `service_account`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    #[serde(rename = "user")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<models::ProjectUser>,

    #[serde(rename = "service_account")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub service_account: Option<models::ProjectServiceAccount>,

}



impl ProjectApiKeyOwner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ProjectApiKeyOwner {
        ProjectApiKeyOwner {
 r_type: None,
 user: None,
 service_account: None,
        }
    }
}

/// Converts the ProjectApiKeyOwner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectApiKeyOwner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),

            // Skipping user in query parameter serialization

            // Skipping service_account in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectApiKeyOwner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectApiKeyOwner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub user: Vec<models::ProjectUser>,
            pub service_account: Vec<models::ProjectServiceAccount>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectApiKeyOwner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "user" => intermediate_rep.user.push(<models::ProjectUser as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "service_account" => intermediate_rep.service_account.push(<models::ProjectServiceAccount as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectApiKeyOwner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectApiKeyOwner {
            r_type: intermediate_rep.r_type.into_iter().next(),
            user: intermediate_rep.user.into_iter().next(),
            service_account: intermediate_rep.service_account.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectApiKeyOwner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectApiKeyOwner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectApiKeyOwner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectApiKeyOwner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectApiKeyOwner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectApiKeyOwner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectApiKeyOwner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectCreateRequest {
    /// The friendly name of the project, this name appears in reports.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

}



impl ProjectCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> ProjectCreateRequest {
        ProjectCreateRequest {
 name,
        }
    }
}

/// Converts the ProjectCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectCreateRequest {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ProjectCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectCreateRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectCreateRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectListResponse {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::Project>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub first_id: String,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl ProjectListResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::Project>, first_id: String, last_id: String, has_more: bool, ) -> ProjectListResponse {
        ProjectListResponse {
 object,
 data,
 first_id,
 last_id,
 has_more,
        }
    }
}

/// Converts the ProjectListResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectListResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectListResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::Project>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectListResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ProjectListResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectListResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectListResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ProjectListResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ProjectListResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ProjectListResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ProjectListResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ProjectListResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectListResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectListResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectListResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectListResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectListResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectListResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectListResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Represents a project rate limit config.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectRateLimit {
    /// The object type, which is always `project.rate_limit`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The model this rate limit applies to.
    #[serde(rename = "model")]
          #[validate(custom(function = "check_xss_string"))]
    pub model: String,

    /// The maximum requests per minute.
    #[serde(rename = "max_requests_per_1_minute")]
    pub max_requests_per_1_minute: i32,

    /// The maximum tokens per minute.
    #[serde(rename = "max_tokens_per_1_minute")]
    pub max_tokens_per_1_minute: i32,

    /// The maximum images per minute. Only present for relevant models.
    #[serde(rename = "max_images_per_1_minute")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_images_per_1_minute: Option<i32>,

    /// The maximum audio megabytes per minute. Only present for relevant models.
    #[serde(rename = "max_audio_megabytes_per_1_minute")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_audio_megabytes_per_1_minute: Option<i32>,

    /// The maximum requests per day. Only present for relevant models.
    #[serde(rename = "max_requests_per_1_day")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_requests_per_1_day: Option<i32>,

    /// The maximum batch input tokens per day. Only present for relevant models.
    #[serde(rename = "batch_1_day_max_input_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub batch_1_day_max_input_tokens: Option<i32>,

}



impl ProjectRateLimit {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, id: String, model: String, max_requests_per_1_minute: i32, max_tokens_per_1_minute: i32, ) -> ProjectRateLimit {
        ProjectRateLimit {
 object,
 id,
 model,
 max_requests_per_1_minute,
 max_tokens_per_1_minute,
 max_images_per_1_minute: None,
 max_audio_megabytes_per_1_minute: None,
 max_requests_per_1_day: None,
 batch_1_day_max_input_tokens: None,
        }
    }
}

/// Converts the ProjectRateLimit value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectRateLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("model".to_string()),
            Some(self.model.to_string()),


            Some("max_requests_per_1_minute".to_string()),
            Some(self.max_requests_per_1_minute.to_string()),


            Some("max_tokens_per_1_minute".to_string()),
            Some(self.max_tokens_per_1_minute.to_string()),


            self.max_images_per_1_minute.as_ref().map(|max_images_per_1_minute| {
                [
                    "max_images_per_1_minute".to_string(),
                    max_images_per_1_minute.to_string(),
                ].join(",")
            }),


            self.max_audio_megabytes_per_1_minute.as_ref().map(|max_audio_megabytes_per_1_minute| {
                [
                    "max_audio_megabytes_per_1_minute".to_string(),
                    max_audio_megabytes_per_1_minute.to_string(),
                ].join(",")
            }),


            self.max_requests_per_1_day.as_ref().map(|max_requests_per_1_day| {
                [
                    "max_requests_per_1_day".to_string(),
                    max_requests_per_1_day.to_string(),
                ].join(",")
            }),


            self.batch_1_day_max_input_tokens.as_ref().map(|batch_1_day_max_input_tokens| {
                [
                    "batch_1_day_max_input_tokens".to_string(),
                    batch_1_day_max_input_tokens.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectRateLimit value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectRateLimit {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub id: Vec<String>,
            pub model: Vec<String>,
            pub max_requests_per_1_minute: Vec<i32>,
            pub max_tokens_per_1_minute: Vec<i32>,
            pub max_images_per_1_minute: Vec<i32>,
            pub max_audio_megabytes_per_1_minute: Vec<i32>,
            pub max_requests_per_1_day: Vec<i32>,
            pub batch_1_day_max_input_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectRateLimit".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_requests_per_1_minute" => intermediate_rep.max_requests_per_1_minute.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_tokens_per_1_minute" => intermediate_rep.max_tokens_per_1_minute.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_images_per_1_minute" => intermediate_rep.max_images_per_1_minute.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_audio_megabytes_per_1_minute" => intermediate_rep.max_audio_megabytes_per_1_minute.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_requests_per_1_day" => intermediate_rep.max_requests_per_1_day.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "batch_1_day_max_input_tokens" => intermediate_rep.batch_1_day_max_input_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectRateLimit".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectRateLimit {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ProjectRateLimit".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ProjectRateLimit".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in ProjectRateLimit".to_string())?,
            max_requests_per_1_minute: intermediate_rep.max_requests_per_1_minute.into_iter().next().ok_or_else(|| "max_requests_per_1_minute missing in ProjectRateLimit".to_string())?,
            max_tokens_per_1_minute: intermediate_rep.max_tokens_per_1_minute.into_iter().next().ok_or_else(|| "max_tokens_per_1_minute missing in ProjectRateLimit".to_string())?,
            max_images_per_1_minute: intermediate_rep.max_images_per_1_minute.into_iter().next(),
            max_audio_megabytes_per_1_minute: intermediate_rep.max_audio_megabytes_per_1_minute.into_iter().next(),
            max_requests_per_1_day: intermediate_rep.max_requests_per_1_day.into_iter().next(),
            batch_1_day_max_input_tokens: intermediate_rep.batch_1_day_max_input_tokens.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectRateLimit> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectRateLimit>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectRateLimit>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectRateLimit - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectRateLimit> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectRateLimit as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectRateLimit - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectRateLimitListResponse {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::ProjectRateLimit>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub first_id: String,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl ProjectRateLimitListResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::ProjectRateLimit>, first_id: String, last_id: String, has_more: bool, ) -> ProjectRateLimitListResponse {
        ProjectRateLimitListResponse {
 object,
 data,
 first_id,
 last_id,
 has_more,
        }
    }
}

/// Converts the ProjectRateLimitListResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectRateLimitListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectRateLimitListResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectRateLimitListResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::ProjectRateLimit>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectRateLimitListResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ProjectRateLimitListResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectRateLimitListResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectRateLimitListResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ProjectRateLimitListResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ProjectRateLimitListResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ProjectRateLimitListResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ProjectRateLimitListResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ProjectRateLimitListResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectRateLimitListResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectRateLimitListResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectRateLimitListResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectRateLimitListResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectRateLimitListResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectRateLimitListResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectRateLimitListResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectRateLimitUpdateRequest {
    /// The maximum requests per minute.
    #[serde(rename = "max_requests_per_1_minute")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_requests_per_1_minute: Option<i32>,

    /// The maximum tokens per minute.
    #[serde(rename = "max_tokens_per_1_minute")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_tokens_per_1_minute: Option<i32>,

    /// The maximum images per minute. Only relevant for certain models.
    #[serde(rename = "max_images_per_1_minute")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_images_per_1_minute: Option<i32>,

    /// The maximum audio megabytes per minute. Only relevant for certain models.
    #[serde(rename = "max_audio_megabytes_per_1_minute")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_audio_megabytes_per_1_minute: Option<i32>,

    /// The maximum requests per day. Only relevant for certain models.
    #[serde(rename = "max_requests_per_1_day")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_requests_per_1_day: Option<i32>,

    /// The maximum batch input tokens per day. Only relevant for certain models.
    #[serde(rename = "batch_1_day_max_input_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub batch_1_day_max_input_tokens: Option<i32>,

}



impl ProjectRateLimitUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ProjectRateLimitUpdateRequest {
        ProjectRateLimitUpdateRequest {
 max_requests_per_1_minute: None,
 max_tokens_per_1_minute: None,
 max_images_per_1_minute: None,
 max_audio_megabytes_per_1_minute: None,
 max_requests_per_1_day: None,
 batch_1_day_max_input_tokens: None,
        }
    }
}

/// Converts the ProjectRateLimitUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectRateLimitUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.max_requests_per_1_minute.as_ref().map(|max_requests_per_1_minute| {
                [
                    "max_requests_per_1_minute".to_string(),
                    max_requests_per_1_minute.to_string(),
                ].join(",")
            }),


            self.max_tokens_per_1_minute.as_ref().map(|max_tokens_per_1_minute| {
                [
                    "max_tokens_per_1_minute".to_string(),
                    max_tokens_per_1_minute.to_string(),
                ].join(",")
            }),


            self.max_images_per_1_minute.as_ref().map(|max_images_per_1_minute| {
                [
                    "max_images_per_1_minute".to_string(),
                    max_images_per_1_minute.to_string(),
                ].join(",")
            }),


            self.max_audio_megabytes_per_1_minute.as_ref().map(|max_audio_megabytes_per_1_minute| {
                [
                    "max_audio_megabytes_per_1_minute".to_string(),
                    max_audio_megabytes_per_1_minute.to_string(),
                ].join(",")
            }),


            self.max_requests_per_1_day.as_ref().map(|max_requests_per_1_day| {
                [
                    "max_requests_per_1_day".to_string(),
                    max_requests_per_1_day.to_string(),
                ].join(",")
            }),


            self.batch_1_day_max_input_tokens.as_ref().map(|batch_1_day_max_input_tokens| {
                [
                    "batch_1_day_max_input_tokens".to_string(),
                    batch_1_day_max_input_tokens.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectRateLimitUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectRateLimitUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub max_requests_per_1_minute: Vec<i32>,
            pub max_tokens_per_1_minute: Vec<i32>,
            pub max_images_per_1_minute: Vec<i32>,
            pub max_audio_megabytes_per_1_minute: Vec<i32>,
            pub max_requests_per_1_day: Vec<i32>,
            pub batch_1_day_max_input_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectRateLimitUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "max_requests_per_1_minute" => intermediate_rep.max_requests_per_1_minute.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_tokens_per_1_minute" => intermediate_rep.max_tokens_per_1_minute.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_images_per_1_minute" => intermediate_rep.max_images_per_1_minute.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_audio_megabytes_per_1_minute" => intermediate_rep.max_audio_megabytes_per_1_minute.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_requests_per_1_day" => intermediate_rep.max_requests_per_1_day.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "batch_1_day_max_input_tokens" => intermediate_rep.batch_1_day_max_input_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectRateLimitUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectRateLimitUpdateRequest {
            max_requests_per_1_minute: intermediate_rep.max_requests_per_1_minute.into_iter().next(),
            max_tokens_per_1_minute: intermediate_rep.max_tokens_per_1_minute.into_iter().next(),
            max_images_per_1_minute: intermediate_rep.max_images_per_1_minute.into_iter().next(),
            max_audio_megabytes_per_1_minute: intermediate_rep.max_audio_megabytes_per_1_minute.into_iter().next(),
            max_requests_per_1_day: intermediate_rep.max_requests_per_1_day.into_iter().next(),
            batch_1_day_max_input_tokens: intermediate_rep.batch_1_day_max_input_tokens.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectRateLimitUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectRateLimitUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectRateLimitUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectRateLimitUpdateRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectRateLimitUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectRateLimitUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectRateLimitUpdateRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Represents an individual service account in a project.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectServiceAccount {
    /// The object type, which is always `organization.project.service_account`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The identifier, which can be referenced in API endpoints
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The name of the service account
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    /// `owner` or `member`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    /// The Unix timestamp (in seconds) of when the service account was created
    #[serde(rename = "created_at")]
    pub created_at: i32,

}



impl ProjectServiceAccount {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, id: String, name: String, role: String, created_at: i32, ) -> ProjectServiceAccount {
        ProjectServiceAccount {
 object,
 id,
 name,
 role,
 created_at,
        }
    }
}

/// Converts the ProjectServiceAccount value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectServiceAccount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("role".to_string()),
            Some(self.role.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectServiceAccount value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectServiceAccount {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub role: Vec<String>,
            pub created_at: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectServiceAccount".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectServiceAccount".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectServiceAccount {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ProjectServiceAccount".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ProjectServiceAccount".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ProjectServiceAccount".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ProjectServiceAccount".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in ProjectServiceAccount".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectServiceAccount> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectServiceAccount>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectServiceAccount>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectServiceAccount - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectServiceAccount> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectServiceAccount as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectServiceAccount - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectServiceAccountApiKey {
    /// The object type, which is always `organization.project.service_account.api_key`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "value")]
          #[validate(custom(function = "check_xss_string"))]
    pub value: String,

    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    #[serde(rename = "created_at")]
    pub created_at: i32,

    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

}



impl ProjectServiceAccountApiKey {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, value: String, name: String, created_at: i32, id: String, ) -> ProjectServiceAccountApiKey {
        ProjectServiceAccountApiKey {
 object,
 value,
 name,
 created_at,
 id,
        }
    }
}

/// Converts the ProjectServiceAccountApiKey value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectServiceAccountApiKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("value".to_string()),
            Some(self.value.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectServiceAccountApiKey value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectServiceAccountApiKey {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub value: Vec<String>,
            pub name: Vec<String>,
            pub created_at: Vec<i32>,
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectServiceAccountApiKey".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectServiceAccountApiKey".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectServiceAccountApiKey {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ProjectServiceAccountApiKey".to_string())?,
            value: intermediate_rep.value.into_iter().next().ok_or_else(|| "value missing in ProjectServiceAccountApiKey".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ProjectServiceAccountApiKey".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in ProjectServiceAccountApiKey".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ProjectServiceAccountApiKey".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectServiceAccountApiKey> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectServiceAccountApiKey>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectServiceAccountApiKey>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectServiceAccountApiKey - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectServiceAccountApiKey> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectServiceAccountApiKey as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectServiceAccountApiKey - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectServiceAccountCreateRequest {
    /// The name of the service account being created.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

}



impl ProjectServiceAccountCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> ProjectServiceAccountCreateRequest {
        ProjectServiceAccountCreateRequest {
 name,
        }
    }
}

/// Converts the ProjectServiceAccountCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectServiceAccountCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectServiceAccountCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectServiceAccountCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectServiceAccountCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectServiceAccountCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectServiceAccountCreateRequest {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ProjectServiceAccountCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectServiceAccountCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectServiceAccountCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectServiceAccountCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectServiceAccountCreateRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectServiceAccountCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectServiceAccountCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectServiceAccountCreateRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectServiceAccountCreateResponse {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    /// Service accounts can only have one role of type `member`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    #[serde(rename = "created_at")]
    pub created_at: i32,

    #[serde(rename = "api_key")]
          #[validate(nested)]
    pub api_key: models::ProjectServiceAccountApiKey,

}



impl ProjectServiceAccountCreateResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, id: String, name: String, role: String, created_at: i32, api_key: models::ProjectServiceAccountApiKey, ) -> ProjectServiceAccountCreateResponse {
        ProjectServiceAccountCreateResponse {
 object,
 id,
 name,
 role,
 created_at,
 api_key,
        }
    }
}

/// Converts the ProjectServiceAccountCreateResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectServiceAccountCreateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("role".to_string()),
            Some(self.role.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),

            // Skipping api_key in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectServiceAccountCreateResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectServiceAccountCreateResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub role: Vec<String>,
            pub created_at: Vec<i32>,
            pub api_key: Vec<models::ProjectServiceAccountApiKey>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectServiceAccountCreateResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "api_key" => intermediate_rep.api_key.push(<models::ProjectServiceAccountApiKey as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectServiceAccountCreateResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectServiceAccountCreateResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ProjectServiceAccountCreateResponse".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ProjectServiceAccountCreateResponse".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ProjectServiceAccountCreateResponse".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ProjectServiceAccountCreateResponse".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in ProjectServiceAccountCreateResponse".to_string())?,
            api_key: intermediate_rep.api_key.into_iter().next().ok_or_else(|| "api_key missing in ProjectServiceAccountCreateResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectServiceAccountCreateResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectServiceAccountCreateResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectServiceAccountCreateResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectServiceAccountCreateResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectServiceAccountCreateResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectServiceAccountCreateResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectServiceAccountCreateResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectServiceAccountDeleteResponse {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

}



impl ProjectServiceAccountDeleteResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, id: String, deleted: bool, ) -> ProjectServiceAccountDeleteResponse {
        ProjectServiceAccountDeleteResponse {
 object,
 id,
 deleted,
        }
    }
}

/// Converts the ProjectServiceAccountDeleteResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectServiceAccountDeleteResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectServiceAccountDeleteResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectServiceAccountDeleteResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectServiceAccountDeleteResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectServiceAccountDeleteResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectServiceAccountDeleteResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ProjectServiceAccountDeleteResponse".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ProjectServiceAccountDeleteResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in ProjectServiceAccountDeleteResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectServiceAccountDeleteResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectServiceAccountDeleteResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectServiceAccountDeleteResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectServiceAccountDeleteResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectServiceAccountDeleteResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectServiceAccountDeleteResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectServiceAccountDeleteResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectServiceAccountListResponse {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::ProjectServiceAccount>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub first_id: String,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl ProjectServiceAccountListResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::ProjectServiceAccount>, first_id: String, last_id: String, has_more: bool, ) -> ProjectServiceAccountListResponse {
        ProjectServiceAccountListResponse {
 object,
 data,
 first_id,
 last_id,
 has_more,
        }
    }
}

/// Converts the ProjectServiceAccountListResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectServiceAccountListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectServiceAccountListResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectServiceAccountListResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::ProjectServiceAccount>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectServiceAccountListResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ProjectServiceAccountListResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectServiceAccountListResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectServiceAccountListResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ProjectServiceAccountListResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ProjectServiceAccountListResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ProjectServiceAccountListResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ProjectServiceAccountListResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ProjectServiceAccountListResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectServiceAccountListResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectServiceAccountListResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectServiceAccountListResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectServiceAccountListResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectServiceAccountListResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectServiceAccountListResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectServiceAccountListResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectUpdateRequest {
    /// The updated name of the project, this name appears in reports.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

}



impl ProjectUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> ProjectUpdateRequest {
        ProjectUpdateRequest {
 name,
        }
    }
}

/// Converts the ProjectUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectUpdateRequest {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ProjectUpdateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectUpdateRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectUpdateRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Represents an individual user in a project.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectUser {
    /// The object type, which is always `organization.project.user`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The identifier, which can be referenced in API endpoints
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The name of the user
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    /// The email address of the user
    #[serde(rename = "email")]
          #[validate(custom(function = "check_xss_string"))]
    pub email: String,

    /// `owner` or `member`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    /// The Unix timestamp (in seconds) of when the project was added.
    #[serde(rename = "added_at")]
    pub added_at: i32,

}



impl ProjectUser {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, id: String, name: String, email: String, role: String, added_at: i32, ) -> ProjectUser {
        ProjectUser {
 object,
 id,
 name,
 email,
 role,
 added_at,
        }
    }
}

/// Converts the ProjectUser value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("email".to_string()),
            Some(self.email.to_string()),


            Some("role".to_string()),
            Some(self.role.to_string()),


            Some("added_at".to_string()),
            Some(self.added_at.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectUser value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectUser {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub email: Vec<String>,
            pub role: Vec<String>,
            pub added_at: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectUser".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "added_at" => intermediate_rep.added_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectUser".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectUser {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ProjectUser".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ProjectUser".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ProjectUser".to_string())?,
            email: intermediate_rep.email.into_iter().next().ok_or_else(|| "email missing in ProjectUser".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ProjectUser".to_string())?,
            added_at: intermediate_rep.added_at.into_iter().next().ok_or_else(|| "added_at missing in ProjectUser".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectUser> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectUser>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectUser>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectUser - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectUser> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectUser as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectUser - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectUserCreateRequest {
    /// The ID of the user.
    #[serde(rename = "user_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub user_id: String,

    /// `owner` or `member`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

}



impl ProjectUserCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(user_id: String, role: String, ) -> ProjectUserCreateRequest {
        ProjectUserCreateRequest {
 user_id,
 role,
        }
    }
}

/// Converts the ProjectUserCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectUserCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("user_id".to_string()),
            Some(self.user_id.to_string()),


            Some("role".to_string()),
            Some(self.role.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectUserCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectUserCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub user_id: Vec<String>,
            pub role: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectUserCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "user_id" => intermediate_rep.user_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectUserCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectUserCreateRequest {
            user_id: intermediate_rep.user_id.into_iter().next().ok_or_else(|| "user_id missing in ProjectUserCreateRequest".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ProjectUserCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectUserCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectUserCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectUserCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectUserCreateRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectUserCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectUserCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectUserCreateRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectUserDeleteResponse {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

}



impl ProjectUserDeleteResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, id: String, deleted: bool, ) -> ProjectUserDeleteResponse {
        ProjectUserDeleteResponse {
 object,
 id,
 deleted,
        }
    }
}

/// Converts the ProjectUserDeleteResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectUserDeleteResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectUserDeleteResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectUserDeleteResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectUserDeleteResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectUserDeleteResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectUserDeleteResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ProjectUserDeleteResponse".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ProjectUserDeleteResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in ProjectUserDeleteResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectUserDeleteResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectUserDeleteResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectUserDeleteResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectUserDeleteResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectUserDeleteResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectUserDeleteResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectUserDeleteResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectUserListResponse {
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::ProjectUser>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub first_id: String,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl ProjectUserListResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::ProjectUser>, first_id: String, last_id: String, has_more: bool, ) -> ProjectUserListResponse {
        ProjectUserListResponse {
 object,
 data,
 first_id,
 last_id,
 has_more,
        }
    }
}

/// Converts the ProjectUserListResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectUserListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectUserListResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectUserListResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::ProjectUser>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectUserListResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in ProjectUserListResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectUserListResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectUserListResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ProjectUserListResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ProjectUserListResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in ProjectUserListResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in ProjectUserListResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in ProjectUserListResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectUserListResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectUserListResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectUserListResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectUserListResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectUserListResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectUserListResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectUserListResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProjectUserUpdateRequest {
    /// `owner` or `member`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

}



impl ProjectUserUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(role: String, ) -> ProjectUserUpdateRequest {
        ProjectUserUpdateRequest {
 role,
        }
    }
}

/// Converts the ProjectUserUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ProjectUserUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("role".to_string()),
            Some(self.role.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProjectUserUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProjectUserUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProjectUserUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProjectUserUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProjectUserUpdateRequest {
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in ProjectUserUpdateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProjectUserUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ProjectUserUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProjectUserUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ProjectUserUpdateRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ProjectUserUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProjectUserUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ProjectUserUpdateRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Add a new Item to the Conversation's context, including messages, function  calls, and function call responses. This event can be used both to populate a  \"history\" of the conversation and to add new items mid-stream, but has the  current limitation that it cannot populate assistant audio messages.  If successful, the server will respond with a `conversation.item.created`  event, otherwise an `error` event will be sent. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeClientEventConversationItemCreate {
    /// Optional client-generated ID used to identify this event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_id: Option<String>,

    /// The event type, must be `conversation.item.create`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the preceding item after which the new item will be inserted.  If not set, the new item will be appended to the end of the conversation.  If set, it allows an item to be inserted mid-conversation. If the ID  cannot be found, an error will be returned and the item will not be added. 
    #[serde(rename = "previous_item_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_item_id: Option<String>,

    #[serde(rename = "item")]
          #[validate(nested)]
    pub item: models::RealtimeConversationItem,

}



impl RealtimeClientEventConversationItemCreate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, item: models::RealtimeConversationItem, ) -> RealtimeClientEventConversationItemCreate {
        RealtimeClientEventConversationItemCreate {
 event_id: None,
 r_type,
 previous_item_id: None,
 item,
        }
    }
}

/// Converts the RealtimeClientEventConversationItemCreate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeClientEventConversationItemCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.event_id.as_ref().map(|event_id| {
                [
                    "event_id".to_string(),
                    event_id.to_string(),
                ].join(",")
            }),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            self.previous_item_id.as_ref().map(|previous_item_id| {
                [
                    "previous_item_id".to_string(),
                    previous_item_id.to_string(),
                ].join(",")
            }),

            // Skipping item in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeClientEventConversationItemCreate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeClientEventConversationItemCreate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub previous_item_id: Vec<String>,
            pub item: Vec<models::RealtimeConversationItem>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeClientEventConversationItemCreate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous_item_id" => intermediate_rep.previous_item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item" => intermediate_rep.item.push(<models::RealtimeConversationItem as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeClientEventConversationItemCreate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeClientEventConversationItemCreate {
            event_id: intermediate_rep.event_id.into_iter().next(),
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeClientEventConversationItemCreate".to_string())?,
            previous_item_id: intermediate_rep.previous_item_id.into_iter().next(),
            item: intermediate_rep.item.into_iter().next().ok_or_else(|| "item missing in RealtimeClientEventConversationItemCreate".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeClientEventConversationItemCreate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeClientEventConversationItemCreate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeClientEventConversationItemCreate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeClientEventConversationItemCreate - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeClientEventConversationItemCreate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeClientEventConversationItemCreate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeClientEventConversationItemCreate - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Send this event when you want to remove any item from the conversation  history. The server will respond with a `conversation.item.deleted` event,  unless the item does not exist in the conversation history, in which case the  server will respond with an error. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeClientEventConversationItemDelete {
    /// Optional client-generated ID used to identify this event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_id: Option<String>,

    /// The event type, must be `conversation.item.delete`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the item to delete.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

}



impl RealtimeClientEventConversationItemDelete {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, item_id: String, ) -> RealtimeClientEventConversationItemDelete {
        RealtimeClientEventConversationItemDelete {
 event_id: None,
 r_type,
 item_id,
        }
    }
}

/// Converts the RealtimeClientEventConversationItemDelete value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeClientEventConversationItemDelete {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.event_id.as_ref().map(|event_id| {
                [
                    "event_id".to_string(),
                    event_id.to_string(),
                ].join(",")
            }),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeClientEventConversationItemDelete value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeClientEventConversationItemDelete {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub item_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeClientEventConversationItemDelete".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeClientEventConversationItemDelete".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeClientEventConversationItemDelete {
            event_id: intermediate_rep.event_id.into_iter().next(),
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeClientEventConversationItemDelete".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeClientEventConversationItemDelete".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeClientEventConversationItemDelete> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeClientEventConversationItemDelete>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeClientEventConversationItemDelete>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeClientEventConversationItemDelete - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeClientEventConversationItemDelete> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeClientEventConversationItemDelete as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeClientEventConversationItemDelete - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Send this event to truncate a previous assistant messages audio. The server  will produce audio faster than realtime, so this event is useful when the user  interrupts to truncate audio that has already been sent to the client but not  yet played. This will synchronize the server's understanding of the audio with  the client's playback.  Truncating audio will delete the server-side text transcript to ensure there  is not text in the context that hasn't been heard by the user.  If successful, the server will respond with a `conversation.item.truncated`  event.  
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeClientEventConversationItemTruncate {
    /// Optional client-generated ID used to identify this event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_id: Option<String>,

    /// The event type, must be `conversation.item.truncate`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the assistant message item to truncate. Only assistant message  items can be truncated. 
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

    /// The index of the content part to truncate. Set this to 0.
    #[serde(rename = "content_index")]
    pub content_index: i32,

    /// Inclusive duration up to which audio is truncated, in milliseconds. If  the audio_end_ms is greater than the actual audio duration, the server  will respond with an error. 
    #[serde(rename = "audio_end_ms")]
    pub audio_end_ms: i32,

}



impl RealtimeClientEventConversationItemTruncate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, item_id: String, content_index: i32, audio_end_ms: i32, ) -> RealtimeClientEventConversationItemTruncate {
        RealtimeClientEventConversationItemTruncate {
 event_id: None,
 r_type,
 item_id,
 content_index,
 audio_end_ms,
        }
    }
}

/// Converts the RealtimeClientEventConversationItemTruncate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeClientEventConversationItemTruncate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.event_id.as_ref().map(|event_id| {
                [
                    "event_id".to_string(),
                    event_id.to_string(),
                ].join(",")
            }),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("content_index".to_string()),
            Some(self.content_index.to_string()),


            Some("audio_end_ms".to_string()),
            Some(self.audio_end_ms.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeClientEventConversationItemTruncate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeClientEventConversationItemTruncate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub item_id: Vec<String>,
            pub content_index: Vec<i32>,
            pub audio_end_ms: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeClientEventConversationItemTruncate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content_index" => intermediate_rep.content_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "audio_end_ms" => intermediate_rep.audio_end_ms.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeClientEventConversationItemTruncate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeClientEventConversationItemTruncate {
            event_id: intermediate_rep.event_id.into_iter().next(),
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeClientEventConversationItemTruncate".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeClientEventConversationItemTruncate".to_string())?,
            content_index: intermediate_rep.content_index.into_iter().next().ok_or_else(|| "content_index missing in RealtimeClientEventConversationItemTruncate".to_string())?,
            audio_end_ms: intermediate_rep.audio_end_ms.into_iter().next().ok_or_else(|| "audio_end_ms missing in RealtimeClientEventConversationItemTruncate".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeClientEventConversationItemTruncate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeClientEventConversationItemTruncate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeClientEventConversationItemTruncate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeClientEventConversationItemTruncate - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeClientEventConversationItemTruncate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeClientEventConversationItemTruncate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeClientEventConversationItemTruncate - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Send this event to append audio bytes to the input audio buffer. The audio  buffer is temporary storage you can write to and later commit. In Server VAD  mode, the audio buffer is used to detect speech and the server will decide  when to commit. When Server VAD is disabled, you must commit the audio buffer manually.  The client may choose how much audio to place in each event up to a maximum  of 15 MiB, for example streaming smaller chunks from the client may allow the  VAD to be more responsive. Unlike made other client events, the server will  not send a confirmation response to this event. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeClientEventInputAudioBufferAppend {
    /// Optional client-generated ID used to identify this event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_id: Option<String>,

    /// The event type, must be `input_audio_buffer.append`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// Base64-encoded audio bytes. This must be in the format specified by the  `input_audio_format` field in the session configuration. 
    #[serde(rename = "audio")]
          #[validate(custom(function = "check_xss_string"))]
    pub audio: String,

}



impl RealtimeClientEventInputAudioBufferAppend {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, audio: String, ) -> RealtimeClientEventInputAudioBufferAppend {
        RealtimeClientEventInputAudioBufferAppend {
 event_id: None,
 r_type,
 audio,
        }
    }
}

/// Converts the RealtimeClientEventInputAudioBufferAppend value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeClientEventInputAudioBufferAppend {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.event_id.as_ref().map(|event_id| {
                [
                    "event_id".to_string(),
                    event_id.to_string(),
                ].join(",")
            }),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("audio".to_string()),
            Some(self.audio.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeClientEventInputAudioBufferAppend value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeClientEventInputAudioBufferAppend {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub audio: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeClientEventInputAudioBufferAppend".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "audio" => intermediate_rep.audio.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeClientEventInputAudioBufferAppend".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeClientEventInputAudioBufferAppend {
            event_id: intermediate_rep.event_id.into_iter().next(),
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeClientEventInputAudioBufferAppend".to_string())?,
            audio: intermediate_rep.audio.into_iter().next().ok_or_else(|| "audio missing in RealtimeClientEventInputAudioBufferAppend".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeClientEventInputAudioBufferAppend> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeClientEventInputAudioBufferAppend>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeClientEventInputAudioBufferAppend>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeClientEventInputAudioBufferAppend - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeClientEventInputAudioBufferAppend> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeClientEventInputAudioBufferAppend as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeClientEventInputAudioBufferAppend - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Send this event to clear the audio bytes in the buffer. The server will  respond with an `input_audio_buffer.cleared` event. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeClientEventInputAudioBufferClear {
    /// Optional client-generated ID used to identify this event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_id: Option<String>,

    /// The event type, must be `input_audio_buffer.clear`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

}



impl RealtimeClientEventInputAudioBufferClear {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> RealtimeClientEventInputAudioBufferClear {
        RealtimeClientEventInputAudioBufferClear {
 event_id: None,
 r_type,
        }
    }
}

/// Converts the RealtimeClientEventInputAudioBufferClear value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeClientEventInputAudioBufferClear {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.event_id.as_ref().map(|event_id| {
                [
                    "event_id".to_string(),
                    event_id.to_string(),
                ].join(",")
            }),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeClientEventInputAudioBufferClear value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeClientEventInputAudioBufferClear {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeClientEventInputAudioBufferClear".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeClientEventInputAudioBufferClear".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeClientEventInputAudioBufferClear {
            event_id: intermediate_rep.event_id.into_iter().next(),
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeClientEventInputAudioBufferClear".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeClientEventInputAudioBufferClear> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeClientEventInputAudioBufferClear>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeClientEventInputAudioBufferClear>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeClientEventInputAudioBufferClear - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeClientEventInputAudioBufferClear> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeClientEventInputAudioBufferClear as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeClientEventInputAudioBufferClear - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Send this event to commit the user input audio buffer, which will create a  new user message item in the conversation. This event will produce an error  if the input audio buffer is empty. When in Server VAD mode, the client does  not need to send this event, the server will commit the audio buffer  automatically.  Committing the input audio buffer will trigger input audio transcription  (if enabled in session configuration), but it will not create a response  from the model. The server will respond with an `input_audio_buffer.committed`  event. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeClientEventInputAudioBufferCommit {
    /// Optional client-generated ID used to identify this event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_id: Option<String>,

    /// The event type, must be `input_audio_buffer.commit`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

}



impl RealtimeClientEventInputAudioBufferCommit {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> RealtimeClientEventInputAudioBufferCommit {
        RealtimeClientEventInputAudioBufferCommit {
 event_id: None,
 r_type,
        }
    }
}

/// Converts the RealtimeClientEventInputAudioBufferCommit value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeClientEventInputAudioBufferCommit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.event_id.as_ref().map(|event_id| {
                [
                    "event_id".to_string(),
                    event_id.to_string(),
                ].join(",")
            }),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeClientEventInputAudioBufferCommit value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeClientEventInputAudioBufferCommit {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeClientEventInputAudioBufferCommit".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeClientEventInputAudioBufferCommit".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeClientEventInputAudioBufferCommit {
            event_id: intermediate_rep.event_id.into_iter().next(),
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeClientEventInputAudioBufferCommit".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeClientEventInputAudioBufferCommit> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeClientEventInputAudioBufferCommit>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeClientEventInputAudioBufferCommit>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeClientEventInputAudioBufferCommit - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeClientEventInputAudioBufferCommit> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeClientEventInputAudioBufferCommit as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeClientEventInputAudioBufferCommit - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Send this event to cancel an in-progress response. The server will respond  with a `response.cancelled` event or an error if there is no response to  cancel. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeClientEventResponseCancel {
    /// Optional client-generated ID used to identify this event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_id: Option<String>,

    /// The event type, must be `response.cancel`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// A specific response ID to cancel - if not provided, will cancel an  in-progress response in the default conversation. 
    #[serde(rename = "response_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_id: Option<String>,

}



impl RealtimeClientEventResponseCancel {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> RealtimeClientEventResponseCancel {
        RealtimeClientEventResponseCancel {
 event_id: None,
 r_type,
 response_id: None,
        }
    }
}

/// Converts the RealtimeClientEventResponseCancel value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeClientEventResponseCancel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.event_id.as_ref().map(|event_id| {
                [
                    "event_id".to_string(),
                    event_id.to_string(),
                ].join(",")
            }),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            self.response_id.as_ref().map(|response_id| {
                [
                    "response_id".to_string(),
                    response_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeClientEventResponseCancel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeClientEventResponseCancel {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeClientEventResponseCancel".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_id" => intermediate_rep.response_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeClientEventResponseCancel".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeClientEventResponseCancel {
            event_id: intermediate_rep.event_id.into_iter().next(),
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeClientEventResponseCancel".to_string())?,
            response_id: intermediate_rep.response_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeClientEventResponseCancel> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeClientEventResponseCancel>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeClientEventResponseCancel>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeClientEventResponseCancel - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeClientEventResponseCancel> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeClientEventResponseCancel as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeClientEventResponseCancel - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// This event instructs the server to create a Response, which means triggering  model inference. When in Server VAD mode, the server will create Responses  automatically.  A Response will include at least one Item, and may have two, in which case  the second will be a function call. These Items will be appended to the  conversation history.  The server will respond with a `response.created` event, events for Items  and content created, and finally a `response.done` event to indicate the  Response is complete.  The `response.create` event includes inference configuration like  `instructions`, and `temperature`. These fields will override the Session's  configuration for this Response only. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeClientEventResponseCreate {
    /// Optional client-generated ID used to identify this event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_id: Option<String>,

    /// The event type, must be `response.create`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "response")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response: Option<models::RealtimeResponseCreateParams>,

}



impl RealtimeClientEventResponseCreate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> RealtimeClientEventResponseCreate {
        RealtimeClientEventResponseCreate {
 event_id: None,
 r_type,
 response: None,
        }
    }
}

/// Converts the RealtimeClientEventResponseCreate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeClientEventResponseCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.event_id.as_ref().map(|event_id| {
                [
                    "event_id".to_string(),
                    event_id.to_string(),
                ].join(",")
            }),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping response in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeClientEventResponseCreate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeClientEventResponseCreate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response: Vec<models::RealtimeResponseCreateParams>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeClientEventResponseCreate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response" => intermediate_rep.response.push(<models::RealtimeResponseCreateParams as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeClientEventResponseCreate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeClientEventResponseCreate {
            event_id: intermediate_rep.event_id.into_iter().next(),
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeClientEventResponseCreate".to_string())?,
            response: intermediate_rep.response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeClientEventResponseCreate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeClientEventResponseCreate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeClientEventResponseCreate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeClientEventResponseCreate - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeClientEventResponseCreate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeClientEventResponseCreate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeClientEventResponseCreate - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Send this event to update the sessions default configuration. The client may  send this event at any time to update the session configuration, and any  field may be updated at any time, except for \"voice\". The server will respond  with a `session.updated` event that shows the full effective configuration.  Only fields that are present are updated, thus the correct way to clear a  field like \"instructions\" is to pass an empty string. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeClientEventSessionUpdate {
    /// Optional client-generated ID used to identify this event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_id: Option<String>,

    /// The event type, must be `session.update`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "session")]
          #[validate(nested)]
    pub session: models::RealtimeSessionCreateRequest,

}



impl RealtimeClientEventSessionUpdate {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, session: models::RealtimeSessionCreateRequest, ) -> RealtimeClientEventSessionUpdate {
        RealtimeClientEventSessionUpdate {
 event_id: None,
 r_type,
 session,
        }
    }
}

/// Converts the RealtimeClientEventSessionUpdate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeClientEventSessionUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.event_id.as_ref().map(|event_id| {
                [
                    "event_id".to_string(),
                    event_id.to_string(),
                ].join(",")
            }),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping session in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeClientEventSessionUpdate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeClientEventSessionUpdate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub session: Vec<models::RealtimeSessionCreateRequest>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeClientEventSessionUpdate".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "session" => intermediate_rep.session.push(<models::RealtimeSessionCreateRequest as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeClientEventSessionUpdate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeClientEventSessionUpdate {
            event_id: intermediate_rep.event_id.into_iter().next(),
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeClientEventSessionUpdate".to_string())?,
            session: intermediate_rep.session.into_iter().next().ok_or_else(|| "session missing in RealtimeClientEventSessionUpdate".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeClientEventSessionUpdate> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeClientEventSessionUpdate>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeClientEventSessionUpdate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeClientEventSessionUpdate - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeClientEventSessionUpdate> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeClientEventSessionUpdate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeClientEventSessionUpdate - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The item to add to the conversation.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeConversationItem {
    /// The unique ID of the item, this can be generated by the client to help  manage server-side context, but is not required because the server will  generate one if not provided. 
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// The type of the item (`message`, `function_call`, `function_call_output`). 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    /// Identifier for the API object being returned - always `realtime.item`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub object: Option<String>,

    /// The status of the item (`completed`, `incomplete`). These have no effect  on the conversation, but are accepted for consistency with the  `conversation.item.created` event. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

    /// The role of the message sender (`user`, `assistant`, `system`), only  applicable for `message` items. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,

    /// The content of the message, applicable for `message` items.  - Message items of role `system` support only `input_text` content - Message items of role `user` support `input_text` and `input_audio`    content - Message items of role `assistant` support `text` content. 
    #[serde(rename = "content")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<Vec<models::RealtimeConversationItemContentInner>>,

    /// The ID of the function call (for `function_call` and  `function_call_output` items). If passed on a `function_call_output`  item, the server will check that a `function_call` item with the same  ID exists in the conversation history. 
    #[serde(rename = "call_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub call_id: Option<String>,

    /// The name of the function being called (for `function_call` items). 
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// The arguments of the function call (for `function_call` items). 
    #[serde(rename = "arguments")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub arguments: Option<String>,

    /// The output of the function call (for `function_call_output` items). 
    #[serde(rename = "output")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output: Option<String>,

}



impl RealtimeConversationItem {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeConversationItem {
        RealtimeConversationItem {
 id: None,
 r_type: None,
 object: None,
 status: None,
 role: None,
 content: None,
 call_id: None,
 name: None,
 arguments: None,
 output: None,
        }
    }
}

/// Converts the RealtimeConversationItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeConversationItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),


            self.object.as_ref().map(|object| {
                [
                    "object".to_string(),
                    object.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),


            self.role.as_ref().map(|role| {
                [
                    "role".to_string(),
                    role.to_string(),
                ].join(",")
            }),

            // Skipping content in query parameter serialization


            self.call_id.as_ref().map(|call_id| {
                [
                    "call_id".to_string(),
                    call_id.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.arguments.as_ref().map(|arguments| {
                [
                    "arguments".to_string(),
                    arguments.to_string(),
                ].join(",")
            }),


            self.output.as_ref().map(|output| {
                [
                    "output".to_string(),
                    output.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeConversationItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeConversationItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r_type: Vec<String>,
            pub object: Vec<String>,
            pub status: Vec<String>,
            pub role: Vec<String>,
            pub content: Vec<Vec<models::RealtimeConversationItemContentInner>>,
            pub call_id: Vec<String>,
            pub name: Vec<String>,
            pub arguments: Vec<String>,
            pub output: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeConversationItem".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "content" => return std::result::Result::Err("Parsing a container in this style is not supported in RealtimeConversationItem".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "call_id" => intermediate_rep.call_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output" => intermediate_rep.output.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeConversationItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeConversationItem {
            id: intermediate_rep.id.into_iter().next(),
            r_type: intermediate_rep.r_type.into_iter().next(),
            object: intermediate_rep.object.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            role: intermediate_rep.role.into_iter().next(),
            content: intermediate_rep.content.into_iter().next(),
            call_id: intermediate_rep.call_id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            arguments: intermediate_rep.arguments.into_iter().next(),
            output: intermediate_rep.output.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeConversationItem> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeConversationItem>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeConversationItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeConversationItem - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeConversationItem> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeConversationItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeConversationItem - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeConversationItemContentInner {
    /// The content type (`input_text`, `input_audio`, `item_reference`, `text`). 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    /// The text content, used for `input_text` and `text` content types. 
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,

    /// ID of a previous conversation item to reference (for `item_reference` content types in `response.create` events). These can reference both client and server created items. 
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Base64-encoded audio bytes, used for `input_audio` content type. 
    #[serde(rename = "audio")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audio: Option<String>,

    /// The transcript of the audio, used for `input_audio` content type. 
    #[serde(rename = "transcript")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub transcript: Option<String>,

}



impl RealtimeConversationItemContentInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeConversationItemContentInner {
        RealtimeConversationItemContentInner {
 r_type: None,
 text: None,
 id: None,
 audio: None,
 transcript: None,
        }
    }
}

/// Converts the RealtimeConversationItemContentInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeConversationItemContentInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),


            self.text.as_ref().map(|text| {
                [
                    "text".to_string(),
                    text.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.audio.as_ref().map(|audio| {
                [
                    "audio".to_string(),
                    audio.to_string(),
                ].join(",")
            }),


            self.transcript.as_ref().map(|transcript| {
                [
                    "transcript".to_string(),
                    transcript.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeConversationItemContentInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeConversationItemContentInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub text: Vec<String>,
            pub id: Vec<String>,
            pub audio: Vec<String>,
            pub transcript: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeConversationItemContentInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "audio" => intermediate_rep.audio.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "transcript" => intermediate_rep.transcript.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeConversationItemContentInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeConversationItemContentInner {
            r_type: intermediate_rep.r_type.into_iter().next(),
            text: intermediate_rep.text.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            audio: intermediate_rep.audio.into_iter().next(),
            transcript: intermediate_rep.transcript.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeConversationItemContentInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeConversationItemContentInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeConversationItemContentInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeConversationItemContentInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeConversationItemContentInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeConversationItemContentInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeConversationItemContentInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The response resource.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeResponse {
    /// The unique ID of the response.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// The object type, must be `realtime.response`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub object: Option<String>,

    /// The final status of the response (`completed`, `cancelled`, `failed`, or  `incomplete`). 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,

    #[serde(rename = "status_details")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status_details: Option<models::RealtimeResponseStatusDetails>,

    /// The list of output items generated by the response.
    #[serde(rename = "output")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output: Option<Vec<models::RealtimeConversationItem>>,

    /// Developer-provided string key-value pairs associated with this response. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

    #[serde(rename = "usage")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub usage: Option<models::RealtimeResponseUsage>,

}



impl RealtimeResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeResponse {
        RealtimeResponse {
 id: None,
 object: None,
 status: None,
 status_details: None,
 output: None,
 metadata: None,
 usage: None,
        }
    }
}

/// Converts the RealtimeResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.object.as_ref().map(|object| {
                [
                    "object".to_string(),
                    object.to_string(),
                ].join(",")
            }),


            self.status.as_ref().map(|status| {
                [
                    "status".to_string(),
                    status.to_string(),
                ].join(",")
            }),

            // Skipping status_details in query parameter serialization

            // Skipping output in query parameter serialization

            // Skipping metadata in query parameter serialization

            // Skipping usage in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub status: Vec<String>,
            pub status_details: Vec<models::RealtimeResponseStatusDetails>,
            pub output: Vec<Vec<models::RealtimeConversationItem>>,
            pub metadata: Vec<crate::types::Object>,
            pub usage: Vec<models::RealtimeResponseUsage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status_details" => intermediate_rep.status_details.push(<models::RealtimeResponseStatusDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "output" => return std::result::Result::Err("Parsing a container in this style is not supported in RealtimeResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usage" => intermediate_rep.usage.push(<models::RealtimeResponseUsage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeResponse {
            id: intermediate_rep.id.into_iter().next(),
            object: intermediate_rep.object.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            status_details: intermediate_rep.status_details.into_iter().next(),
            output: intermediate_rep.output.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            usage: intermediate_rep.usage.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Create a new Realtime response with these parameters
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeResponseCreateParams {
    /// The set of modalities the model can respond with. To disable audio, set this to [\"text\"]. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "modalities")]
          #[validate(custom(function = "check_xss_vec_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub modalities: Option<Vec<String>>,

    /// The default system instructions (i.e. system message) prepended to model  calls. This field allows the client to guide the model on desired  responses. The model can be instructed on response content and format,  (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good  responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion  into your voice\", \"laugh frequently\"). The instructions are not guaranteed  to be followed by the model, but they provide guidance to the model on the  desired behavior.  Note that the server sets default instructions which will be used if this  field is not set and are visible in the `session.created` event at the  start of the session. 
    #[serde(rename = "instructions")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instructions: Option<String>,

    /// The voice the model uses to respond. Voice cannot be changed during the  session once the model has responded with audio at least once. Current  voice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`,  `shimmer` and `verse`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "voice")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub voice: Option<String>,

    /// The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "output_audio_format")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output_audio_format: Option<String>,

    /// Tools (functions) available to the model.
    #[serde(rename = "tools")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Vec<models::RealtimeResponseCreateParamsToolsInner>>,

    /// How the model chooses tools. Options are `auto`, `none`, `required`, or  specify a function, like `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}`. 
    #[serde(rename = "tool_choice")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_choice: Option<String>,

    /// Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8. 
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<f64>,

    #[serde(rename = "max_response_output_tokens")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_response_output_tokens: Option<models::RealtimeResponseCreateParamsMaxResponseOutputTokens>,

    #[serde(rename = "conversation")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conversation: Option<models::RealtimeResponseCreateParamsConversation>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

    /// Input items to include in the prompt for the model. Creates a new context for this response, without including the default conversation. Can include references to items from the default conversation. 
    #[serde(rename = "input")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub input: Option<Vec<models::RealtimeConversationItem>>,

}



impl RealtimeResponseCreateParams {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeResponseCreateParams {
        RealtimeResponseCreateParams {
 modalities: None,
 instructions: None,
 voice: None,
 output_audio_format: None,
 tools: None,
 tool_choice: None,
 temperature: None,
 max_response_output_tokens: None,
 conversation: None,
 metadata: None,
 input: None,
        }
    }
}

/// Converts the RealtimeResponseCreateParams value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeResponseCreateParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.modalities.as_ref().map(|modalities| {
                [
                    "modalities".to_string(),
                    modalities.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.instructions.as_ref().map(|instructions| {
                [
                    "instructions".to_string(),
                    instructions.to_string(),
                ].join(",")
            }),


            self.voice.as_ref().map(|voice| {
                [
                    "voice".to_string(),
                    voice.to_string(),
                ].join(",")
            }),


            self.output_audio_format.as_ref().map(|output_audio_format| {
                [
                    "output_audio_format".to_string(),
                    output_audio_format.to_string(),
                ].join(",")
            }),

            // Skipping tools in query parameter serialization


            self.tool_choice.as_ref().map(|tool_choice| {
                [
                    "tool_choice".to_string(),
                    tool_choice.to_string(),
                ].join(",")
            }),


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.to_string(),
                ].join(",")
            }),

            // Skipping max_response_output_tokens in query parameter serialization

            // Skipping conversation in query parameter serialization

            // Skipping metadata in query parameter serialization

            // Skipping input in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeResponseCreateParams value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeResponseCreateParams {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub modalities: Vec<Vec<String>>,
            pub instructions: Vec<String>,
            pub voice: Vec<String>,
            pub output_audio_format: Vec<String>,
            pub tools: Vec<Vec<models::RealtimeResponseCreateParamsToolsInner>>,
            pub tool_choice: Vec<String>,
            pub temperature: Vec<f64>,
            pub max_response_output_tokens: Vec<models::RealtimeResponseCreateParamsMaxResponseOutputTokens>,
            pub conversation: Vec<models::RealtimeResponseCreateParamsConversation>,
            pub metadata: Vec<crate::types::Object>,
            pub input: Vec<Vec<models::RealtimeConversationItem>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeResponseCreateParams".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "modalities" => return std::result::Result::Err("Parsing a container in this style is not supported in RealtimeResponseCreateParams".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "instructions" => intermediate_rep.instructions.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "voice" => intermediate_rep.voice.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_audio_format" => intermediate_rep.output_audio_format.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in RealtimeResponseCreateParams".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "tool_choice" => intermediate_rep.tool_choice.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "temperature" => intermediate_rep.temperature.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_response_output_tokens" => intermediate_rep.max_response_output_tokens.push(<models::RealtimeResponseCreateParamsMaxResponseOutputTokens as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "conversation" => intermediate_rep.conversation.push(<models::RealtimeResponseCreateParamsConversation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "input" => return std::result::Result::Err("Parsing a container in this style is not supported in RealtimeResponseCreateParams".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeResponseCreateParams".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeResponseCreateParams {
            modalities: intermediate_rep.modalities.into_iter().next(),
            instructions: intermediate_rep.instructions.into_iter().next(),
            voice: intermediate_rep.voice.into_iter().next(),
            output_audio_format: intermediate_rep.output_audio_format.into_iter().next(),
            tools: intermediate_rep.tools.into_iter().next(),
            tool_choice: intermediate_rep.tool_choice.into_iter().next(),
            temperature: intermediate_rep.temperature.into_iter().next(),
            max_response_output_tokens: intermediate_rep.max_response_output_tokens.into_iter().next(),
            conversation: intermediate_rep.conversation.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
            input: intermediate_rep.input.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeResponseCreateParams> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeResponseCreateParams>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeResponseCreateParams>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeResponseCreateParams - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeResponseCreateParams> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeResponseCreateParams as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeResponseCreateParams - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Controls which conversation the response is added to. Currently supports `auto` and `none`, with `auto` as the default value. The `auto` value means that the contents of the response will be added to the default conversation. Set this to `none` to create an out-of-band response which  will not add items to default conversation. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum RealtimeResponseCreateParamsConversation {
    String(String),
    String1(String),
}

impl validator::Validate for RealtimeResponseCreateParamsConversation
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::String1(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeResponseCreateParamsConversation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeResponseCreateParamsConversation {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}







/// Maximum number of output tokens for a single assistant response, inclusive of tool calls. Provide an integer between 1 and 4096 to limit output tokens, or `inf` for the maximum available tokens for a given model. Defaults to `inf`. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum RealtimeResponseCreateParamsMaxResponseOutputTokens {
    I32(i32),
    String(String),
}

impl validator::Validate for RealtimeResponseCreateParamsMaxResponseOutputTokens
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::I32(_) => std::result::Result::Ok(()),
            Self::String(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeResponseCreateParamsMaxResponseOutputTokens value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeResponseCreateParamsMaxResponseOutputTokens {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<i32> for RealtimeResponseCreateParamsMaxResponseOutputTokens {
    fn from(value: i32) -> Self {
        Self::I32(value)
    }
}
impl From<String> for RealtimeResponseCreateParamsMaxResponseOutputTokens {
    fn from(value: String) -> Self {
        Self::String(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeResponseCreateParamsToolsInner {
    /// The type of the tool, i.e. `function`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    /// The name of the function.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// The description of the function, including guidance on when and how  to call it, and guidance about what to tell the user when calling  (if anything). 
    #[serde(rename = "description")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// Parameters of the function in JSON Schema.
    #[serde(rename = "parameters")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<crate::types::Object>,

}



impl RealtimeResponseCreateParamsToolsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeResponseCreateParamsToolsInner {
        RealtimeResponseCreateParamsToolsInner {
 r_type: None,
 name: None,
 description: None,
 parameters: None,
        }
    }
}

/// Converts the RealtimeResponseCreateParamsToolsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeResponseCreateParamsToolsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),


            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping parameters in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeResponseCreateParamsToolsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeResponseCreateParamsToolsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub parameters: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeResponseCreateParamsToolsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parameters" => intermediate_rep.parameters.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeResponseCreateParamsToolsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeResponseCreateParamsToolsInner {
            r_type: intermediate_rep.r_type.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            parameters: intermediate_rep.parameters.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeResponseCreateParamsToolsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeResponseCreateParamsToolsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeResponseCreateParamsToolsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeResponseCreateParamsToolsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeResponseCreateParamsToolsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeResponseCreateParamsToolsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeResponseCreateParamsToolsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Additional details about the status.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeResponseStatusDetails {
    /// The type of error that caused the response to fail, corresponding  with the `status` field (`completed`, `cancelled`, `incomplete`,  `failed`). 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    /// The reason the Response did not complete. For a `cancelled` Response,  one of `turn_detected` (the server VAD detected a new start of speech)  or `client_cancelled` (the client sent a cancel event). For an  `incomplete` Response, one of `max_output_tokens` or `content_filter`  (the server-side safety filter activated and cut off the response). 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "reason")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,

    #[serde(rename = "error")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<models::RealtimeResponseStatusDetailsError>,

}



impl RealtimeResponseStatusDetails {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeResponseStatusDetails {
        RealtimeResponseStatusDetails {
 r_type: None,
 reason: None,
 error: None,
        }
    }
}

/// Converts the RealtimeResponseStatusDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeResponseStatusDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),


            self.reason.as_ref().map(|reason| {
                [
                    "reason".to_string(),
                    reason.to_string(),
                ].join(",")
            }),

            // Skipping error in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeResponseStatusDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeResponseStatusDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub reason: Vec<String>,
            pub error: Vec<models::RealtimeResponseStatusDetailsError>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeResponseStatusDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(<models::RealtimeResponseStatusDetailsError as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeResponseStatusDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeResponseStatusDetails {
            r_type: intermediate_rep.r_type.into_iter().next(),
            reason: intermediate_rep.reason.into_iter().next(),
            error: intermediate_rep.error.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeResponseStatusDetails> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeResponseStatusDetails>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeResponseStatusDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeResponseStatusDetails - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeResponseStatusDetails> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeResponseStatusDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeResponseStatusDetails - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A description of the error that caused the response to fail,  populated when the `status` is `failed`. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeResponseStatusDetailsError {
    /// The type of error.
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    /// Error code, if any.
    #[serde(rename = "code")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<String>,

}



impl RealtimeResponseStatusDetailsError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeResponseStatusDetailsError {
        RealtimeResponseStatusDetailsError {
 r_type: None,
 code: None,
        }
    }
}

/// Converts the RealtimeResponseStatusDetailsError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeResponseStatusDetailsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),


            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeResponseStatusDetailsError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeResponseStatusDetailsError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub code: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeResponseStatusDetailsError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeResponseStatusDetailsError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeResponseStatusDetailsError {
            r_type: intermediate_rep.r_type.into_iter().next(),
            code: intermediate_rep.code.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeResponseStatusDetailsError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeResponseStatusDetailsError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeResponseStatusDetailsError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeResponseStatusDetailsError - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeResponseStatusDetailsError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeResponseStatusDetailsError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeResponseStatusDetailsError - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Usage statistics for the Response, this will correspond to billing. A  Realtime API session will maintain a conversation context and append new  Items to the Conversation, thus output from previous turns (text and  audio tokens) will become the input for later turns. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeResponseUsage {
    /// The total number of tokens in the Response including input and output  text and audio tokens. 
    #[serde(rename = "total_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_tokens: Option<i32>,

    /// The number of input tokens used in the Response, including text and  audio tokens. 
    #[serde(rename = "input_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub input_tokens: Option<i32>,

    /// The number of output tokens sent in the Response, including text and  audio tokens. 
    #[serde(rename = "output_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output_tokens: Option<i32>,

    #[serde(rename = "input_token_details")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub input_token_details: Option<models::RealtimeResponseUsageInputTokenDetails>,

    #[serde(rename = "output_token_details")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output_token_details: Option<models::RealtimeResponseUsageOutputTokenDetails>,

}



impl RealtimeResponseUsage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeResponseUsage {
        RealtimeResponseUsage {
 total_tokens: None,
 input_tokens: None,
 output_tokens: None,
 input_token_details: None,
 output_token_details: None,
        }
    }
}

/// Converts the RealtimeResponseUsage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeResponseUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.total_tokens.as_ref().map(|total_tokens| {
                [
                    "total_tokens".to_string(),
                    total_tokens.to_string(),
                ].join(",")
            }),


            self.input_tokens.as_ref().map(|input_tokens| {
                [
                    "input_tokens".to_string(),
                    input_tokens.to_string(),
                ].join(",")
            }),


            self.output_tokens.as_ref().map(|output_tokens| {
                [
                    "output_tokens".to_string(),
                    output_tokens.to_string(),
                ].join(",")
            }),

            // Skipping input_token_details in query parameter serialization

            // Skipping output_token_details in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeResponseUsage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeResponseUsage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub total_tokens: Vec<i32>,
            pub input_tokens: Vec<i32>,
            pub output_tokens: Vec<i32>,
            pub input_token_details: Vec<models::RealtimeResponseUsageInputTokenDetails>,
            pub output_token_details: Vec<models::RealtimeResponseUsageOutputTokenDetails>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeResponseUsage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "total_tokens" => intermediate_rep.total_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input_tokens" => intermediate_rep.input_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_tokens" => intermediate_rep.output_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input_token_details" => intermediate_rep.input_token_details.push(<models::RealtimeResponseUsageInputTokenDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_token_details" => intermediate_rep.output_token_details.push(<models::RealtimeResponseUsageOutputTokenDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeResponseUsage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeResponseUsage {
            total_tokens: intermediate_rep.total_tokens.into_iter().next(),
            input_tokens: intermediate_rep.input_tokens.into_iter().next(),
            output_tokens: intermediate_rep.output_tokens.into_iter().next(),
            input_token_details: intermediate_rep.input_token_details.into_iter().next(),
            output_token_details: intermediate_rep.output_token_details.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeResponseUsage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeResponseUsage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeResponseUsage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeResponseUsage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeResponseUsage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeResponseUsage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeResponseUsage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Details about the input tokens used in the Response.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeResponseUsageInputTokenDetails {
    /// The number of cached tokens used in the Response.
    #[serde(rename = "cached_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cached_tokens: Option<i32>,

    /// The number of text tokens used in the Response.
    #[serde(rename = "text_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text_tokens: Option<i32>,

    /// The number of audio tokens used in the Response.
    #[serde(rename = "audio_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audio_tokens: Option<i32>,

}



impl RealtimeResponseUsageInputTokenDetails {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeResponseUsageInputTokenDetails {
        RealtimeResponseUsageInputTokenDetails {
 cached_tokens: None,
 text_tokens: None,
 audio_tokens: None,
        }
    }
}

/// Converts the RealtimeResponseUsageInputTokenDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeResponseUsageInputTokenDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.cached_tokens.as_ref().map(|cached_tokens| {
                [
                    "cached_tokens".to_string(),
                    cached_tokens.to_string(),
                ].join(",")
            }),


            self.text_tokens.as_ref().map(|text_tokens| {
                [
                    "text_tokens".to_string(),
                    text_tokens.to_string(),
                ].join(",")
            }),


            self.audio_tokens.as_ref().map(|audio_tokens| {
                [
                    "audio_tokens".to_string(),
                    audio_tokens.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeResponseUsageInputTokenDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeResponseUsageInputTokenDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub cached_tokens: Vec<i32>,
            pub text_tokens: Vec<i32>,
            pub audio_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeResponseUsageInputTokenDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "cached_tokens" => intermediate_rep.cached_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text_tokens" => intermediate_rep.text_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "audio_tokens" => intermediate_rep.audio_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeResponseUsageInputTokenDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeResponseUsageInputTokenDetails {
            cached_tokens: intermediate_rep.cached_tokens.into_iter().next(),
            text_tokens: intermediate_rep.text_tokens.into_iter().next(),
            audio_tokens: intermediate_rep.audio_tokens.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeResponseUsageInputTokenDetails> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeResponseUsageInputTokenDetails>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeResponseUsageInputTokenDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeResponseUsageInputTokenDetails - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeResponseUsageInputTokenDetails> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeResponseUsageInputTokenDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeResponseUsageInputTokenDetails - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Details about the output tokens used in the Response.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeResponseUsageOutputTokenDetails {
    /// The number of text tokens used in the Response.
    #[serde(rename = "text_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text_tokens: Option<i32>,

    /// The number of audio tokens used in the Response.
    #[serde(rename = "audio_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audio_tokens: Option<i32>,

}



impl RealtimeResponseUsageOutputTokenDetails {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeResponseUsageOutputTokenDetails {
        RealtimeResponseUsageOutputTokenDetails {
 text_tokens: None,
 audio_tokens: None,
        }
    }
}

/// Converts the RealtimeResponseUsageOutputTokenDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeResponseUsageOutputTokenDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.text_tokens.as_ref().map(|text_tokens| {
                [
                    "text_tokens".to_string(),
                    text_tokens.to_string(),
                ].join(",")
            }),


            self.audio_tokens.as_ref().map(|audio_tokens| {
                [
                    "audio_tokens".to_string(),
                    audio_tokens.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeResponseUsageOutputTokenDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeResponseUsageOutputTokenDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub text_tokens: Vec<i32>,
            pub audio_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeResponseUsageOutputTokenDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "text_tokens" => intermediate_rep.text_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "audio_tokens" => intermediate_rep.audio_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeResponseUsageOutputTokenDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeResponseUsageOutputTokenDetails {
            text_tokens: intermediate_rep.text_tokens.into_iter().next(),
            audio_tokens: intermediate_rep.audio_tokens.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeResponseUsageOutputTokenDetails> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeResponseUsageOutputTokenDetails>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeResponseUsageOutputTokenDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeResponseUsageOutputTokenDetails - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeResponseUsageOutputTokenDetails> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeResponseUsageOutputTokenDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeResponseUsageOutputTokenDetails - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when a conversation is created. Emitted right after session creation. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventConversationCreated {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `conversation.created`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "conversation")]
          #[validate(nested)]
    pub conversation: models::RealtimeServerEventConversationCreatedConversation,

}



impl RealtimeServerEventConversationCreated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, conversation: models::RealtimeServerEventConversationCreatedConversation, ) -> RealtimeServerEventConversationCreated {
        RealtimeServerEventConversationCreated {
 event_id,
 r_type,
 conversation,
        }
    }
}

/// Converts the RealtimeServerEventConversationCreated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventConversationCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping conversation in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventConversationCreated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventConversationCreated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub conversation: Vec<models::RealtimeServerEventConversationCreatedConversation>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventConversationCreated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "conversation" => intermediate_rep.conversation.push(<models::RealtimeServerEventConversationCreatedConversation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventConversationCreated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventConversationCreated {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventConversationCreated".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventConversationCreated".to_string())?,
            conversation: intermediate_rep.conversation.into_iter().next().ok_or_else(|| "conversation missing in RealtimeServerEventConversationCreated".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventConversationCreated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventConversationCreated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventConversationCreated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventConversationCreated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventConversationCreated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventConversationCreated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventConversationCreated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The conversation resource.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventConversationCreatedConversation {
    /// The unique ID of the conversation.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// The object type, must be `realtime.conversation`.
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub object: Option<String>,

}



impl RealtimeServerEventConversationCreatedConversation {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeServerEventConversationCreatedConversation {
        RealtimeServerEventConversationCreatedConversation {
 id: None,
 object: None,
        }
    }
}

/// Converts the RealtimeServerEventConversationCreatedConversation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventConversationCreatedConversation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.object.as_ref().map(|object| {
                [
                    "object".to_string(),
                    object.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventConversationCreatedConversation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventConversationCreatedConversation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventConversationCreatedConversation".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventConversationCreatedConversation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventConversationCreatedConversation {
            id: intermediate_rep.id.into_iter().next(),
            object: intermediate_rep.object.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventConversationCreatedConversation> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventConversationCreatedConversation>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventConversationCreatedConversation>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventConversationCreatedConversation - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventConversationCreatedConversation> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventConversationCreatedConversation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventConversationCreatedConversation - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when a conversation item is created. There are several scenarios that  produce this event:   - The server is generating a Response, which if successful will produce      either one or two Items, which will be of type `message`      (role `assistant`) or type `function_call`.   - The input audio buffer has been committed, either by the client or the      server (in `server_vad` mode). The server will take the content of the      input audio buffer and add it to a new user message Item.   - The client has sent a `conversation.item.create` event to add a new Item      to the Conversation. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventConversationItemCreated {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `conversation.item.created`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the preceding item in the Conversation context, allows the  client to understand the order of the conversation. 
    #[serde(rename = "previous_item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub previous_item_id: String,

    #[serde(rename = "item")]
          #[validate(nested)]
    pub item: models::RealtimeConversationItem,

}



impl RealtimeServerEventConversationItemCreated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, previous_item_id: String, item: models::RealtimeConversationItem, ) -> RealtimeServerEventConversationItemCreated {
        RealtimeServerEventConversationItemCreated {
 event_id,
 r_type,
 previous_item_id,
 item,
        }
    }
}

/// Converts the RealtimeServerEventConversationItemCreated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventConversationItemCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("previous_item_id".to_string()),
            Some(self.previous_item_id.to_string()),

            // Skipping item in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventConversationItemCreated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventConversationItemCreated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub previous_item_id: Vec<String>,
            pub item: Vec<models::RealtimeConversationItem>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventConversationItemCreated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous_item_id" => intermediate_rep.previous_item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item" => intermediate_rep.item.push(<models::RealtimeConversationItem as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventConversationItemCreated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventConversationItemCreated {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventConversationItemCreated".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventConversationItemCreated".to_string())?,
            previous_item_id: intermediate_rep.previous_item_id.into_iter().next().ok_or_else(|| "previous_item_id missing in RealtimeServerEventConversationItemCreated".to_string())?,
            item: intermediate_rep.item.into_iter().next().ok_or_else(|| "item missing in RealtimeServerEventConversationItemCreated".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventConversationItemCreated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventConversationItemCreated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventConversationItemCreated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventConversationItemCreated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventConversationItemCreated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventConversationItemCreated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventConversationItemCreated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when an item in the conversation is deleted by the client with a  `conversation.item.delete` event. This event is used to synchronize the  server's understanding of the conversation history with the client's view. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventConversationItemDeleted {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `conversation.item.deleted`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the item that was deleted.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

}



impl RealtimeServerEventConversationItemDeleted {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, item_id: String, ) -> RealtimeServerEventConversationItemDeleted {
        RealtimeServerEventConversationItemDeleted {
 event_id,
 r_type,
 item_id,
        }
    }
}

/// Converts the RealtimeServerEventConversationItemDeleted value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventConversationItemDeleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventConversationItemDeleted value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventConversationItemDeleted {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub item_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventConversationItemDeleted".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventConversationItemDeleted".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventConversationItemDeleted {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventConversationItemDeleted".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventConversationItemDeleted".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventConversationItemDeleted".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventConversationItemDeleted> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventConversationItemDeleted>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventConversationItemDeleted>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventConversationItemDeleted - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventConversationItemDeleted> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventConversationItemDeleted as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventConversationItemDeleted - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// This event is the output of audio transcription for user audio written to the  user audio buffer. Transcription begins when the input audio buffer is  committed by the client or server (in `server_vad` mode). Transcription runs  asynchronously with Response creation, so this event may come before or after  the Response events.  Realtime API models accept audio natively, and thus input transcription is a  separate process run on a separate ASR (Automatic Speech Recognition) model,  currently always `whisper-1`. Thus the transcript may diverge somewhat from  the model's interpretation, and should be treated as a rough guide. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `conversation.item.input_audio_transcription.completed`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the user message item containing the audio.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

    /// The index of the content part containing the audio.
    #[serde(rename = "content_index")]
    pub content_index: i32,

    /// The transcribed text.
    #[serde(rename = "transcript")]
          #[validate(custom(function = "check_xss_string"))]
    pub transcript: String,

}



impl RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, item_id: String, content_index: i32, transcript: String, ) -> RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
        RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
 event_id,
 r_type,
 item_id,
 content_index,
 transcript,
        }
    }
}

/// Converts the RealtimeServerEventConversationItemInputAudioTranscriptionCompleted value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("content_index".to_string()),
            Some(self.content_index.to_string()),


            Some("transcript".to_string()),
            Some(self.transcript.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventConversationItemInputAudioTranscriptionCompleted value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub item_id: Vec<String>,
            pub content_index: Vec<i32>,
            pub transcript: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventConversationItemInputAudioTranscriptionCompleted".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content_index" => intermediate_rep.content_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "transcript" => intermediate_rep.transcript.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventConversationItemInputAudioTranscriptionCompleted".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventConversationItemInputAudioTranscriptionCompleted".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventConversationItemInputAudioTranscriptionCompleted".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventConversationItemInputAudioTranscriptionCompleted".to_string())?,
            content_index: intermediate_rep.content_index.into_iter().next().ok_or_else(|| "content_index missing in RealtimeServerEventConversationItemInputAudioTranscriptionCompleted".to_string())?,
            transcript: intermediate_rep.transcript.into_iter().next().ok_or_else(|| "transcript missing in RealtimeServerEventConversationItemInputAudioTranscriptionCompleted".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventConversationItemInputAudioTranscriptionCompleted> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventConversationItemInputAudioTranscriptionCompleted>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventConversationItemInputAudioTranscriptionCompleted>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventConversationItemInputAudioTranscriptionCompleted - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventConversationItemInputAudioTranscriptionCompleted> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventConversationItemInputAudioTranscriptionCompleted as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventConversationItemInputAudioTranscriptionCompleted - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when input audio transcription is configured, and a transcription  request for a user message failed. These events are separate from other  `error` events so that the client can identify the related Item. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `conversation.item.input_audio_transcription.failed`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the user message item.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

    /// The index of the content part containing the audio.
    #[serde(rename = "content_index")]
    pub content_index: i32,

    #[serde(rename = "error")]
          #[validate(nested)]
    pub error: models::RealtimeServerEventConversationItemInputAudioTranscriptionFailedError,

}



impl RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, item_id: String, content_index: i32, error: models::RealtimeServerEventConversationItemInputAudioTranscriptionFailedError, ) -> RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
        RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
 event_id,
 r_type,
 item_id,
 content_index,
 error,
        }
    }
}

/// Converts the RealtimeServerEventConversationItemInputAudioTranscriptionFailed value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("content_index".to_string()),
            Some(self.content_index.to_string()),

            // Skipping error in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventConversationItemInputAudioTranscriptionFailed value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub item_id: Vec<String>,
            pub content_index: Vec<i32>,
            pub error: Vec<models::RealtimeServerEventConversationItemInputAudioTranscriptionFailedError>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventConversationItemInputAudioTranscriptionFailed".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content_index" => intermediate_rep.content_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(<models::RealtimeServerEventConversationItemInputAudioTranscriptionFailedError as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventConversationItemInputAudioTranscriptionFailed".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventConversationItemInputAudioTranscriptionFailed".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventConversationItemInputAudioTranscriptionFailed".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventConversationItemInputAudioTranscriptionFailed".to_string())?,
            content_index: intermediate_rep.content_index.into_iter().next().ok_or_else(|| "content_index missing in RealtimeServerEventConversationItemInputAudioTranscriptionFailed".to_string())?,
            error: intermediate_rep.error.into_iter().next().ok_or_else(|| "error missing in RealtimeServerEventConversationItemInputAudioTranscriptionFailed".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventConversationItemInputAudioTranscriptionFailed> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventConversationItemInputAudioTranscriptionFailed>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventConversationItemInputAudioTranscriptionFailed>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventConversationItemInputAudioTranscriptionFailed - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventConversationItemInputAudioTranscriptionFailed> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventConversationItemInputAudioTranscriptionFailed as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventConversationItemInputAudioTranscriptionFailed - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Details of the transcription error.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
    /// The type of error.
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    /// Error code, if any.
    #[serde(rename = "code")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<String>,

    /// A human-readable error message.
    #[serde(rename = "message")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

    /// Parameter related to the error, if any.
    #[serde(rename = "param")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub param: Option<String>,

}



impl RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
        RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
 r_type: None,
 code: None,
 message: None,
 param: None,
        }
    }
}

/// Converts the RealtimeServerEventConversationItemInputAudioTranscriptionFailedError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),


            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.to_string(),
                ].join(",")
            }),


            self.message.as_ref().map(|message| {
                [
                    "message".to_string(),
                    message.to_string(),
                ].join(",")
            }),


            self.param.as_ref().map(|param| {
                [
                    "param".to_string(),
                    param.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventConversationItemInputAudioTranscriptionFailedError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub code: Vec<String>,
            pub message: Vec<String>,
            pub param: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventConversationItemInputAudioTranscriptionFailedError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "param" => intermediate_rep.param.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventConversationItemInputAudioTranscriptionFailedError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
            r_type: intermediate_rep.r_type.into_iter().next(),
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
            param: intermediate_rep.param.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventConversationItemInputAudioTranscriptionFailedError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventConversationItemInputAudioTranscriptionFailedError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventConversationItemInputAudioTranscriptionFailedError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventConversationItemInputAudioTranscriptionFailedError - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventConversationItemInputAudioTranscriptionFailedError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventConversationItemInputAudioTranscriptionFailedError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventConversationItemInputAudioTranscriptionFailedError - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when an earlier assistant audio message item is truncated by the  client with a `conversation.item.truncate` event. This event is used to  synchronize the server's understanding of the audio with the client's playback.  This action will truncate the audio and remove the server-side text transcript  to ensure there is no text in the context that hasn't been heard by the user. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventConversationItemTruncated {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `conversation.item.truncated`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the assistant message item that was truncated.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

    /// The index of the content part that was truncated.
    #[serde(rename = "content_index")]
    pub content_index: i32,

    /// The duration up to which the audio was truncated, in milliseconds. 
    #[serde(rename = "audio_end_ms")]
    pub audio_end_ms: i32,

}



impl RealtimeServerEventConversationItemTruncated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, item_id: String, content_index: i32, audio_end_ms: i32, ) -> RealtimeServerEventConversationItemTruncated {
        RealtimeServerEventConversationItemTruncated {
 event_id,
 r_type,
 item_id,
 content_index,
 audio_end_ms,
        }
    }
}

/// Converts the RealtimeServerEventConversationItemTruncated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventConversationItemTruncated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("content_index".to_string()),
            Some(self.content_index.to_string()),


            Some("audio_end_ms".to_string()),
            Some(self.audio_end_ms.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventConversationItemTruncated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventConversationItemTruncated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub item_id: Vec<String>,
            pub content_index: Vec<i32>,
            pub audio_end_ms: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventConversationItemTruncated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content_index" => intermediate_rep.content_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "audio_end_ms" => intermediate_rep.audio_end_ms.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventConversationItemTruncated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventConversationItemTruncated {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventConversationItemTruncated".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventConversationItemTruncated".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventConversationItemTruncated".to_string())?,
            content_index: intermediate_rep.content_index.into_iter().next().ok_or_else(|| "content_index missing in RealtimeServerEventConversationItemTruncated".to_string())?,
            audio_end_ms: intermediate_rep.audio_end_ms.into_iter().next().ok_or_else(|| "audio_end_ms missing in RealtimeServerEventConversationItemTruncated".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventConversationItemTruncated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventConversationItemTruncated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventConversationItemTruncated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventConversationItemTruncated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventConversationItemTruncated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventConversationItemTruncated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventConversationItemTruncated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when an error occurs, which could be a client problem or a server  problem. Most errors are recoverable and the session will stay open, we  recommend to implementors to monitor and log error messages by default. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventError {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `error`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "error")]
          #[validate(nested)]
    pub error: models::RealtimeServerEventErrorError,

}



impl RealtimeServerEventError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, error: models::RealtimeServerEventErrorError, ) -> RealtimeServerEventError {
        RealtimeServerEventError {
 event_id,
 r_type,
 error,
        }
    }
}

/// Converts the RealtimeServerEventError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping error in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub error: Vec<models::RealtimeServerEventErrorError>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "error" => intermediate_rep.error.push(<models::RealtimeServerEventErrorError as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventError {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventError".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventError".to_string())?,
            error: intermediate_rep.error.into_iter().next().ok_or_else(|| "error missing in RealtimeServerEventError".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventError - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventError - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Details of the error.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventErrorError {
    /// The type of error (e.g., \"invalid_request_error\", \"server_error\"). 
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// Error code, if any.
    #[serde(rename = "code")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<Nullable<String>>,

    /// A human-readable error message.
    #[serde(rename = "message")]
          #[validate(custom(function = "check_xss_string"))]
    pub message: String,

    /// Parameter related to the error, if any.
    #[serde(rename = "param")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub param: Option<Nullable<String>>,

    /// The event_id of the client event that caused the error, if applicable. 
    #[serde(rename = "event_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_id: Option<Nullable<String>>,

}



impl RealtimeServerEventErrorError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, message: String, ) -> RealtimeServerEventErrorError {
        RealtimeServerEventErrorError {
 r_type,
 code: None,
 message,
 param: None,
 event_id: None,
        }
    }
}

/// Converts the RealtimeServerEventErrorError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventErrorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),


            self.code.as_ref().map(|code| {
                [
                    "code".to_string(),
                    code.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            Some("message".to_string()),
            Some(self.message.to_string()),


            self.param.as_ref().map(|param| {
                [
                    "param".to_string(),
                    param.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.event_id.as_ref().map(|event_id| {
                [
                    "event_id".to_string(),
                    event_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventErrorError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventErrorError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub code: Vec<String>,
            pub message: Vec<String>,
            pub param: Vec<String>,
            pub event_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventErrorError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "code" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RealtimeServerEventErrorError".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "param" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RealtimeServerEventErrorError".to_string()),
                    "event_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RealtimeServerEventErrorError".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventErrorError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventErrorError {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventErrorError".to_string())?,
            code: std::result::Result::Err("Nullable types not supported in RealtimeServerEventErrorError".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in RealtimeServerEventErrorError".to_string())?,
            param: std::result::Result::Err("Nullable types not supported in RealtimeServerEventErrorError".to_string())?,
            event_id: std::result::Result::Err("Nullable types not supported in RealtimeServerEventErrorError".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventErrorError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventErrorError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventErrorError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventErrorError - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventErrorError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventErrorError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventErrorError - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when the input audio buffer is cleared by the client with a  `input_audio_buffer.clear` event. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventInputAudioBufferCleared {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `input_audio_buffer.cleared`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

}



impl RealtimeServerEventInputAudioBufferCleared {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, ) -> RealtimeServerEventInputAudioBufferCleared {
        RealtimeServerEventInputAudioBufferCleared {
 event_id,
 r_type,
        }
    }
}

/// Converts the RealtimeServerEventInputAudioBufferCleared value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventInputAudioBufferCleared {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventInputAudioBufferCleared value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventInputAudioBufferCleared {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventInputAudioBufferCleared".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventInputAudioBufferCleared".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventInputAudioBufferCleared {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventInputAudioBufferCleared".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventInputAudioBufferCleared".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventInputAudioBufferCleared> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventInputAudioBufferCleared>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventInputAudioBufferCleared>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventInputAudioBufferCleared - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventInputAudioBufferCleared> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventInputAudioBufferCleared as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventInputAudioBufferCleared - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when an input audio buffer is committed, either by the client or  automatically in server VAD mode. The `item_id` property is the ID of the user message item that will be created, thus a `conversation.item.created` event  will also be sent to the client. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventInputAudioBufferCommitted {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `input_audio_buffer.committed`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the preceding item after which the new item will be inserted. 
    #[serde(rename = "previous_item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub previous_item_id: String,

    /// The ID of the user message item that will be created.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

}



impl RealtimeServerEventInputAudioBufferCommitted {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, previous_item_id: String, item_id: String, ) -> RealtimeServerEventInputAudioBufferCommitted {
        RealtimeServerEventInputAudioBufferCommitted {
 event_id,
 r_type,
 previous_item_id,
 item_id,
        }
    }
}

/// Converts the RealtimeServerEventInputAudioBufferCommitted value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventInputAudioBufferCommitted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("previous_item_id".to_string()),
            Some(self.previous_item_id.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventInputAudioBufferCommitted value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventInputAudioBufferCommitted {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub previous_item_id: Vec<String>,
            pub item_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventInputAudioBufferCommitted".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous_item_id" => intermediate_rep.previous_item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventInputAudioBufferCommitted".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventInputAudioBufferCommitted {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventInputAudioBufferCommitted".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventInputAudioBufferCommitted".to_string())?,
            previous_item_id: intermediate_rep.previous_item_id.into_iter().next().ok_or_else(|| "previous_item_id missing in RealtimeServerEventInputAudioBufferCommitted".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventInputAudioBufferCommitted".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventInputAudioBufferCommitted> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventInputAudioBufferCommitted>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventInputAudioBufferCommitted>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventInputAudioBufferCommitted - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventInputAudioBufferCommitted> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventInputAudioBufferCommitted as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventInputAudioBufferCommitted - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Sent by the server when in `server_vad` mode to indicate that speech has been  detected in the audio buffer. This can happen any time audio is added to the  buffer (unless speech is already detected). The client may want to use this  event to interrupt audio playback or provide visual feedback to the user.   The client should expect to receive a `input_audio_buffer.speech_stopped` event  when speech stops. The `item_id` property is the ID of the user message item  that will be created when speech stops and will also be included in the  `input_audio_buffer.speech_stopped` event (unless the client manually commits  the audio buffer during VAD activation). 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventInputAudioBufferSpeechStarted {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `input_audio_buffer.speech_started`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// Milliseconds from the start of all audio written to the buffer during the  session when speech was first detected. This will correspond to the  beginning of audio sent to the model, and thus includes the  `prefix_padding_ms` configured in the Session. 
    #[serde(rename = "audio_start_ms")]
    pub audio_start_ms: i32,

    /// The ID of the user message item that will be created when speech stops. 
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

}



impl RealtimeServerEventInputAudioBufferSpeechStarted {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, audio_start_ms: i32, item_id: String, ) -> RealtimeServerEventInputAudioBufferSpeechStarted {
        RealtimeServerEventInputAudioBufferSpeechStarted {
 event_id,
 r_type,
 audio_start_ms,
 item_id,
        }
    }
}

/// Converts the RealtimeServerEventInputAudioBufferSpeechStarted value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventInputAudioBufferSpeechStarted {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("audio_start_ms".to_string()),
            Some(self.audio_start_ms.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventInputAudioBufferSpeechStarted value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventInputAudioBufferSpeechStarted {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub audio_start_ms: Vec<i32>,
            pub item_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventInputAudioBufferSpeechStarted".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "audio_start_ms" => intermediate_rep.audio_start_ms.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventInputAudioBufferSpeechStarted".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventInputAudioBufferSpeechStarted {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventInputAudioBufferSpeechStarted".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventInputAudioBufferSpeechStarted".to_string())?,
            audio_start_ms: intermediate_rep.audio_start_ms.into_iter().next().ok_or_else(|| "audio_start_ms missing in RealtimeServerEventInputAudioBufferSpeechStarted".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventInputAudioBufferSpeechStarted".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventInputAudioBufferSpeechStarted> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventInputAudioBufferSpeechStarted>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventInputAudioBufferSpeechStarted>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventInputAudioBufferSpeechStarted - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventInputAudioBufferSpeechStarted> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventInputAudioBufferSpeechStarted as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventInputAudioBufferSpeechStarted - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned in `server_vad` mode when the server detects the end of speech in  the audio buffer. The server will also send an `conversation.item.created`  event with the user message item that is created from the audio buffer. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventInputAudioBufferSpeechStopped {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `input_audio_buffer.speech_stopped`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// Milliseconds since the session started when speech stopped. This will  correspond to the end of audio sent to the model, and thus includes the  `min_silence_duration_ms` configured in the Session. 
    #[serde(rename = "audio_end_ms")]
    pub audio_end_ms: i32,

    /// The ID of the user message item that will be created.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

}



impl RealtimeServerEventInputAudioBufferSpeechStopped {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, audio_end_ms: i32, item_id: String, ) -> RealtimeServerEventInputAudioBufferSpeechStopped {
        RealtimeServerEventInputAudioBufferSpeechStopped {
 event_id,
 r_type,
 audio_end_ms,
 item_id,
        }
    }
}

/// Converts the RealtimeServerEventInputAudioBufferSpeechStopped value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventInputAudioBufferSpeechStopped {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("audio_end_ms".to_string()),
            Some(self.audio_end_ms.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventInputAudioBufferSpeechStopped value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventInputAudioBufferSpeechStopped {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub audio_end_ms: Vec<i32>,
            pub item_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventInputAudioBufferSpeechStopped".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "audio_end_ms" => intermediate_rep.audio_end_ms.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventInputAudioBufferSpeechStopped".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventInputAudioBufferSpeechStopped {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventInputAudioBufferSpeechStopped".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventInputAudioBufferSpeechStopped".to_string())?,
            audio_end_ms: intermediate_rep.audio_end_ms.into_iter().next().ok_or_else(|| "audio_end_ms missing in RealtimeServerEventInputAudioBufferSpeechStopped".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventInputAudioBufferSpeechStopped".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventInputAudioBufferSpeechStopped> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventInputAudioBufferSpeechStopped>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventInputAudioBufferSpeechStopped>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventInputAudioBufferSpeechStopped - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventInputAudioBufferSpeechStopped> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventInputAudioBufferSpeechStopped as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventInputAudioBufferSpeechStopped - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Emitted at the beginning of a Response to indicate the updated rate limits.  When a Response is created some tokens will be \"reserved\" for the output  tokens, the rate limits shown here reflect that reservation, which is then  adjusted accordingly once the Response is completed. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventRateLimitsUpdated {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `rate_limits.updated`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// List of rate limit information.
    #[serde(rename = "rate_limits")]
          #[validate(nested)]
    pub rate_limits: Vec<models::RealtimeServerEventRateLimitsUpdatedRateLimitsInner>,

}



impl RealtimeServerEventRateLimitsUpdated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, rate_limits: Vec<models::RealtimeServerEventRateLimitsUpdatedRateLimitsInner>, ) -> RealtimeServerEventRateLimitsUpdated {
        RealtimeServerEventRateLimitsUpdated {
 event_id,
 r_type,
 rate_limits,
        }
    }
}

/// Converts the RealtimeServerEventRateLimitsUpdated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventRateLimitsUpdated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping rate_limits in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventRateLimitsUpdated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventRateLimitsUpdated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub rate_limits: Vec<Vec<models::RealtimeServerEventRateLimitsUpdatedRateLimitsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventRateLimitsUpdated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "rate_limits" => return std::result::Result::Err("Parsing a container in this style is not supported in RealtimeServerEventRateLimitsUpdated".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventRateLimitsUpdated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventRateLimitsUpdated {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventRateLimitsUpdated".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventRateLimitsUpdated".to_string())?,
            rate_limits: intermediate_rep.rate_limits.into_iter().next().ok_or_else(|| "rate_limits missing in RealtimeServerEventRateLimitsUpdated".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventRateLimitsUpdated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventRateLimitsUpdated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventRateLimitsUpdated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventRateLimitsUpdated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventRateLimitsUpdated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventRateLimitsUpdated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventRateLimitsUpdated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventRateLimitsUpdatedRateLimitsInner {
    /// The name of the rate limit (`requests`, `tokens`). 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// The maximum allowed value for the rate limit.
    #[serde(rename = "limit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub limit: Option<i32>,

    /// The remaining value before the limit is reached.
    #[serde(rename = "remaining")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub remaining: Option<i32>,

    /// Seconds until the rate limit resets.
    #[serde(rename = "reset_seconds")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reset_seconds: Option<f64>,

}



impl RealtimeServerEventRateLimitsUpdatedRateLimitsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeServerEventRateLimitsUpdatedRateLimitsInner {
        RealtimeServerEventRateLimitsUpdatedRateLimitsInner {
 name: None,
 limit: None,
 remaining: None,
 reset_seconds: None,
        }
    }
}

/// Converts the RealtimeServerEventRateLimitsUpdatedRateLimitsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventRateLimitsUpdatedRateLimitsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.limit.as_ref().map(|limit| {
                [
                    "limit".to_string(),
                    limit.to_string(),
                ].join(",")
            }),


            self.remaining.as_ref().map(|remaining| {
                [
                    "remaining".to_string(),
                    remaining.to_string(),
                ].join(",")
            }),


            self.reset_seconds.as_ref().map(|reset_seconds| {
                [
                    "reset_seconds".to_string(),
                    reset_seconds.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventRateLimitsUpdatedRateLimitsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventRateLimitsUpdatedRateLimitsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub limit: Vec<i32>,
            pub remaining: Vec<i32>,
            pub reset_seconds: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventRateLimitsUpdatedRateLimitsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "limit" => intermediate_rep.limit.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "remaining" => intermediate_rep.remaining.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "reset_seconds" => intermediate_rep.reset_seconds.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventRateLimitsUpdatedRateLimitsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventRateLimitsUpdatedRateLimitsInner {
            name: intermediate_rep.name.into_iter().next(),
            limit: intermediate_rep.limit.into_iter().next(),
            remaining: intermediate_rep.remaining.into_iter().next(),
            reset_seconds: intermediate_rep.reset_seconds.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventRateLimitsUpdatedRateLimitsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventRateLimitsUpdatedRateLimitsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventRateLimitsUpdatedRateLimitsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventRateLimitsUpdatedRateLimitsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventRateLimitsUpdatedRateLimitsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventRateLimitsUpdatedRateLimitsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventRateLimitsUpdatedRateLimitsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when the model-generated audio is updated.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseAudioDelta {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `response.audio.delta`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the response.
    #[serde(rename = "response_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub response_id: String,

    /// The ID of the item.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

    /// The index of the output item in the response.
    #[serde(rename = "output_index")]
    pub output_index: i32,

    /// The index of the content part in the item's content array.
    #[serde(rename = "content_index")]
    pub content_index: i32,

    /// Base64-encoded audio data delta.
    #[serde(rename = "delta")]
          #[validate(custom(function = "check_xss_string"))]
    pub delta: String,

}



impl RealtimeServerEventResponseAudioDelta {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, response_id: String, item_id: String, output_index: i32, content_index: i32, delta: String, ) -> RealtimeServerEventResponseAudioDelta {
        RealtimeServerEventResponseAudioDelta {
 event_id,
 r_type,
 response_id,
 item_id,
 output_index,
 content_index,
 delta,
        }
    }
}

/// Converts the RealtimeServerEventResponseAudioDelta value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseAudioDelta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("response_id".to_string()),
            Some(self.response_id.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("output_index".to_string()),
            Some(self.output_index.to_string()),


            Some("content_index".to_string()),
            Some(self.content_index.to_string()),


            Some("delta".to_string()),
            Some(self.delta.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseAudioDelta value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseAudioDelta {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response_id: Vec<String>,
            pub item_id: Vec<String>,
            pub output_index: Vec<i32>,
            pub content_index: Vec<i32>,
            pub delta: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseAudioDelta".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_id" => intermediate_rep.response_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_index" => intermediate_rep.output_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content_index" => intermediate_rep.content_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "delta" => intermediate_rep.delta.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseAudioDelta".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseAudioDelta {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventResponseAudioDelta".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventResponseAudioDelta".to_string())?,
            response_id: intermediate_rep.response_id.into_iter().next().ok_or_else(|| "response_id missing in RealtimeServerEventResponseAudioDelta".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventResponseAudioDelta".to_string())?,
            output_index: intermediate_rep.output_index.into_iter().next().ok_or_else(|| "output_index missing in RealtimeServerEventResponseAudioDelta".to_string())?,
            content_index: intermediate_rep.content_index.into_iter().next().ok_or_else(|| "content_index missing in RealtimeServerEventResponseAudioDelta".to_string())?,
            delta: intermediate_rep.delta.into_iter().next().ok_or_else(|| "delta missing in RealtimeServerEventResponseAudioDelta".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseAudioDelta> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseAudioDelta>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseAudioDelta>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseAudioDelta - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseAudioDelta> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseAudioDelta as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseAudioDelta - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when the model-generated audio is done. Also emitted when a Response is interrupted, incomplete, or cancelled. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseAudioDone {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `response.audio.done`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the response.
    #[serde(rename = "response_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub response_id: String,

    /// The ID of the item.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

    /// The index of the output item in the response.
    #[serde(rename = "output_index")]
    pub output_index: i32,

    /// The index of the content part in the item's content array.
    #[serde(rename = "content_index")]
    pub content_index: i32,

}



impl RealtimeServerEventResponseAudioDone {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, response_id: String, item_id: String, output_index: i32, content_index: i32, ) -> RealtimeServerEventResponseAudioDone {
        RealtimeServerEventResponseAudioDone {
 event_id,
 r_type,
 response_id,
 item_id,
 output_index,
 content_index,
        }
    }
}

/// Converts the RealtimeServerEventResponseAudioDone value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseAudioDone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("response_id".to_string()),
            Some(self.response_id.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("output_index".to_string()),
            Some(self.output_index.to_string()),


            Some("content_index".to_string()),
            Some(self.content_index.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseAudioDone value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseAudioDone {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response_id: Vec<String>,
            pub item_id: Vec<String>,
            pub output_index: Vec<i32>,
            pub content_index: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseAudioDone".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_id" => intermediate_rep.response_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_index" => intermediate_rep.output_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content_index" => intermediate_rep.content_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseAudioDone".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseAudioDone {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventResponseAudioDone".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventResponseAudioDone".to_string())?,
            response_id: intermediate_rep.response_id.into_iter().next().ok_or_else(|| "response_id missing in RealtimeServerEventResponseAudioDone".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventResponseAudioDone".to_string())?,
            output_index: intermediate_rep.output_index.into_iter().next().ok_or_else(|| "output_index missing in RealtimeServerEventResponseAudioDone".to_string())?,
            content_index: intermediate_rep.content_index.into_iter().next().ok_or_else(|| "content_index missing in RealtimeServerEventResponseAudioDone".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseAudioDone> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseAudioDone>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseAudioDone>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseAudioDone - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseAudioDone> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseAudioDone as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseAudioDone - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when the model-generated transcription of audio output is updated. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseAudioTranscriptDelta {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `response.audio_transcript.delta`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the response.
    #[serde(rename = "response_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub response_id: String,

    /// The ID of the item.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

    /// The index of the output item in the response.
    #[serde(rename = "output_index")]
    pub output_index: i32,

    /// The index of the content part in the item's content array.
    #[serde(rename = "content_index")]
    pub content_index: i32,

    /// The transcript delta.
    #[serde(rename = "delta")]
          #[validate(custom(function = "check_xss_string"))]
    pub delta: String,

}



impl RealtimeServerEventResponseAudioTranscriptDelta {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, response_id: String, item_id: String, output_index: i32, content_index: i32, delta: String, ) -> RealtimeServerEventResponseAudioTranscriptDelta {
        RealtimeServerEventResponseAudioTranscriptDelta {
 event_id,
 r_type,
 response_id,
 item_id,
 output_index,
 content_index,
 delta,
        }
    }
}

/// Converts the RealtimeServerEventResponseAudioTranscriptDelta value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseAudioTranscriptDelta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("response_id".to_string()),
            Some(self.response_id.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("output_index".to_string()),
            Some(self.output_index.to_string()),


            Some("content_index".to_string()),
            Some(self.content_index.to_string()),


            Some("delta".to_string()),
            Some(self.delta.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseAudioTranscriptDelta value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseAudioTranscriptDelta {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response_id: Vec<String>,
            pub item_id: Vec<String>,
            pub output_index: Vec<i32>,
            pub content_index: Vec<i32>,
            pub delta: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseAudioTranscriptDelta".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_id" => intermediate_rep.response_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_index" => intermediate_rep.output_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content_index" => intermediate_rep.content_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "delta" => intermediate_rep.delta.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseAudioTranscriptDelta".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseAudioTranscriptDelta {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventResponseAudioTranscriptDelta".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventResponseAudioTranscriptDelta".to_string())?,
            response_id: intermediate_rep.response_id.into_iter().next().ok_or_else(|| "response_id missing in RealtimeServerEventResponseAudioTranscriptDelta".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventResponseAudioTranscriptDelta".to_string())?,
            output_index: intermediate_rep.output_index.into_iter().next().ok_or_else(|| "output_index missing in RealtimeServerEventResponseAudioTranscriptDelta".to_string())?,
            content_index: intermediate_rep.content_index.into_iter().next().ok_or_else(|| "content_index missing in RealtimeServerEventResponseAudioTranscriptDelta".to_string())?,
            delta: intermediate_rep.delta.into_iter().next().ok_or_else(|| "delta missing in RealtimeServerEventResponseAudioTranscriptDelta".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseAudioTranscriptDelta> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseAudioTranscriptDelta>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseAudioTranscriptDelta>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseAudioTranscriptDelta - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseAudioTranscriptDelta> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseAudioTranscriptDelta as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseAudioTranscriptDelta - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when the model-generated transcription of audio output is done streaming. Also emitted when a Response is interrupted, incomplete, or cancelled. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseAudioTranscriptDone {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `response.audio_transcript.done`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the response.
    #[serde(rename = "response_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub response_id: String,

    /// The ID of the item.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

    /// The index of the output item in the response.
    #[serde(rename = "output_index")]
    pub output_index: i32,

    /// The index of the content part in the item's content array.
    #[serde(rename = "content_index")]
    pub content_index: i32,

    /// The final transcript of the audio.
    #[serde(rename = "transcript")]
          #[validate(custom(function = "check_xss_string"))]
    pub transcript: String,

}



impl RealtimeServerEventResponseAudioTranscriptDone {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, response_id: String, item_id: String, output_index: i32, content_index: i32, transcript: String, ) -> RealtimeServerEventResponseAudioTranscriptDone {
        RealtimeServerEventResponseAudioTranscriptDone {
 event_id,
 r_type,
 response_id,
 item_id,
 output_index,
 content_index,
 transcript,
        }
    }
}

/// Converts the RealtimeServerEventResponseAudioTranscriptDone value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseAudioTranscriptDone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("response_id".to_string()),
            Some(self.response_id.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("output_index".to_string()),
            Some(self.output_index.to_string()),


            Some("content_index".to_string()),
            Some(self.content_index.to_string()),


            Some("transcript".to_string()),
            Some(self.transcript.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseAudioTranscriptDone value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseAudioTranscriptDone {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response_id: Vec<String>,
            pub item_id: Vec<String>,
            pub output_index: Vec<i32>,
            pub content_index: Vec<i32>,
            pub transcript: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseAudioTranscriptDone".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_id" => intermediate_rep.response_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_index" => intermediate_rep.output_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content_index" => intermediate_rep.content_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "transcript" => intermediate_rep.transcript.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseAudioTranscriptDone".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseAudioTranscriptDone {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventResponseAudioTranscriptDone".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventResponseAudioTranscriptDone".to_string())?,
            response_id: intermediate_rep.response_id.into_iter().next().ok_or_else(|| "response_id missing in RealtimeServerEventResponseAudioTranscriptDone".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventResponseAudioTranscriptDone".to_string())?,
            output_index: intermediate_rep.output_index.into_iter().next().ok_or_else(|| "output_index missing in RealtimeServerEventResponseAudioTranscriptDone".to_string())?,
            content_index: intermediate_rep.content_index.into_iter().next().ok_or_else(|| "content_index missing in RealtimeServerEventResponseAudioTranscriptDone".to_string())?,
            transcript: intermediate_rep.transcript.into_iter().next().ok_or_else(|| "transcript missing in RealtimeServerEventResponseAudioTranscriptDone".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseAudioTranscriptDone> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseAudioTranscriptDone>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseAudioTranscriptDone>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseAudioTranscriptDone - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseAudioTranscriptDone> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseAudioTranscriptDone as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseAudioTranscriptDone - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when a new content part is added to an assistant message item during response generation. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseContentPartAdded {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `response.content_part.added`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the response.
    #[serde(rename = "response_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub response_id: String,

    /// The ID of the item to which the content part was added.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

    /// The index of the output item in the response.
    #[serde(rename = "output_index")]
    pub output_index: i32,

    /// The index of the content part in the item's content array.
    #[serde(rename = "content_index")]
    pub content_index: i32,

    #[serde(rename = "part")]
          #[validate(nested)]
    pub part: models::RealtimeServerEventResponseContentPartAddedPart,

}



impl RealtimeServerEventResponseContentPartAdded {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, response_id: String, item_id: String, output_index: i32, content_index: i32, part: models::RealtimeServerEventResponseContentPartAddedPart, ) -> RealtimeServerEventResponseContentPartAdded {
        RealtimeServerEventResponseContentPartAdded {
 event_id,
 r_type,
 response_id,
 item_id,
 output_index,
 content_index,
 part,
        }
    }
}

/// Converts the RealtimeServerEventResponseContentPartAdded value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseContentPartAdded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("response_id".to_string()),
            Some(self.response_id.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("output_index".to_string()),
            Some(self.output_index.to_string()),


            Some("content_index".to_string()),
            Some(self.content_index.to_string()),

            // Skipping part in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseContentPartAdded value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseContentPartAdded {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response_id: Vec<String>,
            pub item_id: Vec<String>,
            pub output_index: Vec<i32>,
            pub content_index: Vec<i32>,
            pub part: Vec<models::RealtimeServerEventResponseContentPartAddedPart>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseContentPartAdded".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_id" => intermediate_rep.response_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_index" => intermediate_rep.output_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content_index" => intermediate_rep.content_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "part" => intermediate_rep.part.push(<models::RealtimeServerEventResponseContentPartAddedPart as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseContentPartAdded".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseContentPartAdded {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventResponseContentPartAdded".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventResponseContentPartAdded".to_string())?,
            response_id: intermediate_rep.response_id.into_iter().next().ok_or_else(|| "response_id missing in RealtimeServerEventResponseContentPartAdded".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventResponseContentPartAdded".to_string())?,
            output_index: intermediate_rep.output_index.into_iter().next().ok_or_else(|| "output_index missing in RealtimeServerEventResponseContentPartAdded".to_string())?,
            content_index: intermediate_rep.content_index.into_iter().next().ok_or_else(|| "content_index missing in RealtimeServerEventResponseContentPartAdded".to_string())?,
            part: intermediate_rep.part.into_iter().next().ok_or_else(|| "part missing in RealtimeServerEventResponseContentPartAdded".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseContentPartAdded> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseContentPartAdded>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseContentPartAdded>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseContentPartAdded - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseContentPartAdded> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseContentPartAdded as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseContentPartAdded - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The content part that was added.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseContentPartAddedPart {
    /// The content type (\"text\", \"audio\").
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    /// The text content (if type is \"text\").
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,

    /// Base64-encoded audio data (if type is \"audio\").
    #[serde(rename = "audio")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audio: Option<String>,

    /// The transcript of the audio (if type is \"audio\").
    #[serde(rename = "transcript")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub transcript: Option<String>,

}



impl RealtimeServerEventResponseContentPartAddedPart {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeServerEventResponseContentPartAddedPart {
        RealtimeServerEventResponseContentPartAddedPart {
 r_type: None,
 text: None,
 audio: None,
 transcript: None,
        }
    }
}

/// Converts the RealtimeServerEventResponseContentPartAddedPart value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseContentPartAddedPart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),


            self.text.as_ref().map(|text| {
                [
                    "text".to_string(),
                    text.to_string(),
                ].join(",")
            }),


            self.audio.as_ref().map(|audio| {
                [
                    "audio".to_string(),
                    audio.to_string(),
                ].join(",")
            }),


            self.transcript.as_ref().map(|transcript| {
                [
                    "transcript".to_string(),
                    transcript.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseContentPartAddedPart value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseContentPartAddedPart {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub text: Vec<String>,
            pub audio: Vec<String>,
            pub transcript: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseContentPartAddedPart".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "audio" => intermediate_rep.audio.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "transcript" => intermediate_rep.transcript.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseContentPartAddedPart".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseContentPartAddedPart {
            r_type: intermediate_rep.r_type.into_iter().next(),
            text: intermediate_rep.text.into_iter().next(),
            audio: intermediate_rep.audio.into_iter().next(),
            transcript: intermediate_rep.transcript.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseContentPartAddedPart> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseContentPartAddedPart>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseContentPartAddedPart>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseContentPartAddedPart - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseContentPartAddedPart> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseContentPartAddedPart as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseContentPartAddedPart - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when a content part is done streaming in an assistant message item. Also emitted when a Response is interrupted, incomplete, or cancelled. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseContentPartDone {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `response.content_part.done`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the response.
    #[serde(rename = "response_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub response_id: String,

    /// The ID of the item.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

    /// The index of the output item in the response.
    #[serde(rename = "output_index")]
    pub output_index: i32,

    /// The index of the content part in the item's content array.
    #[serde(rename = "content_index")]
    pub content_index: i32,

    #[serde(rename = "part")]
          #[validate(nested)]
    pub part: models::RealtimeServerEventResponseContentPartDonePart,

}



impl RealtimeServerEventResponseContentPartDone {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, response_id: String, item_id: String, output_index: i32, content_index: i32, part: models::RealtimeServerEventResponseContentPartDonePart, ) -> RealtimeServerEventResponseContentPartDone {
        RealtimeServerEventResponseContentPartDone {
 event_id,
 r_type,
 response_id,
 item_id,
 output_index,
 content_index,
 part,
        }
    }
}

/// Converts the RealtimeServerEventResponseContentPartDone value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseContentPartDone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("response_id".to_string()),
            Some(self.response_id.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("output_index".to_string()),
            Some(self.output_index.to_string()),


            Some("content_index".to_string()),
            Some(self.content_index.to_string()),

            // Skipping part in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseContentPartDone value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseContentPartDone {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response_id: Vec<String>,
            pub item_id: Vec<String>,
            pub output_index: Vec<i32>,
            pub content_index: Vec<i32>,
            pub part: Vec<models::RealtimeServerEventResponseContentPartDonePart>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseContentPartDone".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_id" => intermediate_rep.response_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_index" => intermediate_rep.output_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content_index" => intermediate_rep.content_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "part" => intermediate_rep.part.push(<models::RealtimeServerEventResponseContentPartDonePart as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseContentPartDone".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseContentPartDone {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventResponseContentPartDone".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventResponseContentPartDone".to_string())?,
            response_id: intermediate_rep.response_id.into_iter().next().ok_or_else(|| "response_id missing in RealtimeServerEventResponseContentPartDone".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventResponseContentPartDone".to_string())?,
            output_index: intermediate_rep.output_index.into_iter().next().ok_or_else(|| "output_index missing in RealtimeServerEventResponseContentPartDone".to_string())?,
            content_index: intermediate_rep.content_index.into_iter().next().ok_or_else(|| "content_index missing in RealtimeServerEventResponseContentPartDone".to_string())?,
            part: intermediate_rep.part.into_iter().next().ok_or_else(|| "part missing in RealtimeServerEventResponseContentPartDone".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseContentPartDone> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseContentPartDone>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseContentPartDone>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseContentPartDone - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseContentPartDone> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseContentPartDone as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseContentPartDone - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The content part that is done.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseContentPartDonePart {
    /// The content type (\"text\", \"audio\").
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    /// The text content (if type is \"text\").
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,

    /// Base64-encoded audio data (if type is \"audio\").
    #[serde(rename = "audio")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audio: Option<String>,

    /// The transcript of the audio (if type is \"audio\").
    #[serde(rename = "transcript")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub transcript: Option<String>,

}



impl RealtimeServerEventResponseContentPartDonePart {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeServerEventResponseContentPartDonePart {
        RealtimeServerEventResponseContentPartDonePart {
 r_type: None,
 text: None,
 audio: None,
 transcript: None,
        }
    }
}

/// Converts the RealtimeServerEventResponseContentPartDonePart value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseContentPartDonePart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),


            self.text.as_ref().map(|text| {
                [
                    "text".to_string(),
                    text.to_string(),
                ].join(",")
            }),


            self.audio.as_ref().map(|audio| {
                [
                    "audio".to_string(),
                    audio.to_string(),
                ].join(",")
            }),


            self.transcript.as_ref().map(|transcript| {
                [
                    "transcript".to_string(),
                    transcript.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseContentPartDonePart value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseContentPartDonePart {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub text: Vec<String>,
            pub audio: Vec<String>,
            pub transcript: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseContentPartDonePart".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "audio" => intermediate_rep.audio.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "transcript" => intermediate_rep.transcript.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseContentPartDonePart".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseContentPartDonePart {
            r_type: intermediate_rep.r_type.into_iter().next(),
            text: intermediate_rep.text.into_iter().next(),
            audio: intermediate_rep.audio.into_iter().next(),
            transcript: intermediate_rep.transcript.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseContentPartDonePart> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseContentPartDonePart>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseContentPartDonePart>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseContentPartDonePart - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseContentPartDonePart> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseContentPartDonePart as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseContentPartDonePart - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when a new Response is created. The first event of response creation, where the response is in an initial state of `in_progress`. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseCreated {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `response.created`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "response")]
          #[validate(nested)]
    pub response: models::RealtimeResponse,

}



impl RealtimeServerEventResponseCreated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, response: models::RealtimeResponse, ) -> RealtimeServerEventResponseCreated {
        RealtimeServerEventResponseCreated {
 event_id,
 r_type,
 response,
        }
    }
}

/// Converts the RealtimeServerEventResponseCreated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping response in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseCreated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseCreated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response: Vec<models::RealtimeResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseCreated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response" => intermediate_rep.response.push(<models::RealtimeResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseCreated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseCreated {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventResponseCreated".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventResponseCreated".to_string())?,
            response: intermediate_rep.response.into_iter().next().ok_or_else(|| "response missing in RealtimeServerEventResponseCreated".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseCreated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseCreated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseCreated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseCreated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseCreated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseCreated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseCreated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when a Response is done streaming. Always emitted, no matter the  final state. The Response object included in the `response.done` event will  include all output Items in the Response but will omit the raw audio data. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseDone {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `response.done`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "response")]
          #[validate(nested)]
    pub response: models::RealtimeResponse,

}



impl RealtimeServerEventResponseDone {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, response: models::RealtimeResponse, ) -> RealtimeServerEventResponseDone {
        RealtimeServerEventResponseDone {
 event_id,
 r_type,
 response,
        }
    }
}

/// Converts the RealtimeServerEventResponseDone value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseDone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping response in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseDone value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseDone {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response: Vec<models::RealtimeResponse>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseDone".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response" => intermediate_rep.response.push(<models::RealtimeResponse as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseDone".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseDone {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventResponseDone".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventResponseDone".to_string())?,
            response: intermediate_rep.response.into_iter().next().ok_or_else(|| "response missing in RealtimeServerEventResponseDone".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseDone> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseDone>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseDone>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseDone - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseDone> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseDone as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseDone - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when the model-generated function call arguments are updated. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseFunctionCallArgumentsDelta {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `response.function_call_arguments.delta`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the response.
    #[serde(rename = "response_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub response_id: String,

    /// The ID of the function call item.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

    /// The index of the output item in the response.
    #[serde(rename = "output_index")]
    pub output_index: i32,

    /// The ID of the function call.
    #[serde(rename = "call_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub call_id: String,

    /// The arguments delta as a JSON string.
    #[serde(rename = "delta")]
          #[validate(custom(function = "check_xss_string"))]
    pub delta: String,

}



impl RealtimeServerEventResponseFunctionCallArgumentsDelta {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, response_id: String, item_id: String, output_index: i32, call_id: String, delta: String, ) -> RealtimeServerEventResponseFunctionCallArgumentsDelta {
        RealtimeServerEventResponseFunctionCallArgumentsDelta {
 event_id,
 r_type,
 response_id,
 item_id,
 output_index,
 call_id,
 delta,
        }
    }
}

/// Converts the RealtimeServerEventResponseFunctionCallArgumentsDelta value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseFunctionCallArgumentsDelta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("response_id".to_string()),
            Some(self.response_id.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("output_index".to_string()),
            Some(self.output_index.to_string()),


            Some("call_id".to_string()),
            Some(self.call_id.to_string()),


            Some("delta".to_string()),
            Some(self.delta.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseFunctionCallArgumentsDelta value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseFunctionCallArgumentsDelta {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response_id: Vec<String>,
            pub item_id: Vec<String>,
            pub output_index: Vec<i32>,
            pub call_id: Vec<String>,
            pub delta: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseFunctionCallArgumentsDelta".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_id" => intermediate_rep.response_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_index" => intermediate_rep.output_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "call_id" => intermediate_rep.call_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "delta" => intermediate_rep.delta.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseFunctionCallArgumentsDelta".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseFunctionCallArgumentsDelta {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventResponseFunctionCallArgumentsDelta".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventResponseFunctionCallArgumentsDelta".to_string())?,
            response_id: intermediate_rep.response_id.into_iter().next().ok_or_else(|| "response_id missing in RealtimeServerEventResponseFunctionCallArgumentsDelta".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventResponseFunctionCallArgumentsDelta".to_string())?,
            output_index: intermediate_rep.output_index.into_iter().next().ok_or_else(|| "output_index missing in RealtimeServerEventResponseFunctionCallArgumentsDelta".to_string())?,
            call_id: intermediate_rep.call_id.into_iter().next().ok_or_else(|| "call_id missing in RealtimeServerEventResponseFunctionCallArgumentsDelta".to_string())?,
            delta: intermediate_rep.delta.into_iter().next().ok_or_else(|| "delta missing in RealtimeServerEventResponseFunctionCallArgumentsDelta".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseFunctionCallArgumentsDelta> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseFunctionCallArgumentsDelta>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseFunctionCallArgumentsDelta>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseFunctionCallArgumentsDelta - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseFunctionCallArgumentsDelta> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseFunctionCallArgumentsDelta as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseFunctionCallArgumentsDelta - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when the model-generated function call arguments are done streaming. Also emitted when a Response is interrupted, incomplete, or cancelled. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseFunctionCallArgumentsDone {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `response.function_call_arguments.done`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the response.
    #[serde(rename = "response_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub response_id: String,

    /// The ID of the function call item.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

    /// The index of the output item in the response.
    #[serde(rename = "output_index")]
    pub output_index: i32,

    /// The ID of the function call.
    #[serde(rename = "call_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub call_id: String,

    /// The final arguments as a JSON string.
    #[serde(rename = "arguments")]
          #[validate(custom(function = "check_xss_string"))]
    pub arguments: String,

}



impl RealtimeServerEventResponseFunctionCallArgumentsDone {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, response_id: String, item_id: String, output_index: i32, call_id: String, arguments: String, ) -> RealtimeServerEventResponseFunctionCallArgumentsDone {
        RealtimeServerEventResponseFunctionCallArgumentsDone {
 event_id,
 r_type,
 response_id,
 item_id,
 output_index,
 call_id,
 arguments,
        }
    }
}

/// Converts the RealtimeServerEventResponseFunctionCallArgumentsDone value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseFunctionCallArgumentsDone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("response_id".to_string()),
            Some(self.response_id.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("output_index".to_string()),
            Some(self.output_index.to_string()),


            Some("call_id".to_string()),
            Some(self.call_id.to_string()),


            Some("arguments".to_string()),
            Some(self.arguments.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseFunctionCallArgumentsDone value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseFunctionCallArgumentsDone {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response_id: Vec<String>,
            pub item_id: Vec<String>,
            pub output_index: Vec<i32>,
            pub call_id: Vec<String>,
            pub arguments: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseFunctionCallArgumentsDone".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_id" => intermediate_rep.response_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_index" => intermediate_rep.output_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "call_id" => intermediate_rep.call_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseFunctionCallArgumentsDone".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseFunctionCallArgumentsDone {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventResponseFunctionCallArgumentsDone".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventResponseFunctionCallArgumentsDone".to_string())?,
            response_id: intermediate_rep.response_id.into_iter().next().ok_or_else(|| "response_id missing in RealtimeServerEventResponseFunctionCallArgumentsDone".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventResponseFunctionCallArgumentsDone".to_string())?,
            output_index: intermediate_rep.output_index.into_iter().next().ok_or_else(|| "output_index missing in RealtimeServerEventResponseFunctionCallArgumentsDone".to_string())?,
            call_id: intermediate_rep.call_id.into_iter().next().ok_or_else(|| "call_id missing in RealtimeServerEventResponseFunctionCallArgumentsDone".to_string())?,
            arguments: intermediate_rep.arguments.into_iter().next().ok_or_else(|| "arguments missing in RealtimeServerEventResponseFunctionCallArgumentsDone".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseFunctionCallArgumentsDone> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseFunctionCallArgumentsDone>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseFunctionCallArgumentsDone>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseFunctionCallArgumentsDone - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseFunctionCallArgumentsDone> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseFunctionCallArgumentsDone as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseFunctionCallArgumentsDone - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when a new Item is created during Response generation.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseOutputItemAdded {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `response.output_item.added`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the Response to which the item belongs.
    #[serde(rename = "response_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub response_id: String,

    /// The index of the output item in the Response.
    #[serde(rename = "output_index")]
    pub output_index: i32,

    #[serde(rename = "item")]
          #[validate(nested)]
    pub item: models::RealtimeConversationItem,

}



impl RealtimeServerEventResponseOutputItemAdded {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, response_id: String, output_index: i32, item: models::RealtimeConversationItem, ) -> RealtimeServerEventResponseOutputItemAdded {
        RealtimeServerEventResponseOutputItemAdded {
 event_id,
 r_type,
 response_id,
 output_index,
 item,
        }
    }
}

/// Converts the RealtimeServerEventResponseOutputItemAdded value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseOutputItemAdded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("response_id".to_string()),
            Some(self.response_id.to_string()),


            Some("output_index".to_string()),
            Some(self.output_index.to_string()),

            // Skipping item in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseOutputItemAdded value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseOutputItemAdded {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response_id: Vec<String>,
            pub output_index: Vec<i32>,
            pub item: Vec<models::RealtimeConversationItem>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseOutputItemAdded".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_id" => intermediate_rep.response_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_index" => intermediate_rep.output_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item" => intermediate_rep.item.push(<models::RealtimeConversationItem as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseOutputItemAdded".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseOutputItemAdded {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventResponseOutputItemAdded".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventResponseOutputItemAdded".to_string())?,
            response_id: intermediate_rep.response_id.into_iter().next().ok_or_else(|| "response_id missing in RealtimeServerEventResponseOutputItemAdded".to_string())?,
            output_index: intermediate_rep.output_index.into_iter().next().ok_or_else(|| "output_index missing in RealtimeServerEventResponseOutputItemAdded".to_string())?,
            item: intermediate_rep.item.into_iter().next().ok_or_else(|| "item missing in RealtimeServerEventResponseOutputItemAdded".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseOutputItemAdded> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseOutputItemAdded>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseOutputItemAdded>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseOutputItemAdded - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseOutputItemAdded> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseOutputItemAdded as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseOutputItemAdded - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when an Item is done streaming. Also emitted when a Response is  interrupted, incomplete, or cancelled. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseOutputItemDone {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `response.output_item.done`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the Response to which the item belongs.
    #[serde(rename = "response_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub response_id: String,

    /// The index of the output item in the Response.
    #[serde(rename = "output_index")]
    pub output_index: i32,

    #[serde(rename = "item")]
          #[validate(nested)]
    pub item: models::RealtimeConversationItem,

}



impl RealtimeServerEventResponseOutputItemDone {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, response_id: String, output_index: i32, item: models::RealtimeConversationItem, ) -> RealtimeServerEventResponseOutputItemDone {
        RealtimeServerEventResponseOutputItemDone {
 event_id,
 r_type,
 response_id,
 output_index,
 item,
        }
    }
}

/// Converts the RealtimeServerEventResponseOutputItemDone value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseOutputItemDone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("response_id".to_string()),
            Some(self.response_id.to_string()),


            Some("output_index".to_string()),
            Some(self.output_index.to_string()),

            // Skipping item in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseOutputItemDone value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseOutputItemDone {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response_id: Vec<String>,
            pub output_index: Vec<i32>,
            pub item: Vec<models::RealtimeConversationItem>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseOutputItemDone".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_id" => intermediate_rep.response_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_index" => intermediate_rep.output_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item" => intermediate_rep.item.push(<models::RealtimeConversationItem as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseOutputItemDone".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseOutputItemDone {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventResponseOutputItemDone".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventResponseOutputItemDone".to_string())?,
            response_id: intermediate_rep.response_id.into_iter().next().ok_or_else(|| "response_id missing in RealtimeServerEventResponseOutputItemDone".to_string())?,
            output_index: intermediate_rep.output_index.into_iter().next().ok_or_else(|| "output_index missing in RealtimeServerEventResponseOutputItemDone".to_string())?,
            item: intermediate_rep.item.into_iter().next().ok_or_else(|| "item missing in RealtimeServerEventResponseOutputItemDone".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseOutputItemDone> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseOutputItemDone>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseOutputItemDone>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseOutputItemDone - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseOutputItemDone> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseOutputItemDone as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseOutputItemDone - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when the text value of a \"text\" content part is updated.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseTextDelta {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `response.text.delta`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the response.
    #[serde(rename = "response_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub response_id: String,

    /// The ID of the item.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

    /// The index of the output item in the response.
    #[serde(rename = "output_index")]
    pub output_index: i32,

    /// The index of the content part in the item's content array.
    #[serde(rename = "content_index")]
    pub content_index: i32,

    /// The text delta.
    #[serde(rename = "delta")]
          #[validate(custom(function = "check_xss_string"))]
    pub delta: String,

}



impl RealtimeServerEventResponseTextDelta {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, response_id: String, item_id: String, output_index: i32, content_index: i32, delta: String, ) -> RealtimeServerEventResponseTextDelta {
        RealtimeServerEventResponseTextDelta {
 event_id,
 r_type,
 response_id,
 item_id,
 output_index,
 content_index,
 delta,
        }
    }
}

/// Converts the RealtimeServerEventResponseTextDelta value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseTextDelta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("response_id".to_string()),
            Some(self.response_id.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("output_index".to_string()),
            Some(self.output_index.to_string()),


            Some("content_index".to_string()),
            Some(self.content_index.to_string()),


            Some("delta".to_string()),
            Some(self.delta.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseTextDelta value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseTextDelta {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response_id: Vec<String>,
            pub item_id: Vec<String>,
            pub output_index: Vec<i32>,
            pub content_index: Vec<i32>,
            pub delta: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseTextDelta".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_id" => intermediate_rep.response_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_index" => intermediate_rep.output_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content_index" => intermediate_rep.content_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "delta" => intermediate_rep.delta.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseTextDelta".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseTextDelta {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventResponseTextDelta".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventResponseTextDelta".to_string())?,
            response_id: intermediate_rep.response_id.into_iter().next().ok_or_else(|| "response_id missing in RealtimeServerEventResponseTextDelta".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventResponseTextDelta".to_string())?,
            output_index: intermediate_rep.output_index.into_iter().next().ok_or_else(|| "output_index missing in RealtimeServerEventResponseTextDelta".to_string())?,
            content_index: intermediate_rep.content_index.into_iter().next().ok_or_else(|| "content_index missing in RealtimeServerEventResponseTextDelta".to_string())?,
            delta: intermediate_rep.delta.into_iter().next().ok_or_else(|| "delta missing in RealtimeServerEventResponseTextDelta".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseTextDelta> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseTextDelta>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseTextDelta>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseTextDelta - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseTextDelta> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseTextDelta as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseTextDelta - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when the text value of a \"text\" content part is done streaming. Also emitted when a Response is interrupted, incomplete, or cancelled. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventResponseTextDone {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `response.text.done`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The ID of the response.
    #[serde(rename = "response_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub response_id: String,

    /// The ID of the item.
    #[serde(rename = "item_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub item_id: String,

    /// The index of the output item in the response.
    #[serde(rename = "output_index")]
    pub output_index: i32,

    /// The index of the content part in the item's content array.
    #[serde(rename = "content_index")]
    pub content_index: i32,

    /// The final text content.
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    pub text: String,

}



impl RealtimeServerEventResponseTextDone {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, response_id: String, item_id: String, output_index: i32, content_index: i32, text: String, ) -> RealtimeServerEventResponseTextDone {
        RealtimeServerEventResponseTextDone {
 event_id,
 r_type,
 response_id,
 item_id,
 output_index,
 content_index,
 text,
        }
    }
}

/// Converts the RealtimeServerEventResponseTextDone value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventResponseTextDone {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("response_id".to_string()),
            Some(self.response_id.to_string()),


            Some("item_id".to_string()),
            Some(self.item_id.to_string()),


            Some("output_index".to_string()),
            Some(self.output_index.to_string()),


            Some("content_index".to_string()),
            Some(self.content_index.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventResponseTextDone value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventResponseTextDone {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub response_id: Vec<String>,
            pub item_id: Vec<String>,
            pub output_index: Vec<i32>,
            pub content_index: Vec<i32>,
            pub text: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventResponseTextDone".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_id" => intermediate_rep.response_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_index" => intermediate_rep.output_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "content_index" => intermediate_rep.content_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventResponseTextDone".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventResponseTextDone {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventResponseTextDone".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventResponseTextDone".to_string())?,
            response_id: intermediate_rep.response_id.into_iter().next().ok_or_else(|| "response_id missing in RealtimeServerEventResponseTextDone".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or_else(|| "item_id missing in RealtimeServerEventResponseTextDone".to_string())?,
            output_index: intermediate_rep.output_index.into_iter().next().ok_or_else(|| "output_index missing in RealtimeServerEventResponseTextDone".to_string())?,
            content_index: intermediate_rep.content_index.into_iter().next().ok_or_else(|| "content_index missing in RealtimeServerEventResponseTextDone".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in RealtimeServerEventResponseTextDone".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventResponseTextDone> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventResponseTextDone>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventResponseTextDone>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventResponseTextDone - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventResponseTextDone> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventResponseTextDone as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventResponseTextDone - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when a Session is created. Emitted automatically when a new  connection is established as the first server event. This event will contain  the default Session configuration. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventSessionCreated {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `session.created`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "session")]
          #[validate(nested)]
    pub session: models::RealtimeSession,

}



impl RealtimeServerEventSessionCreated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, session: models::RealtimeSession, ) -> RealtimeServerEventSessionCreated {
        RealtimeServerEventSessionCreated {
 event_id,
 r_type,
 session,
        }
    }
}

/// Converts the RealtimeServerEventSessionCreated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventSessionCreated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping session in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventSessionCreated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventSessionCreated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub session: Vec<models::RealtimeSession>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventSessionCreated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "session" => intermediate_rep.session.push(<models::RealtimeSession as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventSessionCreated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventSessionCreated {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventSessionCreated".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventSessionCreated".to_string())?,
            session: intermediate_rep.session.into_iter().next().ok_or_else(|| "session missing in RealtimeServerEventSessionCreated".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventSessionCreated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventSessionCreated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventSessionCreated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventSessionCreated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventSessionCreated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventSessionCreated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventSessionCreated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Returned when a session is updated with a `session.update` event, unless  there is an error. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeServerEventSessionUpdated {
    /// The unique ID of the server event.
    #[serde(rename = "event_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub event_id: String,

    /// The event type, must be `session.updated`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "session")]
          #[validate(nested)]
    pub session: models::RealtimeSession,

}



impl RealtimeServerEventSessionUpdated {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event_id: String, r_type: String, session: models::RealtimeSession, ) -> RealtimeServerEventSessionUpdated {
        RealtimeServerEventSessionUpdated {
 event_id,
 r_type,
 session,
        }
    }
}

/// Converts the RealtimeServerEventSessionUpdated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeServerEventSessionUpdated {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event_id".to_string()),
            Some(self.event_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping session in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeServerEventSessionUpdated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeServerEventSessionUpdated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event_id: Vec<String>,
            pub r_type: Vec<String>,
            pub session: Vec<models::RealtimeSession>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeServerEventSessionUpdated".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event_id" => intermediate_rep.event_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "session" => intermediate_rep.session.push(<models::RealtimeSession as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeServerEventSessionUpdated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeServerEventSessionUpdated {
            event_id: intermediate_rep.event_id.into_iter().next().ok_or_else(|| "event_id missing in RealtimeServerEventSessionUpdated".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RealtimeServerEventSessionUpdated".to_string())?,
            session: intermediate_rep.session.into_iter().next().ok_or_else(|| "session missing in RealtimeServerEventSessionUpdated".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeServerEventSessionUpdated> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeServerEventSessionUpdated>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeServerEventSessionUpdated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeServerEventSessionUpdated - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeServerEventSessionUpdated> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeServerEventSessionUpdated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeServerEventSessionUpdated - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Realtime session object configuration.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeSession {
    /// Unique identifier for the session object. 
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// The set of modalities the model can respond with. To disable audio, set this to [\"text\"]. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "modalities")]
          #[validate(custom(function = "check_xss_vec_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub modalities: Option<Vec<String>>,

    #[serde(rename = "model")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<models::RealtimeSessionModel>,

    /// The default system instructions (i.e. system message) prepended to model  calls. This field allows the client to guide the model on desired  responses. The model can be instructed on response content and format,  (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good  responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion  into your voice\", \"laugh frequently\"). The instructions are not guaranteed  to be followed by the model, but they provide guidance to the model on the  desired behavior.  Note that the server sets default instructions which will be used if this  field is not set and are visible in the `session.created` event at the  start of the session. 
    #[serde(rename = "instructions")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instructions: Option<String>,

    /// The voice the model uses to respond. Voice cannot be changed during the  session once the model has responded with audio at least once. Current  voice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`,  `shimmer` and `verse`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "voice")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub voice: Option<String>,

    /// The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "input_audio_format")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub input_audio_format: Option<String>,

    /// The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "output_audio_format")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output_audio_format: Option<String>,

    #[serde(rename = "input_audio_transcription")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub input_audio_transcription: Option<models::RealtimeSessionInputAudioTranscription>,

    #[serde(rename = "turn_detection")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub turn_detection: Option<Nullable<models::RealtimeSessionTurnDetection>>,

    /// Tools (functions) available to the model.
    #[serde(rename = "tools")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Vec<models::RealtimeResponseCreateParamsToolsInner>>,

    /// How the model chooses tools. Options are `auto`, `none`, `required`, or  specify a function. 
    #[serde(rename = "tool_choice")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_choice: Option<String>,

    /// Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8. 
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<f64>,

    #[serde(rename = "max_response_output_tokens")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_response_output_tokens: Option<models::RealtimeResponseCreateParamsMaxResponseOutputTokens>,

}



impl RealtimeSession {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeSession {
        RealtimeSession {
 id: None,
 modalities: None,
 model: None,
 instructions: None,
 voice: None,
 input_audio_format: None,
 output_audio_format: None,
 input_audio_transcription: None,
 turn_detection: None,
 tools: None,
 tool_choice: None,
 temperature: None,
 max_response_output_tokens: None,
        }
    }
}

/// Converts the RealtimeSession value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeSession {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            self.modalities.as_ref().map(|modalities| {
                [
                    "modalities".to_string(),
                    modalities.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

            // Skipping model in query parameter serialization


            self.instructions.as_ref().map(|instructions| {
                [
                    "instructions".to_string(),
                    instructions.to_string(),
                ].join(",")
            }),


            self.voice.as_ref().map(|voice| {
                [
                    "voice".to_string(),
                    voice.to_string(),
                ].join(",")
            }),


            self.input_audio_format.as_ref().map(|input_audio_format| {
                [
                    "input_audio_format".to_string(),
                    input_audio_format.to_string(),
                ].join(",")
            }),


            self.output_audio_format.as_ref().map(|output_audio_format| {
                [
                    "output_audio_format".to_string(),
                    output_audio_format.to_string(),
                ].join(",")
            }),

            // Skipping input_audio_transcription in query parameter serialization

            // Skipping turn_detection in query parameter serialization

            // Skipping tools in query parameter serialization


            self.tool_choice.as_ref().map(|tool_choice| {
                [
                    "tool_choice".to_string(),
                    tool_choice.to_string(),
                ].join(",")
            }),


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.to_string(),
                ].join(",")
            }),

            // Skipping max_response_output_tokens in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeSession value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeSession {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub modalities: Vec<Vec<String>>,
            pub model: Vec<models::RealtimeSessionModel>,
            pub instructions: Vec<String>,
            pub voice: Vec<String>,
            pub input_audio_format: Vec<String>,
            pub output_audio_format: Vec<String>,
            pub input_audio_transcription: Vec<models::RealtimeSessionInputAudioTranscription>,
            pub turn_detection: Vec<models::RealtimeSessionTurnDetection>,
            pub tools: Vec<Vec<models::RealtimeResponseCreateParamsToolsInner>>,
            pub tool_choice: Vec<String>,
            pub temperature: Vec<f64>,
            pub max_response_output_tokens: Vec<models::RealtimeResponseCreateParamsMaxResponseOutputTokens>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeSession".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "modalities" => return std::result::Result::Err("Parsing a container in this style is not supported in RealtimeSession".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<models::RealtimeSessionModel as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "instructions" => intermediate_rep.instructions.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "voice" => intermediate_rep.voice.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input_audio_format" => intermediate_rep.input_audio_format.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_audio_format" => intermediate_rep.output_audio_format.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input_audio_transcription" => intermediate_rep.input_audio_transcription.push(<models::RealtimeSessionInputAudioTranscription as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "turn_detection" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RealtimeSession".to_string()),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in RealtimeSession".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "tool_choice" => intermediate_rep.tool_choice.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "temperature" => intermediate_rep.temperature.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_response_output_tokens" => intermediate_rep.max_response_output_tokens.push(<models::RealtimeResponseCreateParamsMaxResponseOutputTokens as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeSession".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeSession {
            id: intermediate_rep.id.into_iter().next(),
            modalities: intermediate_rep.modalities.into_iter().next(),
            model: intermediate_rep.model.into_iter().next(),
            instructions: intermediate_rep.instructions.into_iter().next(),
            voice: intermediate_rep.voice.into_iter().next(),
            input_audio_format: intermediate_rep.input_audio_format.into_iter().next(),
            output_audio_format: intermediate_rep.output_audio_format.into_iter().next(),
            input_audio_transcription: intermediate_rep.input_audio_transcription.into_iter().next(),
            turn_detection: std::result::Result::Err("Nullable types not supported in RealtimeSession".to_string())?,
            tools: intermediate_rep.tools.into_iter().next(),
            tool_choice: intermediate_rep.tool_choice.into_iter().next(),
            temperature: intermediate_rep.temperature.into_iter().next(),
            max_response_output_tokens: intermediate_rep.max_response_output_tokens.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeSession> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeSession>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeSession>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeSession - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeSession> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeSession as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeSession - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Realtime session object configuration.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeSessionCreateRequest {
    /// The set of modalities the model can respond with. To disable audio, set this to [\"text\"]. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "modalities")]
          #[validate(custom(function = "check_xss_vec_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub modalities: Option<Vec<String>>,

    /// The Realtime model used for this session. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "model")]
          #[validate(custom(function = "check_xss_string"))]
    pub model: String,

    /// The default system instructions (i.e. system message) prepended to model  calls. This field allows the client to guide the model on desired  responses. The model can be instructed on response content and format,  (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good  responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion  into your voice\", \"laugh frequently\"). The instructions are not guaranteed  to be followed by the model, but they provide guidance to the model on the  desired behavior.  Note that the server sets default instructions which will be used if this  field is not set and are visible in the `session.created` event at the  start of the session. 
    #[serde(rename = "instructions")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instructions: Option<String>,

    /// The voice the model uses to respond. Voice cannot be changed during the  session once the model has responded with audio at least once. Current  voice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`,  `shimmer` and `verse`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "voice")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub voice: Option<String>,

    /// The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "input_audio_format")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub input_audio_format: Option<String>,

    /// The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "output_audio_format")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output_audio_format: Option<String>,

    #[serde(rename = "input_audio_transcription")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub input_audio_transcription: Option<models::RealtimeSessionInputAudioTranscription>,

    #[serde(rename = "turn_detection")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub turn_detection: Option<models::RealtimeSessionCreateRequestTurnDetection>,

    /// Tools (functions) available to the model.
    #[serde(rename = "tools")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Vec<models::RealtimeResponseCreateParamsToolsInner>>,

    /// How the model chooses tools. Options are `auto`, `none`, `required`, or  specify a function. 
    #[serde(rename = "tool_choice")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_choice: Option<String>,

    /// Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8. 
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<f64>,

    #[serde(rename = "max_response_output_tokens")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_response_output_tokens: Option<models::RealtimeResponseCreateParamsMaxResponseOutputTokens>,

}



impl RealtimeSessionCreateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(model: String, ) -> RealtimeSessionCreateRequest {
        RealtimeSessionCreateRequest {
 modalities: None,
 model,
 instructions: None,
 voice: None,
 input_audio_format: None,
 output_audio_format: None,
 input_audio_transcription: None,
 turn_detection: None,
 tools: None,
 tool_choice: None,
 temperature: None,
 max_response_output_tokens: None,
        }
    }
}

/// Converts the RealtimeSessionCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeSessionCreateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.modalities.as_ref().map(|modalities| {
                [
                    "modalities".to_string(),
                    modalities.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            Some("model".to_string()),
            Some(self.model.to_string()),


            self.instructions.as_ref().map(|instructions| {
                [
                    "instructions".to_string(),
                    instructions.to_string(),
                ].join(",")
            }),


            self.voice.as_ref().map(|voice| {
                [
                    "voice".to_string(),
                    voice.to_string(),
                ].join(",")
            }),


            self.input_audio_format.as_ref().map(|input_audio_format| {
                [
                    "input_audio_format".to_string(),
                    input_audio_format.to_string(),
                ].join(",")
            }),


            self.output_audio_format.as_ref().map(|output_audio_format| {
                [
                    "output_audio_format".to_string(),
                    output_audio_format.to_string(),
                ].join(",")
            }),

            // Skipping input_audio_transcription in query parameter serialization

            // Skipping turn_detection in query parameter serialization

            // Skipping tools in query parameter serialization


            self.tool_choice.as_ref().map(|tool_choice| {
                [
                    "tool_choice".to_string(),
                    tool_choice.to_string(),
                ].join(",")
            }),


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.to_string(),
                ].join(",")
            }),

            // Skipping max_response_output_tokens in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeSessionCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeSessionCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub modalities: Vec<Vec<String>>,
            pub model: Vec<String>,
            pub instructions: Vec<String>,
            pub voice: Vec<String>,
            pub input_audio_format: Vec<String>,
            pub output_audio_format: Vec<String>,
            pub input_audio_transcription: Vec<models::RealtimeSessionInputAudioTranscription>,
            pub turn_detection: Vec<models::RealtimeSessionCreateRequestTurnDetection>,
            pub tools: Vec<Vec<models::RealtimeResponseCreateParamsToolsInner>>,
            pub tool_choice: Vec<String>,
            pub temperature: Vec<f64>,
            pub max_response_output_tokens: Vec<models::RealtimeResponseCreateParamsMaxResponseOutputTokens>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeSessionCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "modalities" => return std::result::Result::Err("Parsing a container in this style is not supported in RealtimeSessionCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "instructions" => intermediate_rep.instructions.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "voice" => intermediate_rep.voice.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input_audio_format" => intermediate_rep.input_audio_format.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_audio_format" => intermediate_rep.output_audio_format.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input_audio_transcription" => intermediate_rep.input_audio_transcription.push(<models::RealtimeSessionInputAudioTranscription as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "turn_detection" => intermediate_rep.turn_detection.push(<models::RealtimeSessionCreateRequestTurnDetection as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in RealtimeSessionCreateRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "tool_choice" => intermediate_rep.tool_choice.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "temperature" => intermediate_rep.temperature.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_response_output_tokens" => intermediate_rep.max_response_output_tokens.push(<models::RealtimeResponseCreateParamsMaxResponseOutputTokens as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeSessionCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeSessionCreateRequest {
            modalities: intermediate_rep.modalities.into_iter().next(),
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in RealtimeSessionCreateRequest".to_string())?,
            instructions: intermediate_rep.instructions.into_iter().next(),
            voice: intermediate_rep.voice.into_iter().next(),
            input_audio_format: intermediate_rep.input_audio_format.into_iter().next(),
            output_audio_format: intermediate_rep.output_audio_format.into_iter().next(),
            input_audio_transcription: intermediate_rep.input_audio_transcription.into_iter().next(),
            turn_detection: intermediate_rep.turn_detection.into_iter().next(),
            tools: intermediate_rep.tools.into_iter().next(),
            tool_choice: intermediate_rep.tool_choice.into_iter().next(),
            temperature: intermediate_rep.temperature.into_iter().next(),
            max_response_output_tokens: intermediate_rep.max_response_output_tokens.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeSessionCreateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeSessionCreateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeSessionCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeSessionCreateRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeSessionCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeSessionCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeSessionCreateRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Configuration for turn detection. Can be set to `null` to turn off. Server  VAD means that the model will detect the start and end of speech based on  audio volume and respond at the end of user speech. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeSessionCreateRequestTurnDetection {
    /// Type of turn detection, only `server_vad` is currently supported. 
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    /// Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A  higher threshold will require louder audio to activate the model, and  thus might perform better in noisy environments. 
    #[serde(rename = "threshold")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub threshold: Option<f64>,

    /// Amount of audio to include before the VAD detected speech (in  milliseconds). Defaults to 300ms. 
    #[serde(rename = "prefix_padding_ms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub prefix_padding_ms: Option<i32>,

    /// Duration of silence to detect speech stop (in milliseconds). Defaults  to 500ms. With shorter values the model will respond more quickly,  but may jump in on short pauses from the user. 
    #[serde(rename = "silence_duration_ms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub silence_duration_ms: Option<i32>,

    /// Whether or not to automatically generate a response when VAD is enabled. `true` by default. 
    #[serde(rename = "create_response")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub create_response: Option<bool>,

}



impl RealtimeSessionCreateRequestTurnDetection {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeSessionCreateRequestTurnDetection {
        RealtimeSessionCreateRequestTurnDetection {
 r_type: None,
 threshold: None,
 prefix_padding_ms: None,
 silence_duration_ms: None,
 create_response: Some(true),
        }
    }
}

/// Converts the RealtimeSessionCreateRequestTurnDetection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeSessionCreateRequestTurnDetection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),


            self.threshold.as_ref().map(|threshold| {
                [
                    "threshold".to_string(),
                    threshold.to_string(),
                ].join(",")
            }),


            self.prefix_padding_ms.as_ref().map(|prefix_padding_ms| {
                [
                    "prefix_padding_ms".to_string(),
                    prefix_padding_ms.to_string(),
                ].join(",")
            }),


            self.silence_duration_ms.as_ref().map(|silence_duration_ms| {
                [
                    "silence_duration_ms".to_string(),
                    silence_duration_ms.to_string(),
                ].join(",")
            }),


            self.create_response.as_ref().map(|create_response| {
                [
                    "create_response".to_string(),
                    create_response.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeSessionCreateRequestTurnDetection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeSessionCreateRequestTurnDetection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub threshold: Vec<f64>,
            pub prefix_padding_ms: Vec<i32>,
            pub silence_duration_ms: Vec<i32>,
            pub create_response: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeSessionCreateRequestTurnDetection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "threshold" => intermediate_rep.threshold.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prefix_padding_ms" => intermediate_rep.prefix_padding_ms.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "silence_duration_ms" => intermediate_rep.silence_duration_ms.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "create_response" => intermediate_rep.create_response.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeSessionCreateRequestTurnDetection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeSessionCreateRequestTurnDetection {
            r_type: intermediate_rep.r_type.into_iter().next(),
            threshold: intermediate_rep.threshold.into_iter().next(),
            prefix_padding_ms: intermediate_rep.prefix_padding_ms.into_iter().next(),
            silence_duration_ms: intermediate_rep.silence_duration_ms.into_iter().next(),
            create_response: intermediate_rep.create_response.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeSessionCreateRequestTurnDetection> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeSessionCreateRequestTurnDetection>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeSessionCreateRequestTurnDetection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeSessionCreateRequestTurnDetection - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeSessionCreateRequestTurnDetection> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeSessionCreateRequestTurnDetection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeSessionCreateRequestTurnDetection - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A new Realtime session configuration, with an ephermeral key. Default TTL for keys is one minute. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeSessionCreateResponse {
    #[serde(rename = "client_secret")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_secret: Option<models::RealtimeSessionCreateResponseClientSecret>,

    /// The set of modalities the model can respond with. To disable audio, set this to [\"text\"]. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "modalities")]
          #[validate(custom(function = "check_xss_vec_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub modalities: Option<Vec<String>>,

    /// The default system instructions (i.e. system message) prepended to model  calls. This field allows the client to guide the model on desired  responses. The model can be instructed on response content and format,  (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good  responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion  into your voice\", \"laugh frequently\"). The instructions are not guaranteed  to be followed by the model, but they provide guidance to the model on the  desired behavior.  Note that the server sets default instructions which will be used if this  field is not set and are visible in the `session.created` event at the  start of the session. 
    #[serde(rename = "instructions")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub instructions: Option<String>,

    /// The voice the model uses to respond. Voice cannot be changed during the  session once the model has responded with audio at least once. Current  voice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`,  `shimmer` and `verse`. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "voice")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub voice: Option<String>,

    /// The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
    #[serde(rename = "input_audio_format")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub input_audio_format: Option<String>,

    /// The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
    #[serde(rename = "output_audio_format")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output_audio_format: Option<String>,

    #[serde(rename = "input_audio_transcription")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub input_audio_transcription: Option<models::RealtimeSessionInputAudioTranscription>,

    #[serde(rename = "turn_detection")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub turn_detection: Option<models::RealtimeSessionCreateResponseTurnDetection>,

    /// Tools (functions) available to the model.
    #[serde(rename = "tools")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tools: Option<Vec<models::RealtimeResponseCreateParamsToolsInner>>,

    /// How the model chooses tools. Options are `auto`, `none`, `required`, or  specify a function. 
    #[serde(rename = "tool_choice")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_choice: Option<String>,

    /// Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8. 
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<f64>,

    #[serde(rename = "max_response_output_tokens")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_response_output_tokens: Option<models::RealtimeResponseCreateParamsMaxResponseOutputTokens>,

}



impl RealtimeSessionCreateResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeSessionCreateResponse {
        RealtimeSessionCreateResponse {
 client_secret: None,
 modalities: None,
 instructions: None,
 voice: None,
 input_audio_format: None,
 output_audio_format: None,
 input_audio_transcription: None,
 turn_detection: None,
 tools: None,
 tool_choice: None,
 temperature: None,
 max_response_output_tokens: None,
        }
    }
}

/// Converts the RealtimeSessionCreateResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeSessionCreateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping client_secret in query parameter serialization


            self.modalities.as_ref().map(|modalities| {
                [
                    "modalities".to_string(),
                    modalities.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.instructions.as_ref().map(|instructions| {
                [
                    "instructions".to_string(),
                    instructions.to_string(),
                ].join(",")
            }),


            self.voice.as_ref().map(|voice| {
                [
                    "voice".to_string(),
                    voice.to_string(),
                ].join(",")
            }),


            self.input_audio_format.as_ref().map(|input_audio_format| {
                [
                    "input_audio_format".to_string(),
                    input_audio_format.to_string(),
                ].join(",")
            }),


            self.output_audio_format.as_ref().map(|output_audio_format| {
                [
                    "output_audio_format".to_string(),
                    output_audio_format.to_string(),
                ].join(",")
            }),

            // Skipping input_audio_transcription in query parameter serialization

            // Skipping turn_detection in query parameter serialization

            // Skipping tools in query parameter serialization


            self.tool_choice.as_ref().map(|tool_choice| {
                [
                    "tool_choice".to_string(),
                    tool_choice.to_string(),
                ].join(",")
            }),


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.to_string(),
                ].join(",")
            }),

            // Skipping max_response_output_tokens in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeSessionCreateResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeSessionCreateResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub client_secret: Vec<models::RealtimeSessionCreateResponseClientSecret>,
            pub modalities: Vec<Vec<String>>,
            pub instructions: Vec<String>,
            pub voice: Vec<String>,
            pub input_audio_format: Vec<String>,
            pub output_audio_format: Vec<String>,
            pub input_audio_transcription: Vec<models::RealtimeSessionInputAudioTranscription>,
            pub turn_detection: Vec<models::RealtimeSessionCreateResponseTurnDetection>,
            pub tools: Vec<Vec<models::RealtimeResponseCreateParamsToolsInner>>,
            pub tool_choice: Vec<String>,
            pub temperature: Vec<f64>,
            pub max_response_output_tokens: Vec<models::RealtimeResponseCreateParamsMaxResponseOutputTokens>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeSessionCreateResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "client_secret" => intermediate_rep.client_secret.push(<models::RealtimeSessionCreateResponseClientSecret as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "modalities" => return std::result::Result::Err("Parsing a container in this style is not supported in RealtimeSessionCreateResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "instructions" => intermediate_rep.instructions.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "voice" => intermediate_rep.voice.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input_audio_format" => intermediate_rep.input_audio_format.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_audio_format" => intermediate_rep.output_audio_format.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input_audio_transcription" => intermediate_rep.input_audio_transcription.push(<models::RealtimeSessionInputAudioTranscription as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "turn_detection" => intermediate_rep.turn_detection.push(<models::RealtimeSessionCreateResponseTurnDetection as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in RealtimeSessionCreateResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "tool_choice" => intermediate_rep.tool_choice.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "temperature" => intermediate_rep.temperature.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_response_output_tokens" => intermediate_rep.max_response_output_tokens.push(<models::RealtimeResponseCreateParamsMaxResponseOutputTokens as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeSessionCreateResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeSessionCreateResponse {
            client_secret: intermediate_rep.client_secret.into_iter().next(),
            modalities: intermediate_rep.modalities.into_iter().next(),
            instructions: intermediate_rep.instructions.into_iter().next(),
            voice: intermediate_rep.voice.into_iter().next(),
            input_audio_format: intermediate_rep.input_audio_format.into_iter().next(),
            output_audio_format: intermediate_rep.output_audio_format.into_iter().next(),
            input_audio_transcription: intermediate_rep.input_audio_transcription.into_iter().next(),
            turn_detection: intermediate_rep.turn_detection.into_iter().next(),
            tools: intermediate_rep.tools.into_iter().next(),
            tool_choice: intermediate_rep.tool_choice.into_iter().next(),
            temperature: intermediate_rep.temperature.into_iter().next(),
            max_response_output_tokens: intermediate_rep.max_response_output_tokens.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeSessionCreateResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeSessionCreateResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeSessionCreateResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeSessionCreateResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeSessionCreateResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeSessionCreateResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeSessionCreateResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Ephemeral key returned by the API.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeSessionCreateResponseClientSecret {
    /// Ephemeral key usable in client environments to authenticate connections to the Realtime API. Use this in client-side environments rather than a standard API token, which should only be used server-side. 
    #[serde(rename = "value")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,

    /// Timestamp for when the token expires. Currently, all tokens expire after one minute. 
    #[serde(rename = "expires_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<i32>,

}



impl RealtimeSessionCreateResponseClientSecret {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeSessionCreateResponseClientSecret {
        RealtimeSessionCreateResponseClientSecret {
 value: None,
 expires_at: None,
        }
    }
}

/// Converts the RealtimeSessionCreateResponseClientSecret value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeSessionCreateResponseClientSecret {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.value.as_ref().map(|value| {
                [
                    "value".to_string(),
                    value.to_string(),
                ].join(",")
            }),


            self.expires_at.as_ref().map(|expires_at| {
                [
                    "expires_at".to_string(),
                    expires_at.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeSessionCreateResponseClientSecret value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeSessionCreateResponseClientSecret {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub value: Vec<String>,
            pub expires_at: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeSessionCreateResponseClientSecret".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "value" => intermediate_rep.value.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expires_at" => intermediate_rep.expires_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeSessionCreateResponseClientSecret".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeSessionCreateResponseClientSecret {
            value: intermediate_rep.value.into_iter().next(),
            expires_at: intermediate_rep.expires_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeSessionCreateResponseClientSecret> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeSessionCreateResponseClientSecret>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeSessionCreateResponseClientSecret>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeSessionCreateResponseClientSecret - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeSessionCreateResponseClientSecret> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeSessionCreateResponseClientSecret as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeSessionCreateResponseClientSecret - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Configuration for turn detection. Can be set to `null` to turn off. Server  VAD means that the model will detect the start and end of speech based on  audio volume and respond at the end of user speech. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeSessionCreateResponseTurnDetection {
    /// Type of turn detection, only `server_vad` is currently supported. 
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    /// Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A  higher threshold will require louder audio to activate the model, and  thus might perform better in noisy environments. 
    #[serde(rename = "threshold")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub threshold: Option<f64>,

    /// Amount of audio to include before the VAD detected speech (in  milliseconds). Defaults to 300ms. 
    #[serde(rename = "prefix_padding_ms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub prefix_padding_ms: Option<i32>,

    /// Duration of silence to detect speech stop (in milliseconds). Defaults  to 500ms. With shorter values the model will respond more quickly,  but may jump in on short pauses from the user. 
    #[serde(rename = "silence_duration_ms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub silence_duration_ms: Option<i32>,

}



impl RealtimeSessionCreateResponseTurnDetection {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeSessionCreateResponseTurnDetection {
        RealtimeSessionCreateResponseTurnDetection {
 r_type: None,
 threshold: None,
 prefix_padding_ms: None,
 silence_duration_ms: None,
        }
    }
}

/// Converts the RealtimeSessionCreateResponseTurnDetection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeSessionCreateResponseTurnDetection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),


            self.threshold.as_ref().map(|threshold| {
                [
                    "threshold".to_string(),
                    threshold.to_string(),
                ].join(",")
            }),


            self.prefix_padding_ms.as_ref().map(|prefix_padding_ms| {
                [
                    "prefix_padding_ms".to_string(),
                    prefix_padding_ms.to_string(),
                ].join(",")
            }),


            self.silence_duration_ms.as_ref().map(|silence_duration_ms| {
                [
                    "silence_duration_ms".to_string(),
                    silence_duration_ms.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeSessionCreateResponseTurnDetection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeSessionCreateResponseTurnDetection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub threshold: Vec<f64>,
            pub prefix_padding_ms: Vec<i32>,
            pub silence_duration_ms: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeSessionCreateResponseTurnDetection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "threshold" => intermediate_rep.threshold.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prefix_padding_ms" => intermediate_rep.prefix_padding_ms.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "silence_duration_ms" => intermediate_rep.silence_duration_ms.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeSessionCreateResponseTurnDetection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeSessionCreateResponseTurnDetection {
            r_type: intermediate_rep.r_type.into_iter().next(),
            threshold: intermediate_rep.threshold.into_iter().next(),
            prefix_padding_ms: intermediate_rep.prefix_padding_ms.into_iter().next(),
            silence_duration_ms: intermediate_rep.silence_duration_ms.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeSessionCreateResponseTurnDetection> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeSessionCreateResponseTurnDetection>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeSessionCreateResponseTurnDetection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeSessionCreateResponseTurnDetection - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeSessionCreateResponseTurnDetection> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeSessionCreateResponseTurnDetection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeSessionCreateResponseTurnDetection - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Configuration for input audio transcription, defaults to off and can be  set to `null` to turn off once on. Input audio transcription is not native  to the model, since the model consumes audio directly. Transcription runs  asynchronously through Whisper and should be treated as rough guidance  rather than the representation understood by the model. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeSessionInputAudioTranscription {
    /// The model to use for transcription, `whisper-1` is the only currently  supported model. 
    #[serde(rename = "model")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<String>,

}



impl RealtimeSessionInputAudioTranscription {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeSessionInputAudioTranscription {
        RealtimeSessionInputAudioTranscription {
 model: None,
        }
    }
}

/// Converts the RealtimeSessionInputAudioTranscription value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeSessionInputAudioTranscription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.model.as_ref().map(|model| {
                [
                    "model".to_string(),
                    model.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeSessionInputAudioTranscription value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeSessionInputAudioTranscription {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub model: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeSessionInputAudioTranscription".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeSessionInputAudioTranscription".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeSessionInputAudioTranscription {
            model: intermediate_rep.model.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeSessionInputAudioTranscription> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeSessionInputAudioTranscription>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeSessionInputAudioTranscription>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeSessionInputAudioTranscription - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeSessionInputAudioTranscription> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeSessionInputAudioTranscription as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeSessionInputAudioTranscription - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The Realtime model used for this session. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum RealtimeSessionModel {
    String(String),
    String1(String),
}

impl validator::Validate for RealtimeSessionModel
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::String(_) => std::result::Result::Ok(()),
            Self::String1(_) => std::result::Result::Ok(()),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeSessionModel value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeSessionModel {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}







/// Configuration for turn detection. Can be set to `null` to turn off. Server  VAD means that the model will detect the start and end of speech based on  audio volume and respond at the end of user speech. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RealtimeSessionTurnDetection {
    /// Type of turn detection, only `server_vad` is currently supported. 
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    /// Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A  higher threshold will require louder audio to activate the model, and  thus might perform better in noisy environments. 
    #[serde(rename = "threshold")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub threshold: Option<f64>,

    /// Amount of audio to include before the VAD detected speech (in  milliseconds). Defaults to 300ms. 
    #[serde(rename = "prefix_padding_ms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub prefix_padding_ms: Option<i32>,

    /// Duration of silence to detect speech stop (in milliseconds). Defaults  to 500ms. With shorter values the model will respond more quickly,  but may jump in on short pauses from the user. 
    #[serde(rename = "silence_duration_ms")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub silence_duration_ms: Option<i32>,

}



impl RealtimeSessionTurnDetection {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RealtimeSessionTurnDetection {
        RealtimeSessionTurnDetection {
 r_type: None,
 threshold: None,
 prefix_padding_ms: None,
 silence_duration_ms: None,
        }
    }
}

/// Converts the RealtimeSessionTurnDetection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RealtimeSessionTurnDetection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),


            self.threshold.as_ref().map(|threshold| {
                [
                    "threshold".to_string(),
                    threshold.to_string(),
                ].join(",")
            }),


            self.prefix_padding_ms.as_ref().map(|prefix_padding_ms| {
                [
                    "prefix_padding_ms".to_string(),
                    prefix_padding_ms.to_string(),
                ].join(",")
            }),


            self.silence_duration_ms.as_ref().map(|silence_duration_ms| {
                [
                    "silence_duration_ms".to_string(),
                    silence_duration_ms.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RealtimeSessionTurnDetection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RealtimeSessionTurnDetection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub threshold: Vec<f64>,
            pub prefix_padding_ms: Vec<i32>,
            pub silence_duration_ms: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RealtimeSessionTurnDetection".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "threshold" => intermediate_rep.threshold.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prefix_padding_ms" => intermediate_rep.prefix_padding_ms.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "silence_duration_ms" => intermediate_rep.silence_duration_ms.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RealtimeSessionTurnDetection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RealtimeSessionTurnDetection {
            r_type: intermediate_rep.r_type.into_iter().next(),
            threshold: intermediate_rep.threshold.into_iter().next(),
            prefix_padding_ms: intermediate_rep.prefix_padding_ms.into_iter().next(),
            silence_duration_ms: intermediate_rep.silence_duration_ms.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RealtimeSessionTurnDetection> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RealtimeSessionTurnDetection>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RealtimeSessionTurnDetection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RealtimeSessionTurnDetection - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RealtimeSessionTurnDetection> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RealtimeSessionTurnDetection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RealtimeSessionTurnDetection - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ResponseFormatJsonObject {
    /// The type of response format being defined: `json_object`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

}



impl ResponseFormatJsonObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> ResponseFormatJsonObject {
        ResponseFormatJsonObject {
 r_type,
        }
    }
}

/// Converts the ResponseFormatJsonObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ResponseFormatJsonObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ResponseFormatJsonObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ResponseFormatJsonObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ResponseFormatJsonObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ResponseFormatJsonObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ResponseFormatJsonObject {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in ResponseFormatJsonObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ResponseFormatJsonObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ResponseFormatJsonObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ResponseFormatJsonObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ResponseFormatJsonObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ResponseFormatJsonObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ResponseFormatJsonObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ResponseFormatJsonObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ResponseFormatJsonSchema {
    /// The type of response format being defined: `json_schema`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "json_schema")]
          #[validate(nested)]
    pub json_schema: models::ResponseFormatJsonSchemaJsonSchema,

}



impl ResponseFormatJsonSchema {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, json_schema: models::ResponseFormatJsonSchemaJsonSchema, ) -> ResponseFormatJsonSchema {
        ResponseFormatJsonSchema {
 r_type,
 json_schema,
        }
    }
}

/// Converts the ResponseFormatJsonSchema value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ResponseFormatJsonSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping json_schema in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ResponseFormatJsonSchema value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ResponseFormatJsonSchema {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub json_schema: Vec<models::ResponseFormatJsonSchemaJsonSchema>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ResponseFormatJsonSchema".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "json_schema" => intermediate_rep.json_schema.push(<models::ResponseFormatJsonSchemaJsonSchema as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ResponseFormatJsonSchema".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ResponseFormatJsonSchema {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in ResponseFormatJsonSchema".to_string())?,
            json_schema: intermediate_rep.json_schema.into_iter().next().ok_or_else(|| "json_schema missing in ResponseFormatJsonSchema".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ResponseFormatJsonSchema> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ResponseFormatJsonSchema>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ResponseFormatJsonSchema>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ResponseFormatJsonSchema - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ResponseFormatJsonSchema> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ResponseFormatJsonSchema as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ResponseFormatJsonSchema - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ResponseFormatJsonSchemaJsonSchema {
    /// A description of what the response format is for, used by the model to determine how to respond in the format.
    #[serde(rename = "description")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    /// The schema for the response format, described as a JSON Schema object.
    #[serde(rename = "schema")]
          #[validate(custom(function = "check_xss_map"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub schema: Option<std::collections::HashMap<String, crate::types::Object>>,

    /// Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. To learn more, read the [Structured Outputs guide](/docs/guides/structured-outputs).
    #[serde(rename = "strict")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub strict: Option<Nullable<bool>>,

}



impl ResponseFormatJsonSchemaJsonSchema {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, ) -> ResponseFormatJsonSchemaJsonSchema {
        ResponseFormatJsonSchemaJsonSchema {
 description: None,
 name,
 schema: None,
 strict: Some(Nullable::Present(false)),
        }
    }
}

/// Converts the ResponseFormatJsonSchemaJsonSchema value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ResponseFormatJsonSchemaJsonSchema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping schema in query parameter serialization
            // Skipping schema in query parameter serialization


            self.strict.as_ref().map(|strict| {
                [
                    "strict".to_string(),
                    strict.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ResponseFormatJsonSchemaJsonSchema value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ResponseFormatJsonSchemaJsonSchema {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub name: Vec<String>,
            pub schema: Vec<std::collections::HashMap<String, crate::types::Object>>,
            pub strict: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ResponseFormatJsonSchemaJsonSchema".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "schema" => return std::result::Result::Err("Parsing a container in this style is not supported in ResponseFormatJsonSchemaJsonSchema".to_string()),
                    "strict" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ResponseFormatJsonSchemaJsonSchema".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ResponseFormatJsonSchemaJsonSchema".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ResponseFormatJsonSchemaJsonSchema {
            description: intermediate_rep.description.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ResponseFormatJsonSchemaJsonSchema".to_string())?,
            schema: intermediate_rep.schema.into_iter().next(),
            strict: std::result::Result::Err("Nullable types not supported in ResponseFormatJsonSchemaJsonSchema".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ResponseFormatJsonSchemaJsonSchema> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ResponseFormatJsonSchemaJsonSchema>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ResponseFormatJsonSchemaJsonSchema>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ResponseFormatJsonSchemaJsonSchema - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ResponseFormatJsonSchemaJsonSchema> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ResponseFormatJsonSchemaJsonSchema as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ResponseFormatJsonSchemaJsonSchema - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ResponseFormatText {
    /// The type of response format being defined: `text`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

}



impl ResponseFormatText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> ResponseFormatText {
        ResponseFormatText {
 r_type,
        }
    }
}

/// Converts the ResponseFormatText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ResponseFormatText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ResponseFormatText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ResponseFormatText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ResponseFormatText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ResponseFormatText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ResponseFormatText {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in ResponseFormatText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ResponseFormatText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ResponseFormatText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ResponseFormatText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ResponseFormatText - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ResponseFormatText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ResponseFormatText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ResponseFormatText - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunCompletionUsage {
    /// Number of completion tokens used over the course of the run.
    #[serde(rename = "completion_tokens")]
    pub completion_tokens: i32,

    /// Number of prompt tokens used over the course of the run.
    #[serde(rename = "prompt_tokens")]
    pub prompt_tokens: i32,

    /// Total number of tokens used (prompt + completion).
    #[serde(rename = "total_tokens")]
    pub total_tokens: i32,

}



impl RunCompletionUsage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(completion_tokens: i32, prompt_tokens: i32, total_tokens: i32, ) -> RunCompletionUsage {
        RunCompletionUsage {
 completion_tokens,
 prompt_tokens,
 total_tokens,
        }
    }
}

/// Converts the RunCompletionUsage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunCompletionUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("completion_tokens".to_string()),
            Some(self.completion_tokens.to_string()),


            Some("prompt_tokens".to_string()),
            Some(self.prompt_tokens.to_string()),


            Some("total_tokens".to_string()),
            Some(self.total_tokens.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunCompletionUsage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunCompletionUsage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub completion_tokens: Vec<i32>,
            pub prompt_tokens: Vec<i32>,
            pub total_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunCompletionUsage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "completion_tokens" => intermediate_rep.completion_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prompt_tokens" => intermediate_rep.prompt_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total_tokens" => intermediate_rep.total_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunCompletionUsage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunCompletionUsage {
            completion_tokens: intermediate_rep.completion_tokens.into_iter().next().ok_or_else(|| "completion_tokens missing in RunCompletionUsage".to_string())?,
            prompt_tokens: intermediate_rep.prompt_tokens.into_iter().next().ok_or_else(|| "prompt_tokens missing in RunCompletionUsage".to_string())?,
            total_tokens: intermediate_rep.total_tokens.into_iter().next().ok_or_else(|| "total_tokens missing in RunCompletionUsage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunCompletionUsage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunCompletionUsage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunCompletionUsage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunCompletionUsage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunCompletionUsage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunCompletionUsage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunCompletionUsage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Represents an execution run on a [thread](/docs/api-reference/threads).
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunObject {
    /// The identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The object type, which is always `thread.run`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The Unix timestamp (in seconds) for when the run was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    /// The ID of the [thread](/docs/api-reference/threads) that was executed on as a part of this run.
    #[serde(rename = "thread_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub thread_id: String,

    /// The ID of the [assistant](/docs/api-reference/assistants) used for execution of this run.
    #[serde(rename = "assistant_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub assistant_id: String,

    /// The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
          #[validate(custom(function = "check_xss_string"))]
    pub status: String,

    #[serde(rename = "required_action")]
    pub required_action: Nullable<models::RunObjectRequiredAction>,

    #[serde(rename = "last_error")]
    pub last_error: Nullable<models::RunObjectLastError>,

    /// The Unix timestamp (in seconds) for when the run will expire.
    #[serde(rename = "expires_at")]
    pub expires_at: Nullable<i32>,

    /// The Unix timestamp (in seconds) for when the run was started.
    #[serde(rename = "started_at")]
    pub started_at: Nullable<i32>,

    /// The Unix timestamp (in seconds) for when the run was cancelled.
    #[serde(rename = "cancelled_at")]
    pub cancelled_at: Nullable<i32>,

    /// The Unix timestamp (in seconds) for when the run failed.
    #[serde(rename = "failed_at")]
    pub failed_at: Nullable<i32>,

    /// The Unix timestamp (in seconds) for when the run was completed.
    #[serde(rename = "completed_at")]
    pub completed_at: Nullable<i32>,

    #[serde(rename = "incomplete_details")]
    pub incomplete_details: Nullable<models::RunObjectIncompleteDetails>,

    /// The model that the [assistant](/docs/api-reference/assistants) used for this run.
    #[serde(rename = "model")]
          #[validate(custom(function = "check_xss_string"))]
    pub model: String,

    /// The instructions that the [assistant](/docs/api-reference/assistants) used for this run.
    #[serde(rename = "instructions")]
          #[validate(custom(function = "check_xss_string"))]
    pub instructions: String,

    /// The list of tools that the [assistant](/docs/api-reference/assistants) used for this run.
    #[serde(rename = "tools")]
    #[validate(
            length(max = 20),
          nested,
    )]
    pub tools: Vec<models::AssistantObjectToolsInner>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    pub metadata: crate::types::Object,

    #[serde(rename = "usage")]
    pub usage: Nullable<models::RunCompletionUsage>,

    /// The sampling temperature used for this run. If not set, defaults to 1.
    #[serde(rename = "temperature")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub temperature: Option<Nullable<f64>>,

    /// The nucleus sampling value used for this run. If not set, defaults to 1.
    #[serde(rename = "top_p")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub top_p: Option<Nullable<f64>>,

    /// The maximum number of prompt tokens specified to have been used over the course of the run. 
    #[serde(rename = "max_prompt_tokens")]
    #[validate(
            range(min = 256u32),
    )]
    pub max_prompt_tokens: Nullable<u32>,

    /// The maximum number of completion tokens specified to have been used over the course of the run. 
    #[serde(rename = "max_completion_tokens")]
    #[validate(
            range(min = 256u32),
    )]
    pub max_completion_tokens: Nullable<u32>,

    #[serde(rename = "truncation_strategy")]
          #[validate(nested)]
    pub truncation_strategy: models::TruncationObject,

    #[serde(rename = "tool_choice")]
          #[validate(nested)]
    pub tool_choice: models::AssistantsApiToolChoiceOption,

    /// Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
    #[serde(rename = "parallel_tool_calls")]
    pub parallel_tool_calls: bool,

    #[serde(rename = "response_format")]
          #[validate(nested)]
    pub response_format: models::AssistantsApiResponseFormatOption,

}



impl RunObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, created_at: i32, thread_id: String, assistant_id: String, status: String, required_action: Nullable<models::RunObjectRequiredAction>, last_error: Nullable<models::RunObjectLastError>, expires_at: Nullable<i32>, started_at: Nullable<i32>, cancelled_at: Nullable<i32>, failed_at: Nullable<i32>, completed_at: Nullable<i32>, incomplete_details: Nullable<models::RunObjectIncompleteDetails>, model: String, instructions: String, tools: Vec<models::AssistantObjectToolsInner>, metadata: crate::types::Object, usage: Nullable<models::RunCompletionUsage>, max_prompt_tokens: Nullable<u32>, max_completion_tokens: Nullable<u32>, truncation_strategy: models::TruncationObject, tool_choice: models::AssistantsApiToolChoiceOption, response_format: models::AssistantsApiResponseFormatOption, ) -> RunObject {
        RunObject {
 id,
 object,
 created_at,
 thread_id,
 assistant_id,
 status,
 required_action,
 last_error,
 expires_at,
 started_at,
 cancelled_at,
 failed_at,
 completed_at,
 incomplete_details,
 model,
 instructions,
 tools,
 metadata,
 usage,
 temperature: None,
 top_p: None,
 max_prompt_tokens,
 max_completion_tokens,
 truncation_strategy,
 tool_choice,
 parallel_tool_calls: true,
 response_format,
        }
    }
}

/// Converts the RunObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("thread_id".to_string()),
            Some(self.thread_id.to_string()),


            Some("assistant_id".to_string()),
            Some(self.assistant_id.to_string()),


            Some("status".to_string()),
            Some(self.status.to_string()),

            // Skipping required_action in query parameter serialization

            // Skipping last_error in query parameter serialization


            Some("expires_at".to_string()),
            Some(self.expires_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("started_at".to_string()),
            Some(self.started_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("cancelled_at".to_string()),
            Some(self.cancelled_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("failed_at".to_string()),
            Some(self.failed_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("completed_at".to_string()),
            Some(self.completed_at.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping incomplete_details in query parameter serialization


            Some("model".to_string()),
            Some(self.model.to_string()),


            Some("instructions".to_string()),
            Some(self.instructions.to_string()),

            // Skipping tools in query parameter serialization

            // Skipping metadata in query parameter serialization

            // Skipping usage in query parameter serialization


            self.temperature.as_ref().map(|temperature| {
                [
                    "temperature".to_string(),
                    temperature.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.top_p.as_ref().map(|top_p| {
                [
                    "top_p".to_string(),
                    top_p.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            Some("max_prompt_tokens".to_string()),
            Some(self.max_prompt_tokens.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("max_completion_tokens".to_string()),
            Some(self.max_completion_tokens.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping truncation_strategy in query parameter serialization

            // Skipping tool_choice in query parameter serialization


            Some("parallel_tool_calls".to_string()),
            Some(self.parallel_tool_calls.to_string()),

            // Skipping response_format in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub created_at: Vec<i32>,
            pub thread_id: Vec<String>,
            pub assistant_id: Vec<String>,
            pub status: Vec<String>,
            pub required_action: Vec<models::RunObjectRequiredAction>,
            pub last_error: Vec<models::RunObjectLastError>,
            pub expires_at: Vec<i32>,
            pub started_at: Vec<i32>,
            pub cancelled_at: Vec<i32>,
            pub failed_at: Vec<i32>,
            pub completed_at: Vec<i32>,
            pub incomplete_details: Vec<models::RunObjectIncompleteDetails>,
            pub model: Vec<String>,
            pub instructions: Vec<String>,
            pub tools: Vec<Vec<models::AssistantObjectToolsInner>>,
            pub metadata: Vec<crate::types::Object>,
            pub usage: Vec<models::RunCompletionUsage>,
            pub temperature: Vec<f64>,
            pub top_p: Vec<f64>,
            pub max_prompt_tokens: Vec<u32>,
            pub max_completion_tokens: Vec<u32>,
            pub truncation_strategy: Vec<models::TruncationObject>,
            pub tool_choice: Vec<models::AssistantsApiToolChoiceOption>,
            pub parallel_tool_calls: Vec<bool>,
            pub response_format: Vec<models::AssistantsApiResponseFormatOption>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "thread_id" => intermediate_rep.thread_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "assistant_id" => intermediate_rep.assistant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "required_action" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "last_error" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "expires_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "started_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "cancelled_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "failed_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "completed_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "incomplete_details" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "model" => intermediate_rep.model.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "instructions" => intermediate_rep.instructions.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tools" => return std::result::Result::Err("Parsing a container in this style is not supported in RunObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "usage" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "temperature" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "top_p" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "max_prompt_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    "max_completion_tokens" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "truncation_strategy" => intermediate_rep.truncation_strategy.push(<models::TruncationObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "tool_choice" => intermediate_rep.tool_choice.push(<models::AssistantsApiToolChoiceOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "parallel_tool_calls" => intermediate_rep.parallel_tool_calls.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "response_format" => intermediate_rep.response_format.push(<models::AssistantsApiResponseFormatOption as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in RunObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in RunObject".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in RunObject".to_string())?,
            thread_id: intermediate_rep.thread_id.into_iter().next().ok_or_else(|| "thread_id missing in RunObject".to_string())?,
            assistant_id: intermediate_rep.assistant_id.into_iter().next().ok_or_else(|| "assistant_id missing in RunObject".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in RunObject".to_string())?,
            required_action: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            last_error: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            expires_at: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            started_at: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            cancelled_at: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            failed_at: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            completed_at: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            incomplete_details: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            model: intermediate_rep.model.into_iter().next().ok_or_else(|| "model missing in RunObject".to_string())?,
            instructions: intermediate_rep.instructions.into_iter().next().ok_or_else(|| "instructions missing in RunObject".to_string())?,
            tools: intermediate_rep.tools.into_iter().next().ok_or_else(|| "tools missing in RunObject".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next().ok_or_else(|| "metadata missing in RunObject".to_string())?,
            usage: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            temperature: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            top_p: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            max_prompt_tokens: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            max_completion_tokens: std::result::Result::Err("Nullable types not supported in RunObject".to_string())?,
            truncation_strategy: intermediate_rep.truncation_strategy.into_iter().next().ok_or_else(|| "truncation_strategy missing in RunObject".to_string())?,
            tool_choice: intermediate_rep.tool_choice.into_iter().next().ok_or_else(|| "tool_choice missing in RunObject".to_string())?,
            parallel_tool_calls: intermediate_rep.parallel_tool_calls.into_iter().next().ok_or_else(|| "parallel_tool_calls missing in RunObject".to_string())?,
            response_format: intermediate_rep.response_format.into_iter().next().ok_or_else(|| "response_format missing in RunObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Details on why the run is incomplete. Will be `null` if the run is not incomplete.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunObjectIncompleteDetails {
    /// The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "reason")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,

}



impl RunObjectIncompleteDetails {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RunObjectIncompleteDetails {
        RunObjectIncompleteDetails {
 reason: None,
        }
    }
}

/// Converts the RunObjectIncompleteDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunObjectIncompleteDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.reason.as_ref().map(|reason| {
                [
                    "reason".to_string(),
                    reason.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunObjectIncompleteDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunObjectIncompleteDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub reason: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunObjectIncompleteDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "reason" => intermediate_rep.reason.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunObjectIncompleteDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunObjectIncompleteDetails {
            reason: intermediate_rep.reason.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunObjectIncompleteDetails> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunObjectIncompleteDetails>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunObjectIncompleteDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunObjectIncompleteDetails - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunObjectIncompleteDetails> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunObjectIncompleteDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunObjectIncompleteDetails - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The last error associated with this run. Will be `null` if there are no errors.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunObjectLastError {
    /// One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "code")]
          #[validate(custom(function = "check_xss_string"))]
    pub code: String,

    /// A human-readable description of the error.
    #[serde(rename = "message")]
          #[validate(custom(function = "check_xss_string"))]
    pub message: String,

}



impl RunObjectLastError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(code: String, message: String, ) -> RunObjectLastError {
        RunObjectLastError {
 code,
 message,
        }
    }
}

/// Converts the RunObjectLastError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunObjectLastError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("code".to_string()),
            Some(self.code.to_string()),


            Some("message".to_string()),
            Some(self.message.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunObjectLastError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunObjectLastError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<String>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunObjectLastError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunObjectLastError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunObjectLastError {
            code: intermediate_rep.code.into_iter().next().ok_or_else(|| "code missing in RunObjectLastError".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in RunObjectLastError".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunObjectLastError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunObjectLastError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunObjectLastError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunObjectLastError - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunObjectLastError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunObjectLastError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunObjectLastError - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Details on the action required to continue the run. Will be `null` if no action is required.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunObjectRequiredAction {
    /// For now, this is always `submit_tool_outputs`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "submit_tool_outputs")]
          #[validate(nested)]
    pub submit_tool_outputs: models::RunObjectRequiredActionSubmitToolOutputs,

}



impl RunObjectRequiredAction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, submit_tool_outputs: models::RunObjectRequiredActionSubmitToolOutputs, ) -> RunObjectRequiredAction {
        RunObjectRequiredAction {
 r_type,
 submit_tool_outputs,
        }
    }
}

/// Converts the RunObjectRequiredAction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunObjectRequiredAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping submit_tool_outputs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunObjectRequiredAction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunObjectRequiredAction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub submit_tool_outputs: Vec<models::RunObjectRequiredActionSubmitToolOutputs>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunObjectRequiredAction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "submit_tool_outputs" => intermediate_rep.submit_tool_outputs.push(<models::RunObjectRequiredActionSubmitToolOutputs as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunObjectRequiredAction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunObjectRequiredAction {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunObjectRequiredAction".to_string())?,
            submit_tool_outputs: intermediate_rep.submit_tool_outputs.into_iter().next().ok_or_else(|| "submit_tool_outputs missing in RunObjectRequiredAction".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunObjectRequiredAction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunObjectRequiredAction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunObjectRequiredAction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunObjectRequiredAction - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunObjectRequiredAction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunObjectRequiredAction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunObjectRequiredAction - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Details on the tool outputs needed for this run to continue.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunObjectRequiredActionSubmitToolOutputs {
    /// A list of the relevant tool calls.
    #[serde(rename = "tool_calls")]
          #[validate(nested)]
    pub tool_calls: Vec<models::RunToolCallObject>,

}



impl RunObjectRequiredActionSubmitToolOutputs {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(tool_calls: Vec<models::RunToolCallObject>, ) -> RunObjectRequiredActionSubmitToolOutputs {
        RunObjectRequiredActionSubmitToolOutputs {
 tool_calls,
        }
    }
}

/// Converts the RunObjectRequiredActionSubmitToolOutputs value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunObjectRequiredActionSubmitToolOutputs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping tool_calls in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunObjectRequiredActionSubmitToolOutputs value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunObjectRequiredActionSubmitToolOutputs {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tool_calls: Vec<Vec<models::RunToolCallObject>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunObjectRequiredActionSubmitToolOutputs".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "tool_calls" => return std::result::Result::Err("Parsing a container in this style is not supported in RunObjectRequiredActionSubmitToolOutputs".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunObjectRequiredActionSubmitToolOutputs".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunObjectRequiredActionSubmitToolOutputs {
            tool_calls: intermediate_rep.tool_calls.into_iter().next().ok_or_else(|| "tool_calls missing in RunObjectRequiredActionSubmitToolOutputs".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunObjectRequiredActionSubmitToolOutputs> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunObjectRequiredActionSubmitToolOutputs>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunObjectRequiredActionSubmitToolOutputs>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunObjectRequiredActionSubmitToolOutputs - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunObjectRequiredActionSubmitToolOutputs> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunObjectRequiredActionSubmitToolOutputs as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunObjectRequiredActionSubmitToolOutputs - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepCompletionUsage {
    /// Number of completion tokens used over the course of the run step.
    #[serde(rename = "completion_tokens")]
    pub completion_tokens: i32,

    /// Number of prompt tokens used over the course of the run step.
    #[serde(rename = "prompt_tokens")]
    pub prompt_tokens: i32,

    /// Total number of tokens used (prompt + completion).
    #[serde(rename = "total_tokens")]
    pub total_tokens: i32,

}



impl RunStepCompletionUsage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(completion_tokens: i32, prompt_tokens: i32, total_tokens: i32, ) -> RunStepCompletionUsage {
        RunStepCompletionUsage {
 completion_tokens,
 prompt_tokens,
 total_tokens,
        }
    }
}

/// Converts the RunStepCompletionUsage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepCompletionUsage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("completion_tokens".to_string()),
            Some(self.completion_tokens.to_string()),


            Some("prompt_tokens".to_string()),
            Some(self.prompt_tokens.to_string()),


            Some("total_tokens".to_string()),
            Some(self.total_tokens.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepCompletionUsage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepCompletionUsage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub completion_tokens: Vec<i32>,
            pub prompt_tokens: Vec<i32>,
            pub total_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepCompletionUsage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "completion_tokens" => intermediate_rep.completion_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "prompt_tokens" => intermediate_rep.prompt_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total_tokens" => intermediate_rep.total_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepCompletionUsage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepCompletionUsage {
            completion_tokens: intermediate_rep.completion_tokens.into_iter().next().ok_or_else(|| "completion_tokens missing in RunStepCompletionUsage".to_string())?,
            prompt_tokens: intermediate_rep.prompt_tokens.into_iter().next().ok_or_else(|| "prompt_tokens missing in RunStepCompletionUsage".to_string())?,
            total_tokens: intermediate_rep.total_tokens.into_iter().next().ok_or_else(|| "total_tokens missing in RunStepCompletionUsage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepCompletionUsage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepCompletionUsage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepCompletionUsage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepCompletionUsage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepCompletionUsage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepCompletionUsage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepCompletionUsage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Represents a run step delta i.e. any changed fields on a run step during streaming. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaObject {
    /// The identifier of the run step, which can be referenced in API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The object type, which is always `thread.run.step.delta`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "delta")]
          #[validate(nested)]
    pub delta: models::RunStepDeltaObjectDelta,

}



impl RunStepDeltaObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, delta: models::RunStepDeltaObjectDelta, ) -> RunStepDeltaObject {
        RunStepDeltaObject {
 id,
 object,
 delta,
        }
    }
}

/// Converts the RunStepDeltaObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping delta in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub delta: Vec<models::RunStepDeltaObjectDelta>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "delta" => intermediate_rep.delta.push(<models::RunStepDeltaObjectDelta as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in RunStepDeltaObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in RunStepDeltaObject".to_string())?,
            delta: intermediate_rep.delta.into_iter().next().ok_or_else(|| "delta missing in RunStepDeltaObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDeltaObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDeltaObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The delta containing the fields that have changed on the run step.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaObjectDelta {
    #[serde(rename = "step_details")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub step_details: Option<models::RunStepDeltaObjectDeltaStepDetails>,

}



impl RunStepDeltaObjectDelta {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RunStepDeltaObjectDelta {
        RunStepDeltaObjectDelta {
 step_details: None,
        }
    }
}

/// Converts the RunStepDeltaObjectDelta value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaObjectDelta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping step_details in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaObjectDelta value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaObjectDelta {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub step_details: Vec<models::RunStepDeltaObjectDeltaStepDetails>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaObjectDelta".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "step_details" => intermediate_rep.step_details.push(<models::RunStepDeltaObjectDeltaStepDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaObjectDelta".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaObjectDelta {
            step_details: intermediate_rep.step_details.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaObjectDelta> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaObjectDelta>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaObjectDelta>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDeltaObjectDelta - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaObjectDelta> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaObjectDelta as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDeltaObjectDelta - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details of the run step.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum RunStepDeltaObjectDeltaStepDetails {
    RunStepDeltaStepDetailsMessageCreationObject(models::RunStepDeltaStepDetailsMessageCreationObject),
    RunStepDeltaStepDetailsToolCallsObject(models::RunStepDeltaStepDetailsToolCallsObject),
}

impl validator::Validate for RunStepDeltaObjectDeltaStepDetails
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::RunStepDeltaStepDetailsMessageCreationObject(v) => v.validate(),
            Self::RunStepDeltaStepDetailsToolCallsObject(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaObjectDeltaStepDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaObjectDeltaStepDetails {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::RunStepDeltaStepDetailsMessageCreationObject> for RunStepDeltaObjectDeltaStepDetails {
    fn from(value: models::RunStepDeltaStepDetailsMessageCreationObject) -> Self {
        Self::RunStepDeltaStepDetailsMessageCreationObject(value)
    }
}
impl From<models::RunStepDeltaStepDetailsToolCallsObject> for RunStepDeltaObjectDeltaStepDetails {
    fn from(value: models::RunStepDeltaStepDetailsToolCallsObject) -> Self {
        Self::RunStepDeltaStepDetailsToolCallsObject(value)
    }
}





/// Details of the message creation by the run step.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsMessageCreationObject {
    /// Always `message_creation`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "message_creation")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message_creation: Option<models::RunStepDeltaStepDetailsMessageCreationObjectMessageCreation>,

}



impl RunStepDeltaStepDetailsMessageCreationObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> RunStepDeltaStepDetailsMessageCreationObject {
        RunStepDeltaStepDetailsMessageCreationObject {
 r_type,
 message_creation: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsMessageCreationObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsMessageCreationObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping message_creation in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsMessageCreationObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsMessageCreationObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub message_creation: Vec<models::RunStepDeltaStepDetailsMessageCreationObjectMessageCreation>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsMessageCreationObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message_creation" => intermediate_rep.message_creation.push(<models::RunStepDeltaStepDetailsMessageCreationObjectMessageCreation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsMessageCreationObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsMessageCreationObject {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunStepDeltaStepDetailsMessageCreationObject".to_string())?,
            message_creation: intermediate_rep.message_creation.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDeltaStepDetailsMessageCreationObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsMessageCreationObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDeltaStepDetailsMessageCreationObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
    /// The ID of the message that was created by this run step.
    #[serde(rename = "message_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message_id: Option<String>,

}



impl RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
        RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
 message_id: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsMessageCreationObjectMessageCreation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.message_id.as_ref().map(|message_id| {
                [
                    "message_id".to_string(),
                    message_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsMessageCreationObjectMessageCreation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub message_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsMessageCreationObjectMessageCreation".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "message_id" => intermediate_rep.message_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsMessageCreationObjectMessageCreation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
            message_id: intermediate_rep.message_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObjectMessageCreation> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObjectMessageCreation>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObjectMessageCreation>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDeltaStepDetailsMessageCreationObjectMessageCreation - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsMessageCreationObjectMessageCreation> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsMessageCreationObjectMessageCreation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDeltaStepDetailsMessageCreationObjectMessageCreation - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Details of the Code Interpreter tool call the run step was involved in.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsCodeObject {
    /// The index of the tool call in the tool calls array.
    #[serde(rename = "index")]
    pub index: i32,

    /// The ID of the tool call.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "code_interpreter")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_interpreter: Option<models::RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>,

}



impl RunStepDeltaStepDetailsToolCallsCodeObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r_type: String, ) -> RunStepDeltaStepDetailsToolCallsCodeObject {
        RunStepDeltaStepDetailsToolCallsCodeObject {
 index,
 id: None,
 r_type,
 code_interpreter: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsCodeObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsCodeObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping code_interpreter in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsCodeObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsCodeObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub id: Vec<String>,
            pub r_type: Vec<String>,
            pub code_interpreter: Vec<models::RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsCodeObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "code_interpreter" => intermediate_rep.code_interpreter.push(<models::RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsCodeObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsCodeObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in RunStepDeltaStepDetailsToolCallsCodeObject".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunStepDeltaStepDetailsToolCallsCodeObject".to_string())?,
            code_interpreter: intermediate_rep.code_interpreter.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDeltaStepDetailsToolCallsCodeObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsCodeObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDeltaStepDetailsToolCallsCodeObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The Code Interpreter tool call definition.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
    /// The input to the Code Interpreter tool call.
    #[serde(rename = "input")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub input: Option<String>,

    /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
    #[serde(rename = "outputs")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub outputs: Option<Vec<models::RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>>,

}



impl RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
        RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
 input: None,
 outputs: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.input.as_ref().map(|input| {
                [
                    "input".to_string(),
                    input.to_string(),
                ].join(",")
            }),

            // Skipping outputs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub input: Vec<String>,
            pub outputs: Vec<Vec<models::RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "input" => intermediate_rep.input.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "outputs" => return std::result::Result::Err("Parsing a container in this style is not supported in RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
            input: intermediate_rep.input.into_iter().next(),
            outputs: intermediate_rep.outputs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner {
    RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject(models::RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject),
    RunStepDeltaStepDetailsToolCallsCodeOutputImageObject(models::RunStepDeltaStepDetailsToolCallsCodeOutputImageObject),
}

impl validator::Validate for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject(v) => v.validate(),
            Self::RunStepDeltaStepDetailsToolCallsCodeOutputImageObject(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject> for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner {
    fn from(value: models::RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject) -> Self {
        Self::RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject(value)
    }
}
impl From<models::RunStepDeltaStepDetailsToolCallsCodeOutputImageObject> for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner {
    fn from(value: models::RunStepDeltaStepDetailsToolCallsCodeOutputImageObject) -> Self {
        Self::RunStepDeltaStepDetailsToolCallsCodeOutputImageObject(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    /// The index of the output in the outputs array.
    #[serde(rename = "index")]
    pub index: i32,

    /// Always `image`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "image")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<models::RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage>,

}



impl RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r_type: String, ) -> RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
        RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
 index,
 r_type,
 image: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping image in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsCodeOutputImageObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub r_type: Vec<String>,
            pub image: Vec<models::RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsCodeOutputImageObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image" => intermediate_rep.image.push(<models::RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsCodeOutputImageObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in RunStepDeltaStepDetailsToolCallsCodeOutputImageObject".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunStepDeltaStepDetailsToolCallsCodeOutputImageObject".to_string())?,
            image: intermediate_rep.image.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDeltaStepDetailsToolCallsCodeOutputImageObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsCodeOutputImageObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDeltaStepDetailsToolCallsCodeOutputImageObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
    /// The [file](/docs/api-reference/files) ID of the image.
    #[serde(rename = "file_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_id: Option<String>,

}



impl RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
        RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
 file_id: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.file_id.as_ref().map(|file_id| {
                [
                    "file_id".to_string(),
                    file_id.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
            file_id: intermediate_rep.file_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Text output from the Code Interpreter tool call as part of a run step.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    /// The index of the output in the outputs array.
    #[serde(rename = "index")]
    pub index: i32,

    /// Always `logs`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The text output from the Code Interpreter tool call.
    #[serde(rename = "logs")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub logs: Option<String>,

}



impl RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r_type: String, ) -> RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
        RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
 index,
 r_type,
 logs: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            self.logs.as_ref().map(|logs| {
                [
                    "logs".to_string(),
                    logs.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub r_type: Vec<String>,
            pub logs: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "logs" => intermediate_rep.logs.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject".to_string())?,
            logs: intermediate_rep.logs.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsFileSearchObject {
    /// The index of the tool call in the tool calls array.
    #[serde(rename = "index")]
    pub index: i32,

    /// The ID of the tool call object.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// The type of tool call. This is always going to be `file_search` for this type of tool call.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// For now, this is always going to be an empty object.
    #[serde(rename = "file_search")]
    pub file_search: crate::types::Object,

}



impl RunStepDeltaStepDetailsToolCallsFileSearchObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r_type: String, file_search: crate::types::Object, ) -> RunStepDeltaStepDetailsToolCallsFileSearchObject {
        RunStepDeltaStepDetailsToolCallsFileSearchObject {
 index,
 id: None,
 r_type,
 file_search,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsFileSearchObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsFileSearchObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping file_search in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsFileSearchObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsFileSearchObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub id: Vec<String>,
            pub r_type: Vec<String>,
            pub file_search: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsFileSearchObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_search" => intermediate_rep.file_search.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsFileSearchObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsFileSearchObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in RunStepDeltaStepDetailsToolCallsFileSearchObject".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunStepDeltaStepDetailsToolCallsFileSearchObject".to_string())?,
            file_search: intermediate_rep.file_search.into_iter().next().ok_or_else(|| "file_search missing in RunStepDeltaStepDetailsToolCallsFileSearchObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFileSearchObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFileSearchObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFileSearchObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDeltaStepDetailsToolCallsFileSearchObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFileSearchObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsFileSearchObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDeltaStepDetailsToolCallsFileSearchObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsFunctionObject {
    /// The index of the tool call in the tool calls array.
    #[serde(rename = "index")]
    pub index: i32,

    /// The ID of the tool call object.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// The type of tool call. This is always going to be `function` for this type of tool call.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "function")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub function: Option<models::RunStepDeltaStepDetailsToolCallsFunctionObjectFunction>,

}



impl RunStepDeltaStepDetailsToolCallsFunctionObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(index: i32, r_type: String, ) -> RunStepDeltaStepDetailsToolCallsFunctionObject {
        RunStepDeltaStepDetailsToolCallsFunctionObject {
 index,
 id: None,
 r_type,
 function: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsFunctionObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsFunctionObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("index".to_string()),
            Some(self.index.to_string()),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsFunctionObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsFunctionObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub index: Vec<i32>,
            pub id: Vec<String>,
            pub r_type: Vec<String>,
            pub function: Vec<models::RunStepDeltaStepDetailsToolCallsFunctionObjectFunction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsFunctionObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "index" => intermediate_rep.index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::RunStepDeltaStepDetailsToolCallsFunctionObjectFunction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsFunctionObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsFunctionObject {
            index: intermediate_rep.index.into_iter().next().ok_or_else(|| "index missing in RunStepDeltaStepDetailsToolCallsFunctionObject".to_string())?,
            id: intermediate_rep.id.into_iter().next(),
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunStepDeltaStepDetailsToolCallsFunctionObject".to_string())?,
            function: intermediate_rep.function.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDeltaStepDetailsToolCallsFunctionObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsFunctionObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDeltaStepDetailsToolCallsFunctionObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The definition of the function that was called.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
    /// The name of the function.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// The arguments passed to the function.
    #[serde(rename = "arguments")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub arguments: Option<String>,

    /// The output of the function. This will be `null` if the outputs have not been [submitted](/docs/api-reference/runs/submitToolOutputs) yet.
    #[serde(rename = "output")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output: Option<Nullable<String>>,

}



impl RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
        RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
 name: None,
 arguments: None,
 output: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsFunctionObjectFunction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.arguments.as_ref().map(|arguments| {
                [
                    "arguments".to_string(),
                    arguments.to_string(),
                ].join(",")
            }),


            self.output.as_ref().map(|output| {
                [
                    "output".to_string(),
                    output.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsFunctionObjectFunction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub arguments: Vec<String>,
            pub output: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsFunctionObjectFunction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "output" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepDeltaStepDetailsToolCallsFunctionObjectFunction".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsFunctionObjectFunction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
            name: intermediate_rep.name.into_iter().next(),
            arguments: intermediate_rep.arguments.into_iter().next(),
            output: std::result::Result::Err("Nullable types not supported in RunStepDeltaStepDetailsToolCallsFunctionObjectFunction".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObjectFunction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObjectFunction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObjectFunction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDeltaStepDetailsToolCallsFunctionObjectFunction - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsFunctionObjectFunction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsFunctionObjectFunction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDeltaStepDetailsToolCallsFunctionObjectFunction - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Details of the tool call.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDeltaStepDetailsToolCallsObject {
    /// Always `tool_calls`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`. 
    #[serde(rename = "tool_calls")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_calls: Option<Vec<models::RunStepDeltaStepDetailsToolCallsObjectToolCallsInner>>,

}



impl RunStepDeltaStepDetailsToolCallsObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> RunStepDeltaStepDetailsToolCallsObject {
        RunStepDeltaStepDetailsToolCallsObject {
 r_type,
 tool_calls: None,
        }
    }
}

/// Converts the RunStepDeltaStepDetailsToolCallsObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDeltaStepDetailsToolCallsObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping tool_calls in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub tool_calls: Vec<Vec<models::RunStepDeltaStepDetailsToolCallsObjectToolCallsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDeltaStepDetailsToolCallsObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tool_calls" => return std::result::Result::Err("Parsing a container in this style is not supported in RunStepDeltaStepDetailsToolCallsObject".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDeltaStepDetailsToolCallsObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDeltaStepDetailsToolCallsObject {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunStepDeltaStepDetailsToolCallsObject".to_string())?,
            tool_calls: intermediate_rep.tool_calls.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDeltaStepDetailsToolCallsObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDeltaStepDetailsToolCallsObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDeltaStepDetailsToolCallsObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDeltaStepDetailsToolCallsObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum RunStepDeltaStepDetailsToolCallsObjectToolCallsInner {
    RunStepDeltaStepDetailsToolCallsCodeObject(models::RunStepDeltaStepDetailsToolCallsCodeObject),
    RunStepDeltaStepDetailsToolCallsFileSearchObject(models::RunStepDeltaStepDetailsToolCallsFileSearchObject),
    RunStepDeltaStepDetailsToolCallsFunctionObject(models::RunStepDeltaStepDetailsToolCallsFunctionObject),
}

impl validator::Validate for RunStepDeltaStepDetailsToolCallsObjectToolCallsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::RunStepDeltaStepDetailsToolCallsCodeObject(v) => v.validate(),
            Self::RunStepDeltaStepDetailsToolCallsFileSearchObject(v) => v.validate(),
            Self::RunStepDeltaStepDetailsToolCallsFunctionObject(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDeltaStepDetailsToolCallsObjectToolCallsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDeltaStepDetailsToolCallsObjectToolCallsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::RunStepDeltaStepDetailsToolCallsCodeObject> for RunStepDeltaStepDetailsToolCallsObjectToolCallsInner {
    fn from(value: models::RunStepDeltaStepDetailsToolCallsCodeObject) -> Self {
        Self::RunStepDeltaStepDetailsToolCallsCodeObject(value)
    }
}
impl From<models::RunStepDeltaStepDetailsToolCallsFileSearchObject> for RunStepDeltaStepDetailsToolCallsObjectToolCallsInner {
    fn from(value: models::RunStepDeltaStepDetailsToolCallsFileSearchObject) -> Self {
        Self::RunStepDeltaStepDetailsToolCallsFileSearchObject(value)
    }
}
impl From<models::RunStepDeltaStepDetailsToolCallsFunctionObject> for RunStepDeltaStepDetailsToolCallsObjectToolCallsInner {
    fn from(value: models::RunStepDeltaStepDetailsToolCallsFunctionObject) -> Self {
        Self::RunStepDeltaStepDetailsToolCallsFunctionObject(value)
    }
}





/// Details of the message creation by the run step.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsMessageCreationObject {
    /// Always `message_creation`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "message_creation")]
          #[validate(nested)]
    pub message_creation: models::RunStepDetailsMessageCreationObjectMessageCreation,

}



impl RunStepDetailsMessageCreationObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, message_creation: models::RunStepDetailsMessageCreationObjectMessageCreation, ) -> RunStepDetailsMessageCreationObject {
        RunStepDetailsMessageCreationObject {
 r_type,
 message_creation,
        }
    }
}

/// Converts the RunStepDetailsMessageCreationObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsMessageCreationObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping message_creation in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsMessageCreationObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsMessageCreationObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub message_creation: Vec<models::RunStepDetailsMessageCreationObjectMessageCreation>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsMessageCreationObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message_creation" => intermediate_rep.message_creation.push(<models::RunStepDetailsMessageCreationObjectMessageCreation as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsMessageCreationObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsMessageCreationObject {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunStepDetailsMessageCreationObject".to_string())?,
            message_creation: intermediate_rep.message_creation.into_iter().next().ok_or_else(|| "message_creation missing in RunStepDetailsMessageCreationObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsMessageCreationObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsMessageCreationObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsMessageCreationObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDetailsMessageCreationObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsMessageCreationObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsMessageCreationObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDetailsMessageCreationObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsMessageCreationObjectMessageCreation {
    /// The ID of the message that was created by this run step.
    #[serde(rename = "message_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub message_id: String,

}



impl RunStepDetailsMessageCreationObjectMessageCreation {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(message_id: String, ) -> RunStepDetailsMessageCreationObjectMessageCreation {
        RunStepDetailsMessageCreationObjectMessageCreation {
 message_id,
        }
    }
}

/// Converts the RunStepDetailsMessageCreationObjectMessageCreation value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsMessageCreationObjectMessageCreation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("message_id".to_string()),
            Some(self.message_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsMessageCreationObjectMessageCreation value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsMessageCreationObjectMessageCreation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub message_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsMessageCreationObjectMessageCreation".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "message_id" => intermediate_rep.message_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsMessageCreationObjectMessageCreation".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsMessageCreationObjectMessageCreation {
            message_id: intermediate_rep.message_id.into_iter().next().ok_or_else(|| "message_id missing in RunStepDetailsMessageCreationObjectMessageCreation".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsMessageCreationObjectMessageCreation> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsMessageCreationObjectMessageCreation>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsMessageCreationObjectMessageCreation>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDetailsMessageCreationObjectMessageCreation - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsMessageCreationObjectMessageCreation> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsMessageCreationObjectMessageCreation as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDetailsMessageCreationObjectMessageCreation - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Details of the Code Interpreter tool call the run step was involved in.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsCodeObject {
    /// The ID of the tool call.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "code_interpreter")]
          #[validate(nested)]
    pub code_interpreter: models::RunStepDetailsToolCallsCodeObjectCodeInterpreter,

}



impl RunStepDetailsToolCallsCodeObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, r_type: String, code_interpreter: models::RunStepDetailsToolCallsCodeObjectCodeInterpreter, ) -> RunStepDetailsToolCallsCodeObject {
        RunStepDetailsToolCallsCodeObject {
 id,
 r_type,
 code_interpreter,
        }
    }
}

/// Converts the RunStepDetailsToolCallsCodeObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsCodeObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping code_interpreter in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsCodeObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsCodeObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r_type: Vec<String>,
            pub code_interpreter: Vec<models::RunStepDetailsToolCallsCodeObjectCodeInterpreter>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsCodeObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "code_interpreter" => intermediate_rep.code_interpreter.push(<models::RunStepDetailsToolCallsCodeObjectCodeInterpreter as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsCodeObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsCodeObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in RunStepDetailsToolCallsCodeObject".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunStepDetailsToolCallsCodeObject".to_string())?,
            code_interpreter: intermediate_rep.code_interpreter.into_iter().next().ok_or_else(|| "code_interpreter missing in RunStepDetailsToolCallsCodeObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsCodeObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsCodeObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsCodeObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDetailsToolCallsCodeObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsCodeObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsCodeObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDetailsToolCallsCodeObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The Code Interpreter tool call definition.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsCodeObjectCodeInterpreter {
    /// The input to the Code Interpreter tool call.
    #[serde(rename = "input")]
          #[validate(custom(function = "check_xss_string"))]
    pub input: String,

    /// The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
    #[serde(rename = "outputs")]
          #[validate(nested)]
    pub outputs: Vec<models::RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>,

}



impl RunStepDetailsToolCallsCodeObjectCodeInterpreter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(input: String, outputs: Vec<models::RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>, ) -> RunStepDetailsToolCallsCodeObjectCodeInterpreter {
        RunStepDetailsToolCallsCodeObjectCodeInterpreter {
 input,
 outputs,
        }
    }
}

/// Converts the RunStepDetailsToolCallsCodeObjectCodeInterpreter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsCodeObjectCodeInterpreter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("input".to_string()),
            Some(self.input.to_string()),

            // Skipping outputs in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsCodeObjectCodeInterpreter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsCodeObjectCodeInterpreter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub input: Vec<String>,
            pub outputs: Vec<Vec<models::RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsCodeObjectCodeInterpreter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "input" => intermediate_rep.input.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "outputs" => return std::result::Result::Err("Parsing a container in this style is not supported in RunStepDetailsToolCallsCodeObjectCodeInterpreter".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsCodeObjectCodeInterpreter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsCodeObjectCodeInterpreter {
            input: intermediate_rep.input.into_iter().next().ok_or_else(|| "input missing in RunStepDetailsToolCallsCodeObjectCodeInterpreter".to_string())?,
            outputs: intermediate_rep.outputs.into_iter().next().ok_or_else(|| "outputs missing in RunStepDetailsToolCallsCodeObjectCodeInterpreter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsCodeObjectCodeInterpreter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsCodeObjectCodeInterpreter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsCodeObjectCodeInterpreter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDetailsToolCallsCodeObjectCodeInterpreter - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsCodeObjectCodeInterpreter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsCodeObjectCodeInterpreter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDetailsToolCallsCodeObjectCodeInterpreter - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner {
    RunStepDetailsToolCallsCodeOutputLogsObject(models::RunStepDetailsToolCallsCodeOutputLogsObject),
    RunStepDetailsToolCallsCodeOutputImageObject(models::RunStepDetailsToolCallsCodeOutputImageObject),
}

impl validator::Validate for RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::RunStepDetailsToolCallsCodeOutputLogsObject(v) => v.validate(),
            Self::RunStepDetailsToolCallsCodeOutputImageObject(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::RunStepDetailsToolCallsCodeOutputLogsObject> for RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner {
    fn from(value: models::RunStepDetailsToolCallsCodeOutputLogsObject) -> Self {
        Self::RunStepDetailsToolCallsCodeOutputLogsObject(value)
    }
}
impl From<models::RunStepDetailsToolCallsCodeOutputImageObject> for RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner {
    fn from(value: models::RunStepDetailsToolCallsCodeOutputImageObject) -> Self {
        Self::RunStepDetailsToolCallsCodeOutputImageObject(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsCodeOutputImageObject {
    /// Always `image`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "image")]
          #[validate(nested)]
    pub image: models::RunStepDetailsToolCallsCodeOutputImageObjectImage,

}



impl RunStepDetailsToolCallsCodeOutputImageObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, image: models::RunStepDetailsToolCallsCodeOutputImageObjectImage, ) -> RunStepDetailsToolCallsCodeOutputImageObject {
        RunStepDetailsToolCallsCodeOutputImageObject {
 r_type,
 image,
        }
    }
}

/// Converts the RunStepDetailsToolCallsCodeOutputImageObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsCodeOutputImageObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping image in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsCodeOutputImageObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsCodeOutputImageObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub image: Vec<models::RunStepDetailsToolCallsCodeOutputImageObjectImage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsCodeOutputImageObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "image" => intermediate_rep.image.push(<models::RunStepDetailsToolCallsCodeOutputImageObjectImage as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsCodeOutputImageObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsCodeOutputImageObject {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunStepDetailsToolCallsCodeOutputImageObject".to_string())?,
            image: intermediate_rep.image.into_iter().next().ok_or_else(|| "image missing in RunStepDetailsToolCallsCodeOutputImageObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDetailsToolCallsCodeOutputImageObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsCodeOutputImageObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDetailsToolCallsCodeOutputImageObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsCodeOutputImageObjectImage {
    /// The [file](/docs/api-reference/files) ID of the image.
    #[serde(rename = "file_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub file_id: String,

}



impl RunStepDetailsToolCallsCodeOutputImageObjectImage {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(file_id: String, ) -> RunStepDetailsToolCallsCodeOutputImageObjectImage {
        RunStepDetailsToolCallsCodeOutputImageObjectImage {
 file_id,
        }
    }
}

/// Converts the RunStepDetailsToolCallsCodeOutputImageObjectImage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsCodeOutputImageObjectImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("file_id".to_string()),
            Some(self.file_id.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsCodeOutputImageObjectImage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsCodeOutputImageObjectImage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsCodeOutputImageObjectImage".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsCodeOutputImageObjectImage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsCodeOutputImageObjectImage {
            file_id: intermediate_rep.file_id.into_iter().next().ok_or_else(|| "file_id missing in RunStepDetailsToolCallsCodeOutputImageObjectImage".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObjectImage> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObjectImage>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObjectImage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDetailsToolCallsCodeOutputImageObjectImage - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputImageObjectImage> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsCodeOutputImageObjectImage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDetailsToolCallsCodeOutputImageObjectImage - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Text output from the Code Interpreter tool call as part of a run step.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsCodeOutputLogsObject {
    /// Always `logs`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The text output from the Code Interpreter tool call.
    #[serde(rename = "logs")]
          #[validate(custom(function = "check_xss_string"))]
    pub logs: String,

}



impl RunStepDetailsToolCallsCodeOutputLogsObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, logs: String, ) -> RunStepDetailsToolCallsCodeOutputLogsObject {
        RunStepDetailsToolCallsCodeOutputLogsObject {
 r_type,
 logs,
        }
    }
}

/// Converts the RunStepDetailsToolCallsCodeOutputLogsObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsCodeOutputLogsObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("logs".to_string()),
            Some(self.logs.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsCodeOutputLogsObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsCodeOutputLogsObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub logs: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsCodeOutputLogsObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "logs" => intermediate_rep.logs.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsCodeOutputLogsObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsCodeOutputLogsObject {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunStepDetailsToolCallsCodeOutputLogsObject".to_string())?,
            logs: intermediate_rep.logs.into_iter().next().ok_or_else(|| "logs missing in RunStepDetailsToolCallsCodeOutputLogsObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputLogsObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputLogsObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputLogsObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDetailsToolCallsCodeOutputLogsObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsCodeOutputLogsObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsCodeOutputLogsObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDetailsToolCallsCodeOutputLogsObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsFileSearchObject {
    /// The ID of the tool call object.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The type of tool call. This is always going to be `file_search` for this type of tool call.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "file_search")]
          #[validate(nested)]
    pub file_search: models::RunStepDetailsToolCallsFileSearchObjectFileSearch,

}



impl RunStepDetailsToolCallsFileSearchObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, r_type: String, file_search: models::RunStepDetailsToolCallsFileSearchObjectFileSearch, ) -> RunStepDetailsToolCallsFileSearchObject {
        RunStepDetailsToolCallsFileSearchObject {
 id,
 r_type,
 file_search,
        }
    }
}

/// Converts the RunStepDetailsToolCallsFileSearchObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsFileSearchObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping file_search in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsFileSearchObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsFileSearchObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r_type: Vec<String>,
            pub file_search: Vec<models::RunStepDetailsToolCallsFileSearchObjectFileSearch>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsFileSearchObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_search" => intermediate_rep.file_search.push(<models::RunStepDetailsToolCallsFileSearchObjectFileSearch as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsFileSearchObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsFileSearchObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in RunStepDetailsToolCallsFileSearchObject".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunStepDetailsToolCallsFileSearchObject".to_string())?,
            file_search: intermediate_rep.file_search.into_iter().next().ok_or_else(|| "file_search missing in RunStepDetailsToolCallsFileSearchObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDetailsToolCallsFileSearchObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsFileSearchObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDetailsToolCallsFileSearchObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// For now, this is always going to be an empty object.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsFileSearchObjectFileSearch {
    #[serde(rename = "ranking_options")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ranking_options: Option<models::RunStepDetailsToolCallsFileSearchRankingOptionsObject>,

    /// The results of the file search.
    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::RunStepDetailsToolCallsFileSearchResultObject>>,

}



impl RunStepDetailsToolCallsFileSearchObjectFileSearch {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RunStepDetailsToolCallsFileSearchObjectFileSearch {
        RunStepDetailsToolCallsFileSearchObjectFileSearch {
 ranking_options: None,
 results: None,
        }
    }
}

/// Converts the RunStepDetailsToolCallsFileSearchObjectFileSearch value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsFileSearchObjectFileSearch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping ranking_options in query parameter serialization

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsFileSearchObjectFileSearch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsFileSearchObjectFileSearch {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ranking_options: Vec<models::RunStepDetailsToolCallsFileSearchRankingOptionsObject>,
            pub results: Vec<Vec<models::RunStepDetailsToolCallsFileSearchResultObject>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsFileSearchObjectFileSearch".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ranking_options" => intermediate_rep.ranking_options.push(<models::RunStepDetailsToolCallsFileSearchRankingOptionsObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in RunStepDetailsToolCallsFileSearchObjectFileSearch".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsFileSearchObjectFileSearch".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsFileSearchObjectFileSearch {
            ranking_options: intermediate_rep.ranking_options.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchObjectFileSearch> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchObjectFileSearch>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchObjectFileSearch>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDetailsToolCallsFileSearchObjectFileSearch - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchObjectFileSearch> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsFileSearchObjectFileSearch as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDetailsToolCallsFileSearchObjectFileSearch - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The ranking options for the file search.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsFileSearchRankingOptionsObject {
    /// The ranker used for the file search.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "ranker")]
          #[validate(custom(function = "check_xss_string"))]
    pub ranker: String,

    /// The score threshold for the file search. All values must be a floating point number between 0 and 1.
    #[serde(rename = "score_threshold")]
    #[validate(
            range(min = 0f64, max = 1f64),
    )]
    pub score_threshold: f64,

}



impl RunStepDetailsToolCallsFileSearchRankingOptionsObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(ranker: String, score_threshold: f64, ) -> RunStepDetailsToolCallsFileSearchRankingOptionsObject {
        RunStepDetailsToolCallsFileSearchRankingOptionsObject {
 ranker,
 score_threshold,
        }
    }
}

/// Converts the RunStepDetailsToolCallsFileSearchRankingOptionsObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsFileSearchRankingOptionsObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("ranker".to_string()),
            Some(self.ranker.to_string()),


            Some("score_threshold".to_string()),
            Some(self.score_threshold.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsFileSearchRankingOptionsObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsFileSearchRankingOptionsObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ranker: Vec<String>,
            pub score_threshold: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsFileSearchRankingOptionsObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ranker" => intermediate_rep.ranker.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "score_threshold" => intermediate_rep.score_threshold.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsFileSearchRankingOptionsObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsFileSearchRankingOptionsObject {
            ranker: intermediate_rep.ranker.into_iter().next().ok_or_else(|| "ranker missing in RunStepDetailsToolCallsFileSearchRankingOptionsObject".to_string())?,
            score_threshold: intermediate_rep.score_threshold.into_iter().next().ok_or_else(|| "score_threshold missing in RunStepDetailsToolCallsFileSearchRankingOptionsObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchRankingOptionsObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchRankingOptionsObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchRankingOptionsObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDetailsToolCallsFileSearchRankingOptionsObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchRankingOptionsObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsFileSearchRankingOptionsObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDetailsToolCallsFileSearchRankingOptionsObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A result instance of the file search.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsFileSearchResultObject {
    /// The ID of the file that result was found in.
    #[serde(rename = "file_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub file_id: String,

    /// The name of the file that result was found in.
    #[serde(rename = "file_name")]
          #[validate(custom(function = "check_xss_string"))]
    pub file_name: String,

    /// The score of the result. All values must be a floating point number between 0 and 1.
    #[serde(rename = "score")]
    #[validate(
            range(min = 0f64, max = 1f64),
    )]
    pub score: f64,

    /// The content of the result that was found. The content is only included if requested via the include query parameter.
    #[serde(rename = "content")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<Vec<models::RunStepDetailsToolCallsFileSearchResultObjectContentInner>>,

}



impl RunStepDetailsToolCallsFileSearchResultObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(file_id: String, file_name: String, score: f64, ) -> RunStepDetailsToolCallsFileSearchResultObject {
        RunStepDetailsToolCallsFileSearchResultObject {
 file_id,
 file_name,
 score,
 content: None,
        }
    }
}

/// Converts the RunStepDetailsToolCallsFileSearchResultObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsFileSearchResultObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("file_id".to_string()),
            Some(self.file_id.to_string()),


            Some("file_name".to_string()),
            Some(self.file_name.to_string()),


            Some("score".to_string()),
            Some(self.score.to_string()),

            // Skipping content in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsFileSearchResultObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsFileSearchResultObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub file_id: Vec<String>,
            pub file_name: Vec<String>,
            pub score: Vec<f64>,
            pub content: Vec<Vec<models::RunStepDetailsToolCallsFileSearchResultObjectContentInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsFileSearchResultObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "file_id" => intermediate_rep.file_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_name" => intermediate_rep.file_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "score" => intermediate_rep.score.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "content" => return std::result::Result::Err("Parsing a container in this style is not supported in RunStepDetailsToolCallsFileSearchResultObject".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsFileSearchResultObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsFileSearchResultObject {
            file_id: intermediate_rep.file_id.into_iter().next().ok_or_else(|| "file_id missing in RunStepDetailsToolCallsFileSearchResultObject".to_string())?,
            file_name: intermediate_rep.file_name.into_iter().next().ok_or_else(|| "file_name missing in RunStepDetailsToolCallsFileSearchResultObject".to_string())?,
            score: intermediate_rep.score.into_iter().next().ok_or_else(|| "score missing in RunStepDetailsToolCallsFileSearchResultObject".to_string())?,
            content: intermediate_rep.content.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchResultObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchResultObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchResultObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDetailsToolCallsFileSearchResultObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchResultObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsFileSearchResultObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDetailsToolCallsFileSearchResultObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsFileSearchResultObjectContentInner {
    /// The type of the content.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub r_type: Option<String>,

    /// The text content of the file.
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,

}



impl RunStepDetailsToolCallsFileSearchResultObjectContentInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> RunStepDetailsToolCallsFileSearchResultObjectContentInner {
        RunStepDetailsToolCallsFileSearchResultObjectContentInner {
 r_type: None,
 text: None,
        }
    }
}

/// Converts the RunStepDetailsToolCallsFileSearchResultObjectContentInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsFileSearchResultObjectContentInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.r_type.as_ref().map(|r_type| {
                [
                    "type".to_string(),
                    r_type.to_string(),
                ].join(",")
            }),


            self.text.as_ref().map(|text| {
                [
                    "text".to_string(),
                    text.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsFileSearchResultObjectContentInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsFileSearchResultObjectContentInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub text: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsFileSearchResultObjectContentInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsFileSearchResultObjectContentInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsFileSearchResultObjectContentInner {
            r_type: intermediate_rep.r_type.into_iter().next(),
            text: intermediate_rep.text.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchResultObjectContentInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchResultObjectContentInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchResultObjectContentInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDetailsToolCallsFileSearchResultObjectContentInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsFileSearchResultObjectContentInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsFileSearchResultObjectContentInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDetailsToolCallsFileSearchResultObjectContentInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsFunctionObject {
    /// The ID of the tool call object.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The type of tool call. This is always going to be `function` for this type of tool call.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "function")]
          #[validate(nested)]
    pub function: models::RunStepDetailsToolCallsFunctionObjectFunction,

}



impl RunStepDetailsToolCallsFunctionObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, r_type: String, function: models::RunStepDetailsToolCallsFunctionObjectFunction, ) -> RunStepDetailsToolCallsFunctionObject {
        RunStepDetailsToolCallsFunctionObject {
 id,
 r_type,
 function,
        }
    }
}

/// Converts the RunStepDetailsToolCallsFunctionObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsFunctionObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsFunctionObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsFunctionObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r_type: Vec<String>,
            pub function: Vec<models::RunStepDetailsToolCallsFunctionObjectFunction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsFunctionObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::RunStepDetailsToolCallsFunctionObjectFunction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsFunctionObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsFunctionObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in RunStepDetailsToolCallsFunctionObject".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunStepDetailsToolCallsFunctionObject".to_string())?,
            function: intermediate_rep.function.into_iter().next().ok_or_else(|| "function missing in RunStepDetailsToolCallsFunctionObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDetailsToolCallsFunctionObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsFunctionObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDetailsToolCallsFunctionObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The definition of the function that was called.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsFunctionObjectFunction {
    /// The name of the function.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    /// The arguments passed to the function.
    #[serde(rename = "arguments")]
          #[validate(custom(function = "check_xss_string"))]
    pub arguments: String,

    /// The output of the function. This will be `null` if the outputs have not been [submitted](/docs/api-reference/runs/submitToolOutputs) yet.
    #[serde(rename = "output")]
    pub output: Nullable<String>,

}



impl RunStepDetailsToolCallsFunctionObjectFunction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, arguments: String, output: Nullable<String>, ) -> RunStepDetailsToolCallsFunctionObjectFunction {
        RunStepDetailsToolCallsFunctionObjectFunction {
 name,
 arguments,
 output,
        }
    }
}

/// Converts the RunStepDetailsToolCallsFunctionObjectFunction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsFunctionObjectFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("arguments".to_string()),
            Some(self.arguments.to_string()),


            Some("output".to_string()),
            Some(self.output.as_ref().map_or("null".to_string(), |x| x.to_string())),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsFunctionObjectFunction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsFunctionObjectFunction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub arguments: Vec<String>,
            pub output: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsFunctionObjectFunction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "output" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepDetailsToolCallsFunctionObjectFunction".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsFunctionObjectFunction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsFunctionObjectFunction {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in RunStepDetailsToolCallsFunctionObjectFunction".to_string())?,
            arguments: intermediate_rep.arguments.into_iter().next().ok_or_else(|| "arguments missing in RunStepDetailsToolCallsFunctionObjectFunction".to_string())?,
            output: std::result::Result::Err("Nullable types not supported in RunStepDetailsToolCallsFunctionObjectFunction".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObjectFunction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObjectFunction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObjectFunction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDetailsToolCallsFunctionObjectFunction - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsFunctionObjectFunction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsFunctionObjectFunction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDetailsToolCallsFunctionObjectFunction - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Details of the tool call.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepDetailsToolCallsObject {
    /// Always `tool_calls`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`. 
    #[serde(rename = "tool_calls")]
          #[validate(nested)]
    pub tool_calls: Vec<models::RunStepDetailsToolCallsObjectToolCallsInner>,

}



impl RunStepDetailsToolCallsObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, tool_calls: Vec<models::RunStepDetailsToolCallsObjectToolCallsInner>, ) -> RunStepDetailsToolCallsObject {
        RunStepDetailsToolCallsObject {
 r_type,
 tool_calls,
        }
    }
}

/// Converts the RunStepDetailsToolCallsObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepDetailsToolCallsObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping tool_calls in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub tool_calls: Vec<Vec<models::RunStepDetailsToolCallsObjectToolCallsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepDetailsToolCallsObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tool_calls" => return std::result::Result::Err("Parsing a container in this style is not supported in RunStepDetailsToolCallsObject".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepDetailsToolCallsObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepDetailsToolCallsObject {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunStepDetailsToolCallsObject".to_string())?,
            tool_calls: intermediate_rep.tool_calls.into_iter().next().ok_or_else(|| "tool_calls missing in RunStepDetailsToolCallsObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepDetailsToolCallsObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepDetailsToolCallsObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepDetailsToolCallsObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepDetailsToolCallsObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepDetailsToolCallsObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepDetailsToolCallsObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepDetailsToolCallsObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum RunStepDetailsToolCallsObjectToolCallsInner {
    RunStepDetailsToolCallsCodeObject(models::RunStepDetailsToolCallsCodeObject),
    RunStepDetailsToolCallsFileSearchObject(models::RunStepDetailsToolCallsFileSearchObject),
    RunStepDetailsToolCallsFunctionObject(models::RunStepDetailsToolCallsFunctionObject),
}

impl validator::Validate for RunStepDetailsToolCallsObjectToolCallsInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::RunStepDetailsToolCallsCodeObject(v) => v.validate(),
            Self::RunStepDetailsToolCallsFileSearchObject(v) => v.validate(),
            Self::RunStepDetailsToolCallsFunctionObject(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepDetailsToolCallsObjectToolCallsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepDetailsToolCallsObjectToolCallsInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::RunStepDetailsToolCallsCodeObject> for RunStepDetailsToolCallsObjectToolCallsInner {
    fn from(value: models::RunStepDetailsToolCallsCodeObject) -> Self {
        Self::RunStepDetailsToolCallsCodeObject(value)
    }
}
impl From<models::RunStepDetailsToolCallsFileSearchObject> for RunStepDetailsToolCallsObjectToolCallsInner {
    fn from(value: models::RunStepDetailsToolCallsFileSearchObject) -> Self {
        Self::RunStepDetailsToolCallsFileSearchObject(value)
    }
}
impl From<models::RunStepDetailsToolCallsFunctionObject> for RunStepDetailsToolCallsObjectToolCallsInner {
    fn from(value: models::RunStepDetailsToolCallsFunctionObject) -> Self {
        Self::RunStepDetailsToolCallsFunctionObject(value)
    }
}





/// Represents a step in execution of a run. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepObject {
    /// The identifier of the run step, which can be referenced in API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The object type, which is always `thread.run.step`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The Unix timestamp (in seconds) for when the run step was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    /// The ID of the [assistant](/docs/api-reference/assistants) associated with the run step.
    #[serde(rename = "assistant_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub assistant_id: String,

    /// The ID of the [thread](/docs/api-reference/threads) that was run.
    #[serde(rename = "thread_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub thread_id: String,

    /// The ID of the [run](/docs/api-reference/runs) that this run step is a part of.
    #[serde(rename = "run_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub run_id: String,

    /// The type of run step, which can be either `message_creation` or `tool_calls`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
          #[validate(custom(function = "check_xss_string"))]
    pub status: String,

    #[serde(rename = "step_details")]
          #[validate(nested)]
    pub step_details: models::RunStepObjectStepDetails,

    #[serde(rename = "last_error")]
    pub last_error: Nullable<models::RunStepObjectLastError>,

    /// The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
    #[serde(rename = "expired_at")]
    pub expired_at: Nullable<i32>,

    /// The Unix timestamp (in seconds) for when the run step was cancelled.
    #[serde(rename = "cancelled_at")]
    pub cancelled_at: Nullable<i32>,

    /// The Unix timestamp (in seconds) for when the run step failed.
    #[serde(rename = "failed_at")]
    pub failed_at: Nullable<i32>,

    /// The Unix timestamp (in seconds) for when the run step completed.
    #[serde(rename = "completed_at")]
    pub completed_at: Nullable<i32>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    pub metadata: crate::types::Object,

    #[serde(rename = "usage")]
    pub usage: Nullable<models::RunStepCompletionUsage>,

}



impl RunStepObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, created_at: i32, assistant_id: String, thread_id: String, run_id: String, r_type: String, status: String, step_details: models::RunStepObjectStepDetails, last_error: Nullable<models::RunStepObjectLastError>, expired_at: Nullable<i32>, cancelled_at: Nullable<i32>, failed_at: Nullable<i32>, completed_at: Nullable<i32>, metadata: crate::types::Object, usage: Nullable<models::RunStepCompletionUsage>, ) -> RunStepObject {
        RunStepObject {
 id,
 object,
 created_at,
 assistant_id,
 thread_id,
 run_id,
 r_type,
 status,
 step_details,
 last_error,
 expired_at,
 cancelled_at,
 failed_at,
 completed_at,
 metadata,
 usage,
        }
    }
}

/// Converts the RunStepObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("assistant_id".to_string()),
            Some(self.assistant_id.to_string()),


            Some("thread_id".to_string()),
            Some(self.thread_id.to_string()),


            Some("run_id".to_string()),
            Some(self.run_id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),


            Some("status".to_string()),
            Some(self.status.to_string()),

            // Skipping step_details in query parameter serialization

            // Skipping last_error in query parameter serialization


            Some("expired_at".to_string()),
            Some(self.expired_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("cancelled_at".to_string()),
            Some(self.cancelled_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("failed_at".to_string()),
            Some(self.failed_at.as_ref().map_or("null".to_string(), |x| x.to_string())),


            Some("completed_at".to_string()),
            Some(self.completed_at.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping metadata in query parameter serialization

            // Skipping usage in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub created_at: Vec<i32>,
            pub assistant_id: Vec<String>,
            pub thread_id: Vec<String>,
            pub run_id: Vec<String>,
            pub r_type: Vec<String>,
            pub status: Vec<String>,
            pub step_details: Vec<models::RunStepObjectStepDetails>,
            pub last_error: Vec<models::RunStepObjectLastError>,
            pub expired_at: Vec<i32>,
            pub cancelled_at: Vec<i32>,
            pub failed_at: Vec<i32>,
            pub completed_at: Vec<i32>,
            pub metadata: Vec<crate::types::Object>,
            pub usage: Vec<models::RunStepCompletionUsage>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "assistant_id" => intermediate_rep.assistant_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "thread_id" => intermediate_rep.thread_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "run_id" => intermediate_rep.run_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "step_details" => intermediate_rep.step_details.push(<models::RunStepObjectStepDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "last_error" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepObject".to_string()),
                    "expired_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepObject".to_string()),
                    "cancelled_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepObject".to_string()),
                    "failed_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepObject".to_string()),
                    "completed_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "usage" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in RunStepObject".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in RunStepObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in RunStepObject".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in RunStepObject".to_string())?,
            assistant_id: intermediate_rep.assistant_id.into_iter().next().ok_or_else(|| "assistant_id missing in RunStepObject".to_string())?,
            thread_id: intermediate_rep.thread_id.into_iter().next().ok_or_else(|| "thread_id missing in RunStepObject".to_string())?,
            run_id: intermediate_rep.run_id.into_iter().next().ok_or_else(|| "run_id missing in RunStepObject".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunStepObject".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in RunStepObject".to_string())?,
            step_details: intermediate_rep.step_details.into_iter().next().ok_or_else(|| "step_details missing in RunStepObject".to_string())?,
            last_error: std::result::Result::Err("Nullable types not supported in RunStepObject".to_string())?,
            expired_at: std::result::Result::Err("Nullable types not supported in RunStepObject".to_string())?,
            cancelled_at: std::result::Result::Err("Nullable types not supported in RunStepObject".to_string())?,
            failed_at: std::result::Result::Err("Nullable types not supported in RunStepObject".to_string())?,
            completed_at: std::result::Result::Err("Nullable types not supported in RunStepObject".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next().ok_or_else(|| "metadata missing in RunStepObject".to_string())?,
            usage: std::result::Result::Err("Nullable types not supported in RunStepObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The last error associated with this run step. Will be `null` if there are no errors.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepObjectLastError {
    /// One of `server_error` or `rate_limit_exceeded`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "code")]
          #[validate(custom(function = "check_xss_string"))]
    pub code: String,

    /// A human-readable description of the error.
    #[serde(rename = "message")]
          #[validate(custom(function = "check_xss_string"))]
    pub message: String,

}



impl RunStepObjectLastError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(code: String, message: String, ) -> RunStepObjectLastError {
        RunStepObjectLastError {
 code,
 message,
        }
    }
}

/// Converts the RunStepObjectLastError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepObjectLastError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("code".to_string()),
            Some(self.code.to_string()),


            Some("message".to_string()),
            Some(self.message.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepObjectLastError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepObjectLastError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<String>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepObjectLastError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepObjectLastError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepObjectLastError {
            code: intermediate_rep.code.into_iter().next().ok_or_else(|| "code missing in RunStepObjectLastError".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in RunStepObjectLastError".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepObjectLastError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepObjectLastError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepObjectLastError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepObjectLastError - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepObjectLastError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepObjectLastError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepObjectLastError - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The details of the run step.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum RunStepObjectStepDetails {
    RunStepDetailsMessageCreationObject(models::RunStepDetailsMessageCreationObject),
    RunStepDetailsToolCallsObject(models::RunStepDetailsToolCallsObject),
}

impl validator::Validate for RunStepObjectStepDetails
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::RunStepDetailsMessageCreationObject(v) => v.validate(),
            Self::RunStepDetailsToolCallsObject(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepObjectStepDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepObjectStepDetails {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::RunStepDetailsMessageCreationObject> for RunStepObjectStepDetails {
    fn from(value: models::RunStepDetailsMessageCreationObject) -> Self {
        Self::RunStepDetailsMessageCreationObject(value)
    }
}
impl From<models::RunStepDetailsToolCallsObject> for RunStepObjectStepDetails {
    fn from(value: models::RunStepDetailsToolCallsObject) -> Self {
        Self::RunStepDetailsToolCallsObject(value)
    }
}





#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum RunStepStreamEvent {
    RunStepStreamEventOneOf(models::RunStepStreamEventOneOf),
    RunStepStreamEventOneOf1(models::RunStepStreamEventOneOf1),
    RunStepStreamEventOneOf2(models::RunStepStreamEventOneOf2),
    RunStepStreamEventOneOf3(models::RunStepStreamEventOneOf3),
    RunStepStreamEventOneOf4(models::RunStepStreamEventOneOf4),
    RunStepStreamEventOneOf5(models::RunStepStreamEventOneOf5),
    RunStepStreamEventOneOf6(models::RunStepStreamEventOneOf6),
}

impl validator::Validate for RunStepStreamEvent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::RunStepStreamEventOneOf(v) => v.validate(),
            Self::RunStepStreamEventOneOf1(v) => v.validate(),
            Self::RunStepStreamEventOneOf2(v) => v.validate(),
            Self::RunStepStreamEventOneOf3(v) => v.validate(),
            Self::RunStepStreamEventOneOf4(v) => v.validate(),
            Self::RunStepStreamEventOneOf5(v) => v.validate(),
            Self::RunStepStreamEventOneOf6(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEvent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::RunStepStreamEventOneOf> for RunStepStreamEvent {
    fn from(value: models::RunStepStreamEventOneOf) -> Self {
        Self::RunStepStreamEventOneOf(value)
    }
}
impl From<models::RunStepStreamEventOneOf1> for RunStepStreamEvent {
    fn from(value: models::RunStepStreamEventOneOf1) -> Self {
        Self::RunStepStreamEventOneOf1(value)
    }
}
impl From<models::RunStepStreamEventOneOf2> for RunStepStreamEvent {
    fn from(value: models::RunStepStreamEventOneOf2) -> Self {
        Self::RunStepStreamEventOneOf2(value)
    }
}
impl From<models::RunStepStreamEventOneOf3> for RunStepStreamEvent {
    fn from(value: models::RunStepStreamEventOneOf3) -> Self {
        Self::RunStepStreamEventOneOf3(value)
    }
}
impl From<models::RunStepStreamEventOneOf4> for RunStepStreamEvent {
    fn from(value: models::RunStepStreamEventOneOf4) -> Self {
        Self::RunStepStreamEventOneOf4(value)
    }
}
impl From<models::RunStepStreamEventOneOf5> for RunStepStreamEvent {
    fn from(value: models::RunStepStreamEventOneOf5) -> Self {
        Self::RunStepStreamEventOneOf5(value)
    }
}
impl From<models::RunStepStreamEventOneOf6> for RunStepStreamEvent {
    fn from(value: models::RunStepStreamEventOneOf6) -> Self {
        Self::RunStepStreamEventOneOf6(value)
    }
}





/// Occurs when a [run step](/docs/api-reference/run-steps/step-object) is created.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepStreamEventOneOf {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunStepObject,

}



impl RunStepStreamEventOneOf {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunStepObject, ) -> RunStepStreamEventOneOf {
        RunStepStreamEventOneOf {
 event,
 data,
        }
    }
}

/// Converts the RunStepStreamEventOneOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepStreamEventOneOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEventOneOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEventOneOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunStepObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepStreamEventOneOf".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunStepObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepStreamEventOneOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepStreamEventOneOf {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStepStreamEventOneOf".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStepStreamEventOneOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepStreamEventOneOf> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepStreamEventOneOf>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepStreamEventOneOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepStreamEventOneOf - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepStreamEventOneOf> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepStreamEventOneOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepStreamEventOneOf - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [run step](/docs/api-reference/run-steps/step-object) moves to an `in_progress` state.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepStreamEventOneOf1 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunStepObject,

}



impl RunStepStreamEventOneOf1 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunStepObject, ) -> RunStepStreamEventOneOf1 {
        RunStepStreamEventOneOf1 {
 event,
 data,
        }
    }
}

/// Converts the RunStepStreamEventOneOf1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepStreamEventOneOf1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEventOneOf1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEventOneOf1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunStepObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepStreamEventOneOf1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunStepObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepStreamEventOneOf1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepStreamEventOneOf1 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStepStreamEventOneOf1".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStepStreamEventOneOf1".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepStreamEventOneOf1> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepStreamEventOneOf1>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepStreamEventOneOf1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepStreamEventOneOf1 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepStreamEventOneOf1> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepStreamEventOneOf1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepStreamEventOneOf1 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when parts of a [run step](/docs/api-reference/run-steps/step-object) are being streamed.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepStreamEventOneOf2 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunStepDeltaObject,

}



impl RunStepStreamEventOneOf2 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunStepDeltaObject, ) -> RunStepStreamEventOneOf2 {
        RunStepStreamEventOneOf2 {
 event,
 data,
        }
    }
}

/// Converts the RunStepStreamEventOneOf2 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepStreamEventOneOf2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEventOneOf2 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEventOneOf2 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunStepDeltaObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepStreamEventOneOf2".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunStepDeltaObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepStreamEventOneOf2".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepStreamEventOneOf2 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStepStreamEventOneOf2".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStepStreamEventOneOf2".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepStreamEventOneOf2> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepStreamEventOneOf2>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepStreamEventOneOf2>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepStreamEventOneOf2 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepStreamEventOneOf2> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepStreamEventOneOf2 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepStreamEventOneOf2 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [run step](/docs/api-reference/run-steps/step-object) is completed.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepStreamEventOneOf3 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunStepObject,

}



impl RunStepStreamEventOneOf3 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunStepObject, ) -> RunStepStreamEventOneOf3 {
        RunStepStreamEventOneOf3 {
 event,
 data,
        }
    }
}

/// Converts the RunStepStreamEventOneOf3 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepStreamEventOneOf3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEventOneOf3 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEventOneOf3 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunStepObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepStreamEventOneOf3".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunStepObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepStreamEventOneOf3".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepStreamEventOneOf3 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStepStreamEventOneOf3".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStepStreamEventOneOf3".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepStreamEventOneOf3> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepStreamEventOneOf3>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepStreamEventOneOf3>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepStreamEventOneOf3 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepStreamEventOneOf3> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepStreamEventOneOf3 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepStreamEventOneOf3 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [run step](/docs/api-reference/run-steps/step-object) fails.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepStreamEventOneOf4 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunStepObject,

}



impl RunStepStreamEventOneOf4 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunStepObject, ) -> RunStepStreamEventOneOf4 {
        RunStepStreamEventOneOf4 {
 event,
 data,
        }
    }
}

/// Converts the RunStepStreamEventOneOf4 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepStreamEventOneOf4 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEventOneOf4 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEventOneOf4 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunStepObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepStreamEventOneOf4".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunStepObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepStreamEventOneOf4".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepStreamEventOneOf4 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStepStreamEventOneOf4".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStepStreamEventOneOf4".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepStreamEventOneOf4> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepStreamEventOneOf4>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepStreamEventOneOf4>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepStreamEventOneOf4 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepStreamEventOneOf4> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepStreamEventOneOf4 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepStreamEventOneOf4 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [run step](/docs/api-reference/run-steps/step-object) is cancelled.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepStreamEventOneOf5 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunStepObject,

}



impl RunStepStreamEventOneOf5 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunStepObject, ) -> RunStepStreamEventOneOf5 {
        RunStepStreamEventOneOf5 {
 event,
 data,
        }
    }
}

/// Converts the RunStepStreamEventOneOf5 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepStreamEventOneOf5 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEventOneOf5 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEventOneOf5 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunStepObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepStreamEventOneOf5".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunStepObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepStreamEventOneOf5".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepStreamEventOneOf5 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStepStreamEventOneOf5".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStepStreamEventOneOf5".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepStreamEventOneOf5> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepStreamEventOneOf5>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepStreamEventOneOf5>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepStreamEventOneOf5 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepStreamEventOneOf5> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepStreamEventOneOf5 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepStreamEventOneOf5 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [run step](/docs/api-reference/run-steps/step-object) expires.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStepStreamEventOneOf6 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunStepObject,

}



impl RunStepStreamEventOneOf6 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunStepObject, ) -> RunStepStreamEventOneOf6 {
        RunStepStreamEventOneOf6 {
 event,
 data,
        }
    }
}

/// Converts the RunStepStreamEventOneOf6 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStepStreamEventOneOf6 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStepStreamEventOneOf6 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStepStreamEventOneOf6 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunStepObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStepStreamEventOneOf6".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunStepObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStepStreamEventOneOf6".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStepStreamEventOneOf6 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStepStreamEventOneOf6".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStepStreamEventOneOf6".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStepStreamEventOneOf6> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStepStreamEventOneOf6>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStepStreamEventOneOf6>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStepStreamEventOneOf6 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStepStreamEventOneOf6> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStepStreamEventOneOf6 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStepStreamEventOneOf6 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum RunStreamEvent {
    RunStreamEventOneOf(models::RunStreamEventOneOf),
    RunStreamEventOneOf1(models::RunStreamEventOneOf1),
    RunStreamEventOneOf2(models::RunStreamEventOneOf2),
    RunStreamEventOneOf3(models::RunStreamEventOneOf3),
    RunStreamEventOneOf4(models::RunStreamEventOneOf4),
    RunStreamEventOneOf5(models::RunStreamEventOneOf5),
    RunStreamEventOneOf6(models::RunStreamEventOneOf6),
    RunStreamEventOneOf7(models::RunStreamEventOneOf7),
    RunStreamEventOneOf8(models::RunStreamEventOneOf8),
    RunStreamEventOneOf9(models::RunStreamEventOneOf9),
}

impl validator::Validate for RunStreamEvent
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::RunStreamEventOneOf(v) => v.validate(),
            Self::RunStreamEventOneOf1(v) => v.validate(),
            Self::RunStreamEventOneOf2(v) => v.validate(),
            Self::RunStreamEventOneOf3(v) => v.validate(),
            Self::RunStreamEventOneOf4(v) => v.validate(),
            Self::RunStreamEventOneOf5(v) => v.validate(),
            Self::RunStreamEventOneOf6(v) => v.validate(),
            Self::RunStreamEventOneOf7(v) => v.validate(),
            Self::RunStreamEventOneOf8(v) => v.validate(),
            Self::RunStreamEventOneOf9(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEvent {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::RunStreamEventOneOf> for RunStreamEvent {
    fn from(value: models::RunStreamEventOneOf) -> Self {
        Self::RunStreamEventOneOf(value)
    }
}
impl From<models::RunStreamEventOneOf1> for RunStreamEvent {
    fn from(value: models::RunStreamEventOneOf1) -> Self {
        Self::RunStreamEventOneOf1(value)
    }
}
impl From<models::RunStreamEventOneOf2> for RunStreamEvent {
    fn from(value: models::RunStreamEventOneOf2) -> Self {
        Self::RunStreamEventOneOf2(value)
    }
}
impl From<models::RunStreamEventOneOf3> for RunStreamEvent {
    fn from(value: models::RunStreamEventOneOf3) -> Self {
        Self::RunStreamEventOneOf3(value)
    }
}
impl From<models::RunStreamEventOneOf4> for RunStreamEvent {
    fn from(value: models::RunStreamEventOneOf4) -> Self {
        Self::RunStreamEventOneOf4(value)
    }
}
impl From<models::RunStreamEventOneOf5> for RunStreamEvent {
    fn from(value: models::RunStreamEventOneOf5) -> Self {
        Self::RunStreamEventOneOf5(value)
    }
}
impl From<models::RunStreamEventOneOf6> for RunStreamEvent {
    fn from(value: models::RunStreamEventOneOf6) -> Self {
        Self::RunStreamEventOneOf6(value)
    }
}
impl From<models::RunStreamEventOneOf7> for RunStreamEvent {
    fn from(value: models::RunStreamEventOneOf7) -> Self {
        Self::RunStreamEventOneOf7(value)
    }
}
impl From<models::RunStreamEventOneOf8> for RunStreamEvent {
    fn from(value: models::RunStreamEventOneOf8) -> Self {
        Self::RunStreamEventOneOf8(value)
    }
}
impl From<models::RunStreamEventOneOf9> for RunStreamEvent {
    fn from(value: models::RunStreamEventOneOf9) -> Self {
        Self::RunStreamEventOneOf9(value)
    }
}





/// Occurs when a new [run](/docs/api-reference/runs/object) is created.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunObject,

}



impl RunStreamEventOneOf {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf {
        RunStreamEventOneOf {
 event,
 data,
        }
    }
}

/// Converts the RunStreamEventOneOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStreamEventOneOf - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStreamEventOneOf - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [run](/docs/api-reference/runs/object) moves to a `queued` status.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf1 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunObject,

}



impl RunStreamEventOneOf1 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf1 {
        RunStreamEventOneOf1 {
 event,
 data,
        }
    }
}

/// Converts the RunStreamEventOneOf1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf1 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf1".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf1 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf1".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf1".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf1> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf1>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStreamEventOneOf1 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf1> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStreamEventOneOf1 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [run](/docs/api-reference/runs/object) moves to an `in_progress` status.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf2 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunObject,

}



impl RunStreamEventOneOf2 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf2 {
        RunStreamEventOneOf2 {
 event,
 data,
        }
    }
}

/// Converts the RunStreamEventOneOf2 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf2 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf2 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf2 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf2".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf2".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf2 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf2".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf2".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf2> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf2>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf2>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStreamEventOneOf2 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf2> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf2 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStreamEventOneOf2 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [run](/docs/api-reference/runs/object) moves to a `requires_action` status.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf3 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunObject,

}



impl RunStreamEventOneOf3 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf3 {
        RunStreamEventOneOf3 {
 event,
 data,
        }
    }
}

/// Converts the RunStreamEventOneOf3 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf3 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf3 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf3 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf3".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf3".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf3 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf3".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf3".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf3> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf3>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf3>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStreamEventOneOf3 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf3> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf3 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStreamEventOneOf3 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [run](/docs/api-reference/runs/object) is completed.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf4 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunObject,

}



impl RunStreamEventOneOf4 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf4 {
        RunStreamEventOneOf4 {
 event,
 data,
        }
    }
}

/// Converts the RunStreamEventOneOf4 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf4 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf4 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf4 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf4".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf4".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf4 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf4".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf4".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf4> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf4>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf4>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStreamEventOneOf4 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf4> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf4 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStreamEventOneOf4 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [run](/docs/api-reference/runs/object) ends with status `incomplete`.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf5 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunObject,

}



impl RunStreamEventOneOf5 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf5 {
        RunStreamEventOneOf5 {
 event,
 data,
        }
    }
}

/// Converts the RunStreamEventOneOf5 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf5 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf5 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf5 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf5".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf5".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf5 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf5".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf5".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf5> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf5>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf5>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStreamEventOneOf5 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf5> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf5 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStreamEventOneOf5 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [run](/docs/api-reference/runs/object) fails.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf6 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunObject,

}



impl RunStreamEventOneOf6 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf6 {
        RunStreamEventOneOf6 {
 event,
 data,
        }
    }
}

/// Converts the RunStreamEventOneOf6 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf6 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf6 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf6 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf6".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf6".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf6 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf6".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf6".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf6> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf6>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf6>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStreamEventOneOf6 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf6> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf6 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStreamEventOneOf6 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [run](/docs/api-reference/runs/object) moves to a `cancelling` status.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf7 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunObject,

}



impl RunStreamEventOneOf7 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf7 {
        RunStreamEventOneOf7 {
 event,
 data,
        }
    }
}

/// Converts the RunStreamEventOneOf7 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf7 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf7 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf7 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf7".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf7".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf7 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf7".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf7".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf7> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf7>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf7>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStreamEventOneOf7 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf7> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf7 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStreamEventOneOf7 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [run](/docs/api-reference/runs/object) is cancelled.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf8 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunObject,

}



impl RunStreamEventOneOf8 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf8 {
        RunStreamEventOneOf8 {
 event,
 data,
        }
    }
}

/// Converts the RunStreamEventOneOf8 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf8 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf8 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf8 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf8".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf8".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf8 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf8".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf8".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf8> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf8>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf8>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStreamEventOneOf8 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf8> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf8 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStreamEventOneOf8 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a [run](/docs/api-reference/runs/object) expires.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunStreamEventOneOf9 {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::RunObject,

}



impl RunStreamEventOneOf9 {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::RunObject, ) -> RunStreamEventOneOf9 {
        RunStreamEventOneOf9 {
 event,
 data,
        }
    }
}

/// Converts the RunStreamEventOneOf9 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunStreamEventOneOf9 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunStreamEventOneOf9 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunStreamEventOneOf9 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub event: Vec<String>,
            pub data: Vec<models::RunObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunStreamEventOneOf9".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::RunObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunStreamEventOneOf9".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunStreamEventOneOf9 {
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in RunStreamEventOneOf9".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in RunStreamEventOneOf9".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunStreamEventOneOf9> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunStreamEventOneOf9>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunStreamEventOneOf9>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunStreamEventOneOf9 - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunStreamEventOneOf9> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunStreamEventOneOf9 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunStreamEventOneOf9 - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Tool call objects
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunToolCallObject {
    /// The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](/docs/api-reference/runs/submitToolOutputs) endpoint.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The type of tool call the output is required for. For now, this is always `function`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "function")]
          #[validate(nested)]
    pub function: models::RunToolCallObjectFunction,

}



impl RunToolCallObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, r_type: String, function: models::RunToolCallObjectFunction, ) -> RunToolCallObject {
        RunToolCallObject {
 id,
 r_type,
 function,
        }
    }
}

/// Converts the RunToolCallObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunToolCallObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping function in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunToolCallObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunToolCallObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub r_type: Vec<String>,
            pub function: Vec<models::RunToolCallObjectFunction>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunToolCallObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "function" => intermediate_rep.function.push(<models::RunToolCallObjectFunction as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunToolCallObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunToolCallObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in RunToolCallObject".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in RunToolCallObject".to_string())?,
            function: intermediate_rep.function.into_iter().next().ok_or_else(|| "function missing in RunToolCallObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunToolCallObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunToolCallObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunToolCallObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunToolCallObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunToolCallObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunToolCallObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunToolCallObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The function definition.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RunToolCallObjectFunction {
    /// The name of the function.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    /// The arguments that the model expects you to pass to the function.
    #[serde(rename = "arguments")]
          #[validate(custom(function = "check_xss_string"))]
    pub arguments: String,

}



impl RunToolCallObjectFunction {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, arguments: String, ) -> RunToolCallObjectFunction {
        RunToolCallObjectFunction {
 name,
 arguments,
        }
    }
}

/// Converts the RunToolCallObjectFunction value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RunToolCallObjectFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("arguments".to_string()),
            Some(self.arguments.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RunToolCallObjectFunction value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RunToolCallObjectFunction {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub arguments: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RunToolCallObjectFunction".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "arguments" => intermediate_rep.arguments.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RunToolCallObjectFunction".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RunToolCallObjectFunction {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in RunToolCallObjectFunction".to_string())?,
            arguments: intermediate_rep.arguments.into_iter().next().ok_or_else(|| "arguments missing in RunToolCallObjectFunction".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RunToolCallObjectFunction> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RunToolCallObjectFunction>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RunToolCallObjectFunction>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RunToolCallObjectFunction - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RunToolCallObjectFunction> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RunToolCallObjectFunction as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RunToolCallObjectFunction - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StaticChunkingStrategy {
    /// Always `static`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "static")]
          #[validate(nested)]
    pub r_static: models::StaticChunkingStrategyStatic,

}



impl StaticChunkingStrategy {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, r_static: models::StaticChunkingStrategyStatic, ) -> StaticChunkingStrategy {
        StaticChunkingStrategy {
 r_type,
 r_static,
        }
    }
}

/// Converts the StaticChunkingStrategy value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for StaticChunkingStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping static in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StaticChunkingStrategy value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StaticChunkingStrategy {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub r_static: Vec<models::StaticChunkingStrategyStatic>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing StaticChunkingStrategy".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "static" => intermediate_rep.r_static.push(<models::StaticChunkingStrategyStatic as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing StaticChunkingStrategy".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StaticChunkingStrategy {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in StaticChunkingStrategy".to_string())?,
            r_static: intermediate_rep.r_static.into_iter().next().ok_or_else(|| "static missing in StaticChunkingStrategy".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StaticChunkingStrategy> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StaticChunkingStrategy>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<StaticChunkingStrategy>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for StaticChunkingStrategy - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StaticChunkingStrategy> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <StaticChunkingStrategy as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into StaticChunkingStrategy - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StaticChunkingStrategyRequestParam {
    /// Always `static`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "static")]
          #[validate(nested)]
    pub r_static: models::StaticChunkingStrategy,

}



impl StaticChunkingStrategyRequestParam {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, r_static: models::StaticChunkingStrategy, ) -> StaticChunkingStrategyRequestParam {
        StaticChunkingStrategyRequestParam {
 r_type,
 r_static,
        }
    }
}

/// Converts the StaticChunkingStrategyRequestParam value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for StaticChunkingStrategyRequestParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping static in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StaticChunkingStrategyRequestParam value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StaticChunkingStrategyRequestParam {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub r_static: Vec<models::StaticChunkingStrategy>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing StaticChunkingStrategyRequestParam".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "static" => intermediate_rep.r_static.push(<models::StaticChunkingStrategy as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing StaticChunkingStrategyRequestParam".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StaticChunkingStrategyRequestParam {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in StaticChunkingStrategyRequestParam".to_string())?,
            r_static: intermediate_rep.r_static.into_iter().next().ok_or_else(|| "static missing in StaticChunkingStrategyRequestParam".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StaticChunkingStrategyRequestParam> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StaticChunkingStrategyRequestParam>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<StaticChunkingStrategyRequestParam>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for StaticChunkingStrategyRequestParam - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StaticChunkingStrategyRequestParam> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <StaticChunkingStrategyRequestParam as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into StaticChunkingStrategyRequestParam - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StaticChunkingStrategyResponseParam {
    /// Always `static`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    #[serde(rename = "static")]
          #[validate(nested)]
    pub r_static: models::StaticChunkingStrategy,

}



impl StaticChunkingStrategyResponseParam {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, r_static: models::StaticChunkingStrategy, ) -> StaticChunkingStrategyResponseParam {
        StaticChunkingStrategyResponseParam {
 r_type,
 r_static,
        }
    }
}

/// Converts the StaticChunkingStrategyResponseParam value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for StaticChunkingStrategyResponseParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),

            // Skipping static in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StaticChunkingStrategyResponseParam value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StaticChunkingStrategyResponseParam {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub r_static: Vec<models::StaticChunkingStrategy>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing StaticChunkingStrategyResponseParam".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "static" => intermediate_rep.r_static.push(<models::StaticChunkingStrategy as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing StaticChunkingStrategyResponseParam".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StaticChunkingStrategyResponseParam {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in StaticChunkingStrategyResponseParam".to_string())?,
            r_static: intermediate_rep.r_static.into_iter().next().ok_or_else(|| "static missing in StaticChunkingStrategyResponseParam".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StaticChunkingStrategyResponseParam> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StaticChunkingStrategyResponseParam>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<StaticChunkingStrategyResponseParam>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for StaticChunkingStrategyResponseParam - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StaticChunkingStrategyResponseParam> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <StaticChunkingStrategyResponseParam as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into StaticChunkingStrategyResponseParam - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StaticChunkingStrategyStatic {
    /// The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`.
    #[serde(rename = "max_chunk_size_tokens")]
    #[validate(
            range(min = 100u16, max = 4096u16),
    )]
    pub max_chunk_size_tokens: u16,

    /// The number of tokens that overlap between chunks. The default value is `400`.  Note that the overlap must not exceed half of `max_chunk_size_tokens`. 
    #[serde(rename = "chunk_overlap_tokens")]
    pub chunk_overlap_tokens: i32,

}



impl StaticChunkingStrategyStatic {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(max_chunk_size_tokens: u16, chunk_overlap_tokens: i32, ) -> StaticChunkingStrategyStatic {
        StaticChunkingStrategyStatic {
 max_chunk_size_tokens,
 chunk_overlap_tokens,
        }
    }
}

/// Converts the StaticChunkingStrategyStatic value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for StaticChunkingStrategyStatic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("max_chunk_size_tokens".to_string()),
            Some(self.max_chunk_size_tokens.to_string()),


            Some("chunk_overlap_tokens".to_string()),
            Some(self.chunk_overlap_tokens.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StaticChunkingStrategyStatic value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StaticChunkingStrategyStatic {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub max_chunk_size_tokens: Vec<u16>,
            pub chunk_overlap_tokens: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing StaticChunkingStrategyStatic".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "max_chunk_size_tokens" => intermediate_rep.max_chunk_size_tokens.push(<u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "chunk_overlap_tokens" => intermediate_rep.chunk_overlap_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing StaticChunkingStrategyStatic".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StaticChunkingStrategyStatic {
            max_chunk_size_tokens: intermediate_rep.max_chunk_size_tokens.into_iter().next().ok_or_else(|| "max_chunk_size_tokens missing in StaticChunkingStrategyStatic".to_string())?,
            chunk_overlap_tokens: intermediate_rep.chunk_overlap_tokens.into_iter().next().ok_or_else(|| "chunk_overlap_tokens missing in StaticChunkingStrategyStatic".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StaticChunkingStrategyStatic> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StaticChunkingStrategyStatic>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<StaticChunkingStrategyStatic>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for StaticChunkingStrategyStatic - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StaticChunkingStrategyStatic> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <StaticChunkingStrategyStatic as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into StaticChunkingStrategyStatic - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SubmitToolOutputsRunRequest {
    /// A list of tools for which the outputs are being submitted.
    #[serde(rename = "tool_outputs")]
          #[validate(nested)]
    pub tool_outputs: Vec<models::SubmitToolOutputsRunRequestToolOutputsInner>,

    /// If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message. 
    #[serde(rename = "stream")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stream: Option<Nullable<bool>>,

}



impl SubmitToolOutputsRunRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(tool_outputs: Vec<models::SubmitToolOutputsRunRequestToolOutputsInner>, ) -> SubmitToolOutputsRunRequest {
        SubmitToolOutputsRunRequest {
 tool_outputs,
 stream: None,
        }
    }
}

/// Converts the SubmitToolOutputsRunRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SubmitToolOutputsRunRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping tool_outputs in query parameter serialization


            self.stream.as_ref().map(|stream| {
                [
                    "stream".to_string(),
                    stream.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SubmitToolOutputsRunRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SubmitToolOutputsRunRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tool_outputs: Vec<Vec<models::SubmitToolOutputsRunRequestToolOutputsInner>>,
            pub stream: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SubmitToolOutputsRunRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "tool_outputs" => return std::result::Result::Err("Parsing a container in this style is not supported in SubmitToolOutputsRunRequest".to_string()),
                    "stream" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in SubmitToolOutputsRunRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SubmitToolOutputsRunRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SubmitToolOutputsRunRequest {
            tool_outputs: intermediate_rep.tool_outputs.into_iter().next().ok_or_else(|| "tool_outputs missing in SubmitToolOutputsRunRequest".to_string())?,
            stream: std::result::Result::Err("Nullable types not supported in SubmitToolOutputsRunRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SubmitToolOutputsRunRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SubmitToolOutputsRunRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SubmitToolOutputsRunRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for SubmitToolOutputsRunRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SubmitToolOutputsRunRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SubmitToolOutputsRunRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into SubmitToolOutputsRunRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SubmitToolOutputsRunRequestToolOutputsInner {
    /// The ID of the tool call in the `required_action` object within the run object the output is being submitted for.
    #[serde(rename = "tool_call_id")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_call_id: Option<String>,

    /// The output of the tool call to be submitted to continue the run.
    #[serde(rename = "output")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output: Option<String>,

}



impl SubmitToolOutputsRunRequestToolOutputsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> SubmitToolOutputsRunRequestToolOutputsInner {
        SubmitToolOutputsRunRequestToolOutputsInner {
 tool_call_id: None,
 output: None,
        }
    }
}

/// Converts the SubmitToolOutputsRunRequestToolOutputsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SubmitToolOutputsRunRequestToolOutputsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.tool_call_id.as_ref().map(|tool_call_id| {
                [
                    "tool_call_id".to_string(),
                    tool_call_id.to_string(),
                ].join(",")
            }),


            self.output.as_ref().map(|output| {
                [
                    "output".to_string(),
                    output.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SubmitToolOutputsRunRequestToolOutputsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SubmitToolOutputsRunRequestToolOutputsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub tool_call_id: Vec<String>,
            pub output: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SubmitToolOutputsRunRequestToolOutputsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "tool_call_id" => intermediate_rep.tool_call_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output" => intermediate_rep.output.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SubmitToolOutputsRunRequestToolOutputsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SubmitToolOutputsRunRequestToolOutputsInner {
            tool_call_id: intermediate_rep.tool_call_id.into_iter().next(),
            output: intermediate_rep.output.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SubmitToolOutputsRunRequestToolOutputsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SubmitToolOutputsRunRequestToolOutputsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SubmitToolOutputsRunRequestToolOutputsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for SubmitToolOutputsRunRequestToolOutputsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SubmitToolOutputsRunRequestToolOutputsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SubmitToolOutputsRunRequestToolOutputsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into SubmitToolOutputsRunRequestToolOutputsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Represents a thread that contains [messages](/docs/api-reference/messages).
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ThreadObject {
    /// The identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The object type, which is always `thread`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The Unix timestamp (in seconds) for when the thread was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    #[serde(rename = "tool_resources")]
    pub tool_resources: Nullable<models::ModifyThreadRequestToolResources>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    pub metadata: crate::types::Object,

}



impl ThreadObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, created_at: i32, tool_resources: Nullable<models::ModifyThreadRequestToolResources>, metadata: crate::types::Object, ) -> ThreadObject {
        ThreadObject {
 id,
 object,
 created_at,
 tool_resources,
 metadata,
        }
    }
}

/// Converts the ThreadObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ThreadObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),

            // Skipping tool_resources in query parameter serialization

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ThreadObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ThreadObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub created_at: Vec<i32>,
            pub tool_resources: Vec<models::ModifyThreadRequestToolResources>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ThreadObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tool_resources" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ThreadObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ThreadObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ThreadObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ThreadObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in ThreadObject".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in ThreadObject".to_string())?,
            tool_resources: std::result::Result::Err("Nullable types not supported in ThreadObject".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next().ok_or_else(|| "metadata missing in ThreadObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ThreadObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ThreadObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ThreadObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ThreadObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ThreadObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ThreadObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ThreadObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Occurs when a new [thread](/docs/api-reference/threads/object) is created.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ThreadStreamEvent {
    /// Whether to enable input audio transcription.
    #[serde(rename = "enabled")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,

    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "event")]
          #[validate(custom(function = "check_xss_string"))]
    pub event: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: models::ThreadObject,

}



impl ThreadStreamEvent {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(event: String, data: models::ThreadObject, ) -> ThreadStreamEvent {
        ThreadStreamEvent {
 enabled: None,
 event,
 data,
        }
    }
}

/// Converts the ThreadStreamEvent value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ThreadStreamEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.enabled.as_ref().map(|enabled| {
                [
                    "enabled".to_string(),
                    enabled.to_string(),
                ].join(",")
            }),


            Some("event".to_string()),
            Some(self.event.to_string()),

            // Skipping data in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ThreadStreamEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ThreadStreamEvent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub enabled: Vec<bool>,
            pub event: Vec<String>,
            pub data: Vec<models::ThreadObject>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ThreadStreamEvent".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "enabled" => intermediate_rep.enabled.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "event" => intermediate_rep.event.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "data" => intermediate_rep.data.push(<models::ThreadObject as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ThreadStreamEvent".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ThreadStreamEvent {
            enabled: intermediate_rep.enabled.into_iter().next(),
            event: intermediate_rep.event.into_iter().next().ok_or_else(|| "event missing in ThreadStreamEvent".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in ThreadStreamEvent".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ThreadStreamEvent> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ThreadStreamEvent>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ThreadStreamEvent>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ThreadStreamEvent - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ThreadStreamEvent> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ThreadStreamEvent as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ThreadStreamEvent - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TranscriptionSegment {
    /// Unique identifier of the segment.
    #[serde(rename = "id")]
    pub id: i32,

    /// Seek offset of the segment.
    #[serde(rename = "seek")]
    pub seek: i32,

    /// Start time of the segment in seconds.
    #[serde(rename = "start")]
    pub start: f32,

    /// End time of the segment in seconds.
    #[serde(rename = "end")]
    pub end: f32,

    /// Text content of the segment.
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    pub text: String,

    /// Array of token IDs for the text content.
    #[serde(rename = "tokens")]
    pub tokens: Vec<i32>,

    /// Temperature parameter used for generating the segment.
    #[serde(rename = "temperature")]
    pub temperature: f32,

    /// Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.
    #[serde(rename = "avg_logprob")]
    pub avg_logprob: f32,

    /// Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.
    #[serde(rename = "compression_ratio")]
    pub compression_ratio: f32,

    /// Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent.
    #[serde(rename = "no_speech_prob")]
    pub no_speech_prob: f32,

}



impl TranscriptionSegment {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, seek: i32, start: f32, end: f32, text: String, tokens: Vec<i32>, temperature: f32, avg_logprob: f32, compression_ratio: f32, no_speech_prob: f32, ) -> TranscriptionSegment {
        TranscriptionSegment {
 id,
 seek,
 start,
 end,
 text,
 tokens,
 temperature,
 avg_logprob,
 compression_ratio,
 no_speech_prob,
        }
    }
}

/// Converts the TranscriptionSegment value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TranscriptionSegment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("seek".to_string()),
            Some(self.seek.to_string()),


            Some("start".to_string()),
            Some(self.start.to_string()),


            Some("end".to_string()),
            Some(self.end.to_string()),


            Some("text".to_string()),
            Some(self.text.to_string()),


            Some("tokens".to_string()),
            Some(self.tokens.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),


            Some("temperature".to_string()),
            Some(self.temperature.to_string()),


            Some("avg_logprob".to_string()),
            Some(self.avg_logprob.to_string()),


            Some("compression_ratio".to_string()),
            Some(self.compression_ratio.to_string()),


            Some("no_speech_prob".to_string()),
            Some(self.no_speech_prob.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TranscriptionSegment value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TranscriptionSegment {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub seek: Vec<i32>,
            pub start: Vec<f32>,
            pub end: Vec<f32>,
            pub text: Vec<String>,
            pub tokens: Vec<Vec<i32>>,
            pub temperature: Vec<f32>,
            pub avg_logprob: Vec<f32>,
            pub compression_ratio: Vec<f32>,
            pub no_speech_prob: Vec<f32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TranscriptionSegment".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "seek" => intermediate_rep.seek.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start" => intermediate_rep.start.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end" => intermediate_rep.end.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "tokens" => return std::result::Result::Err("Parsing a container in this style is not supported in TranscriptionSegment".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "temperature" => intermediate_rep.temperature.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "avg_logprob" => intermediate_rep.avg_logprob.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "compression_ratio" => intermediate_rep.compression_ratio.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "no_speech_prob" => intermediate_rep.no_speech_prob.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TranscriptionSegment".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TranscriptionSegment {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in TranscriptionSegment".to_string())?,
            seek: intermediate_rep.seek.into_iter().next().ok_or_else(|| "seek missing in TranscriptionSegment".to_string())?,
            start: intermediate_rep.start.into_iter().next().ok_or_else(|| "start missing in TranscriptionSegment".to_string())?,
            end: intermediate_rep.end.into_iter().next().ok_or_else(|| "end missing in TranscriptionSegment".to_string())?,
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in TranscriptionSegment".to_string())?,
            tokens: intermediate_rep.tokens.into_iter().next().ok_or_else(|| "tokens missing in TranscriptionSegment".to_string())?,
            temperature: intermediate_rep.temperature.into_iter().next().ok_or_else(|| "temperature missing in TranscriptionSegment".to_string())?,
            avg_logprob: intermediate_rep.avg_logprob.into_iter().next().ok_or_else(|| "avg_logprob missing in TranscriptionSegment".to_string())?,
            compression_ratio: intermediate_rep.compression_ratio.into_iter().next().ok_or_else(|| "compression_ratio missing in TranscriptionSegment".to_string())?,
            no_speech_prob: intermediate_rep.no_speech_prob.into_iter().next().ok_or_else(|| "no_speech_prob missing in TranscriptionSegment".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TranscriptionSegment> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TranscriptionSegment>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TranscriptionSegment>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for TranscriptionSegment - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TranscriptionSegment> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TranscriptionSegment as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into TranscriptionSegment - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TranscriptionWord {
    /// The text content of the word.
    #[serde(rename = "word")]
          #[validate(custom(function = "check_xss_string"))]
    pub word: String,

    /// Start time of the word in seconds.
    #[serde(rename = "start")]
    pub start: f32,

    /// End time of the word in seconds.
    #[serde(rename = "end")]
    pub end: f32,

}



impl TranscriptionWord {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(word: String, start: f32, end: f32, ) -> TranscriptionWord {
        TranscriptionWord {
 word,
 start,
 end,
        }
    }
}

/// Converts the TranscriptionWord value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TranscriptionWord {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("word".to_string()),
            Some(self.word.to_string()),


            Some("start".to_string()),
            Some(self.start.to_string()),


            Some("end".to_string()),
            Some(self.end.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TranscriptionWord value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TranscriptionWord {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub word: Vec<String>,
            pub start: Vec<f32>,
            pub end: Vec<f32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TranscriptionWord".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "word" => intermediate_rep.word.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start" => intermediate_rep.start.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end" => intermediate_rep.end.push(<f32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TranscriptionWord".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TranscriptionWord {
            word: intermediate_rep.word.into_iter().next().ok_or_else(|| "word missing in TranscriptionWord".to_string())?,
            start: intermediate_rep.start.into_iter().next().ok_or_else(|| "start missing in TranscriptionWord".to_string())?,
            end: intermediate_rep.end.into_iter().next().ok_or_else(|| "end missing in TranscriptionWord".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TranscriptionWord> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TranscriptionWord>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TranscriptionWord>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for TranscriptionWord - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TranscriptionWord> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TranscriptionWord as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into TranscriptionWord - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TruncationObject {
    /// The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "type")]
          #[validate(custom(function = "check_xss_string"))]
    pub r_type: String,

    /// The number of most recent messages from the thread when constructing the context for the run.
    #[serde(rename = "last_messages")]
    #[validate(
            range(min = 1u32),
    )]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_messages: Option<Nullable<u32>>,

}



impl TruncationObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_type: String, ) -> TruncationObject {
        TruncationObject {
 r_type,
 last_messages: None,
        }
    }
}

/// Converts the TruncationObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TruncationObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("type".to_string()),
            Some(self.r_type.to_string()),


            self.last_messages.as_ref().map(|last_messages| {
                [
                    "last_messages".to_string(),
                    last_messages.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TruncationObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TruncationObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_type: Vec<String>,
            pub last_messages: Vec<u32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TruncationObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "last_messages" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in TruncationObject".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TruncationObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TruncationObject {
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in TruncationObject".to_string())?,
            last_messages: std::result::Result::Err("Nullable types not supported in TruncationObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TruncationObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TruncationObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TruncationObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for TruncationObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TruncationObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TruncationObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into TruncationObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UpdateVectorStoreRequest {
    /// The name of the vector store.
    #[serde(rename = "name")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Nullable<String>>,

    #[serde(rename = "expires_after")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_after: Option<models::VectorStoreExpirationAfter>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<crate::types::Object>,

}



impl UpdateVectorStoreRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> UpdateVectorStoreRequest {
        UpdateVectorStoreRequest {
 name: None,
 expires_after: None,
 metadata: None,
        }
    }
}

/// Converts the UpdateVectorStoreRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UpdateVectorStoreRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping expires_after in query parameter serialization

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UpdateVectorStoreRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UpdateVectorStoreRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub expires_after: Vec<models::VectorStoreExpirationAfter>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UpdateVectorStoreRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UpdateVectorStoreRequest".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "expires_after" => intermediate_rep.expires_after.push(<models::VectorStoreExpirationAfter as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UpdateVectorStoreRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UpdateVectorStoreRequest {
            name: std::result::Result::Err("Nullable types not supported in UpdateVectorStoreRequest".to_string())?,
            expires_after: intermediate_rep.expires_after.into_iter().next(),
            metadata: intermediate_rep.metadata.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UpdateVectorStoreRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UpdateVectorStoreRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UpdateVectorStoreRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for UpdateVectorStoreRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UpdateVectorStoreRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UpdateVectorStoreRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into UpdateVectorStoreRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The Upload object can accept byte chunks in the form of Parts. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Upload {
    /// The Upload unique identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The Unix timestamp (in seconds) for when the Upload was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    /// The name of the file to be uploaded.
    #[serde(rename = "filename")]
          #[validate(custom(function = "check_xss_string"))]
    pub filename: String,

    /// The intended number of bytes to be uploaded.
    #[serde(rename = "bytes")]
    pub bytes: i32,

    /// The intended purpose of the file. [Please refer here](/docs/api-reference/files/object#files/object-purpose) for acceptable values.
    #[serde(rename = "purpose")]
          #[validate(custom(function = "check_xss_string"))]
    pub purpose: String,

    /// The status of the Upload.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
          #[validate(custom(function = "check_xss_string"))]
    pub status: String,

    /// The Unix timestamp (in seconds) for when the Upload was created.
    #[serde(rename = "expires_at")]
    pub expires_at: i32,

    /// The object type, which is always \"upload\".
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub object: Option<String>,

    #[serde(rename = "file")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub file: Option<models::OpenAiFile>,

}



impl Upload {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, created_at: i32, filename: String, bytes: i32, purpose: String, status: String, expires_at: i32, ) -> Upload {
        Upload {
 id,
 created_at,
 filename,
 bytes,
 purpose,
 status,
 expires_at,
 object: None,
 file: None,
        }
    }
}

/// Converts the Upload value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Upload {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("filename".to_string()),
            Some(self.filename.to_string()),


            Some("bytes".to_string()),
            Some(self.bytes.to_string()),


            Some("purpose".to_string()),
            Some(self.purpose.to_string()),


            Some("status".to_string()),
            Some(self.status.to_string()),


            Some("expires_at".to_string()),
            Some(self.expires_at.to_string()),


            self.object.as_ref().map(|object| {
                [
                    "object".to_string(),
                    object.to_string(),
                ].join(",")
            }),

            // Skipping file in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Upload value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Upload {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub created_at: Vec<i32>,
            pub filename: Vec<String>,
            pub bytes: Vec<i32>,
            pub purpose: Vec<String>,
            pub status: Vec<String>,
            pub expires_at: Vec<i32>,
            pub object: Vec<String>,
            pub file: Vec<models::OpenAiFile>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Upload".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "filename" => intermediate_rep.filename.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "bytes" => intermediate_rep.bytes.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "purpose" => intermediate_rep.purpose.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expires_at" => intermediate_rep.expires_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file" => intermediate_rep.file.push(<models::OpenAiFile as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Upload".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Upload {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in Upload".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in Upload".to_string())?,
            filename: intermediate_rep.filename.into_iter().next().ok_or_else(|| "filename missing in Upload".to_string())?,
            bytes: intermediate_rep.bytes.into_iter().next().ok_or_else(|| "bytes missing in Upload".to_string())?,
            purpose: intermediate_rep.purpose.into_iter().next().ok_or_else(|| "purpose missing in Upload".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in Upload".to_string())?,
            expires_at: intermediate_rep.expires_at.into_iter().next().ok_or_else(|| "expires_at missing in Upload".to_string())?,
            object: intermediate_rep.object.into_iter().next(),
            file: intermediate_rep.file.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Upload> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Upload>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Upload>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for Upload - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Upload> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Upload as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into Upload - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The upload Part represents a chunk of bytes we can add to an Upload object. 
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UploadPart {
    /// The upload Part unique identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The Unix timestamp (in seconds) for when the Part was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    /// The ID of the Upload object that this Part was added to.
    #[serde(rename = "upload_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub upload_id: String,

    /// The object type, which is always `upload.part`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

}



impl UploadPart {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, created_at: i32, upload_id: String, object: String, ) -> UploadPart {
        UploadPart {
 id,
 created_at,
 upload_id,
 object,
        }
    }
}

/// Converts the UploadPart value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UploadPart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("upload_id".to_string()),
            Some(self.upload_id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UploadPart value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UploadPart {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub created_at: Vec<i32>,
            pub upload_id: Vec<String>,
            pub object: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UploadPart".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "upload_id" => intermediate_rep.upload_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UploadPart".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UploadPart {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in UploadPart".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in UploadPart".to_string())?,
            upload_id: intermediate_rep.upload_id.into_iter().next().ok_or_else(|| "upload_id missing in UploadPart".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in UploadPart".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UploadPart> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UploadPart>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UploadPart>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for UploadPart - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UploadPart> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UploadPart as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into UploadPart - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The aggregated audio speeches usage details of the specific time bucket.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UsageAudioSpeechesResult {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The number of characters processed.
    #[serde(rename = "characters")]
    pub characters: i32,

    /// The count of requests made to the model.
    #[serde(rename = "num_model_requests")]
    pub num_model_requests: i32,

    /// When `group_by=project_id`, this field provides the project ID of the grouped usage result.
    #[serde(rename = "project_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_id: Option<Nullable<String>>,

    /// When `group_by=user_id`, this field provides the user ID of the grouped usage result.
    #[serde(rename = "user_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_id: Option<Nullable<String>>,

    /// When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
    #[serde(rename = "api_key_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key_id: Option<Nullable<String>>,

    /// When `group_by=model`, this field provides the model name of the grouped usage result.
    #[serde(rename = "model")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<Nullable<String>>,

}



impl UsageAudioSpeechesResult {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, characters: i32, num_model_requests: i32, ) -> UsageAudioSpeechesResult {
        UsageAudioSpeechesResult {
 object,
 characters,
 num_model_requests,
 project_id: None,
 user_id: None,
 api_key_id: None,
 model: None,
        }
    }
}

/// Converts the UsageAudioSpeechesResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UsageAudioSpeechesResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("characters".to_string()),
            Some(self.characters.to_string()),


            Some("num_model_requests".to_string()),
            Some(self.num_model_requests.to_string()),


            self.project_id.as_ref().map(|project_id| {
                [
                    "project_id".to_string(),
                    project_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.user_id.as_ref().map(|user_id| {
                [
                    "user_id".to_string(),
                    user_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.api_key_id.as_ref().map(|api_key_id| {
                [
                    "api_key_id".to_string(),
                    api_key_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.model.as_ref().map(|model| {
                [
                    "model".to_string(),
                    model.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UsageAudioSpeechesResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UsageAudioSpeechesResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub characters: Vec<i32>,
            pub num_model_requests: Vec<i32>,
            pub project_id: Vec<String>,
            pub user_id: Vec<String>,
            pub api_key_id: Vec<String>,
            pub model: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UsageAudioSpeechesResult".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "characters" => intermediate_rep.characters.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "num_model_requests" => intermediate_rep.num_model_requests.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "project_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageAudioSpeechesResult".to_string()),
                    "user_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageAudioSpeechesResult".to_string()),
                    "api_key_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageAudioSpeechesResult".to_string()),
                    "model" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageAudioSpeechesResult".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UsageAudioSpeechesResult".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UsageAudioSpeechesResult {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in UsageAudioSpeechesResult".to_string())?,
            characters: intermediate_rep.characters.into_iter().next().ok_or_else(|| "characters missing in UsageAudioSpeechesResult".to_string())?,
            num_model_requests: intermediate_rep.num_model_requests.into_iter().next().ok_or_else(|| "num_model_requests missing in UsageAudioSpeechesResult".to_string())?,
            project_id: std::result::Result::Err("Nullable types not supported in UsageAudioSpeechesResult".to_string())?,
            user_id: std::result::Result::Err("Nullable types not supported in UsageAudioSpeechesResult".to_string())?,
            api_key_id: std::result::Result::Err("Nullable types not supported in UsageAudioSpeechesResult".to_string())?,
            model: std::result::Result::Err("Nullable types not supported in UsageAudioSpeechesResult".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UsageAudioSpeechesResult> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UsageAudioSpeechesResult>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UsageAudioSpeechesResult>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for UsageAudioSpeechesResult - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UsageAudioSpeechesResult> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UsageAudioSpeechesResult as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into UsageAudioSpeechesResult - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The aggregated audio transcriptions usage details of the specific time bucket.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UsageAudioTranscriptionsResult {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The number of seconds processed.
    #[serde(rename = "seconds")]
    pub seconds: i32,

    /// The count of requests made to the model.
    #[serde(rename = "num_model_requests")]
    pub num_model_requests: i32,

    /// When `group_by=project_id`, this field provides the project ID of the grouped usage result.
    #[serde(rename = "project_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_id: Option<Nullable<String>>,

    /// When `group_by=user_id`, this field provides the user ID of the grouped usage result.
    #[serde(rename = "user_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_id: Option<Nullable<String>>,

    /// When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
    #[serde(rename = "api_key_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key_id: Option<Nullable<String>>,

    /// When `group_by=model`, this field provides the model name of the grouped usage result.
    #[serde(rename = "model")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<Nullable<String>>,

}



impl UsageAudioTranscriptionsResult {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, seconds: i32, num_model_requests: i32, ) -> UsageAudioTranscriptionsResult {
        UsageAudioTranscriptionsResult {
 object,
 seconds,
 num_model_requests,
 project_id: None,
 user_id: None,
 api_key_id: None,
 model: None,
        }
    }
}

/// Converts the UsageAudioTranscriptionsResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UsageAudioTranscriptionsResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("seconds".to_string()),
            Some(self.seconds.to_string()),


            Some("num_model_requests".to_string()),
            Some(self.num_model_requests.to_string()),


            self.project_id.as_ref().map(|project_id| {
                [
                    "project_id".to_string(),
                    project_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.user_id.as_ref().map(|user_id| {
                [
                    "user_id".to_string(),
                    user_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.api_key_id.as_ref().map(|api_key_id| {
                [
                    "api_key_id".to_string(),
                    api_key_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.model.as_ref().map(|model| {
                [
                    "model".to_string(),
                    model.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UsageAudioTranscriptionsResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UsageAudioTranscriptionsResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub seconds: Vec<i32>,
            pub num_model_requests: Vec<i32>,
            pub project_id: Vec<String>,
            pub user_id: Vec<String>,
            pub api_key_id: Vec<String>,
            pub model: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UsageAudioTranscriptionsResult".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "seconds" => intermediate_rep.seconds.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "num_model_requests" => intermediate_rep.num_model_requests.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "project_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageAudioTranscriptionsResult".to_string()),
                    "user_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageAudioTranscriptionsResult".to_string()),
                    "api_key_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageAudioTranscriptionsResult".to_string()),
                    "model" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageAudioTranscriptionsResult".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UsageAudioTranscriptionsResult".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UsageAudioTranscriptionsResult {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in UsageAudioTranscriptionsResult".to_string())?,
            seconds: intermediate_rep.seconds.into_iter().next().ok_or_else(|| "seconds missing in UsageAudioTranscriptionsResult".to_string())?,
            num_model_requests: intermediate_rep.num_model_requests.into_iter().next().ok_or_else(|| "num_model_requests missing in UsageAudioTranscriptionsResult".to_string())?,
            project_id: std::result::Result::Err("Nullable types not supported in UsageAudioTranscriptionsResult".to_string())?,
            user_id: std::result::Result::Err("Nullable types not supported in UsageAudioTranscriptionsResult".to_string())?,
            api_key_id: std::result::Result::Err("Nullable types not supported in UsageAudioTranscriptionsResult".to_string())?,
            model: std::result::Result::Err("Nullable types not supported in UsageAudioTranscriptionsResult".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UsageAudioTranscriptionsResult> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UsageAudioTranscriptionsResult>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UsageAudioTranscriptionsResult>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for UsageAudioTranscriptionsResult - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UsageAudioTranscriptionsResult> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UsageAudioTranscriptionsResult as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into UsageAudioTranscriptionsResult - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The aggregated code interpreter sessions usage details of the specific time bucket.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UsageCodeInterpreterSessionsResult {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The number of code interpreter sessions.
    #[serde(rename = "sessions")]
    pub sessions: i32,

    /// When `group_by=project_id`, this field provides the project ID of the grouped usage result.
    #[serde(rename = "project_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_id: Option<Nullable<String>>,

}



impl UsageCodeInterpreterSessionsResult {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, sessions: i32, ) -> UsageCodeInterpreterSessionsResult {
        UsageCodeInterpreterSessionsResult {
 object,
 sessions,
 project_id: None,
        }
    }
}

/// Converts the UsageCodeInterpreterSessionsResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UsageCodeInterpreterSessionsResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("sessions".to_string()),
            Some(self.sessions.to_string()),


            self.project_id.as_ref().map(|project_id| {
                [
                    "project_id".to_string(),
                    project_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UsageCodeInterpreterSessionsResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UsageCodeInterpreterSessionsResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub sessions: Vec<i32>,
            pub project_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UsageCodeInterpreterSessionsResult".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sessions" => intermediate_rep.sessions.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "project_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageCodeInterpreterSessionsResult".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UsageCodeInterpreterSessionsResult".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UsageCodeInterpreterSessionsResult {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in UsageCodeInterpreterSessionsResult".to_string())?,
            sessions: intermediate_rep.sessions.into_iter().next().ok_or_else(|| "sessions missing in UsageCodeInterpreterSessionsResult".to_string())?,
            project_id: std::result::Result::Err("Nullable types not supported in UsageCodeInterpreterSessionsResult".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UsageCodeInterpreterSessionsResult> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UsageCodeInterpreterSessionsResult>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UsageCodeInterpreterSessionsResult>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for UsageCodeInterpreterSessionsResult - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UsageCodeInterpreterSessionsResult> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UsageCodeInterpreterSessionsResult as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into UsageCodeInterpreterSessionsResult - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The aggregated completions usage details of the specific time bucket.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UsageCompletionsResult {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The aggregated number of text input tokens used, including cached tokens. For customers subscribe to scale tier, this includes scale tier tokens.
    #[serde(rename = "input_tokens")]
    pub input_tokens: i32,

    /// The aggregated number of text input tokens that has been cached from previous requests. For customers subscribe to scale tier, this includes scale tier tokens.
    #[serde(rename = "input_cached_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub input_cached_tokens: Option<i32>,

    /// The aggregated number of text output tokens used. For customers subscribe to scale tier, this includes scale tier tokens.
    #[serde(rename = "output_tokens")]
    pub output_tokens: i32,

    /// The aggregated number of audio input tokens used, including cached tokens.
    #[serde(rename = "input_audio_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub input_audio_tokens: Option<i32>,

    /// The aggregated number of audio output tokens used.
    #[serde(rename = "output_audio_tokens")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub output_audio_tokens: Option<i32>,

    /// The count of requests made to the model.
    #[serde(rename = "num_model_requests")]
    pub num_model_requests: i32,

    /// When `group_by=project_id`, this field provides the project ID of the grouped usage result.
    #[serde(rename = "project_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_id: Option<Nullable<String>>,

    /// When `group_by=user_id`, this field provides the user ID of the grouped usage result.
    #[serde(rename = "user_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_id: Option<Nullable<String>>,

    /// When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
    #[serde(rename = "api_key_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key_id: Option<Nullable<String>>,

    /// When `group_by=model`, this field provides the model name of the grouped usage result.
    #[serde(rename = "model")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<Nullable<String>>,

    /// When `group_by=batch`, this field tells whether the grouped usage result is batch or not.
    #[serde(rename = "batch")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub batch: Option<Nullable<bool>>,

}



impl UsageCompletionsResult {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, input_tokens: i32, output_tokens: i32, num_model_requests: i32, ) -> UsageCompletionsResult {
        UsageCompletionsResult {
 object,
 input_tokens,
 input_cached_tokens: None,
 output_tokens,
 input_audio_tokens: None,
 output_audio_tokens: None,
 num_model_requests,
 project_id: None,
 user_id: None,
 api_key_id: None,
 model: None,
 batch: None,
        }
    }
}

/// Converts the UsageCompletionsResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UsageCompletionsResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("input_tokens".to_string()),
            Some(self.input_tokens.to_string()),


            self.input_cached_tokens.as_ref().map(|input_cached_tokens| {
                [
                    "input_cached_tokens".to_string(),
                    input_cached_tokens.to_string(),
                ].join(",")
            }),


            Some("output_tokens".to_string()),
            Some(self.output_tokens.to_string()),


            self.input_audio_tokens.as_ref().map(|input_audio_tokens| {
                [
                    "input_audio_tokens".to_string(),
                    input_audio_tokens.to_string(),
                ].join(",")
            }),


            self.output_audio_tokens.as_ref().map(|output_audio_tokens| {
                [
                    "output_audio_tokens".to_string(),
                    output_audio_tokens.to_string(),
                ].join(",")
            }),


            Some("num_model_requests".to_string()),
            Some(self.num_model_requests.to_string()),


            self.project_id.as_ref().map(|project_id| {
                [
                    "project_id".to_string(),
                    project_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.user_id.as_ref().map(|user_id| {
                [
                    "user_id".to_string(),
                    user_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.api_key_id.as_ref().map(|api_key_id| {
                [
                    "api_key_id".to_string(),
                    api_key_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.model.as_ref().map(|model| {
                [
                    "model".to_string(),
                    model.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.batch.as_ref().map(|batch| {
                [
                    "batch".to_string(),
                    batch.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UsageCompletionsResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UsageCompletionsResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub input_tokens: Vec<i32>,
            pub input_cached_tokens: Vec<i32>,
            pub output_tokens: Vec<i32>,
            pub input_audio_tokens: Vec<i32>,
            pub output_audio_tokens: Vec<i32>,
            pub num_model_requests: Vec<i32>,
            pub project_id: Vec<String>,
            pub user_id: Vec<String>,
            pub api_key_id: Vec<String>,
            pub model: Vec<String>,
            pub batch: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UsageCompletionsResult".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input_tokens" => intermediate_rep.input_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input_cached_tokens" => intermediate_rep.input_cached_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_tokens" => intermediate_rep.output_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input_audio_tokens" => intermediate_rep.input_audio_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "output_audio_tokens" => intermediate_rep.output_audio_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "num_model_requests" => intermediate_rep.num_model_requests.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "project_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageCompletionsResult".to_string()),
                    "user_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageCompletionsResult".to_string()),
                    "api_key_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageCompletionsResult".to_string()),
                    "model" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageCompletionsResult".to_string()),
                    "batch" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageCompletionsResult".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UsageCompletionsResult".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UsageCompletionsResult {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in UsageCompletionsResult".to_string())?,
            input_tokens: intermediate_rep.input_tokens.into_iter().next().ok_or_else(|| "input_tokens missing in UsageCompletionsResult".to_string())?,
            input_cached_tokens: intermediate_rep.input_cached_tokens.into_iter().next(),
            output_tokens: intermediate_rep.output_tokens.into_iter().next().ok_or_else(|| "output_tokens missing in UsageCompletionsResult".to_string())?,
            input_audio_tokens: intermediate_rep.input_audio_tokens.into_iter().next(),
            output_audio_tokens: intermediate_rep.output_audio_tokens.into_iter().next(),
            num_model_requests: intermediate_rep.num_model_requests.into_iter().next().ok_or_else(|| "num_model_requests missing in UsageCompletionsResult".to_string())?,
            project_id: std::result::Result::Err("Nullable types not supported in UsageCompletionsResult".to_string())?,
            user_id: std::result::Result::Err("Nullable types not supported in UsageCompletionsResult".to_string())?,
            api_key_id: std::result::Result::Err("Nullable types not supported in UsageCompletionsResult".to_string())?,
            model: std::result::Result::Err("Nullable types not supported in UsageCompletionsResult".to_string())?,
            batch: std::result::Result::Err("Nullable types not supported in UsageCompletionsResult".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UsageCompletionsResult> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UsageCompletionsResult>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UsageCompletionsResult>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for UsageCompletionsResult - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UsageCompletionsResult> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UsageCompletionsResult as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into UsageCompletionsResult - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The aggregated embeddings usage details of the specific time bucket.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UsageEmbeddingsResult {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The aggregated number of input tokens used.
    #[serde(rename = "input_tokens")]
    pub input_tokens: i32,

    /// The count of requests made to the model.
    #[serde(rename = "num_model_requests")]
    pub num_model_requests: i32,

    /// When `group_by=project_id`, this field provides the project ID of the grouped usage result.
    #[serde(rename = "project_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_id: Option<Nullable<String>>,

    /// When `group_by=user_id`, this field provides the user ID of the grouped usage result.
    #[serde(rename = "user_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_id: Option<Nullable<String>>,

    /// When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
    #[serde(rename = "api_key_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key_id: Option<Nullable<String>>,

    /// When `group_by=model`, this field provides the model name of the grouped usage result.
    #[serde(rename = "model")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<Nullable<String>>,

}



impl UsageEmbeddingsResult {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, input_tokens: i32, num_model_requests: i32, ) -> UsageEmbeddingsResult {
        UsageEmbeddingsResult {
 object,
 input_tokens,
 num_model_requests,
 project_id: None,
 user_id: None,
 api_key_id: None,
 model: None,
        }
    }
}

/// Converts the UsageEmbeddingsResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UsageEmbeddingsResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("input_tokens".to_string()),
            Some(self.input_tokens.to_string()),


            Some("num_model_requests".to_string()),
            Some(self.num_model_requests.to_string()),


            self.project_id.as_ref().map(|project_id| {
                [
                    "project_id".to_string(),
                    project_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.user_id.as_ref().map(|user_id| {
                [
                    "user_id".to_string(),
                    user_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.api_key_id.as_ref().map(|api_key_id| {
                [
                    "api_key_id".to_string(),
                    api_key_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.model.as_ref().map(|model| {
                [
                    "model".to_string(),
                    model.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UsageEmbeddingsResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UsageEmbeddingsResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub input_tokens: Vec<i32>,
            pub num_model_requests: Vec<i32>,
            pub project_id: Vec<String>,
            pub user_id: Vec<String>,
            pub api_key_id: Vec<String>,
            pub model: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UsageEmbeddingsResult".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input_tokens" => intermediate_rep.input_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "num_model_requests" => intermediate_rep.num_model_requests.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "project_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageEmbeddingsResult".to_string()),
                    "user_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageEmbeddingsResult".to_string()),
                    "api_key_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageEmbeddingsResult".to_string()),
                    "model" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageEmbeddingsResult".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UsageEmbeddingsResult".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UsageEmbeddingsResult {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in UsageEmbeddingsResult".to_string())?,
            input_tokens: intermediate_rep.input_tokens.into_iter().next().ok_or_else(|| "input_tokens missing in UsageEmbeddingsResult".to_string())?,
            num_model_requests: intermediate_rep.num_model_requests.into_iter().next().ok_or_else(|| "num_model_requests missing in UsageEmbeddingsResult".to_string())?,
            project_id: std::result::Result::Err("Nullable types not supported in UsageEmbeddingsResult".to_string())?,
            user_id: std::result::Result::Err("Nullable types not supported in UsageEmbeddingsResult".to_string())?,
            api_key_id: std::result::Result::Err("Nullable types not supported in UsageEmbeddingsResult".to_string())?,
            model: std::result::Result::Err("Nullable types not supported in UsageEmbeddingsResult".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UsageEmbeddingsResult> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UsageEmbeddingsResult>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UsageEmbeddingsResult>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for UsageEmbeddingsResult - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UsageEmbeddingsResult> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UsageEmbeddingsResult as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into UsageEmbeddingsResult - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The aggregated images usage details of the specific time bucket.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UsageImagesResult {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The number of images processed.
    #[serde(rename = "images")]
    pub images: i32,

    /// The count of requests made to the model.
    #[serde(rename = "num_model_requests")]
    pub num_model_requests: i32,

    /// When `group_by=source`, this field provides the source of the grouped usage result, possible values are `image.generation`, `image.edit`, `image.variation`.
    #[serde(rename = "source")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<Nullable<String>>,

    /// When `group_by=size`, this field provides the image size of the grouped usage result.
    #[serde(rename = "size")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<Nullable<String>>,

    /// When `group_by=project_id`, this field provides the project ID of the grouped usage result.
    #[serde(rename = "project_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_id: Option<Nullable<String>>,

    /// When `group_by=user_id`, this field provides the user ID of the grouped usage result.
    #[serde(rename = "user_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_id: Option<Nullable<String>>,

    /// When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
    #[serde(rename = "api_key_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key_id: Option<Nullable<String>>,

    /// When `group_by=model`, this field provides the model name of the grouped usage result.
    #[serde(rename = "model")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<Nullable<String>>,

}



impl UsageImagesResult {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, images: i32, num_model_requests: i32, ) -> UsageImagesResult {
        UsageImagesResult {
 object,
 images,
 num_model_requests,
 source: None,
 size: None,
 project_id: None,
 user_id: None,
 api_key_id: None,
 model: None,
        }
    }
}

/// Converts the UsageImagesResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UsageImagesResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("images".to_string()),
            Some(self.images.to_string()),


            Some("num_model_requests".to_string()),
            Some(self.num_model_requests.to_string()),


            self.source.as_ref().map(|source| {
                [
                    "source".to_string(),
                    source.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.size.as_ref().map(|size| {
                [
                    "size".to_string(),
                    size.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.project_id.as_ref().map(|project_id| {
                [
                    "project_id".to_string(),
                    project_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.user_id.as_ref().map(|user_id| {
                [
                    "user_id".to_string(),
                    user_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.api_key_id.as_ref().map(|api_key_id| {
                [
                    "api_key_id".to_string(),
                    api_key_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.model.as_ref().map(|model| {
                [
                    "model".to_string(),
                    model.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UsageImagesResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UsageImagesResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub images: Vec<i32>,
            pub num_model_requests: Vec<i32>,
            pub source: Vec<String>,
            pub size: Vec<String>,
            pub project_id: Vec<String>,
            pub user_id: Vec<String>,
            pub api_key_id: Vec<String>,
            pub model: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UsageImagesResult".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "images" => intermediate_rep.images.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "num_model_requests" => intermediate_rep.num_model_requests.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "source" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageImagesResult".to_string()),
                    "size" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageImagesResult".to_string()),
                    "project_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageImagesResult".to_string()),
                    "user_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageImagesResult".to_string()),
                    "api_key_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageImagesResult".to_string()),
                    "model" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageImagesResult".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UsageImagesResult".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UsageImagesResult {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in UsageImagesResult".to_string())?,
            images: intermediate_rep.images.into_iter().next().ok_or_else(|| "images missing in UsageImagesResult".to_string())?,
            num_model_requests: intermediate_rep.num_model_requests.into_iter().next().ok_or_else(|| "num_model_requests missing in UsageImagesResult".to_string())?,
            source: std::result::Result::Err("Nullable types not supported in UsageImagesResult".to_string())?,
            size: std::result::Result::Err("Nullable types not supported in UsageImagesResult".to_string())?,
            project_id: std::result::Result::Err("Nullable types not supported in UsageImagesResult".to_string())?,
            user_id: std::result::Result::Err("Nullable types not supported in UsageImagesResult".to_string())?,
            api_key_id: std::result::Result::Err("Nullable types not supported in UsageImagesResult".to_string())?,
            model: std::result::Result::Err("Nullable types not supported in UsageImagesResult".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UsageImagesResult> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UsageImagesResult>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UsageImagesResult>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for UsageImagesResult - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UsageImagesResult> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UsageImagesResult as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into UsageImagesResult - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The aggregated moderations usage details of the specific time bucket.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UsageModerationsResult {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The aggregated number of input tokens used.
    #[serde(rename = "input_tokens")]
    pub input_tokens: i32,

    /// The count of requests made to the model.
    #[serde(rename = "num_model_requests")]
    pub num_model_requests: i32,

    /// When `group_by=project_id`, this field provides the project ID of the grouped usage result.
    #[serde(rename = "project_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_id: Option<Nullable<String>>,

    /// When `group_by=user_id`, this field provides the user ID of the grouped usage result.
    #[serde(rename = "user_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_id: Option<Nullable<String>>,

    /// When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
    #[serde(rename = "api_key_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_key_id: Option<Nullable<String>>,

    /// When `group_by=model`, this field provides the model name of the grouped usage result.
    #[serde(rename = "model")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub model: Option<Nullable<String>>,

}



impl UsageModerationsResult {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, input_tokens: i32, num_model_requests: i32, ) -> UsageModerationsResult {
        UsageModerationsResult {
 object,
 input_tokens,
 num_model_requests,
 project_id: None,
 user_id: None,
 api_key_id: None,
 model: None,
        }
    }
}

/// Converts the UsageModerationsResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UsageModerationsResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("input_tokens".to_string()),
            Some(self.input_tokens.to_string()),


            Some("num_model_requests".to_string()),
            Some(self.num_model_requests.to_string()),


            self.project_id.as_ref().map(|project_id| {
                [
                    "project_id".to_string(),
                    project_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.user_id.as_ref().map(|user_id| {
                [
                    "user_id".to_string(),
                    user_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.api_key_id.as_ref().map(|api_key_id| {
                [
                    "api_key_id".to_string(),
                    api_key_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.model.as_ref().map(|model| {
                [
                    "model".to_string(),
                    model.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UsageModerationsResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UsageModerationsResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub input_tokens: Vec<i32>,
            pub num_model_requests: Vec<i32>,
            pub project_id: Vec<String>,
            pub user_id: Vec<String>,
            pub api_key_id: Vec<String>,
            pub model: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UsageModerationsResult".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "input_tokens" => intermediate_rep.input_tokens.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "num_model_requests" => intermediate_rep.num_model_requests.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "project_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageModerationsResult".to_string()),
                    "user_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageModerationsResult".to_string()),
                    "api_key_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageModerationsResult".to_string()),
                    "model" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageModerationsResult".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UsageModerationsResult".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UsageModerationsResult {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in UsageModerationsResult".to_string())?,
            input_tokens: intermediate_rep.input_tokens.into_iter().next().ok_or_else(|| "input_tokens missing in UsageModerationsResult".to_string())?,
            num_model_requests: intermediate_rep.num_model_requests.into_iter().next().ok_or_else(|| "num_model_requests missing in UsageModerationsResult".to_string())?,
            project_id: std::result::Result::Err("Nullable types not supported in UsageModerationsResult".to_string())?,
            user_id: std::result::Result::Err("Nullable types not supported in UsageModerationsResult".to_string())?,
            api_key_id: std::result::Result::Err("Nullable types not supported in UsageModerationsResult".to_string())?,
            model: std::result::Result::Err("Nullable types not supported in UsageModerationsResult".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UsageModerationsResult> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UsageModerationsResult>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UsageModerationsResult>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for UsageModerationsResult - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UsageModerationsResult> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UsageModerationsResult as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into UsageModerationsResult - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UsageResponse {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::UsageTimeBucket>,

    #[serde(rename = "has_more")]
    pub has_more: bool,

    #[serde(rename = "next_page")]
          #[validate(custom(function = "check_xss_string"))]
    pub next_page: String,

}



impl UsageResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::UsageTimeBucket>, has_more: bool, next_page: String, ) -> UsageResponse {
        UsageResponse {
 object,
 data,
 has_more,
 next_page,
        }
    }
}

/// Converts the UsageResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UsageResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),


            Some("next_page".to_string()),
            Some(self.next_page.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UsageResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UsageResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::UsageTimeBucket>>,
            pub has_more: Vec<bool>,
            pub next_page: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UsageResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in UsageResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next_page" => intermediate_rep.next_page.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UsageResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UsageResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in UsageResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in UsageResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in UsageResponse".to_string())?,
            next_page: intermediate_rep.next_page.into_iter().next().ok_or_else(|| "next_page missing in UsageResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UsageResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UsageResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UsageResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for UsageResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UsageResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UsageResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into UsageResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UsageTimeBucket {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "start_time")]
    pub start_time: i32,

    #[serde(rename = "end_time")]
    pub end_time: i32,

    #[serde(rename = "result")]
          #[validate(nested)]
    pub result: Vec<models::UsageTimeBucketResultInner>,

}



impl UsageTimeBucket {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, start_time: i32, end_time: i32, result: Vec<models::UsageTimeBucketResultInner>, ) -> UsageTimeBucket {
        UsageTimeBucket {
 object,
 start_time,
 end_time,
 result,
        }
    }
}

/// Converts the UsageTimeBucket value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UsageTimeBucket {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("start_time".to_string()),
            Some(self.start_time.to_string()),


            Some("end_time".to_string()),
            Some(self.end_time.to_string()),

            // Skipping result in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UsageTimeBucket value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UsageTimeBucket {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub start_time: Vec<i32>,
            pub end_time: Vec<i32>,
            pub result: Vec<Vec<models::UsageTimeBucketResultInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UsageTimeBucket".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "start_time" => intermediate_rep.start_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "end_time" => intermediate_rep.end_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "result" => return std::result::Result::Err("Parsing a container in this style is not supported in UsageTimeBucket".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UsageTimeBucket".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UsageTimeBucket {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in UsageTimeBucket".to_string())?,
            start_time: intermediate_rep.start_time.into_iter().next().ok_or_else(|| "start_time missing in UsageTimeBucket".to_string())?,
            end_time: intermediate_rep.end_time.into_iter().next().ok_or_else(|| "end_time missing in UsageTimeBucket".to_string())?,
            result: intermediate_rep.result.into_iter().next().ok_or_else(|| "result missing in UsageTimeBucket".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UsageTimeBucket> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UsageTimeBucket>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UsageTimeBucket>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for UsageTimeBucket - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UsageTimeBucket> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UsageTimeBucket as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into UsageTimeBucket - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum UsageTimeBucketResultInner {
    UsageCompletionsResult(models::UsageCompletionsResult),
    UsageEmbeddingsResult(models::UsageEmbeddingsResult),
    UsageModerationsResult(models::UsageModerationsResult),
    UsageImagesResult(models::UsageImagesResult),
    UsageAudioSpeechesResult(models::UsageAudioSpeechesResult),
    UsageAudioTranscriptionsResult(models::UsageAudioTranscriptionsResult),
    UsageVectorStoresResult(models::UsageVectorStoresResult),
    UsageCodeInterpreterSessionsResult(models::UsageCodeInterpreterSessionsResult),
    CostsResult(models::CostsResult),
}

impl validator::Validate for UsageTimeBucketResultInner
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::UsageCompletionsResult(v) => v.validate(),
            Self::UsageEmbeddingsResult(v) => v.validate(),
            Self::UsageModerationsResult(v) => v.validate(),
            Self::UsageImagesResult(v) => v.validate(),
            Self::UsageAudioSpeechesResult(v) => v.validate(),
            Self::UsageAudioTranscriptionsResult(v) => v.validate(),
            Self::UsageVectorStoresResult(v) => v.validate(),
            Self::UsageCodeInterpreterSessionsResult(v) => v.validate(),
            Self::CostsResult(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UsageTimeBucketResultInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UsageTimeBucketResultInner {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::UsageCompletionsResult> for UsageTimeBucketResultInner {
    fn from(value: models::UsageCompletionsResult) -> Self {
        Self::UsageCompletionsResult(value)
    }
}
impl From<models::UsageEmbeddingsResult> for UsageTimeBucketResultInner {
    fn from(value: models::UsageEmbeddingsResult) -> Self {
        Self::UsageEmbeddingsResult(value)
    }
}
impl From<models::UsageModerationsResult> for UsageTimeBucketResultInner {
    fn from(value: models::UsageModerationsResult) -> Self {
        Self::UsageModerationsResult(value)
    }
}
impl From<models::UsageImagesResult> for UsageTimeBucketResultInner {
    fn from(value: models::UsageImagesResult) -> Self {
        Self::UsageImagesResult(value)
    }
}
impl From<models::UsageAudioSpeechesResult> for UsageTimeBucketResultInner {
    fn from(value: models::UsageAudioSpeechesResult) -> Self {
        Self::UsageAudioSpeechesResult(value)
    }
}
impl From<models::UsageAudioTranscriptionsResult> for UsageTimeBucketResultInner {
    fn from(value: models::UsageAudioTranscriptionsResult) -> Self {
        Self::UsageAudioTranscriptionsResult(value)
    }
}
impl From<models::UsageVectorStoresResult> for UsageTimeBucketResultInner {
    fn from(value: models::UsageVectorStoresResult) -> Self {
        Self::UsageVectorStoresResult(value)
    }
}
impl From<models::UsageCodeInterpreterSessionsResult> for UsageTimeBucketResultInner {
    fn from(value: models::UsageCodeInterpreterSessionsResult) -> Self {
        Self::UsageCodeInterpreterSessionsResult(value)
    }
}
impl From<models::CostsResult> for UsageTimeBucketResultInner {
    fn from(value: models::CostsResult) -> Self {
        Self::CostsResult(value)
    }
}





/// The aggregated vector stores usage details of the specific time bucket.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UsageVectorStoresResult {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The vector stores usage in bytes.
    #[serde(rename = "usage_bytes")]
    pub usage_bytes: i32,

    /// When `group_by=project_id`, this field provides the project ID of the grouped usage result.
    #[serde(rename = "project_id")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_id: Option<Nullable<String>>,

}



impl UsageVectorStoresResult {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, usage_bytes: i32, ) -> UsageVectorStoresResult {
        UsageVectorStoresResult {
 object,
 usage_bytes,
 project_id: None,
        }
    }
}

/// Converts the UsageVectorStoresResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UsageVectorStoresResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("usage_bytes".to_string()),
            Some(self.usage_bytes.to_string()),


            self.project_id.as_ref().map(|project_id| {
                [
                    "project_id".to_string(),
                    project_id.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UsageVectorStoresResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UsageVectorStoresResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub usage_bytes: Vec<i32>,
            pub project_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UsageVectorStoresResult".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usage_bytes" => intermediate_rep.usage_bytes.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "project_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in UsageVectorStoresResult".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing UsageVectorStoresResult".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UsageVectorStoresResult {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in UsageVectorStoresResult".to_string())?,
            usage_bytes: intermediate_rep.usage_bytes.into_iter().next().ok_or_else(|| "usage_bytes missing in UsageVectorStoresResult".to_string())?,
            project_id: std::result::Result::Err("Nullable types not supported in UsageVectorStoresResult".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UsageVectorStoresResult> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UsageVectorStoresResult>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UsageVectorStoresResult>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for UsageVectorStoresResult - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UsageVectorStoresResult> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UsageVectorStoresResult as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into UsageVectorStoresResult - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Represents an individual `user` within an organization.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct User {
    /// The object type, which is always `organization.user`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The identifier, which can be referenced in API endpoints
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The name of the user
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    /// The email address of the user
    #[serde(rename = "email")]
          #[validate(custom(function = "check_xss_string"))]
    pub email: String,

    /// `owner` or `reader`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

    /// The Unix timestamp (in seconds) of when the user was added.
    #[serde(rename = "added_at")]
    pub added_at: i32,

}



impl User {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, id: String, name: String, email: String, role: String, added_at: i32, ) -> User {
        User {
 object,
 id,
 name,
 email,
 role,
 added_at,
        }
    }
}

/// Converts the User value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for User {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("email".to_string()),
            Some(self.email.to_string()),


            Some("role".to_string()),
            Some(self.role.to_string()),


            Some("added_at".to_string()),
            Some(self.added_at.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a User value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for User {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub email: Vec<String>,
            pub role: Vec<String>,
            pub added_at: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing User".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "email" => intermediate_rep.email.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "added_at" => intermediate_rep.added_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing User".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(User {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in User".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in User".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in User".to_string())?,
            email: intermediate_rep.email.into_iter().next().ok_or_else(|| "email missing in User".to_string())?,
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in User".to_string())?,
            added_at: intermediate_rep.added_at.into_iter().next().ok_or_else(|| "added_at missing in User".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<User> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<User>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<User>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for User - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<User> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <User as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into User - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserDeleteResponse {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    #[serde(rename = "deleted")]
    pub deleted: bool,

}



impl UserDeleteResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, id: String, deleted: bool, ) -> UserDeleteResponse {
        UserDeleteResponse {
 object,
 id,
 deleted,
        }
    }
}

/// Converts the UserDeleteResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UserDeleteResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("deleted".to_string()),
            Some(self.deleted.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserDeleteResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserDeleteResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub id: Vec<String>,
            pub deleted: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserDeleteResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "deleted" => intermediate_rep.deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserDeleteResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserDeleteResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in UserDeleteResponse".to_string())?,
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in UserDeleteResponse".to_string())?,
            deleted: intermediate_rep.deleted.into_iter().next().ok_or_else(|| "deleted missing in UserDeleteResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserDeleteResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UserDeleteResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserDeleteResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for UserDeleteResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UserDeleteResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserDeleteResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into UserDeleteResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserListResponse {
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    #[serde(rename = "data")]
          #[validate(nested)]
    pub data: Vec<models::User>,

    #[serde(rename = "first_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub first_id: String,

    #[serde(rename = "last_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub last_id: String,

    #[serde(rename = "has_more")]
    pub has_more: bool,

}



impl UserListResponse {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(object: String, data: Vec<models::User>, first_id: String, last_id: String, has_more: bool, ) -> UserListResponse {
        UserListResponse {
 object,
 data,
 first_id,
 last_id,
 has_more,
        }
    }
}

/// Converts the UserListResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UserListResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("object".to_string()),
            Some(self.object.to_string()),

            // Skipping data in query parameter serialization


            Some("first_id".to_string()),
            Some(self.first_id.to_string()),


            Some("last_id".to_string()),
            Some(self.last_id.to_string()),


            Some("has_more".to_string()),
            Some(self.has_more.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserListResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserListResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub object: Vec<String>,
            pub data: Vec<Vec<models::User>>,
            pub first_id: Vec<String>,
            pub last_id: Vec<String>,
            pub has_more: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserListResponse".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "data" => return std::result::Result::Err("Parsing a container in this style is not supported in UserListResponse".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "first_id" => intermediate_rep.first_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "last_id" => intermediate_rep.last_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "has_more" => intermediate_rep.has_more.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserListResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserListResponse {
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in UserListResponse".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or_else(|| "data missing in UserListResponse".to_string())?,
            first_id: intermediate_rep.first_id.into_iter().next().ok_or_else(|| "first_id missing in UserListResponse".to_string())?,
            last_id: intermediate_rep.last_id.into_iter().next().ok_or_else(|| "last_id missing in UserListResponse".to_string())?,
            has_more: intermediate_rep.has_more.into_iter().next().ok_or_else(|| "has_more missing in UserListResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserListResponse> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UserListResponse>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserListResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for UserListResponse - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UserListResponse> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserListResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into UserListResponse - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct UserRoleUpdateRequest {
    /// `owner` or `reader`
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "role")]
          #[validate(custom(function = "check_xss_string"))]
    pub role: String,

}



impl UserRoleUpdateRequest {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(role: String, ) -> UserRoleUpdateRequest {
        UserRoleUpdateRequest {
 role,
        }
    }
}

/// Converts the UserRoleUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for UserRoleUpdateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("role".to_string()),
            Some(self.role.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a UserRoleUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for UserRoleUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub role: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing UserRoleUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "role" => intermediate_rep.role.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing UserRoleUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(UserRoleUpdateRequest {
            role: intermediate_rep.role.into_iter().next().ok_or_else(|| "role missing in UserRoleUpdateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<UserRoleUpdateRequest> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<UserRoleUpdateRequest>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<UserRoleUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for UserRoleUpdateRequest - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<UserRoleUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <UserRoleUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into UserRoleUpdateRequest - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The expiration policy for a vector store.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VectorStoreExpirationAfter {
    /// Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "anchor")]
          #[validate(custom(function = "check_xss_string"))]
    pub anchor: String,

    /// The number of days after the anchor time that the vector store will expire.
    #[serde(rename = "days")]
    #[validate(
            range(min = 1u16, max = 365u16),
    )]
    pub days: u16,

}



impl VectorStoreExpirationAfter {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(anchor: String, days: u16, ) -> VectorStoreExpirationAfter {
        VectorStoreExpirationAfter {
 anchor,
 days,
        }
    }
}

/// Converts the VectorStoreExpirationAfter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VectorStoreExpirationAfter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("anchor".to_string()),
            Some(self.anchor.to_string()),


            Some("days".to_string()),
            Some(self.days.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VectorStoreExpirationAfter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VectorStoreExpirationAfter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub anchor: Vec<String>,
            pub days: Vec<u16>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VectorStoreExpirationAfter".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "anchor" => intermediate_rep.anchor.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "days" => intermediate_rep.days.push(<u16 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VectorStoreExpirationAfter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VectorStoreExpirationAfter {
            anchor: intermediate_rep.anchor.into_iter().next().ok_or_else(|| "anchor missing in VectorStoreExpirationAfter".to_string())?,
            days: intermediate_rep.days.into_iter().next().ok_or_else(|| "days missing in VectorStoreExpirationAfter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VectorStoreExpirationAfter> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VectorStoreExpirationAfter>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VectorStoreExpirationAfter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for VectorStoreExpirationAfter - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VectorStoreExpirationAfter> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VectorStoreExpirationAfter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into VectorStoreExpirationAfter - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A batch of files attached to a vector store.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VectorStoreFileBatchObject {
    /// The identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The object type, which is always `vector_store.file_batch`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The Unix timestamp (in seconds) for when the vector store files batch was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    /// The ID of the [vector store](/docs/api-reference/vector-stores/object) that the [File](/docs/api-reference/files) is attached to.
    #[serde(rename = "vector_store_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub vector_store_id: String,

    /// The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
          #[validate(custom(function = "check_xss_string"))]
    pub status: String,

    #[serde(rename = "file_counts")]
          #[validate(nested)]
    pub file_counts: models::VectorStoreFileBatchObjectFileCounts,

}



impl VectorStoreFileBatchObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, created_at: i32, vector_store_id: String, status: String, file_counts: models::VectorStoreFileBatchObjectFileCounts, ) -> VectorStoreFileBatchObject {
        VectorStoreFileBatchObject {
 id,
 object,
 created_at,
 vector_store_id,
 status,
 file_counts,
        }
    }
}

/// Converts the VectorStoreFileBatchObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VectorStoreFileBatchObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("vector_store_id".to_string()),
            Some(self.vector_store_id.to_string()),


            Some("status".to_string()),
            Some(self.status.to_string()),

            // Skipping file_counts in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VectorStoreFileBatchObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VectorStoreFileBatchObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub created_at: Vec<i32>,
            pub vector_store_id: Vec<String>,
            pub status: Vec<String>,
            pub file_counts: Vec<models::VectorStoreFileBatchObjectFileCounts>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VectorStoreFileBatchObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vector_store_id" => intermediate_rep.vector_store_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_counts" => intermediate_rep.file_counts.push(<models::VectorStoreFileBatchObjectFileCounts as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VectorStoreFileBatchObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VectorStoreFileBatchObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in VectorStoreFileBatchObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in VectorStoreFileBatchObject".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in VectorStoreFileBatchObject".to_string())?,
            vector_store_id: intermediate_rep.vector_store_id.into_iter().next().ok_or_else(|| "vector_store_id missing in VectorStoreFileBatchObject".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in VectorStoreFileBatchObject".to_string())?,
            file_counts: intermediate_rep.file_counts.into_iter().next().ok_or_else(|| "file_counts missing in VectorStoreFileBatchObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VectorStoreFileBatchObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VectorStoreFileBatchObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VectorStoreFileBatchObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for VectorStoreFileBatchObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VectorStoreFileBatchObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VectorStoreFileBatchObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into VectorStoreFileBatchObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VectorStoreFileBatchObjectFileCounts {
    /// The number of files that are currently being processed.
    #[serde(rename = "in_progress")]
    pub in_progress: i32,

    /// The number of files that have been processed.
    #[serde(rename = "completed")]
    pub completed: i32,

    /// The number of files that have failed to process.
    #[serde(rename = "failed")]
    pub failed: i32,

    /// The number of files that where cancelled.
    #[serde(rename = "cancelled")]
    pub cancelled: i32,

    /// The total number of files.
    #[serde(rename = "total")]
    pub total: i32,

}



impl VectorStoreFileBatchObjectFileCounts {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(in_progress: i32, completed: i32, failed: i32, cancelled: i32, total: i32, ) -> VectorStoreFileBatchObjectFileCounts {
        VectorStoreFileBatchObjectFileCounts {
 in_progress,
 completed,
 failed,
 cancelled,
 total,
        }
    }
}

/// Converts the VectorStoreFileBatchObjectFileCounts value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VectorStoreFileBatchObjectFileCounts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("in_progress".to_string()),
            Some(self.in_progress.to_string()),


            Some("completed".to_string()),
            Some(self.completed.to_string()),


            Some("failed".to_string()),
            Some(self.failed.to_string()),


            Some("cancelled".to_string()),
            Some(self.cancelled.to_string()),


            Some("total".to_string()),
            Some(self.total.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VectorStoreFileBatchObjectFileCounts value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VectorStoreFileBatchObjectFileCounts {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub in_progress: Vec<i32>,
            pub completed: Vec<i32>,
            pub failed: Vec<i32>,
            pub cancelled: Vec<i32>,
            pub total: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VectorStoreFileBatchObjectFileCounts".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "in_progress" => intermediate_rep.in_progress.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "completed" => intermediate_rep.completed.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "failed" => intermediate_rep.failed.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cancelled" => intermediate_rep.cancelled.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total" => intermediate_rep.total.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VectorStoreFileBatchObjectFileCounts".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VectorStoreFileBatchObjectFileCounts {
            in_progress: intermediate_rep.in_progress.into_iter().next().ok_or_else(|| "in_progress missing in VectorStoreFileBatchObjectFileCounts".to_string())?,
            completed: intermediate_rep.completed.into_iter().next().ok_or_else(|| "completed missing in VectorStoreFileBatchObjectFileCounts".to_string())?,
            failed: intermediate_rep.failed.into_iter().next().ok_or_else(|| "failed missing in VectorStoreFileBatchObjectFileCounts".to_string())?,
            cancelled: intermediate_rep.cancelled.into_iter().next().ok_or_else(|| "cancelled missing in VectorStoreFileBatchObjectFileCounts".to_string())?,
            total: intermediate_rep.total.into_iter().next().ok_or_else(|| "total missing in VectorStoreFileBatchObjectFileCounts".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VectorStoreFileBatchObjectFileCounts> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VectorStoreFileBatchObjectFileCounts>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VectorStoreFileBatchObjectFileCounts>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for VectorStoreFileBatchObjectFileCounts - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VectorStoreFileBatchObjectFileCounts> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VectorStoreFileBatchObjectFileCounts as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into VectorStoreFileBatchObjectFileCounts - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A list of files attached to a vector store.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VectorStoreFileObject {
    /// The identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The object type, which is always `vector_store.file`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The total vector store usage in bytes. Note that this may be different from the original file size.
    #[serde(rename = "usage_bytes")]
    pub usage_bytes: i32,

    /// The Unix timestamp (in seconds) for when the vector store file was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    /// The ID of the [vector store](/docs/api-reference/vector-stores/object) that the [File](/docs/api-reference/files) is attached to.
    #[serde(rename = "vector_store_id")]
          #[validate(custom(function = "check_xss_string"))]
    pub vector_store_id: String,

    /// The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
          #[validate(custom(function = "check_xss_string"))]
    pub status: String,

    #[serde(rename = "last_error")]
    pub last_error: Nullable<models::VectorStoreFileObjectLastError>,

    #[serde(rename = "chunking_strategy")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub chunking_strategy: Option<models::VectorStoreFileObjectChunkingStrategy>,

}



impl VectorStoreFileObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, usage_bytes: i32, created_at: i32, vector_store_id: String, status: String, last_error: Nullable<models::VectorStoreFileObjectLastError>, ) -> VectorStoreFileObject {
        VectorStoreFileObject {
 id,
 object,
 usage_bytes,
 created_at,
 vector_store_id,
 status,
 last_error,
 chunking_strategy: None,
        }
    }
}

/// Converts the VectorStoreFileObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VectorStoreFileObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("usage_bytes".to_string()),
            Some(self.usage_bytes.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("vector_store_id".to_string()),
            Some(self.vector_store_id.to_string()),


            Some("status".to_string()),
            Some(self.status.to_string()),

            // Skipping last_error in query parameter serialization

            // Skipping chunking_strategy in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VectorStoreFileObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VectorStoreFileObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub usage_bytes: Vec<i32>,
            pub created_at: Vec<i32>,
            pub vector_store_id: Vec<String>,
            pub status: Vec<String>,
            pub last_error: Vec<models::VectorStoreFileObjectLastError>,
            pub chunking_strategy: Vec<models::VectorStoreFileObjectChunkingStrategy>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VectorStoreFileObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usage_bytes" => intermediate_rep.usage_bytes.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "vector_store_id" => intermediate_rep.vector_store_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "last_error" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in VectorStoreFileObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "chunking_strategy" => intermediate_rep.chunking_strategy.push(<models::VectorStoreFileObjectChunkingStrategy as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VectorStoreFileObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VectorStoreFileObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in VectorStoreFileObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in VectorStoreFileObject".to_string())?,
            usage_bytes: intermediate_rep.usage_bytes.into_iter().next().ok_or_else(|| "usage_bytes missing in VectorStoreFileObject".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in VectorStoreFileObject".to_string())?,
            vector_store_id: intermediate_rep.vector_store_id.into_iter().next().ok_or_else(|| "vector_store_id missing in VectorStoreFileObject".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in VectorStoreFileObject".to_string())?,
            last_error: std::result::Result::Err("Nullable types not supported in VectorStoreFileObject".to_string())?,
            chunking_strategy: intermediate_rep.chunking_strategy.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VectorStoreFileObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VectorStoreFileObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VectorStoreFileObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for VectorStoreFileObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VectorStoreFileObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VectorStoreFileObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into VectorStoreFileObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// The strategy used to chunk the file.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
#[allow(non_camel_case_types, clippy::large_enum_variant)]
pub enum VectorStoreFileObjectChunkingStrategy {
    StaticChunkingStrategyResponseParam(models::StaticChunkingStrategyResponseParam),
    OtherChunkingStrategyResponseParam(models::OtherChunkingStrategyResponseParam),
}

impl validator::Validate for VectorStoreFileObjectChunkingStrategy
{
    fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
        match self {
            Self::StaticChunkingStrategyResponseParam(v) => v.validate(),
            Self::OtherChunkingStrategyResponseParam(v) => v.validate(),
        }
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VectorStoreFileObjectChunkingStrategy value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VectorStoreFileObjectChunkingStrategy {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}


impl From<models::StaticChunkingStrategyResponseParam> for VectorStoreFileObjectChunkingStrategy {
    fn from(value: models::StaticChunkingStrategyResponseParam) -> Self {
        Self::StaticChunkingStrategyResponseParam(value)
    }
}
impl From<models::OtherChunkingStrategyResponseParam> for VectorStoreFileObjectChunkingStrategy {
    fn from(value: models::OtherChunkingStrategyResponseParam) -> Self {
        Self::OtherChunkingStrategyResponseParam(value)
    }
}





/// The last error associated with this vector store file. Will be `null` if there are no errors.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VectorStoreFileObjectLastError {
    /// One of `server_error` or `rate_limit_exceeded`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "code")]
          #[validate(custom(function = "check_xss_string"))]
    pub code: String,

    /// A human-readable description of the error.
    #[serde(rename = "message")]
          #[validate(custom(function = "check_xss_string"))]
    pub message: String,

}



impl VectorStoreFileObjectLastError {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(code: String, message: String, ) -> VectorStoreFileObjectLastError {
        VectorStoreFileObjectLastError {
 code,
 message,
        }
    }
}

/// Converts the VectorStoreFileObjectLastError value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VectorStoreFileObjectLastError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("code".to_string()),
            Some(self.code.to_string()),


            Some("message".to_string()),
            Some(self.message.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VectorStoreFileObjectLastError value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VectorStoreFileObjectLastError {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub code: Vec<String>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VectorStoreFileObjectLastError".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VectorStoreFileObjectLastError".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VectorStoreFileObjectLastError {
            code: intermediate_rep.code.into_iter().next().ok_or_else(|| "code missing in VectorStoreFileObjectLastError".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or_else(|| "message missing in VectorStoreFileObjectLastError".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VectorStoreFileObjectLastError> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VectorStoreFileObjectLastError>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VectorStoreFileObjectLastError>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for VectorStoreFileObjectLastError - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VectorStoreFileObjectLastError> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VectorStoreFileObjectLastError as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into VectorStoreFileObjectLastError - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// A vector store is a collection of processed files can be used by the `file_search` tool.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VectorStoreObject {
    /// The identifier, which can be referenced in API endpoints.
    #[serde(rename = "id")]
          #[validate(custom(function = "check_xss_string"))]
    pub id: String,

    /// The object type, which is always `vector_store`.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "object")]
          #[validate(custom(function = "check_xss_string"))]
    pub object: String,

    /// The Unix timestamp (in seconds) for when the vector store was created.
    #[serde(rename = "created_at")]
    pub created_at: i32,

    /// The name of the vector store.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    /// The total number of bytes used by the files in the vector store.
    #[serde(rename = "usage_bytes")]
    pub usage_bytes: i32,

    #[serde(rename = "file_counts")]
          #[validate(nested)]
    pub file_counts: models::VectorStoreObjectFileCounts,

    /// The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use.
    /// Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "status")]
          #[validate(custom(function = "check_xss_string"))]
    pub status: String,

    #[serde(rename = "expires_after")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_after: Option<models::VectorStoreExpirationAfter>,

    /// The Unix timestamp (in seconds) for when the vector store will expire.
    #[serde(rename = "expires_at")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<Nullable<i32>>,

    /// The Unix timestamp (in seconds) for when the vector store was last active.
    #[serde(rename = "last_active_at")]
    pub last_active_at: Nullable<i32>,

    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
    #[serde(rename = "metadata")]
    pub metadata: crate::types::Object,

}



impl VectorStoreObject {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: String, object: String, created_at: i32, name: String, usage_bytes: i32, file_counts: models::VectorStoreObjectFileCounts, status: String, last_active_at: Nullable<i32>, metadata: crate::types::Object, ) -> VectorStoreObject {
        VectorStoreObject {
 id,
 object,
 created_at,
 name,
 usage_bytes,
 file_counts,
 status,
 expires_after: None,
 expires_at: None,
 last_active_at,
 metadata,
        }
    }
}

/// Converts the VectorStoreObject value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VectorStoreObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("object".to_string()),
            Some(self.object.to_string()),


            Some("created_at".to_string()),
            Some(self.created_at.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("usage_bytes".to_string()),
            Some(self.usage_bytes.to_string()),

            // Skipping file_counts in query parameter serialization


            Some("status".to_string()),
            Some(self.status.to_string()),

            // Skipping expires_after in query parameter serialization


            self.expires_at.as_ref().map(|expires_at| {
                [
                    "expires_at".to_string(),
                    expires_at.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            Some("last_active_at".to_string()),
            Some(self.last_active_at.as_ref().map_or("null".to_string(), |x| x.to_string())),

            // Skipping metadata in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VectorStoreObject value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VectorStoreObject {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<String>,
            pub object: Vec<String>,
            pub created_at: Vec<i32>,
            pub name: Vec<String>,
            pub usage_bytes: Vec<i32>,
            pub file_counts: Vec<models::VectorStoreObjectFileCounts>,
            pub status: Vec<String>,
            pub expires_after: Vec<models::VectorStoreExpirationAfter>,
            pub expires_at: Vec<i32>,
            pub last_active_at: Vec<i32>,
            pub metadata: Vec<crate::types::Object>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VectorStoreObject".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "object" => intermediate_rep.object.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "created_at" => intermediate_rep.created_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "usage_bytes" => intermediate_rep.usage_bytes.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "file_counts" => intermediate_rep.file_counts.push(<models::VectorStoreObjectFileCounts as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "status" => intermediate_rep.status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "expires_after" => intermediate_rep.expires_after.push(<models::VectorStoreExpirationAfter as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "expires_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in VectorStoreObject".to_string()),
                    "last_active_at" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in VectorStoreObject".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "metadata" => intermediate_rep.metadata.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VectorStoreObject".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VectorStoreObject {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in VectorStoreObject".to_string())?,
            object: intermediate_rep.object.into_iter().next().ok_or_else(|| "object missing in VectorStoreObject".to_string())?,
            created_at: intermediate_rep.created_at.into_iter().next().ok_or_else(|| "created_at missing in VectorStoreObject".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in VectorStoreObject".to_string())?,
            usage_bytes: intermediate_rep.usage_bytes.into_iter().next().ok_or_else(|| "usage_bytes missing in VectorStoreObject".to_string())?,
            file_counts: intermediate_rep.file_counts.into_iter().next().ok_or_else(|| "file_counts missing in VectorStoreObject".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or_else(|| "status missing in VectorStoreObject".to_string())?,
            expires_after: intermediate_rep.expires_after.into_iter().next(),
            expires_at: std::result::Result::Err("Nullable types not supported in VectorStoreObject".to_string())?,
            last_active_at: std::result::Result::Err("Nullable types not supported in VectorStoreObject".to_string())?,
            metadata: intermediate_rep.metadata.into_iter().next().ok_or_else(|| "metadata missing in VectorStoreObject".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VectorStoreObject> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VectorStoreObject>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VectorStoreObject>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for VectorStoreObject - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VectorStoreObject> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VectorStoreObject as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into VectorStoreObject - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VectorStoreObjectFileCounts {
    /// The number of files that are currently being processed.
    #[serde(rename = "in_progress")]
    pub in_progress: i32,

    /// The number of files that have been successfully processed.
    #[serde(rename = "completed")]
    pub completed: i32,

    /// The number of files that have failed to process.
    #[serde(rename = "failed")]
    pub failed: i32,

    /// The number of files that were cancelled.
    #[serde(rename = "cancelled")]
    pub cancelled: i32,

    /// The total number of files.
    #[serde(rename = "total")]
    pub total: i32,

}



impl VectorStoreObjectFileCounts {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(in_progress: i32, completed: i32, failed: i32, cancelled: i32, total: i32, ) -> VectorStoreObjectFileCounts {
        VectorStoreObjectFileCounts {
 in_progress,
 completed,
 failed,
 cancelled,
 total,
        }
    }
}

/// Converts the VectorStoreObjectFileCounts value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VectorStoreObjectFileCounts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("in_progress".to_string()),
            Some(self.in_progress.to_string()),


            Some("completed".to_string()),
            Some(self.completed.to_string()),


            Some("failed".to_string()),
            Some(self.failed.to_string()),


            Some("cancelled".to_string()),
            Some(self.cancelled.to_string()),


            Some("total".to_string()),
            Some(self.total.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VectorStoreObjectFileCounts value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VectorStoreObjectFileCounts {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub in_progress: Vec<i32>,
            pub completed: Vec<i32>,
            pub failed: Vec<i32>,
            pub cancelled: Vec<i32>,
            pub total: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VectorStoreObjectFileCounts".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "in_progress" => intermediate_rep.in_progress.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "completed" => intermediate_rep.completed.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "failed" => intermediate_rep.failed.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cancelled" => intermediate_rep.cancelled.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "total" => intermediate_rep.total.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VectorStoreObjectFileCounts".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VectorStoreObjectFileCounts {
            in_progress: intermediate_rep.in_progress.into_iter().next().ok_or_else(|| "in_progress missing in VectorStoreObjectFileCounts".to_string())?,
            completed: intermediate_rep.completed.into_iter().next().ok_or_else(|| "completed missing in VectorStoreObjectFileCounts".to_string())?,
            failed: intermediate_rep.failed.into_iter().next().ok_or_else(|| "failed missing in VectorStoreObjectFileCounts".to_string())?,
            cancelled: intermediate_rep.cancelled.into_iter().next().ok_or_else(|| "cancelled missing in VectorStoreObjectFileCounts".to_string())?,
            total: intermediate_rep.total.into_iter().next().ok_or_else(|| "total missing in VectorStoreObjectFileCounts".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VectorStoreObjectFileCounts> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VectorStoreObjectFileCounts>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VectorStoreObjectFileCounts>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for VectorStoreObjectFileCounts - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VectorStoreObjectFileCounts> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VectorStoreObjectFileCounts as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into VectorStoreObjectFileCounts - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}


