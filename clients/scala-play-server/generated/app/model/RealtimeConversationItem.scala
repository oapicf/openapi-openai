package model

import play.api.libs.json._

/**
  * The item to add to the conversation.
  * @param id The unique ID of the item, this can be generated by the client to help  manage server-side context, but is not required because the server will  generate one if not provided. 
  * @param `type` The type of the item (`message`, `function_call`, `function_call_output`). 
  * @param `object` Identifier for the API object being returned - always `realtime.item`. 
  * @param status The status of the item (`completed`, `incomplete`). These have no effect  on the conversation, but are accepted for consistency with the  `conversation.item.created` event. 
  * @param role The role of the message sender (`user`, `assistant`, `system`), only  applicable for `message` items. 
  * @param content The content of the message, applicable for `message` items.  - Message items of role `system` support only `input_text` content - Message items of role `user` support `input_text` and `input_audio`    content - Message items of role `assistant` support `text` content. 
  * @param callId The ID of the function call (for `function_call` and  `function_call_output` items). If passed on a `function_call_output`  item, the server will check that a `function_call` item with the same  ID exists in the conversation history. 
  * @param name The name of the function being called (for `function_call` items). 
  * @param arguments The arguments of the function call (for `function_call` items). 
  * @param output The output of the function call (for `function_call_output` items). 
  */
@javax.annotation.Generated(value = Array("org.openapitools.codegen.languages.ScalaPlayFrameworkServerCodegen"), date = "2026-01-29T14:17:05.516820397Z[Etc/UTC]", comments = "Generator version: 7.18.0")
case class RealtimeConversationItem(
  id: Option[String],
  `type`: Option[RealtimeConversationItem.Type.Value],
  `object`: Option[RealtimeConversationItem.Object.Value],
  status: Option[RealtimeConversationItem.Status.Value],
  role: Option[RealtimeConversationItem.Role.Value],
  content: Option[List[RealtimeConversationItemContentInner]],
  callId: Option[String],
  name: Option[String],
  arguments: Option[String],
  output: Option[String]
)

object RealtimeConversationItem {
  implicit lazy val realtimeConversationItemJsonFormat: Format[RealtimeConversationItem] = Json.format[RealtimeConversationItem]

  // noinspection TypeAnnotation
  object Type extends Enumeration {
    val Message = Value("message")
    val FunctionCall = Value("function_call")
    val FunctionCallOutput = Value("function_call_output")

    type Type = Value
    implicit lazy val TypeJsonFormat: Format[Value] = Format(Reads.enumNameReads(this), Writes.enumNameWrites[this.type])
  }

  // noinspection TypeAnnotation
  object Object extends Enumeration {
    val RealtimeItem = Value("realtime.item")

    type Object = Value
    implicit lazy val ObjectJsonFormat: Format[Value] = Format(Reads.enumNameReads(this), Writes.enumNameWrites[this.type])
  }

  // noinspection TypeAnnotation
  object Status extends Enumeration {
    val Completed = Value("completed")
    val Incomplete = Value("incomplete")

    type Status = Value
    implicit lazy val StatusJsonFormat: Format[Value] = Format(Reads.enumNameReads(this), Writes.enumNameWrites[this.type])
  }

  // noinspection TypeAnnotation
  object Role extends Enumeration {
    val User = Value("user")
    val Assistant = Value("assistant")
    val System = Value("system")

    type Role = Value
    implicit lazy val RoleJsonFormat: Format[Value] = Format(Reads.enumNameReads(this), Writes.enumNameWrites[this.type])
  }
}

