//
// AssistantStreamEvent.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** Represents an event emitted when streaming a Run.  Each event in a server-sent events stream has an &#x60;event&#x60; and &#x60;data&#x60; property:  &#x60;&#x60;&#x60; event: thread.created data: {\&quot;id\&quot;: \&quot;thread_123\&quot;, \&quot;object\&quot;: \&quot;thread\&quot;, ...} &#x60;&#x60;&#x60;  We emit events whenever a new object is created, transitions to a new state, or is being streamed in parts (deltas). For example, we emit &#x60;thread.run.created&#x60; when a new run is created, &#x60;thread.run.completed&#x60; when a run completes, and so on. When an Assistant chooses to create a message during a run, we emit a &#x60;thread.message.created event&#x60;, a &#x60;thread.message.in_progress&#x60; event, many &#x60;thread.message.delta&#x60; events, and finally a &#x60;thread.message.completed&#x60; event.  We may add additional events over time, so we recommend handling unknown events gracefully in your code. See the [Assistants API quickstart](/docs/assistants/overview) to learn how to integrate the Assistants API with streaming.  */
public enum AssistantStreamEvent: Codable, JSONEncodable, Hashable {
    case typeDoneEvent(DoneEvent)
    case typeErrorEvent(ErrorEvent)
    case typeMessageStreamEvent(MessageStreamEvent)
    case typeRunStepStreamEvent(RunStepStreamEvent)
    case typeRunStreamEvent(RunStreamEvent)
    case typeThreadStreamEvent(ThreadStreamEvent)

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .typeDoneEvent(let value):
            try container.encode(value)
        case .typeErrorEvent(let value):
            try container.encode(value)
        case .typeMessageStreamEvent(let value):
            try container.encode(value)
        case .typeRunStepStreamEvent(let value):
            try container.encode(value)
        case .typeRunStreamEvent(let value):
            try container.encode(value)
        case .typeThreadStreamEvent(let value):
            try container.encode(value)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(DoneEvent.self) {
            self = .typeDoneEvent(value)
        } else if let value = try? container.decode(ErrorEvent.self) {
            self = .typeErrorEvent(value)
        } else if let value = try? container.decode(MessageStreamEvent.self) {
            self = .typeMessageStreamEvent(value)
        } else if let value = try? container.decode(RunStepStreamEvent.self) {
            self = .typeRunStepStreamEvent(value)
        } else if let value = try? container.decode(RunStreamEvent.self) {
            self = .typeRunStreamEvent(value)
        } else if let value = try? container.decode(ThreadStreamEvent.self) {
            self = .typeThreadStreamEvent(value)
        } else {
            throw DecodingError.typeMismatch(Self.Type.self, .init(codingPath: decoder.codingPath, debugDescription: "Unable to decode instance of AssistantStreamEvent"))
        }
    }
}

