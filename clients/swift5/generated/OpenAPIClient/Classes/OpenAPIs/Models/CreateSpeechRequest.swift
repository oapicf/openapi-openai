//
// CreateSpeechRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct CreateSpeechRequest: Codable, JSONEncodable, Hashable {

    public enum Voice: String, Codable, CaseIterable {
        case alloy = "alloy"
        case echo = "echo"
        case fable = "fable"
        case onyx = "onyx"
        case nova = "nova"
        case shimmer = "shimmer"
    }
    public enum ResponseFormat: String, Codable, CaseIterable {
        case mp3 = "mp3"
        case opus = "opus"
        case aac = "aac"
        case flac = "flac"
        case wav = "wav"
        case pcm = "pcm"
    }
    static let inputRule = StringRule(minLength: nil, maxLength: 4096, pattern: nil)
    static let speedRule = NumericRule<Double>(minimum: 0.25, exclusiveMinimum: false, maximum: 4.0, exclusiveMaximum: false, multipleOf: nil)
    public var model: CreateSpeechRequestModel
    /** The text to generate audio for. The maximum length is 4096 characters. */
    public var input: String
    /** The voice to use when generating the audio. Supported voices are `alloy`, `echo`, `fable`, `onyx`, `nova`, and `shimmer`. Previews of the voices are available in the [Text to speech guide](/docs/guides/text-to-speech/voice-options). */
    public var voice: Voice
    /** The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`. */
    public var responseFormat: ResponseFormat? = .mp3
    /** The speed of the generated audio. Select a value from `0.25` to `4.0`. `1.0` is the default. */
    public var speed: Double? = 1.0

    public init(model: CreateSpeechRequestModel, input: String, voice: Voice, responseFormat: ResponseFormat? = .mp3, speed: Double? = 1.0) {
        self.model = model
        self.input = input
        self.voice = voice
        self.responseFormat = responseFormat
        self.speed = speed
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case model
        case input
        case voice
        case responseFormat = "response_format"
        case speed
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(model, forKey: .model)
        try container.encode(input, forKey: .input)
        try container.encode(voice, forKey: .voice)
        try container.encodeIfPresent(responseFormat, forKey: .responseFormat)
        try container.encodeIfPresent(speed, forKey: .speed)
    }
}

