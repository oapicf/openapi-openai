//
// UsageTimeBucketResultInner.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public enum UsageTimeBucketResultInner: Codable, JSONEncodable, Hashable {
    case typeCostsResult(CostsResult)
    case typeUsageAudioSpeechesResult(UsageAudioSpeechesResult)
    case typeUsageAudioTranscriptionsResult(UsageAudioTranscriptionsResult)
    case typeUsageCodeInterpreterSessionsResult(UsageCodeInterpreterSessionsResult)
    case typeUsageCompletionsResult(UsageCompletionsResult)
    case typeUsageEmbeddingsResult(UsageEmbeddingsResult)
    case typeUsageImagesResult(UsageImagesResult)
    case typeUsageModerationsResult(UsageModerationsResult)
    case typeUsageVectorStoresResult(UsageVectorStoresResult)

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .typeCostsResult(let value):
            try container.encode(value)
        case .typeUsageAudioSpeechesResult(let value):
            try container.encode(value)
        case .typeUsageAudioTranscriptionsResult(let value):
            try container.encode(value)
        case .typeUsageCodeInterpreterSessionsResult(let value):
            try container.encode(value)
        case .typeUsageCompletionsResult(let value):
            try container.encode(value)
        case .typeUsageEmbeddingsResult(let value):
            try container.encode(value)
        case .typeUsageImagesResult(let value):
            try container.encode(value)
        case .typeUsageModerationsResult(let value):
            try container.encode(value)
        case .typeUsageVectorStoresResult(let value):
            try container.encode(value)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let value = try? container.decode(CostsResult.self) {
            self = .typeCostsResult(value)
        } else if let value = try? container.decode(UsageAudioSpeechesResult.self) {
            self = .typeUsageAudioSpeechesResult(value)
        } else if let value = try? container.decode(UsageAudioTranscriptionsResult.self) {
            self = .typeUsageAudioTranscriptionsResult(value)
        } else if let value = try? container.decode(UsageCodeInterpreterSessionsResult.self) {
            self = .typeUsageCodeInterpreterSessionsResult(value)
        } else if let value = try? container.decode(UsageCompletionsResult.self) {
            self = .typeUsageCompletionsResult(value)
        } else if let value = try? container.decode(UsageEmbeddingsResult.self) {
            self = .typeUsageEmbeddingsResult(value)
        } else if let value = try? container.decode(UsageImagesResult.self) {
            self = .typeUsageImagesResult(value)
        } else if let value = try? container.decode(UsageModerationsResult.self) {
            self = .typeUsageModerationsResult(value)
        } else if let value = try? container.decode(UsageVectorStoresResult.self) {
            self = .typeUsageVectorStoresResult(value)
        } else {
            throw DecodingError.typeMismatch(Self.Type.self, .init(codingPath: decoder.codingPath, debugDescription: "Unable to decode instance of UsageTimeBucketResultInner"))
        }
    }
}

