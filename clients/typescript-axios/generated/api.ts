/* tslint:disable */
/* eslint-disable */
/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AdminApiKey {
    'object'?: string;
    'id'?: string;
    'name'?: string;
    'redacted_value'?: string;
    'value'?: string;
    'created_at'?: number;
    'owner'?: AdminApiKeyOwner;
}
export interface AdminApiKeyOwner {
    'type'?: string;
    'id'?: string;
    'name'?: string;
    'created_at'?: number;
    'role'?: string;
}
export interface AdminApiKeysCreateRequest {
    'name': string;
}
export interface AdminApiKeysDelete200Response {
    'id'?: string;
    'object'?: string;
    'deleted'?: boolean;
}
export interface ApiKeyList {
    'object'?: string;
    'data'?: Array<AdminApiKey>;
    'has_more'?: boolean;
    'first_id'?: string;
    'last_id'?: string;
}
/**
 * @type ArrayOfContentPartsInner
 */
export type ArrayOfContentPartsInner = MessageContentImageFileObject | MessageContentImageUrlObject | MessageRequestContentTextObject;

/**
 * Represents an `assistant` that can call the model and use tools.
 */
export interface AssistantObject {
    /**
     * The identifier, which can be referenced in API endpoints.
     */
    'id': string;
    /**
     * The object type, which is always `assistant`.
     */
    'object': AssistantObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the assistant was created.
     */
    'created_at': number;
    /**
     * The name of the assistant. The maximum length is 256 characters. 
     */
    'name': string | null;
    /**
     * The description of the assistant. The maximum length is 512 characters. 
     */
    'description': string | null;
    /**
     * ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them. 
     */
    'model': string;
    /**
     * The system instructions that the assistant uses. The maximum length is 256,000 characters. 
     */
    'instructions': string | null;
    /**
     * A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`. 
     */
    'tools': Array<AssistantObjectToolsInner>;
    'tool_resources'?: AssistantObjectToolResources | null;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata': object | null;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
     */
    'temperature'?: number | null;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
     */
    'top_p'?: number | null;
    'response_format'?: AssistantsApiResponseFormatOption;
}

export const AssistantObjectObjectEnum = {
    Assistant: 'assistant'
} as const;

export type AssistantObjectObjectEnum = typeof AssistantObjectObjectEnum[keyof typeof AssistantObjectObjectEnum];

/**
 * A set of resources that are used by the assistant\'s tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
 */
export interface AssistantObjectToolResources {
    'code_interpreter'?: AssistantObjectToolResourcesCodeInterpreter;
    'file_search'?: AssistantObjectToolResourcesFileSearch;
}
export interface AssistantObjectToolResourcesCodeInterpreter {
    /**
     * A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter`` tool. There can be a maximum of 20 files associated with the tool. 
     */
    'file_ids'?: Array<string>;
}
export interface AssistantObjectToolResourcesFileSearch {
    /**
     * The ID of the [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant. 
     */
    'vector_store_ids'?: Array<string>;
}
/**
 * @type AssistantObjectToolsInner
 */
export type AssistantObjectToolsInner = AssistantToolsCode | AssistantToolsFileSearch | AssistantToolsFunction;

/**
 * @type AssistantStreamEvent
 * Represents an event emitted when streaming a Run.  Each event in a server-sent events stream has an `event` and `data` property:  ``` event: thread.created data: {\"id\": \"thread_123\", \"object\": \"thread\", ...} ```  We emit events whenever a new object is created, transitions to a new state, or is being streamed in parts (deltas). For example, we emit `thread.run.created` when a new run is created, `thread.run.completed` when a run completes, and so on. When an Assistant chooses to create a message during a run, we emit a `thread.message.created event`, a `thread.message.in_progress` event, many `thread.message.delta` events, and finally a `thread.message.completed` event.  We may add additional events over time, so we recommend handling unknown events gracefully in your code. See the [Assistants API quickstart](/docs/assistants/overview) to learn how to integrate the Assistants API with streaming. 
 */
export type AssistantStreamEvent = DoneEvent | ErrorEvent | MessageStreamEvent | RunStepStreamEvent | RunStreamEvent | ThreadStreamEvent;

export interface AssistantToolsCode {
    /**
     * The type of tool being defined: `code_interpreter`
     */
    'type': AssistantToolsCodeTypeEnum;
}

export const AssistantToolsCodeTypeEnum = {
    CodeInterpreter: 'code_interpreter'
} as const;

export type AssistantToolsCodeTypeEnum = typeof AssistantToolsCodeTypeEnum[keyof typeof AssistantToolsCodeTypeEnum];

export interface AssistantToolsFileSearch {
    /**
     * The type of tool being defined: `file_search`
     */
    'type': AssistantToolsFileSearchTypeEnum;
    'file_search'?: AssistantToolsFileSearchFileSearch;
}

export const AssistantToolsFileSearchTypeEnum = {
    FileSearch: 'file_search'
} as const;

export type AssistantToolsFileSearchTypeEnum = typeof AssistantToolsFileSearchTypeEnum[keyof typeof AssistantToolsFileSearchTypeEnum];

/**
 * Overrides for the file search tool.
 */
export interface AssistantToolsFileSearchFileSearch {
    /**
     * The maximum number of results the file search tool should output. The default is 20 for `gpt-4*` models and 5 for `gpt-3.5-turbo`. This number should be between 1 and 50 inclusive.  Note that the file search tool may output fewer than `max_num_results` results. See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
     */
    'max_num_results'?: number;
    'ranking_options'?: FileSearchRankingOptions;
}
export interface AssistantToolsFileSearchTypeOnly {
    /**
     * The type of tool being defined: `file_search`
     */
    'type': AssistantToolsFileSearchTypeOnlyTypeEnum;
}

export const AssistantToolsFileSearchTypeOnlyTypeEnum = {
    FileSearch: 'file_search'
} as const;

export type AssistantToolsFileSearchTypeOnlyTypeEnum = typeof AssistantToolsFileSearchTypeOnlyTypeEnum[keyof typeof AssistantToolsFileSearchTypeOnlyTypeEnum];

export interface AssistantToolsFunction {
    /**
     * The type of tool being defined: `function`
     */
    'type': AssistantToolsFunctionTypeEnum;
    'function': FunctionObject;
}

export const AssistantToolsFunctionTypeEnum = {
    Function: 'function'
} as const;

export type AssistantToolsFunctionTypeEnum = typeof AssistantToolsFunctionTypeEnum[keyof typeof AssistantToolsFunctionTypeEnum];

/**
 * @type AssistantsApiResponseFormatOption
 * Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.  Setting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).  Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the message the model generates is valid JSON.  **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \"stuck\" request. Also note that the message content may be partially cut off if `finish_reason=\"length\"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length. 
 */
export type AssistantsApiResponseFormatOption = ResponseFormatJsonObject | ResponseFormatJsonSchema | ResponseFormatText | string;

/**
 * @type AssistantsApiToolChoiceOption
 * Controls which (if any) tool is called by the model. `none` means the model will not call any tools and instead generates a message. `auto` is the default value and means the model can pick between generating a message or calling one or more tools. `required` means the model must call one or more tools before responding to the user. Specifying a particular tool like `{\"type\": \"file_search\"}` or `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool. 
 */
export type AssistantsApiToolChoiceOption = AssistantsNamedToolChoice | string;

/**
 * Specifies a tool the model should use. Use to force the model to call a specific tool.
 */
export interface AssistantsNamedToolChoice {
    /**
     * The type of the tool. If type is `function`, the function name must be set
     */
    'type': AssistantsNamedToolChoiceTypeEnum;
    'function'?: AssistantsNamedToolChoiceFunction;
}

export const AssistantsNamedToolChoiceTypeEnum = {
    Function: 'function',
    CodeInterpreter: 'code_interpreter',
    FileSearch: 'file_search'
} as const;

export type AssistantsNamedToolChoiceTypeEnum = typeof AssistantsNamedToolChoiceTypeEnum[keyof typeof AssistantsNamedToolChoiceTypeEnum];

export interface AssistantsNamedToolChoiceFunction {
    /**
     * The name of the function to call.
     */
    'name': string;
}
/**
 * The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`. 
 */

export const AudioResponseFormat = {
    Json: 'json',
    Text: 'text',
    Srt: 'srt',
    VerboseJson: 'verbose_json',
    Vtt: 'vtt'
} as const;

export type AudioResponseFormat = typeof AudioResponseFormat[keyof typeof AudioResponseFormat];


/**
 * A log of a user action or configuration change within this organization.
 */
export interface AuditLog {
    /**
     * The ID of this log.
     */
    'id': string;
    'type': AuditLogEventType;
    /**
     * The Unix timestamp (in seconds) of the event.
     */
    'effective_at': number;
    'project'?: AuditLogProject;
    'actor': AuditLogActor;
    'api_key.created'?: AuditLogApiKeyCreated;
    'api_key.updated'?: AuditLogApiKeyUpdated;
    'api_key.deleted'?: AuditLogApiKeyDeleted;
    'invite.sent'?: AuditLogInviteSent;
    'invite.accepted'?: AuditLogInviteAccepted;
    'invite.deleted'?: AuditLogInviteAccepted;
    'login.failed'?: AuditLogLoginFailed;
    'logout.failed'?: AuditLogLoginFailed;
    'organization.updated'?: AuditLogOrganizationUpdated;
    'project.created'?: AuditLogProjectCreated;
    'project.updated'?: AuditLogProjectUpdated;
    'project.archived'?: AuditLogProjectArchived;
    'rate_limit.updated'?: AuditLogRateLimitUpdated;
    'rate_limit.deleted'?: AuditLogRateLimitDeleted;
    'service_account.created'?: AuditLogServiceAccountCreated;
    'service_account.updated'?: AuditLogServiceAccountUpdated;
    'service_account.deleted'?: AuditLogServiceAccountDeleted;
    'user.added'?: AuditLogUserAdded;
    'user.updated'?: AuditLogUserUpdated;
    'user.deleted'?: AuditLogUserDeleted;
}


/**
 * The actor who performed the audit logged action.
 */
export interface AuditLogActor {
    /**
     * The type of actor. Is either `session` or `api_key`.
     */
    'type'?: AuditLogActorTypeEnum;
    'session'?: AuditLogActorSession;
    'api_key'?: AuditLogActorApiKey;
}

export const AuditLogActorTypeEnum = {
    Session: 'session',
    ApiKey: 'api_key'
} as const;

export type AuditLogActorTypeEnum = typeof AuditLogActorTypeEnum[keyof typeof AuditLogActorTypeEnum];

/**
 * The API Key used to perform the audit logged action.
 */
export interface AuditLogActorApiKey {
    /**
     * The tracking id of the API key.
     */
    'id'?: string;
    /**
     * The type of API key. Can be either `user` or `service_account`.
     */
    'type'?: AuditLogActorApiKeyTypeEnum;
    'user'?: AuditLogActorUser;
    'service_account'?: AuditLogActorServiceAccount;
}

export const AuditLogActorApiKeyTypeEnum = {
    User: 'user',
    ServiceAccount: 'service_account'
} as const;

export type AuditLogActorApiKeyTypeEnum = typeof AuditLogActorApiKeyTypeEnum[keyof typeof AuditLogActorApiKeyTypeEnum];

/**
 * The service account that performed the audit logged action.
 */
export interface AuditLogActorServiceAccount {
    /**
     * The service account id.
     */
    'id'?: string;
}
/**
 * The session in which the audit logged action was performed.
 */
export interface AuditLogActorSession {
    'user'?: AuditLogActorUser;
    /**
     * The IP address from which the action was performed.
     */
    'ip_address'?: string;
}
/**
 * The user who performed the audit logged action.
 */
export interface AuditLogActorUser {
    /**
     * The user id.
     */
    'id'?: string;
    /**
     * The user email.
     */
    'email'?: string;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogApiKeyCreated {
    /**
     * The tracking ID of the API key.
     */
    'id'?: string;
    'data'?: AuditLogApiKeyCreatedData;
}
/**
 * The payload used to create the API key.
 */
export interface AuditLogApiKeyCreatedData {
    /**
     * A list of scopes allowed for the API key, e.g. `[\"api.model.request\"]`
     */
    'scopes'?: Array<string>;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogApiKeyDeleted {
    /**
     * The tracking ID of the API key.
     */
    'id'?: string;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogApiKeyUpdated {
    /**
     * The tracking ID of the API key.
     */
    'id'?: string;
    'changes_requested'?: AuditLogApiKeyUpdatedChangesRequested;
}
/**
 * The payload used to update the API key.
 */
export interface AuditLogApiKeyUpdatedChangesRequested {
    /**
     * A list of scopes allowed for the API key, e.g. `[\"api.model.request\"]`
     */
    'scopes'?: Array<string>;
}
/**
 * The event type.
 */

export const AuditLogEventType = {
    ApiKeyCreated: 'api_key.created',
    ApiKeyUpdated: 'api_key.updated',
    ApiKeyDeleted: 'api_key.deleted',
    InviteSent: 'invite.sent',
    InviteAccepted: 'invite.accepted',
    InviteDeleted: 'invite.deleted',
    LoginSucceeded: 'login.succeeded',
    LoginFailed: 'login.failed',
    LogoutSucceeded: 'logout.succeeded',
    LogoutFailed: 'logout.failed',
    OrganizationUpdated: 'organization.updated',
    ProjectCreated: 'project.created',
    ProjectUpdated: 'project.updated',
    ProjectArchived: 'project.archived',
    ServiceAccountCreated: 'service_account.created',
    ServiceAccountUpdated: 'service_account.updated',
    ServiceAccountDeleted: 'service_account.deleted',
    RateLimitUpdated: 'rate_limit.updated',
    RateLimitDeleted: 'rate_limit.deleted',
    UserAdded: 'user.added',
    UserUpdated: 'user.updated',
    UserDeleted: 'user.deleted'
} as const;

export type AuditLogEventType = typeof AuditLogEventType[keyof typeof AuditLogEventType];


/**
 * The details for events with this `type`.
 */
export interface AuditLogInviteAccepted {
    /**
     * The ID of the invite.
     */
    'id'?: string;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogInviteSent {
    /**
     * The ID of the invite.
     */
    'id'?: string;
    'data'?: AuditLogInviteSentData;
}
/**
 * The payload used to create the invite.
 */
export interface AuditLogInviteSentData {
    /**
     * The email invited to the organization.
     */
    'email'?: string;
    /**
     * The role the email was invited to be. Is either `owner` or `member`.
     */
    'role'?: string;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogLoginFailed {
    /**
     * The error code of the failure.
     */
    'error_code'?: string;
    /**
     * The error message of the failure.
     */
    'error_message'?: string;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogOrganizationUpdated {
    /**
     * The organization ID.
     */
    'id'?: string;
    'changes_requested'?: AuditLogOrganizationUpdatedChangesRequested;
}
/**
 * The payload used to update the organization settings.
 */
export interface AuditLogOrganizationUpdatedChangesRequested {
    /**
     * The organization title.
     */
    'title'?: string;
    /**
     * The organization description.
     */
    'description'?: string;
    /**
     * The organization name.
     */
    'name'?: string;
    'settings'?: AuditLogOrganizationUpdatedChangesRequestedSettings;
}
export interface AuditLogOrganizationUpdatedChangesRequestedSettings {
    /**
     * Visibility of the threads page which shows messages created with the Assistants API and Playground. One of `ANY_ROLE`, `OWNERS`, or `NONE`.
     */
    'threads_ui_visibility'?: string;
    /**
     * Visibility of the usage dashboard which shows activity and costs for your organization. One of `ANY_ROLE` or `OWNERS`.
     */
    'usage_dashboard_visibility'?: string;
}
/**
 * The project that the action was scoped to. Absent for actions not scoped to projects.
 */
export interface AuditLogProject {
    /**
     * The project ID.
     */
    'id'?: string;
    /**
     * The project title.
     */
    'name'?: string;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogProjectArchived {
    /**
     * The project ID.
     */
    'id'?: string;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogProjectCreated {
    /**
     * The project ID.
     */
    'id'?: string;
    'data'?: AuditLogProjectCreatedData;
}
/**
 * The payload used to create the project.
 */
export interface AuditLogProjectCreatedData {
    /**
     * The project name.
     */
    'name'?: string;
    /**
     * The title of the project as seen on the dashboard.
     */
    'title'?: string;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogProjectUpdated {
    /**
     * The project ID.
     */
    'id'?: string;
    'changes_requested'?: AuditLogProjectUpdatedChangesRequested;
}
/**
 * The payload used to update the project.
 */
export interface AuditLogProjectUpdatedChangesRequested {
    /**
     * The title of the project as seen on the dashboard.
     */
    'title'?: string;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogRateLimitDeleted {
    /**
     * The rate limit ID
     */
    'id'?: string;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogRateLimitUpdated {
    /**
     * The rate limit ID
     */
    'id'?: string;
    'changes_requested'?: AuditLogRateLimitUpdatedChangesRequested;
}
/**
 * The payload used to update the rate limits.
 */
export interface AuditLogRateLimitUpdatedChangesRequested {
    /**
     * The maximum requests per minute.
     */
    'max_requests_per_1_minute'?: number;
    /**
     * The maximum tokens per minute.
     */
    'max_tokens_per_1_minute'?: number;
    /**
     * The maximum images per minute. Only relevant for certain models.
     */
    'max_images_per_1_minute'?: number;
    /**
     * The maximum audio megabytes per minute. Only relevant for certain models.
     */
    'max_audio_megabytes_per_1_minute'?: number;
    /**
     * The maximum requests per day. Only relevant for certain models.
     */
    'max_requests_per_1_day'?: number;
    /**
     * The maximum batch input tokens per day. Only relevant for certain models.
     */
    'batch_1_day_max_input_tokens'?: number;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogServiceAccountCreated {
    /**
     * The service account ID.
     */
    'id'?: string;
    'data'?: AuditLogServiceAccountCreatedData;
}
/**
 * The payload used to create the service account.
 */
export interface AuditLogServiceAccountCreatedData {
    /**
     * The role of the service account. Is either `owner` or `member`.
     */
    'role'?: string;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogServiceAccountDeleted {
    /**
     * The service account ID.
     */
    'id'?: string;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogServiceAccountUpdated {
    /**
     * The service account ID.
     */
    'id'?: string;
    'changes_requested'?: AuditLogServiceAccountUpdatedChangesRequested;
}
/**
 * The payload used to updated the service account.
 */
export interface AuditLogServiceAccountUpdatedChangesRequested {
    /**
     * The role of the service account. Is either `owner` or `member`.
     */
    'role'?: string;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogUserAdded {
    /**
     * The user ID.
     */
    'id'?: string;
    'data'?: AuditLogUserAddedData;
}
/**
 * The payload used to add the user to the project.
 */
export interface AuditLogUserAddedData {
    /**
     * The role of the user. Is either `owner` or `member`.
     */
    'role'?: string;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogUserDeleted {
    /**
     * The user ID.
     */
    'id'?: string;
}
/**
 * The details for events with this `type`.
 */
export interface AuditLogUserUpdated {
    /**
     * The project ID.
     */
    'id'?: string;
    'changes_requested'?: AuditLogUserUpdatedChangesRequested;
}
/**
 * The payload used to update the user.
 */
export interface AuditLogUserUpdatedChangesRequested {
    /**
     * The role of the user. Is either `owner` or `member`.
     */
    'role'?: string;
}
/**
 * The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`.
 */
export interface AutoChunkingStrategy {
    /**
     * Always `auto`.
     */
    'type': AutoChunkingStrategyTypeEnum;
}

export const AutoChunkingStrategyTypeEnum = {
    Auto: 'auto'
} as const;

export type AutoChunkingStrategyTypeEnum = typeof AutoChunkingStrategyTypeEnum[keyof typeof AutoChunkingStrategyTypeEnum];

/**
 * The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`.
 */
export interface AutoChunkingStrategyRequestParam {
    /**
     * Always `auto`.
     */
    'type': AutoChunkingStrategyRequestParamTypeEnum;
}

export const AutoChunkingStrategyRequestParamTypeEnum = {
    Auto: 'auto'
} as const;

export type AutoChunkingStrategyRequestParamTypeEnum = typeof AutoChunkingStrategyRequestParamTypeEnum[keyof typeof AutoChunkingStrategyRequestParamTypeEnum];

export interface Batch {
    'id': string;
    /**
     * The object type, which is always `batch`.
     */
    'object': BatchObjectEnum;
    /**
     * The OpenAI API endpoint used by the batch.
     */
    'endpoint': string;
    'errors'?: BatchErrors;
    /**
     * The ID of the input file for the batch.
     */
    'input_file_id': string;
    /**
     * The time frame within which the batch should be processed.
     */
    'completion_window': string;
    /**
     * The current status of the batch.
     */
    'status': BatchStatusEnum;
    /**
     * The ID of the file containing the outputs of successfully executed requests.
     */
    'output_file_id'?: string;
    /**
     * The ID of the file containing the outputs of requests with errors.
     */
    'error_file_id'?: string;
    /**
     * The Unix timestamp (in seconds) for when the batch was created.
     */
    'created_at': number;
    /**
     * The Unix timestamp (in seconds) for when the batch started processing.
     */
    'in_progress_at'?: number;
    /**
     * The Unix timestamp (in seconds) for when the batch will expire.
     */
    'expires_at'?: number;
    /**
     * The Unix timestamp (in seconds) for when the batch started finalizing.
     */
    'finalizing_at'?: number;
    /**
     * The Unix timestamp (in seconds) for when the batch was completed.
     */
    'completed_at'?: number;
    /**
     * The Unix timestamp (in seconds) for when the batch failed.
     */
    'failed_at'?: number;
    /**
     * The Unix timestamp (in seconds) for when the batch expired.
     */
    'expired_at'?: number;
    /**
     * The Unix timestamp (in seconds) for when the batch started cancelling.
     */
    'cancelling_at'?: number;
    /**
     * The Unix timestamp (in seconds) for when the batch was cancelled.
     */
    'cancelled_at'?: number;
    'request_counts'?: BatchRequestCounts;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata'?: object | null;
}

export const BatchObjectEnum = {
    Batch: 'batch'
} as const;

export type BatchObjectEnum = typeof BatchObjectEnum[keyof typeof BatchObjectEnum];
export const BatchStatusEnum = {
    Validating: 'validating',
    Failed: 'failed',
    InProgress: 'in_progress',
    Finalizing: 'finalizing',
    Completed: 'completed',
    Expired: 'expired',
    Cancelling: 'cancelling',
    Cancelled: 'cancelled'
} as const;

export type BatchStatusEnum = typeof BatchStatusEnum[keyof typeof BatchStatusEnum];

export interface BatchErrors {
    /**
     * The object type, which is always `list`.
     */
    'object'?: string;
    'data'?: Array<BatchErrorsDataInner>;
}
export interface BatchErrorsDataInner {
    /**
     * An error code identifying the error type.
     */
    'code'?: string;
    /**
     * A human-readable message providing more details about the error.
     */
    'message'?: string;
    /**
     * The name of the parameter that caused the error, if applicable.
     */
    'param'?: string | null;
    /**
     * The line number of the input file where the error occurred, if applicable.
     */
    'line'?: number | null;
}
/**
 * The request counts for different statuses within the batch.
 */
export interface BatchRequestCounts {
    /**
     * Total number of requests in the batch.
     */
    'total': number;
    /**
     * Number of requests that have been completed successfully.
     */
    'completed': number;
    /**
     * Number of requests that have failed.
     */
    'failed': number;
}
/**
 * The per-line object of the batch input file
 */
export interface BatchRequestInput {
    /**
     * A developer-provided per-request id that will be used to match outputs to inputs. Must be unique for each request in a batch.
     */
    'custom_id'?: string;
    /**
     * The HTTP method to be used for the request. Currently only `POST` is supported.
     */
    'method'?: BatchRequestInputMethodEnum;
    /**
     * The OpenAI API relative URL to be used for the request. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported.
     */
    'url'?: string;
}

export const BatchRequestInputMethodEnum = {
    Post: 'POST'
} as const;

export type BatchRequestInputMethodEnum = typeof BatchRequestInputMethodEnum[keyof typeof BatchRequestInputMethodEnum];

/**
 * The per-line object of the batch output and error files
 */
export interface BatchRequestOutput {
    'id'?: string;
    /**
     * A developer-provided per-request id that will be used to match outputs to inputs.
     */
    'custom_id'?: string;
    'response'?: BatchRequestOutputResponse | null;
    'error'?: BatchRequestOutputError | null;
}
/**
 * For requests that failed with a non-HTTP error, this will contain more information on the cause of the failure.
 */
export interface BatchRequestOutputError {
    /**
     * A machine-readable error code.
     */
    'code'?: string;
    /**
     * A human-readable error message.
     */
    'message'?: string;
}
export interface BatchRequestOutputResponse {
    /**
     * The HTTP status code of the response
     */
    'status_code'?: number;
    /**
     * An unique identifier for the OpenAI API request. Please include this request ID when contacting support.
     */
    'request_id'?: string;
    /**
     * The JSON body of the response
     */
    'body'?: object;
}
/**
 * Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function. 
 */
export interface ChatCompletionFunctionCallOption {
    /**
     * The name of the function to call.
     */
    'name': string;
}
export interface ChatCompletionFunctions {
    /**
     * A description of what the function does, used by the model to choose when and how to call the function.
     */
    'description'?: string;
    /**
     * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     */
    'name': string;
    /**
     * The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.   Omitting `parameters` defines a function with an empty parameter list.
     */
    'parameters'?: { [key: string]: any; };
}
export interface ChatCompletionMessageToolCall {
    /**
     * The ID of the tool call.
     */
    'id': string;
    /**
     * The type of the tool. Currently, only `function` is supported.
     */
    'type': ChatCompletionMessageToolCallTypeEnum;
    'function': ChatCompletionMessageToolCallFunction;
}

export const ChatCompletionMessageToolCallTypeEnum = {
    Function: 'function'
} as const;

export type ChatCompletionMessageToolCallTypeEnum = typeof ChatCompletionMessageToolCallTypeEnum[keyof typeof ChatCompletionMessageToolCallTypeEnum];

export interface ChatCompletionMessageToolCallChunk {
    'index': number;
    /**
     * The ID of the tool call.
     */
    'id'?: string;
    /**
     * The type of the tool. Currently, only `function` is supported.
     */
    'type'?: ChatCompletionMessageToolCallChunkTypeEnum;
    'function'?: ChatCompletionMessageToolCallChunkFunction;
}

export const ChatCompletionMessageToolCallChunkTypeEnum = {
    Function: 'function'
} as const;

export type ChatCompletionMessageToolCallChunkTypeEnum = typeof ChatCompletionMessageToolCallChunkTypeEnum[keyof typeof ChatCompletionMessageToolCallChunkTypeEnum];

export interface ChatCompletionMessageToolCallChunkFunction {
    /**
     * The name of the function to call.
     */
    'name'?: string;
    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     */
    'arguments'?: string;
}
/**
 * The function that the model called.
 */
export interface ChatCompletionMessageToolCallFunction {
    /**
     * The name of the function to call.
     */
    'name': string;
    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     */
    'arguments': string;
}
/**
 * Specifies a tool the model should use. Use to force the model to call a specific function.
 */
export interface ChatCompletionNamedToolChoice {
    /**
     * The type of the tool. Currently, only `function` is supported.
     */
    'type': ChatCompletionNamedToolChoiceTypeEnum;
    'function': AssistantsNamedToolChoiceFunction;
}

export const ChatCompletionNamedToolChoiceTypeEnum = {
    Function: 'function'
} as const;

export type ChatCompletionNamedToolChoiceTypeEnum = typeof ChatCompletionNamedToolChoiceTypeEnum[keyof typeof ChatCompletionNamedToolChoiceTypeEnum];

/**
 * Messages sent by the model in response to user messages. 
 */
export interface ChatCompletionRequestAssistantMessage {
    'content'?: ChatCompletionRequestAssistantMessageContent | null;
    /**
     * The refusal message by the assistant.
     */
    'refusal'?: string | null;
    /**
     * The role of the messages author, in this case `assistant`.
     */
    'role': ChatCompletionRequestAssistantMessageRoleEnum;
    /**
     * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     */
    'name'?: string;
    'audio'?: ChatCompletionRequestAssistantMessageAudio | null;
    /**
     * The tool calls generated by the model, such as function calls.
     */
    'tool_calls'?: Array<ChatCompletionMessageToolCall>;
    /**
     * @deprecated
     */
    'function_call'?: ChatCompletionRequestAssistantMessageFunctionCall | null;
}

export const ChatCompletionRequestAssistantMessageRoleEnum = {
    Assistant: 'assistant'
} as const;

export type ChatCompletionRequestAssistantMessageRoleEnum = typeof ChatCompletionRequestAssistantMessageRoleEnum[keyof typeof ChatCompletionRequestAssistantMessageRoleEnum];

/**
 * Data about a previous audio response from the model.  [Learn more](/docs/guides/audio). 
 */
export interface ChatCompletionRequestAssistantMessageAudio {
    /**
     * Unique identifier for a previous audio response from the model. 
     */
    'id': string;
}
/**
 * @type ChatCompletionRequestAssistantMessageContent
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified. 
 */
export type ChatCompletionRequestAssistantMessageContent = Array<ChatCompletionRequestAssistantMessageContentPart> | string;

/**
 * @type ChatCompletionRequestAssistantMessageContentPart
 */
export type ChatCompletionRequestAssistantMessageContentPart = ChatCompletionRequestMessageContentPartRefusal | ChatCompletionRequestMessageContentPartText;

/**
 * Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
 */
export interface ChatCompletionRequestAssistantMessageFunctionCall {
    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     */
    'arguments': string;
    /**
     * The name of the function to call.
     */
    'name': string;
}
/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user. With o1 models and newer, `developer` messages replace the previous `system` messages. 
 */
export interface ChatCompletionRequestDeveloperMessage {
    'content': ChatCompletionRequestDeveloperMessageContent;
    /**
     * The role of the messages author, in this case `developer`.
     */
    'role': ChatCompletionRequestDeveloperMessageRoleEnum;
    /**
     * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     */
    'name'?: string;
}

export const ChatCompletionRequestDeveloperMessageRoleEnum = {
    Developer: 'developer'
} as const;

export type ChatCompletionRequestDeveloperMessageRoleEnum = typeof ChatCompletionRequestDeveloperMessageRoleEnum[keyof typeof ChatCompletionRequestDeveloperMessageRoleEnum];

/**
 * @type ChatCompletionRequestDeveloperMessageContent
 * The contents of the developer message.
 */
export type ChatCompletionRequestDeveloperMessageContent = Array<ChatCompletionRequestMessageContentPartText> | string;

export interface ChatCompletionRequestFunctionMessage {
    /**
     * The role of the messages author, in this case `function`.
     */
    'role': ChatCompletionRequestFunctionMessageRoleEnum;
    /**
     * The contents of the function message.
     */
    'content': string | null;
    /**
     * The name of the function to call.
     */
    'name': string;
}

export const ChatCompletionRequestFunctionMessageRoleEnum = {
    Function: 'function'
} as const;

export type ChatCompletionRequestFunctionMessageRoleEnum = typeof ChatCompletionRequestFunctionMessageRoleEnum[keyof typeof ChatCompletionRequestFunctionMessageRoleEnum];

/**
 * @type ChatCompletionRequestMessage
 */
export type ChatCompletionRequestMessage = ChatCompletionRequestAssistantMessage | ChatCompletionRequestDeveloperMessage | ChatCompletionRequestFunctionMessage | ChatCompletionRequestSystemMessage | ChatCompletionRequestToolMessage | ChatCompletionRequestUserMessage;

/**
 * Learn about [audio inputs](/docs/guides/audio). 
 */
export interface ChatCompletionRequestMessageContentPartAudio {
    /**
     * The type of the content part. Always `input_audio`.
     */
    'type': ChatCompletionRequestMessageContentPartAudioTypeEnum;
    'input_audio': ChatCompletionRequestMessageContentPartAudioInputAudio;
}

export const ChatCompletionRequestMessageContentPartAudioTypeEnum = {
    InputAudio: 'input_audio'
} as const;

export type ChatCompletionRequestMessageContentPartAudioTypeEnum = typeof ChatCompletionRequestMessageContentPartAudioTypeEnum[keyof typeof ChatCompletionRequestMessageContentPartAudioTypeEnum];

export interface ChatCompletionRequestMessageContentPartAudioInputAudio {
    /**
     * Base64 encoded audio data.
     */
    'data': string;
    /**
     * The format of the encoded audio data. Currently supports \"wav\" and \"mp3\". 
     */
    'format': ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum;
}

export const ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum = {
    Wav: 'wav',
    Mp3: 'mp3'
} as const;

export type ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum = typeof ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum[keyof typeof ChatCompletionRequestMessageContentPartAudioInputAudioFormatEnum];

/**
 * Learn about [image inputs](/docs/guides/vision). 
 */
export interface ChatCompletionRequestMessageContentPartImage {
    /**
     * The type of the content part.
     */
    'type': ChatCompletionRequestMessageContentPartImageTypeEnum;
    'image_url': ChatCompletionRequestMessageContentPartImageImageUrl;
}

export const ChatCompletionRequestMessageContentPartImageTypeEnum = {
    ImageUrl: 'image_url'
} as const;

export type ChatCompletionRequestMessageContentPartImageTypeEnum = typeof ChatCompletionRequestMessageContentPartImageTypeEnum[keyof typeof ChatCompletionRequestMessageContentPartImageTypeEnum];

export interface ChatCompletionRequestMessageContentPartImageImageUrl {
    /**
     * Either a URL of the image or the base64 encoded image data.
     */
    'url': string;
    /**
     * Specifies the detail level of the image. Learn more in the [Vision guide](/docs/guides/vision#low-or-high-fidelity-image-understanding).
     */
    'detail'?: ChatCompletionRequestMessageContentPartImageImageUrlDetailEnum;
}

export const ChatCompletionRequestMessageContentPartImageImageUrlDetailEnum = {
    Auto: 'auto',
    Low: 'low',
    High: 'high'
} as const;

export type ChatCompletionRequestMessageContentPartImageImageUrlDetailEnum = typeof ChatCompletionRequestMessageContentPartImageImageUrlDetailEnum[keyof typeof ChatCompletionRequestMessageContentPartImageImageUrlDetailEnum];

export interface ChatCompletionRequestMessageContentPartRefusal {
    /**
     * The type of the content part.
     */
    'type': ChatCompletionRequestMessageContentPartRefusalTypeEnum;
    /**
     * The refusal message generated by the model.
     */
    'refusal': string;
}

export const ChatCompletionRequestMessageContentPartRefusalTypeEnum = {
    Refusal: 'refusal'
} as const;

export type ChatCompletionRequestMessageContentPartRefusalTypeEnum = typeof ChatCompletionRequestMessageContentPartRefusalTypeEnum[keyof typeof ChatCompletionRequestMessageContentPartRefusalTypeEnum];

/**
 * Learn about [text inputs](/docs/guides/text-generation). 
 */
export interface ChatCompletionRequestMessageContentPartText {
    /**
     * The type of the content part.
     */
    'type': ChatCompletionRequestMessageContentPartTextTypeEnum;
    /**
     * The text content.
     */
    'text': string;
}

export const ChatCompletionRequestMessageContentPartTextTypeEnum = {
    Text: 'text'
} as const;

export type ChatCompletionRequestMessageContentPartTextTypeEnum = typeof ChatCompletionRequestMessageContentPartTextTypeEnum[keyof typeof ChatCompletionRequestMessageContentPartTextTypeEnum];

/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user. With o1 models and newer, use `developer` messages for this purpose instead. 
 */
export interface ChatCompletionRequestSystemMessage {
    'content': ChatCompletionRequestSystemMessageContent;
    /**
     * The role of the messages author, in this case `system`.
     */
    'role': ChatCompletionRequestSystemMessageRoleEnum;
    /**
     * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     */
    'name'?: string;
}

export const ChatCompletionRequestSystemMessageRoleEnum = {
    System: 'system'
} as const;

export type ChatCompletionRequestSystemMessageRoleEnum = typeof ChatCompletionRequestSystemMessageRoleEnum[keyof typeof ChatCompletionRequestSystemMessageRoleEnum];

/**
 * @type ChatCompletionRequestSystemMessageContent
 * The contents of the system message.
 */
export type ChatCompletionRequestSystemMessageContent = Array<ChatCompletionRequestMessageContentPartText> | string;

export interface ChatCompletionRequestToolMessage {
    /**
     * The role of the messages author, in this case `tool`.
     */
    'role': ChatCompletionRequestToolMessageRoleEnum;
    'content': ChatCompletionRequestToolMessageContent;
    /**
     * Tool call that this message is responding to.
     */
    'tool_call_id': string;
}

export const ChatCompletionRequestToolMessageRoleEnum = {
    Tool: 'tool'
} as const;

export type ChatCompletionRequestToolMessageRoleEnum = typeof ChatCompletionRequestToolMessageRoleEnum[keyof typeof ChatCompletionRequestToolMessageRoleEnum];

/**
 * @type ChatCompletionRequestToolMessageContent
 * The contents of the tool message.
 */
export type ChatCompletionRequestToolMessageContent = Array<ChatCompletionRequestMessageContentPartText> | string;

/**
 * Messages sent by an end user, containing prompts or additional context information. 
 */
export interface ChatCompletionRequestUserMessage {
    'content': ChatCompletionRequestUserMessageContent;
    /**
     * The role of the messages author, in this case `user`.
     */
    'role': ChatCompletionRequestUserMessageRoleEnum;
    /**
     * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     */
    'name'?: string;
}

export const ChatCompletionRequestUserMessageRoleEnum = {
    User: 'user'
} as const;

export type ChatCompletionRequestUserMessageRoleEnum = typeof ChatCompletionRequestUserMessageRoleEnum[keyof typeof ChatCompletionRequestUserMessageRoleEnum];

/**
 * @type ChatCompletionRequestUserMessageContent
 * The contents of the user message. 
 */
export type ChatCompletionRequestUserMessageContent = Array<ChatCompletionRequestUserMessageContentPart> | string;

/**
 * @type ChatCompletionRequestUserMessageContentPart
 */
export type ChatCompletionRequestUserMessageContentPart = ChatCompletionRequestMessageContentPartAudio | ChatCompletionRequestMessageContentPartImage | ChatCompletionRequestMessageContentPartText;

/**
 * A chat completion message generated by the model.
 */
export interface ChatCompletionResponseMessage {
    /**
     * The contents of the message.
     */
    'content': string | null;
    /**
     * The refusal message generated by the model.
     */
    'refusal': string | null;
    /**
     * The tool calls generated by the model, such as function calls.
     */
    'tool_calls'?: Array<ChatCompletionMessageToolCall>;
    /**
     * The role of the author of this message.
     */
    'role': ChatCompletionResponseMessageRoleEnum;
    /**
     * @deprecated
     */
    'function_call'?: ChatCompletionResponseMessageFunctionCall;
    'audio'?: ChatCompletionResponseMessageAudio | null;
}

export const ChatCompletionResponseMessageRoleEnum = {
    Assistant: 'assistant'
} as const;

export type ChatCompletionResponseMessageRoleEnum = typeof ChatCompletionResponseMessageRoleEnum[keyof typeof ChatCompletionResponseMessageRoleEnum];

/**
 * If the audio output modality is requested, this object contains data about the audio response from the model. [Learn more](/docs/guides/audio). 
 */
export interface ChatCompletionResponseMessageAudio {
    /**
     * Unique identifier for this audio response.
     */
    'id': string;
    /**
     * The Unix timestamp (in seconds) for when this audio response will no longer be accessible on the server for use in multi-turn conversations. 
     */
    'expires_at': number;
    /**
     * Base64 encoded audio bytes generated by the model, in the format specified in the request. 
     */
    'data': string;
    /**
     * Transcript of the audio generated by the model.
     */
    'transcript': string;
}
/**
 * Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
 */
export interface ChatCompletionResponseMessageFunctionCall {
    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     */
    'arguments': string;
    /**
     * The name of the function to call.
     */
    'name': string;
}
/**
 * The role of the author of a message
 */

export const ChatCompletionRole = {
    System: 'system',
    User: 'user',
    Assistant: 'assistant',
    Tool: 'tool',
    Function: 'function'
} as const;

export type ChatCompletionRole = typeof ChatCompletionRole[keyof typeof ChatCompletionRole];


/**
 * Options for streaming response. Only set this when you set `stream: true`. 
 */
export interface ChatCompletionStreamOptions {
    /**
     * If set, an additional chunk will be streamed before the `data: [DONE]` message. The `usage` field on this chunk shows the token usage statistics for the entire request, and the `choices` field will always be an empty array. All other chunks will also include a `usage` field, but with a null value. 
     */
    'include_usage'?: boolean;
}
/**
 * A chat completion delta generated by streamed model responses.
 */
export interface ChatCompletionStreamResponseDelta {
    /**
     * The contents of the chunk message.
     */
    'content'?: string | null;
    /**
     * @deprecated
     */
    'function_call'?: ChatCompletionStreamResponseDeltaFunctionCall;
    'tool_calls'?: Array<ChatCompletionMessageToolCallChunk>;
    /**
     * The role of the author of this message.
     */
    'role'?: ChatCompletionStreamResponseDeltaRoleEnum;
    /**
     * The refusal message generated by the model.
     */
    'refusal'?: string | null;
}

export const ChatCompletionStreamResponseDeltaRoleEnum = {
    System: 'system',
    User: 'user',
    Assistant: 'assistant',
    Tool: 'tool'
} as const;

export type ChatCompletionStreamResponseDeltaRoleEnum = typeof ChatCompletionStreamResponseDeltaRoleEnum[keyof typeof ChatCompletionStreamResponseDeltaRoleEnum];

/**
 * Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
 */
export interface ChatCompletionStreamResponseDeltaFunctionCall {
    /**
     * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
     */
    'arguments'?: string;
    /**
     * The name of the function to call.
     */
    'name'?: string;
}
export interface ChatCompletionTokenLogprob {
    /**
     * The token.
     */
    'token': string;
    /**
     * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
     */
    'logprob': number;
    /**
     * A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
     */
    'bytes': Array<number> | null;
    /**
     * List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
     */
    'top_logprobs': Array<ChatCompletionTokenLogprobTopLogprobsInner>;
}
export interface ChatCompletionTokenLogprobTopLogprobsInner {
    /**
     * The token.
     */
    'token': string;
    /**
     * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
     */
    'logprob': number;
    /**
     * A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
     */
    'bytes': Array<number> | null;
}
export interface ChatCompletionTool {
    /**
     * The type of the tool. Currently, only `function` is supported.
     */
    'type': ChatCompletionToolTypeEnum;
    'function': FunctionObject;
}

export const ChatCompletionToolTypeEnum = {
    Function: 'function'
} as const;

export type ChatCompletionToolTypeEnum = typeof ChatCompletionToolTypeEnum[keyof typeof ChatCompletionToolTypeEnum];

/**
 * @type ChatCompletionToolChoiceOption
 * Controls which (if any) tool is called by the model. `none` means the model will not call any tool and instead generates a message. `auto` means the model can pick between generating a message or calling one or more tools. `required` means the model must call one or more tools. Specifying a particular tool via `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool.  `none` is the default when no tools are present. `auto` is the default if tools are present. 
 */
export type ChatCompletionToolChoiceOption = ChatCompletionNamedToolChoice | string;

/**
 * @type ChunkingStrategyRequestParam
 * The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
 */
export type ChunkingStrategyRequestParam = AutoChunkingStrategyRequestParam | StaticChunkingStrategyRequestParam;

export interface CompleteUploadRequest {
    /**
     * The ordered list of Part IDs. 
     */
    'part_ids': Array<string>;
    /**
     * The optional md5 checksum for the file contents to verify if the bytes uploaded matches what you expect. 
     */
    'md5'?: string;
}
/**
 * Usage statistics for the completion request.
 */
export interface CompletionUsage {
    /**
     * Number of tokens in the generated completion.
     */
    'completion_tokens': number;
    /**
     * Number of tokens in the prompt.
     */
    'prompt_tokens': number;
    /**
     * Total number of tokens used in the request (prompt + completion).
     */
    'total_tokens': number;
    'completion_tokens_details'?: CompletionUsageCompletionTokensDetails;
    'prompt_tokens_details'?: CompletionUsagePromptTokensDetails;
}
/**
 * Breakdown of tokens used in a completion.
 */
export interface CompletionUsageCompletionTokensDetails {
    /**
     * When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion. 
     */
    'accepted_prediction_tokens'?: number;
    /**
     * Audio input tokens generated by the model.
     */
    'audio_tokens'?: number;
    /**
     * Tokens generated by the model for reasoning.
     */
    'reasoning_tokens'?: number;
    /**
     * When using Predicted Outputs, the number of tokens in the prediction that did not appear in the completion. However, like reasoning tokens, these tokens are still counted in the total completion tokens for purposes of billing, output, and context window limits. 
     */
    'rejected_prediction_tokens'?: number;
}
/**
 * Breakdown of tokens used in the prompt.
 */
export interface CompletionUsagePromptTokensDetails {
    /**
     * Audio input tokens present in the prompt.
     */
    'audio_tokens'?: number;
    /**
     * Cached tokens present in the prompt.
     */
    'cached_tokens'?: number;
}
/**
 * The aggregated costs details of the specific time bucket.
 */
export interface CostsResult {
    'object': CostsResultObjectEnum;
    'amount'?: CostsResultAmount;
    /**
     * When `group_by=line_item`, this field provides the line item of the grouped costs result.
     */
    'line_item'?: string | null;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped costs result.
     */
    'project_id'?: string | null;
}

export const CostsResultObjectEnum = {
    OrganizationCostsResult: 'organization.costs.result'
} as const;

export type CostsResultObjectEnum = typeof CostsResultObjectEnum[keyof typeof CostsResultObjectEnum];

/**
 * The monetary value in its associated currency.
 */
export interface CostsResultAmount {
    /**
     * The numeric value of the cost.
     */
    'value'?: number;
    /**
     * Lowercase ISO-4217 currency e.g. \"usd\"
     */
    'currency'?: string;
}
export interface CreateAssistantRequest {
    'model': CreateAssistantRequestModel;
    /**
     * The name of the assistant. The maximum length is 256 characters. 
     */
    'name'?: string | null;
    /**
     * The description of the assistant. The maximum length is 512 characters. 
     */
    'description'?: string | null;
    /**
     * The system instructions that the assistant uses. The maximum length is 256,000 characters. 
     */
    'instructions'?: string | null;
    /**
     * A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`. 
     */
    'tools'?: Array<AssistantObjectToolsInner>;
    'tool_resources'?: CreateAssistantRequestToolResources | null;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata'?: object | null;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
     */
    'temperature'?: number | null;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
     */
    'top_p'?: number | null;
    'response_format'?: AssistantsApiResponseFormatOption;
}
/**
 * ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them. 
 */
export interface CreateAssistantRequestModel {
}
/**
 * A set of resources that are used by the assistant\'s tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
 */
export interface CreateAssistantRequestToolResources {
    'code_interpreter'?: CreateAssistantRequestToolResourcesCodeInterpreter;
    'file_search'?: CreateAssistantRequestToolResourcesFileSearch | null;
}
export interface CreateAssistantRequestToolResourcesCodeInterpreter {
    /**
     * A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool. 
     */
    'file_ids'?: Array<string>;
}
export interface CreateAssistantRequestToolResourcesFileSearch {
    /**
     * The [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant. 
     */
    'vector_store_ids'?: Array<string>;
    /**
     * A helper to create a [vector store](/docs/api-reference/vector-stores/object) with file_ids and attach it to this assistant. There can be a maximum of 1 vector store attached to the assistant. 
     */
    'vector_stores'?: Array<CreateAssistantRequestToolResourcesFileSearchVectorStoresInner>;
}
export interface CreateAssistantRequestToolResourcesFileSearchVectorStoresInner {
    /**
     * A list of [file](/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store. 
     */
    'file_ids'?: Array<string>;
    'chunking_strategy'?: CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy;
    /**
     * Set of 16 key-value pairs that can be attached to a vector store. This can be useful for storing additional information about the vector store in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata'?: object;
}
/**
 * @type CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy
 * The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy.
 */
export type CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy = AutoChunkingStrategy | StaticChunkingStrategy;

export interface CreateBatchRequest {
    /**
     * The ID of an uploaded file that contains requests for the new batch.  See [upload file](/docs/api-reference/files/create) for how to upload a file.  Your input file must be formatted as a [JSONL file](/docs/api-reference/batch/request-input), and must be uploaded with the purpose `batch`. The file can contain up to 50,000 requests, and can be up to 200 MB in size. 
     */
    'input_file_id': string;
    /**
     * The endpoint to be used for all requests in the batch. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.
     */
    'endpoint': CreateBatchRequestEndpointEnum;
    /**
     * The time frame within which the batch should be processed. Currently only `24h` is supported.
     */
    'completion_window': CreateBatchRequestCompletionWindowEnum;
    /**
     * Optional custom metadata for the batch.
     */
    'metadata'?: { [key: string]: string; } | null;
}

export const CreateBatchRequestEndpointEnum = {
    V1ChatCompletions: '/v1/chat/completions',
    V1Embeddings: '/v1/embeddings',
    V1Completions: '/v1/completions'
} as const;

export type CreateBatchRequestEndpointEnum = typeof CreateBatchRequestEndpointEnum[keyof typeof CreateBatchRequestEndpointEnum];
export const CreateBatchRequestCompletionWindowEnum = {
    _24h: '24h'
} as const;

export type CreateBatchRequestCompletionWindowEnum = typeof CreateBatchRequestCompletionWindowEnum[keyof typeof CreateBatchRequestCompletionWindowEnum];

/**
 * Represents a chat completion response returned by model, based on the provided input.
 */
export interface CreateChatCompletionFunctionResponse {
    /**
     * A unique identifier for the chat completion.
     */
    'id': string;
    /**
     * A list of chat completion choices. Can be more than one if `n` is greater than 1.
     */
    'choices': Array<CreateChatCompletionFunctionResponseChoicesInner>;
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created.
     */
    'created': number;
    /**
     * The model used for the chat completion.
     */
    'model': string;
    /**
     * This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
     */
    'system_fingerprint'?: string;
    /**
     * The object type, which is always `chat.completion`.
     */
    'object': CreateChatCompletionFunctionResponseObjectEnum;
    'usage'?: CompletionUsage;
}

export const CreateChatCompletionFunctionResponseObjectEnum = {
    ChatCompletion: 'chat.completion'
} as const;

export type CreateChatCompletionFunctionResponseObjectEnum = typeof CreateChatCompletionFunctionResponseObjectEnum[keyof typeof CreateChatCompletionFunctionResponseObjectEnum];

export interface CreateChatCompletionFunctionResponseChoicesInner {
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, or `function_call` if the model called a function. 
     */
    'finish_reason': CreateChatCompletionFunctionResponseChoicesInnerFinishReasonEnum;
    /**
     * The index of the choice in the list of choices.
     */
    'index': number;
    'message': ChatCompletionResponseMessage;
}

export const CreateChatCompletionFunctionResponseChoicesInnerFinishReasonEnum = {
    Stop: 'stop',
    Length: 'length',
    FunctionCall: 'function_call',
    ContentFilter: 'content_filter'
} as const;

export type CreateChatCompletionFunctionResponseChoicesInnerFinishReasonEnum = typeof CreateChatCompletionFunctionResponseChoicesInnerFinishReasonEnum[keyof typeof CreateChatCompletionFunctionResponseChoicesInnerFinishReasonEnum];

export interface CreateChatCompletionRequest {
    /**
     * A list of messages comprising the conversation so far. Depending on the [model](/docs/models) you use, different message types (modalities) are supported, like [text](/docs/guides/text-generation), [images](/docs/guides/vision), and [audio](/docs/guides/audio). 
     */
    'messages': Array<ChatCompletionRequestMessage>;
    'model': CreateChatCompletionRequestModel;
    /**
     * Whether or not to store the output of this chat completion request for  use in our [model distillation](/docs/guides/distillation) or [evals](/docs/guides/evals) products. 
     */
    'store'?: boolean | null;
    /**
     * **o1 models only**   Constrains effort on reasoning for  [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `low`, `medium`, and `high`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response. 
     */
    'reasoning_effort'?: CreateChatCompletionRequestReasoningEffortEnum;
    /**
     * Developer-defined tags and values used for filtering completions in the [dashboard](https://platform.openai.com/chat-completions). 
     */
    'metadata'?: { [key: string]: string; } | null;
    /**
     * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model\'s likelihood to repeat the same line verbatim. 
     */
    'frequency_penalty'?: number | null;
    /**
     * Modify the likelihood of specified tokens appearing in the completion.  Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token. 
     */
    'logit_bias'?: { [key: string]: number; } | null;
    /**
     * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the `content` of `message`. 
     */
    'logprobs'?: boolean | null;
    /**
     * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. `logprobs` must be set to `true` if this parameter is used. 
     */
    'top_logprobs'?: number | null;
    /**
     * The maximum number of [tokens](/tokenizer) that can be generated in the chat completion. This value can be used to control [costs](https://openai.com/api/pricing/) for text generated via API.  This value is now deprecated in favor of `max_completion_tokens`, and is not compatible with [o1 series models](/docs/guides/reasoning). 
     * @deprecated
     */
    'max_tokens'?: number | null;
    /**
     * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and [reasoning tokens](/docs/guides/reasoning). 
     */
    'max_completion_tokens'?: number | null;
    /**
     * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs.
     */
    'n'?: number | null;
    /**
     * Output types that you would like the model to generate for this request. Most models are capable of generating text, which is the default:  `[\"text\"]`  The `gpt-4o-audio-preview` model can also be used to [generate audio](/docs/guides/audio). To request that this model generate both text and audio responses, you can use:  `[\"text\", \"audio\"]` 
     */
    'modalities'?: Array<CreateChatCompletionRequestModalitiesEnum> | null;
    'prediction'?: PredictionContent | null;
    'audio'?: CreateChatCompletionRequestAudio | null;
    /**
     * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model\'s likelihood to talk about new topics. 
     */
    'presence_penalty'?: number | null;
    'response_format'?: CreateChatCompletionRequestResponseFormat;
    /**
     * This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result. Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend. 
     */
    'seed'?: number | null;
    /**
     * Specifies the latency tier to use for processing the request. This parameter is relevant for customers subscribed to the scale tier service:    - If set to \'auto\', and the Project is Scale tier enabled, the system will utilize scale tier credits until they are exhausted.   - If set to \'auto\', and the Project is not Scale tier enabled, the request will be processed using the default service tier with a lower uptime SLA and no latency guarentee.   - If set to \'default\', the request will be processed using the default service tier with a lower uptime SLA and no latency guarentee.   - When not set, the default behavior is \'auto\'.    When this parameter is set, the response body will include the `service_tier` utilized. 
     */
    'service_tier'?: CreateChatCompletionRequestServiceTierEnum | null;
    'stop'?: CreateChatCompletionRequestStop;
    /**
     * If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions). 
     */
    'stream'?: boolean | null;
    'stream_options'?: ChatCompletionStreamOptions | null;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. We generally recommend altering this or `top_p` but not both. 
     */
    'temperature'?: number | null;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or `temperature` but not both. 
     */
    'top_p'?: number | null;
    /**
     * A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported. 
     */
    'tools'?: Array<ChatCompletionTool>;
    'tool_choice'?: ChatCompletionToolChoiceOption;
    /**
     * Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
     */
    'parallel_tool_calls'?: boolean;
    /**
     * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
     */
    'user'?: string;
    /**
     * @deprecated
     */
    'function_call'?: CreateChatCompletionRequestFunctionCall;
    /**
     * Deprecated in favor of `tools`.  A list of functions the model may generate JSON inputs for. 
     * @deprecated
     */
    'functions'?: Array<ChatCompletionFunctions>;
}

export const CreateChatCompletionRequestReasoningEffortEnum = {
    Low: 'low',
    Medium: 'medium',
    High: 'high'
} as const;

export type CreateChatCompletionRequestReasoningEffortEnum = typeof CreateChatCompletionRequestReasoningEffortEnum[keyof typeof CreateChatCompletionRequestReasoningEffortEnum];
export const CreateChatCompletionRequestModalitiesEnum = {
    Text: 'text',
    Audio: 'audio'
} as const;

export type CreateChatCompletionRequestModalitiesEnum = typeof CreateChatCompletionRequestModalitiesEnum[keyof typeof CreateChatCompletionRequestModalitiesEnum];
export const CreateChatCompletionRequestServiceTierEnum = {
    Auto: 'auto',
    Default: 'default'
} as const;

export type CreateChatCompletionRequestServiceTierEnum = typeof CreateChatCompletionRequestServiceTierEnum[keyof typeof CreateChatCompletionRequestServiceTierEnum];

/**
 * Parameters for audio output. Required when audio output is requested with `modalities: [\"audio\"]`. [Learn more](/docs/guides/audio). 
 */
export interface CreateChatCompletionRequestAudio {
    /**
     * The voice the model uses to respond. Supported voices are `ash`, `ballad`, `coral`, `sage`, and `verse` (also supported but not recommended are `alloy`, `echo`, and `shimmer`; these voices are less expressive). 
     */
    'voice': CreateChatCompletionRequestAudioVoiceEnum;
    /**
     * Specifies the output audio format. Must be one of `wav`, `mp3`, `flac`, `opus`, or `pcm16`. 
     */
    'format': CreateChatCompletionRequestAudioFormatEnum;
}

export const CreateChatCompletionRequestAudioVoiceEnum = {
    Alloy: 'alloy',
    Ash: 'ash',
    Ballad: 'ballad',
    Coral: 'coral',
    Echo: 'echo',
    Sage: 'sage',
    Shimmer: 'shimmer',
    Verse: 'verse'
} as const;

export type CreateChatCompletionRequestAudioVoiceEnum = typeof CreateChatCompletionRequestAudioVoiceEnum[keyof typeof CreateChatCompletionRequestAudioVoiceEnum];
export const CreateChatCompletionRequestAudioFormatEnum = {
    Wav: 'wav',
    Mp3: 'mp3',
    Flac: 'flac',
    Opus: 'opus',
    Pcm16: 'pcm16'
} as const;

export type CreateChatCompletionRequestAudioFormatEnum = typeof CreateChatCompletionRequestAudioFormatEnum[keyof typeof CreateChatCompletionRequestAudioFormatEnum];

/**
 * @type CreateChatCompletionRequestFunctionCall
 * Deprecated in favor of `tool_choice`.  Controls which (if any) function is called by the model.  `none` means the model will not call a function and instead generates a message.  `auto` means the model can pick between generating a message or calling a function.  Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function.  `none` is the default when no functions are present. `auto` is the default if functions are present. 
 */
export type CreateChatCompletionRequestFunctionCall = ChatCompletionFunctionCallOption | string;

/**
 * ID of the model to use. See the [model endpoint compatibility](/docs/models#model-endpoint-compatibility) table for details on which models work with the Chat API.
 */
export interface CreateChatCompletionRequestModel {
}
/**
 * @type CreateChatCompletionRequestResponseFormat
 * An object specifying the format that the model must output.  Setting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).  Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the message the model generates is valid JSON.  **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \"stuck\" request. Also note that the message content may be partially cut off if `finish_reason=\"length\"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length. 
 */
export type CreateChatCompletionRequestResponseFormat = ResponseFormatJsonObject | ResponseFormatJsonSchema | ResponseFormatText;

/**
 * @type CreateChatCompletionRequestStop
 * Up to 4 sequences where the API will stop generating further tokens. 
 */
export type CreateChatCompletionRequestStop = Array<string> | string;

/**
 * Represents a chat completion response returned by model, based on the provided input.
 */
export interface CreateChatCompletionResponse {
    /**
     * A unique identifier for the chat completion.
     */
    'id': string;
    /**
     * A list of chat completion choices. Can be more than one if `n` is greater than 1.
     */
    'choices': Array<CreateChatCompletionResponseChoicesInner>;
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created.
     */
    'created': number;
    /**
     * The model used for the chat completion.
     */
    'model': string;
    /**
     * The service tier used for processing the request. This field is only included if the `service_tier` parameter is specified in the request.
     */
    'service_tier'?: CreateChatCompletionResponseServiceTierEnum | null;
    /**
     * This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
     */
    'system_fingerprint'?: string;
    /**
     * The object type, which is always `chat.completion`.
     */
    'object': CreateChatCompletionResponseObjectEnum;
    'usage'?: CompletionUsage;
}

export const CreateChatCompletionResponseServiceTierEnum = {
    Scale: 'scale',
    Default: 'default'
} as const;

export type CreateChatCompletionResponseServiceTierEnum = typeof CreateChatCompletionResponseServiceTierEnum[keyof typeof CreateChatCompletionResponseServiceTierEnum];
export const CreateChatCompletionResponseObjectEnum = {
    ChatCompletion: 'chat.completion'
} as const;

export type CreateChatCompletionResponseObjectEnum = typeof CreateChatCompletionResponseObjectEnum[keyof typeof CreateChatCompletionResponseObjectEnum];

export interface CreateChatCompletionResponseChoicesInner {
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
     */
    'finish_reason': CreateChatCompletionResponseChoicesInnerFinishReasonEnum;
    /**
     * The index of the choice in the list of choices.
     */
    'index': number;
    'message': ChatCompletionResponseMessage;
    'logprobs': CreateChatCompletionResponseChoicesInnerLogprobs | null;
}

export const CreateChatCompletionResponseChoicesInnerFinishReasonEnum = {
    Stop: 'stop',
    Length: 'length',
    ToolCalls: 'tool_calls',
    ContentFilter: 'content_filter',
    FunctionCall: 'function_call'
} as const;

export type CreateChatCompletionResponseChoicesInnerFinishReasonEnum = typeof CreateChatCompletionResponseChoicesInnerFinishReasonEnum[keyof typeof CreateChatCompletionResponseChoicesInnerFinishReasonEnum];

/**
 * Log probability information for the choice.
 */
export interface CreateChatCompletionResponseChoicesInnerLogprobs {
    /**
     * A list of message content tokens with log probability information.
     */
    'content': Array<ChatCompletionTokenLogprob> | null;
    /**
     * A list of message refusal tokens with log probability information.
     */
    'refusal': Array<ChatCompletionTokenLogprob> | null;
}
/**
 * Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
 */
export interface CreateChatCompletionStreamResponse {
    /**
     * A unique identifier for the chat completion. Each chunk has the same ID.
     */
    'id': string;
    /**
     * A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the last chunk if you set `stream_options: {\"include_usage\": true}`. 
     */
    'choices': Array<CreateChatCompletionStreamResponseChoicesInner>;
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
     */
    'created': number;
    /**
     * The model to generate the completion.
     */
    'model': string;
    /**
     * The service tier used for processing the request. This field is only included if the `service_tier` parameter is specified in the request.
     */
    'service_tier'?: CreateChatCompletionStreamResponseServiceTierEnum | null;
    /**
     * This fingerprint represents the backend configuration that the model runs with. Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
     */
    'system_fingerprint'?: string;
    /**
     * The object type, which is always `chat.completion.chunk`.
     */
    'object': CreateChatCompletionStreamResponseObjectEnum;
    'usage'?: CreateChatCompletionStreamResponseUsage | null;
}

export const CreateChatCompletionStreamResponseServiceTierEnum = {
    Scale: 'scale',
    Default: 'default'
} as const;

export type CreateChatCompletionStreamResponseServiceTierEnum = typeof CreateChatCompletionStreamResponseServiceTierEnum[keyof typeof CreateChatCompletionStreamResponseServiceTierEnum];
export const CreateChatCompletionStreamResponseObjectEnum = {
    ChatCompletionChunk: 'chat.completion.chunk'
} as const;

export type CreateChatCompletionStreamResponseObjectEnum = typeof CreateChatCompletionStreamResponseObjectEnum[keyof typeof CreateChatCompletionStreamResponseObjectEnum];

export interface CreateChatCompletionStreamResponseChoicesInner {
    'delta': ChatCompletionStreamResponseDelta;
    'logprobs'?: CreateChatCompletionResponseChoicesInnerLogprobs | null;
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
     */
    'finish_reason': CreateChatCompletionStreamResponseChoicesInnerFinishReasonEnum | null;
    /**
     * The index of the choice in the list of choices.
     */
    'index': number;
}

export const CreateChatCompletionStreamResponseChoicesInnerFinishReasonEnum = {
    Stop: 'stop',
    Length: 'length',
    ToolCalls: 'tool_calls',
    ContentFilter: 'content_filter',
    FunctionCall: 'function_call'
} as const;

export type CreateChatCompletionStreamResponseChoicesInnerFinishReasonEnum = typeof CreateChatCompletionStreamResponseChoicesInnerFinishReasonEnum[keyof typeof CreateChatCompletionStreamResponseChoicesInnerFinishReasonEnum];

/**
 * An optional field that will only be present when you set `stream_options: {\"include_usage\": true}` in your request. When present, it contains a null value except for the last chunk which contains the token usage statistics for the entire request. 
 */
export interface CreateChatCompletionStreamResponseUsage {
    /**
     * Number of tokens in the generated completion.
     */
    'completion_tokens': number;
    /**
     * Number of tokens in the prompt.
     */
    'prompt_tokens': number;
    /**
     * Total number of tokens used in the request (prompt + completion).
     */
    'total_tokens': number;
}
export interface CreateCompletionRequest {
    'model': CreateCompletionRequestModel;
    'prompt': CreateCompletionRequestPrompt | null;
    /**
     * Generates `best_of` completions server-side and returns the \"best\" (the one with the highest log probability per token). Results cannot be streamed.  When used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return  `best_of` must be greater than `n`.  **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`. 
     */
    'best_of'?: number | null;
    /**
     * Echo back the prompt in addition to the completion 
     */
    'echo'?: boolean | null;
    /**
     * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model\'s likelihood to repeat the same line verbatim.  [See more information about frequency and presence penalties.](/docs/guides/text-generation) 
     */
    'frequency_penalty'?: number | null;
    /**
     * Modify the likelihood of specified tokens appearing in the completion.  Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.  As an example, you can pass `{\"50256\": -100}` to prevent the <|endoftext|> token from being generated. 
     */
    'logit_bias'?: { [key: string]: number; } | null;
    /**
     * Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.  The maximum value for `logprobs` is 5. 
     */
    'logprobs'?: number | null;
    /**
     * The maximum number of [tokens](/tokenizer) that can be generated in the completion.  The token count of your prompt plus `max_tokens` cannot exceed the model\'s context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. 
     */
    'max_tokens'?: number | null;
    /**
     * How many completions to generate for each prompt.  **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`. 
     */
    'n'?: number | null;
    /**
     * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model\'s likelihood to talk about new topics.  [See more information about frequency and presence penalties.](/docs/guides/text-generation) 
     */
    'presence_penalty'?: number | null;
    /**
     * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.  Determinism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend. 
     */
    'seed'?: number | null;
    'stop'?: CreateCompletionRequestStop | null;
    /**
     * Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions). 
     */
    'stream'?: boolean | null;
    'stream_options'?: ChatCompletionStreamOptions | null;
    /**
     * The suffix that comes after a completion of inserted text.  This parameter is only supported for `gpt-3.5-turbo-instruct`. 
     */
    'suffix'?: string | null;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or `top_p` but not both. 
     */
    'temperature'?: number | null;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or `temperature` but not both. 
     */
    'top_p'?: number | null;
    /**
     * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
     */
    'user'?: string;
}
/**
 * ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them. 
 */
export interface CreateCompletionRequestModel {
}
/**
 * @type CreateCompletionRequestPrompt
 * The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.  Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document. 
 */
export type CreateCompletionRequestPrompt = Array<Array<number>> | Array<number> | Array<string> | string;

/**
 * @type CreateCompletionRequestStop
 * Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence. 
 */
export type CreateCompletionRequestStop = Array<string> | string;

/**
 * Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape (unlike the chat endpoint). 
 */
export interface CreateCompletionResponse {
    /**
     * A unique identifier for the completion.
     */
    'id': string;
    /**
     * The list of completion choices the model generated for the input prompt.
     */
    'choices': Array<CreateCompletionResponseChoicesInner>;
    /**
     * The Unix timestamp (in seconds) of when the completion was created.
     */
    'created': number;
    /**
     * The model used for completion.
     */
    'model': string;
    /**
     * This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism. 
     */
    'system_fingerprint'?: string;
    /**
     * The object type, which is always \"text_completion\"
     */
    'object': CreateCompletionResponseObjectEnum;
    'usage'?: CompletionUsage;
}

export const CreateCompletionResponseObjectEnum = {
    TextCompletion: 'text_completion'
} as const;

export type CreateCompletionResponseObjectEnum = typeof CreateCompletionResponseObjectEnum[keyof typeof CreateCompletionResponseObjectEnum];

export interface CreateCompletionResponseChoicesInner {
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, or `content_filter` if content was omitted due to a flag from our content filters. 
     */
    'finish_reason': CreateCompletionResponseChoicesInnerFinishReasonEnum;
    'index': number;
    'logprobs': CreateCompletionResponseChoicesInnerLogprobs | null;
    'text': string;
}

export const CreateCompletionResponseChoicesInnerFinishReasonEnum = {
    Stop: 'stop',
    Length: 'length',
    ContentFilter: 'content_filter'
} as const;

export type CreateCompletionResponseChoicesInnerFinishReasonEnum = typeof CreateCompletionResponseChoicesInnerFinishReasonEnum[keyof typeof CreateCompletionResponseChoicesInnerFinishReasonEnum];

export interface CreateCompletionResponseChoicesInnerLogprobs {
    'text_offset'?: Array<number>;
    'token_logprobs'?: Array<number>;
    'tokens'?: Array<string>;
    'top_logprobs'?: Array<{ [key: string]: number; }>;
}
export interface CreateEmbeddingRequest {
    'input': CreateEmbeddingRequestInput;
    'model': CreateEmbeddingRequestModel;
    /**
     * The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
     */
    'encoding_format'?: CreateEmbeddingRequestEncodingFormatEnum;
    /**
     * The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models. 
     */
    'dimensions'?: number;
    /**
     * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
     */
    'user'?: string;
}

export const CreateEmbeddingRequestEncodingFormatEnum = {
    Float: 'float',
    Base64: 'base64'
} as const;

export type CreateEmbeddingRequestEncodingFormatEnum = typeof CreateEmbeddingRequestEncodingFormatEnum[keyof typeof CreateEmbeddingRequestEncodingFormatEnum];

/**
 * @type CreateEmbeddingRequestInput
 * Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. 
 */
export type CreateEmbeddingRequestInput = Array<Array<number>> | Array<number> | Array<string> | string;

/**
 * ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them. 
 */
export interface CreateEmbeddingRequestModel {
}
export interface CreateEmbeddingResponse {
    /**
     * The list of embeddings generated by the model.
     */
    'data': Array<Embedding>;
    /**
     * The name of the model used to generate the embedding.
     */
    'model': string;
    /**
     * The object type, which is always \"list\".
     */
    'object': CreateEmbeddingResponseObjectEnum;
    'usage': CreateEmbeddingResponseUsage;
}

export const CreateEmbeddingResponseObjectEnum = {
    List: 'list'
} as const;

export type CreateEmbeddingResponseObjectEnum = typeof CreateEmbeddingResponseObjectEnum[keyof typeof CreateEmbeddingResponseObjectEnum];

/**
 * The usage information for the request.
 */
export interface CreateEmbeddingResponseUsage {
    /**
     * The number of tokens used by the prompt.
     */
    'prompt_tokens': number;
    /**
     * The total number of tokens used by the request.
     */
    'total_tokens': number;
}
export interface CreateFineTuningJobRequest {
    'model': CreateFineTuningJobRequestModel;
    /**
     * The ID of an uploaded file that contains training data.  See [upload file](/docs/api-reference/files/create) for how to upload a file.  Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.  The contents of the file should differ depending on if the model uses the [chat](/docs/api-reference/fine-tuning/chat-input), [completions](/docs/api-reference/fine-tuning/completions-input) format, or if the fine-tuning method uses the [preference](/docs/api-reference/fine-tuning/preference-input) format.  See the [fine-tuning guide](/docs/guides/fine-tuning) for more details. 
     */
    'training_file': string;
    /**
     * @deprecated
     */
    'hyperparameters'?: CreateFineTuningJobRequestHyperparameters;
    /**
     * A string of up to 64 characters that will be added to your fine-tuned model name.  For example, a `suffix` of \"custom-model-name\" would produce a model name like `ft:gpt-4o-mini:openai:custom-model-name:7p4lURel`. 
     */
    'suffix'?: string | null;
    /**
     * The ID of an uploaded file that contains validation data.  If you provide this file, the data is used to generate validation metrics periodically during fine-tuning. These metrics can be viewed in the fine-tuning results file. The same data should not be present in both train and validation files.  Your dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.  See the [fine-tuning guide](/docs/guides/fine-tuning) for more details. 
     */
    'validation_file'?: string | null;
    /**
     * A list of integrations to enable for your fine-tuning job.
     */
    'integrations'?: Array<CreateFineTuningJobRequestIntegrationsInner> | null;
    /**
     * The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases. If a seed is not specified, one will be generated for you. 
     */
    'seed'?: number | null;
    'method'?: FineTuneMethod;
}
/**
 * The hyperparameters used for the fine-tuning job. This value is now deprecated in favor of `method`, and should be passed in under the `method` parameter. 
 */
export interface CreateFineTuningJobRequestHyperparameters {
    'batch_size'?: CreateFineTuningJobRequestHyperparametersBatchSize;
    'learning_rate_multiplier'?: CreateFineTuningJobRequestHyperparametersLearningRateMultiplier;
    'n_epochs'?: CreateFineTuningJobRequestHyperparametersNEpochs;
}
/**
 * @type CreateFineTuningJobRequestHyperparametersBatchSize
 * Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance. 
 */
export type CreateFineTuningJobRequestHyperparametersBatchSize = number | string;

/**
 * @type CreateFineTuningJobRequestHyperparametersLearningRateMultiplier
 * Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting. 
 */
export type CreateFineTuningJobRequestHyperparametersLearningRateMultiplier = number | string;

/**
 * @type CreateFineTuningJobRequestHyperparametersNEpochs
 * The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset. 
 */
export type CreateFineTuningJobRequestHyperparametersNEpochs = number | string;

export interface CreateFineTuningJobRequestIntegrationsInner {
    'type': CreateFineTuningJobRequestIntegrationsInnerTypeEnum;
    'wandb': CreateFineTuningJobRequestIntegrationsInnerWandb;
}

export const CreateFineTuningJobRequestIntegrationsInnerTypeEnum = {
    Wandb: 'wandb'
} as const;

export type CreateFineTuningJobRequestIntegrationsInnerTypeEnum = typeof CreateFineTuningJobRequestIntegrationsInnerTypeEnum[keyof typeof CreateFineTuningJobRequestIntegrationsInnerTypeEnum];

/**
 * The settings for your integration with Weights and Biases. This payload specifies the project that metrics will be sent to. Optionally, you can set an explicit display name for your run, add tags to your run, and set a default entity (team, username, etc) to be associated with your run. 
 */
export interface CreateFineTuningJobRequestIntegrationsInnerWandb {
    /**
     * The name of the project that the new run will be created under. 
     */
    'project': string;
    /**
     * A display name to set for the run. If not set, we will use the Job ID as the name. 
     */
    'name'?: string | null;
    /**
     * The entity to use for the run. This allows you to set the team or username of the WandB user that you would like associated with the run. If not set, the default entity for the registered WandB API key is used. 
     */
    'entity'?: string | null;
    /**
     * A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some default tags are generated by OpenAI: \"openai/finetune\", \"openai/{base-model}\", \"openai/{ftjob-abcdef}\". 
     */
    'tags'?: Array<string>;
}
/**
 * The name of the model to fine-tune. You can select one of the [supported models](/docs/guides/fine-tuning#which-models-can-be-fine-tuned). 
 */
export interface CreateFineTuningJobRequestModel {
}
/**
 * The model to use for image generation. Only `dall-e-2` is supported at this time.
 */
export interface CreateImageEditRequestModel {
}
export interface CreateImageRequest {
    /**
     * A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
     */
    'prompt': string;
    'model'?: CreateImageRequestModel | null;
    /**
     * The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
     */
    'n'?: number | null;
    /**
     * The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
     */
    'quality'?: CreateImageRequestQualityEnum;
    /**
     * The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
     */
    'response_format'?: CreateImageRequestResponseFormatEnum | null;
    /**
     * The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
     */
    'size'?: CreateImageRequestSizeEnum | null;
    /**
     * The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
     */
    'style'?: CreateImageRequestStyleEnum | null;
    /**
     * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
     */
    'user'?: string;
}

export const CreateImageRequestQualityEnum = {
    Standard: 'standard',
    Hd: 'hd'
} as const;

export type CreateImageRequestQualityEnum = typeof CreateImageRequestQualityEnum[keyof typeof CreateImageRequestQualityEnum];
export const CreateImageRequestResponseFormatEnum = {
    Url: 'url',
    B64Json: 'b64_json'
} as const;

export type CreateImageRequestResponseFormatEnum = typeof CreateImageRequestResponseFormatEnum[keyof typeof CreateImageRequestResponseFormatEnum];
export const CreateImageRequestSizeEnum = {
    _256x256: '256x256',
    _512x512: '512x512',
    _1024x1024: '1024x1024',
    _1792x1024: '1792x1024',
    _1024x1792: '1024x1792'
} as const;

export type CreateImageRequestSizeEnum = typeof CreateImageRequestSizeEnum[keyof typeof CreateImageRequestSizeEnum];
export const CreateImageRequestStyleEnum = {
    Vivid: 'vivid',
    Natural: 'natural'
} as const;

export type CreateImageRequestStyleEnum = typeof CreateImageRequestStyleEnum[keyof typeof CreateImageRequestStyleEnum];

/**
 * The model to use for image generation.
 */
export interface CreateImageRequestModel {
}
export interface CreateMessageRequest {
    /**
     * The role of the entity that is creating the message. Allowed values include: - `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages. - `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation. 
     */
    'role': CreateMessageRequestRoleEnum;
    'content': CreateMessageRequestContent;
    /**
     * A list of files attached to the message, and the tools they should be added to.
     */
    'attachments'?: Array<CreateMessageRequestAttachmentsInner> | null;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata'?: object | null;
}

export const CreateMessageRequestRoleEnum = {
    User: 'user',
    Assistant: 'assistant'
} as const;

export type CreateMessageRequestRoleEnum = typeof CreateMessageRequestRoleEnum[keyof typeof CreateMessageRequestRoleEnum];

export interface CreateMessageRequestAttachmentsInner {
    /**
     * The ID of the file to attach to the message.
     */
    'file_id'?: string;
    /**
     * The tools to add this file to.
     */
    'tools'?: Array<CreateMessageRequestAttachmentsInnerToolsInner>;
}
/**
 * @type CreateMessageRequestAttachmentsInnerToolsInner
 */
export type CreateMessageRequestAttachmentsInnerToolsInner = AssistantToolsCode | AssistantToolsFileSearchTypeOnly;

/**
 * @type CreateMessageRequestContent
 */
export type CreateMessageRequestContent = Array<ArrayOfContentPartsInner> | string;

export interface CreateModerationRequest {
    'input': CreateModerationRequestInput;
    'model'?: CreateModerationRequestModel;
}
/**
 * @type CreateModerationRequestInput
 * Input (or inputs) to classify. Can be a single string, an array of strings, or an array of multi-modal input objects similar to other models. 
 */
export type CreateModerationRequestInput = Array<CreateModerationRequestInputOneOfInner> | Array<string> | string;

/**
 * @type CreateModerationRequestInputOneOfInner
 */
export type CreateModerationRequestInputOneOfInner = CreateModerationRequestInputOneOfInnerOneOf | CreateModerationRequestInputOneOfInnerOneOf1;

/**
 * An object describing an image to classify.
 */
export interface CreateModerationRequestInputOneOfInnerOneOf {
    /**
     * Always `image_url`.
     */
    'type': CreateModerationRequestInputOneOfInnerOneOfTypeEnum;
    'image_url': CreateModerationRequestInputOneOfInnerOneOfImageUrl;
}

export const CreateModerationRequestInputOneOfInnerOneOfTypeEnum = {
    ImageUrl: 'image_url'
} as const;

export type CreateModerationRequestInputOneOfInnerOneOfTypeEnum = typeof CreateModerationRequestInputOneOfInnerOneOfTypeEnum[keyof typeof CreateModerationRequestInputOneOfInnerOneOfTypeEnum];

/**
 * An object describing text to classify.
 */
export interface CreateModerationRequestInputOneOfInnerOneOf1 {
    /**
     * Always `text`.
     */
    'type': CreateModerationRequestInputOneOfInnerOneOf1TypeEnum;
    /**
     * A string of text to classify.
     */
    'text': string;
}

export const CreateModerationRequestInputOneOfInnerOneOf1TypeEnum = {
    Text: 'text'
} as const;

export type CreateModerationRequestInputOneOfInnerOneOf1TypeEnum = typeof CreateModerationRequestInputOneOfInnerOneOf1TypeEnum[keyof typeof CreateModerationRequestInputOneOfInnerOneOf1TypeEnum];

/**
 * Contains either an image URL or a data URL for a base64 encoded image.
 */
export interface CreateModerationRequestInputOneOfInnerOneOfImageUrl {
    /**
     * Either a URL of the image or the base64 encoded image data.
     */
    'url': string;
}
/**
 * The content moderation model you would like to use. Learn more in [the moderation guide](/docs/guides/moderation), and learn about available models [here](/docs/models#moderation). 
 */
export interface CreateModerationRequestModel {
}
/**
 * Represents if a given text input is potentially harmful.
 */
export interface CreateModerationResponse {
    /**
     * The unique identifier for the moderation request.
     */
    'id': string;
    /**
     * The model used to generate the moderation results.
     */
    'model': string;
    /**
     * A list of moderation objects.
     */
    'results': Array<CreateModerationResponseResultsInner>;
}
export interface CreateModerationResponseResultsInner {
    /**
     * Whether any of the below categories are flagged.
     */
    'flagged': boolean;
    'categories': CreateModerationResponseResultsInnerCategories;
    'category_scores': CreateModerationResponseResultsInnerCategoryScores;
    'category_applied_input_types': CreateModerationResponseResultsInnerCategoryAppliedInputTypes;
}
/**
 * A list of the categories, and whether they are flagged or not.
 */
export interface CreateModerationResponseResultsInnerCategories {
    /**
     * Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
     */
    'hate': boolean;
    /**
     * Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
     */
    'hate/threatening': boolean;
    /**
     * Content that expresses, incites, or promotes harassing language towards any target.
     */
    'harassment': boolean;
    /**
     * Harassment content that also includes violence or serious harm towards any target.
     */
    'harassment/threatening': boolean;
    /**
     * Content that includes instructions or advice that facilitate the planning or execution of wrongdoing, or that gives advice or instruction on how to commit illicit acts. For example, \"how to shoplift\" would fit this category.
     */
    'illicit': boolean;
    /**
     * Content that includes instructions or advice that facilitate the planning or execution of wrongdoing that also includes violence, or that gives advice or instruction on the procurement of any weapon.
     */
    'illicit/violent': boolean;
    /**
     * Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
     */
    'self-harm': boolean;
    /**
     * Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
     */
    'self-harm/intent': boolean;
    /**
     * Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
     */
    'self-harm/instructions': boolean;
    /**
     * Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
     */
    'sexual': boolean;
    /**
     * Sexual content that includes an individual who is under 18 years old.
     */
    'sexual/minors': boolean;
    /**
     * Content that depicts death, violence, or physical injury.
     */
    'violence': boolean;
    /**
     * Content that depicts death, violence, or physical injury in graphic detail.
     */
    'violence/graphic': boolean;
}
/**
 * A list of the categories along with the input type(s) that the score applies to.
 */
export interface CreateModerationResponseResultsInnerCategoryAppliedInputTypes {
    /**
     * The applied input type(s) for the category \'hate\'.
     */
    'hate': Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesHateEnum>;
    /**
     * The applied input type(s) for the category \'hate/threatening\'.
     */
    'hate/threatening': Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesHateThreateningEnum>;
    /**
     * The applied input type(s) for the category \'harassment\'.
     */
    'harassment': Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesHarassmentEnum>;
    /**
     * The applied input type(s) for the category \'harassment/threatening\'.
     */
    'harassment/threatening': Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesHarassmentThreateningEnum>;
    /**
     * The applied input type(s) for the category \'illicit\'.
     */
    'illicit': Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesIllicitEnum>;
    /**
     * The applied input type(s) for the category \'illicit/violent\'.
     */
    'illicit/violent': Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesIllicitViolentEnum>;
    /**
     * The applied input type(s) for the category \'self-harm\'.
     */
    'self-harm': Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmEnum>;
    /**
     * The applied input type(s) for the category \'self-harm/intent\'.
     */
    'self-harm/intent': Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmIntentEnum>;
    /**
     * The applied input type(s) for the category \'self-harm/instructions\'.
     */
    'self-harm/instructions': Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmInstructionsEnum>;
    /**
     * The applied input type(s) for the category \'sexual\'.
     */
    'sexual': Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesSexualEnum>;
    /**
     * The applied input type(s) for the category \'sexual/minors\'.
     */
    'sexual/minors': Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesSexualMinorsEnum>;
    /**
     * The applied input type(s) for the category \'violence\'.
     */
    'violence': Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesViolenceEnum>;
    /**
     * The applied input type(s) for the category \'violence/graphic\'.
     */
    'violence/graphic': Array<CreateModerationResponseResultsInnerCategoryAppliedInputTypesViolenceGraphicEnum>;
}

export const CreateModerationResponseResultsInnerCategoryAppliedInputTypesHateEnum = {
    Text: 'text'
} as const;

export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesHateEnum = typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesHateEnum[keyof typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesHateEnum];
export const CreateModerationResponseResultsInnerCategoryAppliedInputTypesHateThreateningEnum = {
    Text: 'text'
} as const;

export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesHateThreateningEnum = typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesHateThreateningEnum[keyof typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesHateThreateningEnum];
export const CreateModerationResponseResultsInnerCategoryAppliedInputTypesHarassmentEnum = {
    Text: 'text'
} as const;

export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesHarassmentEnum = typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesHarassmentEnum[keyof typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesHarassmentEnum];
export const CreateModerationResponseResultsInnerCategoryAppliedInputTypesHarassmentThreateningEnum = {
    Text: 'text'
} as const;

export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesHarassmentThreateningEnum = typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesHarassmentThreateningEnum[keyof typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesHarassmentThreateningEnum];
export const CreateModerationResponseResultsInnerCategoryAppliedInputTypesIllicitEnum = {
    Text: 'text'
} as const;

export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesIllicitEnum = typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesIllicitEnum[keyof typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesIllicitEnum];
export const CreateModerationResponseResultsInnerCategoryAppliedInputTypesIllicitViolentEnum = {
    Text: 'text'
} as const;

export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesIllicitViolentEnum = typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesIllicitViolentEnum[keyof typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesIllicitViolentEnum];
export const CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmEnum = {
    Text: 'text',
    Image: 'image'
} as const;

export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmEnum = typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmEnum[keyof typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmEnum];
export const CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmIntentEnum = {
    Text: 'text',
    Image: 'image'
} as const;

export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmIntentEnum = typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmIntentEnum[keyof typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmIntentEnum];
export const CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmInstructionsEnum = {
    Text: 'text',
    Image: 'image'
} as const;

export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmInstructionsEnum = typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmInstructionsEnum[keyof typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesSelfHarmInstructionsEnum];
export const CreateModerationResponseResultsInnerCategoryAppliedInputTypesSexualEnum = {
    Text: 'text',
    Image: 'image'
} as const;

export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesSexualEnum = typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesSexualEnum[keyof typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesSexualEnum];
export const CreateModerationResponseResultsInnerCategoryAppliedInputTypesSexualMinorsEnum = {
    Text: 'text'
} as const;

export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesSexualMinorsEnum = typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesSexualMinorsEnum[keyof typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesSexualMinorsEnum];
export const CreateModerationResponseResultsInnerCategoryAppliedInputTypesViolenceEnum = {
    Text: 'text',
    Image: 'image'
} as const;

export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesViolenceEnum = typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesViolenceEnum[keyof typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesViolenceEnum];
export const CreateModerationResponseResultsInnerCategoryAppliedInputTypesViolenceGraphicEnum = {
    Text: 'text',
    Image: 'image'
} as const;

export type CreateModerationResponseResultsInnerCategoryAppliedInputTypesViolenceGraphicEnum = typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesViolenceGraphicEnum[keyof typeof CreateModerationResponseResultsInnerCategoryAppliedInputTypesViolenceGraphicEnum];

/**
 * A list of the categories along with their scores as predicted by model.
 */
export interface CreateModerationResponseResultsInnerCategoryScores {
    /**
     * The score for the category \'hate\'.
     */
    'hate': number;
    /**
     * The score for the category \'hate/threatening\'.
     */
    'hate/threatening': number;
    /**
     * The score for the category \'harassment\'.
     */
    'harassment': number;
    /**
     * The score for the category \'harassment/threatening\'.
     */
    'harassment/threatening': number;
    /**
     * The score for the category \'illicit\'.
     */
    'illicit': number;
    /**
     * The score for the category \'illicit/violent\'.
     */
    'illicit/violent': number;
    /**
     * The score for the category \'self-harm\'.
     */
    'self-harm': number;
    /**
     * The score for the category \'self-harm/intent\'.
     */
    'self-harm/intent': number;
    /**
     * The score for the category \'self-harm/instructions\'.
     */
    'self-harm/instructions': number;
    /**
     * The score for the category \'sexual\'.
     */
    'sexual': number;
    /**
     * The score for the category \'sexual/minors\'.
     */
    'sexual/minors': number;
    /**
     * The score for the category \'violence\'.
     */
    'violence': number;
    /**
     * The score for the category \'violence/graphic\'.
     */
    'violence/graphic': number;
}
export interface CreateRunRequest {
    /**
     * The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
     */
    'assistant_id': string;
    'model'?: CreateRunRequestModel | null;
    /**
     * Overrides the [instructions](/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis.
     */
    'instructions'?: string | null;
    /**
     * Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.
     */
    'additional_instructions'?: string | null;
    /**
     * Adds additional messages to the thread before creating the run.
     */
    'additional_messages'?: Array<CreateMessageRequest> | null;
    /**
     * Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
     */
    'tools'?: Array<AssistantObjectToolsInner> | null;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata'?: object | null;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
     */
    'temperature'?: number | null;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
     */
    'top_p'?: number | null;
    /**
     * If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message. 
     */
    'stream'?: boolean | null;
    /**
     * The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info. 
     */
    'max_prompt_tokens'?: number | null;
    /**
     * The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info. 
     */
    'max_completion_tokens'?: number | null;
    'truncation_strategy'?: TruncationObject;
    'tool_choice'?: AssistantsApiToolChoiceOption;
    /**
     * Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
     */
    'parallel_tool_calls'?: boolean;
    'response_format'?: AssistantsApiResponseFormatOption;
}
/**
 * The ID of the [Model](/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
 */
export interface CreateRunRequestModel {
}
export interface CreateSpeechRequest {
    'model': CreateSpeechRequestModel;
    /**
     * The text to generate audio for. The maximum length is 4096 characters.
     */
    'input': string;
    /**
     * The voice to use when generating the audio. Supported voices are `alloy`, `echo`, `fable`, `onyx`, `nova`, and `shimmer`. Previews of the voices are available in the [Text to speech guide](/docs/guides/text-to-speech#voice-options).
     */
    'voice': CreateSpeechRequestVoiceEnum;
    /**
     * The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`.
     */
    'response_format'?: CreateSpeechRequestResponseFormatEnum;
    /**
     * The speed of the generated audio. Select a value from `0.25` to `4.0`. `1.0` is the default.
     */
    'speed'?: number;
}

export const CreateSpeechRequestVoiceEnum = {
    Alloy: 'alloy',
    Echo: 'echo',
    Fable: 'fable',
    Onyx: 'onyx',
    Nova: 'nova',
    Shimmer: 'shimmer'
} as const;

export type CreateSpeechRequestVoiceEnum = typeof CreateSpeechRequestVoiceEnum[keyof typeof CreateSpeechRequestVoiceEnum];
export const CreateSpeechRequestResponseFormatEnum = {
    Mp3: 'mp3',
    Opus: 'opus',
    Aac: 'aac',
    Flac: 'flac',
    Wav: 'wav',
    Pcm: 'pcm'
} as const;

export type CreateSpeechRequestResponseFormatEnum = typeof CreateSpeechRequestResponseFormatEnum[keyof typeof CreateSpeechRequestResponseFormatEnum];

/**
 * One of the available [TTS models](/docs/models#tts): `tts-1` or `tts-1-hd` 
 */
export interface CreateSpeechRequestModel {
}
export interface CreateThreadAndRunRequest {
    /**
     * The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
     */
    'assistant_id': string;
    'thread'?: CreateThreadRequest;
    'model'?: CreateRunRequestModel | null;
    /**
     * Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.
     */
    'instructions'?: string | null;
    /**
     * Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
     */
    'tools'?: Array<CreateThreadAndRunRequestToolsInner> | null;
    'tool_resources'?: CreateThreadAndRunRequestToolResources | null;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata'?: object | null;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
     */
    'temperature'?: number | null;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
     */
    'top_p'?: number | null;
    /**
     * If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message. 
     */
    'stream'?: boolean | null;
    /**
     * The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info. 
     */
    'max_prompt_tokens'?: number | null;
    /**
     * The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info. 
     */
    'max_completion_tokens'?: number | null;
    'truncation_strategy'?: TruncationObject;
    'tool_choice'?: AssistantsApiToolChoiceOption;
    /**
     * Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
     */
    'parallel_tool_calls'?: boolean;
    'response_format'?: AssistantsApiResponseFormatOption;
}
/**
 * A set of resources that are used by the assistant\'s tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
 */
export interface CreateThreadAndRunRequestToolResources {
    'code_interpreter'?: CreateAssistantRequestToolResourcesCodeInterpreter;
    'file_search'?: AssistantObjectToolResourcesFileSearch;
}
/**
 * @type CreateThreadAndRunRequestToolsInner
 */
export type CreateThreadAndRunRequestToolsInner = AssistantToolsCode | AssistantToolsFileSearch | AssistantToolsFunction;

export interface CreateThreadRequest {
    /**
     * A list of [messages](/docs/api-reference/messages) to start the thread with.
     */
    'messages'?: Array<CreateMessageRequest>;
    'tool_resources'?: CreateThreadRequestToolResources | null;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata'?: object | null;
}
/**
 * A set of resources that are made available to the assistant\'s tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
 */
export interface CreateThreadRequestToolResources {
    'code_interpreter'?: CreateAssistantRequestToolResourcesCodeInterpreter;
    'file_search'?: CreateThreadRequestToolResourcesFileSearch | null;
}
export interface CreateThreadRequestToolResourcesFileSearch {
    /**
     * The [vector store](/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread. 
     */
    'vector_store_ids'?: Array<string>;
    /**
     * A helper to create a [vector store](/docs/api-reference/vector-stores/object) with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the thread. 
     */
    'vector_stores'?: Array<CreateThreadRequestToolResourcesFileSearchVectorStoresInner>;
}
export interface CreateThreadRequestToolResourcesFileSearchVectorStoresInner {
    /**
     * A list of [file](/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store. 
     */
    'file_ids'?: Array<string>;
    'chunking_strategy'?: CreateAssistantRequestToolResourcesFileSearchVectorStoresInnerChunkingStrategy;
    /**
     * Set of 16 key-value pairs that can be attached to a vector store. This can be useful for storing additional information about the vector store in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata'?: object;
}
/**
 * @type CreateTranscription200Response
 */
export type CreateTranscription200Response = CreateTranscriptionResponseJson | CreateTranscriptionResponseVerboseJson;

/**
 * ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available. 
 */
export interface CreateTranscriptionRequestModel {
}
/**
 * Represents a transcription response returned by model, based on the provided input.
 */
export interface CreateTranscriptionResponseJson {
    /**
     * The transcribed text.
     */
    'text': string;
}
/**
 * Represents a verbose json transcription response returned by model, based on the provided input.
 */
export interface CreateTranscriptionResponseVerboseJson {
    /**
     * The language of the input audio.
     */
    'language': string;
    /**
     * The duration of the input audio.
     */
    'duration': string;
    /**
     * The transcribed text.
     */
    'text': string;
    /**
     * Extracted words and their corresponding timestamps.
     */
    'words'?: Array<TranscriptionWord>;
    /**
     * Segments of the transcribed text and their corresponding details.
     */
    'segments'?: Array<TranscriptionSegment>;
}
/**
 * @type CreateTranslation200Response
 */
export type CreateTranslation200Response = CreateTranslationResponseJson | CreateTranslationResponseVerboseJson;

export interface CreateTranslationResponseJson {
    'text': string;
}
export interface CreateTranslationResponseVerboseJson {
    /**
     * The language of the output translation (always `english`).
     */
    'language': string;
    /**
     * The duration of the input audio.
     */
    'duration': string;
    /**
     * The translated text.
     */
    'text': string;
    /**
     * Segments of the translated text and their corresponding details.
     */
    'segments'?: Array<TranscriptionSegment>;
}
export interface CreateUploadRequest {
    /**
     * The name of the file to upload. 
     */
    'filename': string;
    /**
     * The intended purpose of the uploaded file.  See the [documentation on File purposes](/docs/api-reference/files/create#files-create-purpose). 
     */
    'purpose': CreateUploadRequestPurposeEnum;
    /**
     * The number of bytes in the file you are uploading. 
     */
    'bytes': number;
    /**
     * The MIME type of the file.  This must fall within the supported MIME types for your file purpose. See the supported MIME types for assistants and vision. 
     */
    'mime_type': string;
}

export const CreateUploadRequestPurposeEnum = {
    Assistants: 'assistants',
    Batch: 'batch',
    FineTune: 'fine-tune',
    Vision: 'vision'
} as const;

export type CreateUploadRequestPurposeEnum = typeof CreateUploadRequestPurposeEnum[keyof typeof CreateUploadRequestPurposeEnum];

export interface CreateVectorStoreFileBatchRequest {
    /**
     * A list of [File](/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
     */
    'file_ids': Array<string>;
    'chunking_strategy'?: ChunkingStrategyRequestParam;
}
export interface CreateVectorStoreFileRequest {
    /**
     * A [File](/docs/api-reference/files) ID that the vector store should use. Useful for tools like `file_search` that can access files.
     */
    'file_id': string;
    'chunking_strategy'?: ChunkingStrategyRequestParam;
}
export interface CreateVectorStoreRequest {
    /**
     * A list of [File](/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.
     */
    'file_ids'?: Array<string>;
    /**
     * The name of the vector store.
     */
    'name'?: string;
    'expires_after'?: VectorStoreExpirationAfter;
    'chunking_strategy'?: CreateVectorStoreRequestChunkingStrategy;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata'?: object | null;
}
/**
 * @type CreateVectorStoreRequestChunkingStrategy
 * The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy. Only applicable if `file_ids` is non-empty.
 */
export type CreateVectorStoreRequestChunkingStrategy = AutoChunkingStrategyRequestParam | StaticChunkingStrategyRequestParam;

export interface DefaultProjectErrorResponse {
    'code': number;
    'message': string;
}
export interface DeleteAssistantResponse {
    'id': string;
    'deleted': boolean;
    'object': DeleteAssistantResponseObjectEnum;
}

export const DeleteAssistantResponseObjectEnum = {
    AssistantDeleted: 'assistant.deleted'
} as const;

export type DeleteAssistantResponseObjectEnum = typeof DeleteAssistantResponseObjectEnum[keyof typeof DeleteAssistantResponseObjectEnum];

export interface DeleteFileResponse {
    'id': string;
    'object': DeleteFileResponseObjectEnum;
    'deleted': boolean;
}

export const DeleteFileResponseObjectEnum = {
    File: 'file'
} as const;

export type DeleteFileResponseObjectEnum = typeof DeleteFileResponseObjectEnum[keyof typeof DeleteFileResponseObjectEnum];

export interface DeleteMessageResponse {
    'id': string;
    'deleted': boolean;
    'object': DeleteMessageResponseObjectEnum;
}

export const DeleteMessageResponseObjectEnum = {
    ThreadMessageDeleted: 'thread.message.deleted'
} as const;

export type DeleteMessageResponseObjectEnum = typeof DeleteMessageResponseObjectEnum[keyof typeof DeleteMessageResponseObjectEnum];

export interface DeleteModelResponse {
    'id': string;
    'deleted': boolean;
    'object': string;
}
export interface DeleteThreadResponse {
    'id': string;
    'deleted': boolean;
    'object': DeleteThreadResponseObjectEnum;
}

export const DeleteThreadResponseObjectEnum = {
    ThreadDeleted: 'thread.deleted'
} as const;

export type DeleteThreadResponseObjectEnum = typeof DeleteThreadResponseObjectEnum[keyof typeof DeleteThreadResponseObjectEnum];

export interface DeleteVectorStoreFileResponse {
    'id': string;
    'deleted': boolean;
    'object': DeleteVectorStoreFileResponseObjectEnum;
}

export const DeleteVectorStoreFileResponseObjectEnum = {
    VectorStoreFileDeleted: 'vector_store.file.deleted'
} as const;

export type DeleteVectorStoreFileResponseObjectEnum = typeof DeleteVectorStoreFileResponseObjectEnum[keyof typeof DeleteVectorStoreFileResponseObjectEnum];

export interface DeleteVectorStoreResponse {
    'id': string;
    'deleted': boolean;
    'object': DeleteVectorStoreResponseObjectEnum;
}

export const DeleteVectorStoreResponseObjectEnum = {
    VectorStoreDeleted: 'vector_store.deleted'
} as const;

export type DeleteVectorStoreResponseObjectEnum = typeof DeleteVectorStoreResponseObjectEnum[keyof typeof DeleteVectorStoreResponseObjectEnum];

/**
 * Occurs when a stream ends.
 */
export interface DoneEvent {
    'event': DoneEventEventEnum;
    'data': DoneEventDataEnum;
}

export const DoneEventEventEnum = {
    Done: 'done'
} as const;

export type DoneEventEventEnum = typeof DoneEventEventEnum[keyof typeof DoneEventEventEnum];
export const DoneEventDataEnum = {
    Done: '[DONE]'
} as const;

export type DoneEventDataEnum = typeof DoneEventDataEnum[keyof typeof DoneEventDataEnum];

/**
 * Represents an embedding vector returned by embedding endpoint. 
 */
export interface Embedding {
    /**
     * The index of the embedding in the list of embeddings.
     */
    'index': number;
    /**
     * The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](/docs/guides/embeddings). 
     */
    'embedding': Array<number>;
    /**
     * The object type, which is always \"embedding\".
     */
    'object': EmbeddingObjectEnum;
}

export const EmbeddingObjectEnum = {
    Embedding: 'embedding'
} as const;

export type EmbeddingObjectEnum = typeof EmbeddingObjectEnum[keyof typeof EmbeddingObjectEnum];

/**
 * Occurs when an [error](/docs/guides/error-codes#api-errors) occurs. This can happen due to an internal server error or a timeout.
 */
export interface ErrorEvent {
    'event': ErrorEventEventEnum;
    'data': Error;
}

export const ErrorEventEventEnum = {
    Error: 'error'
} as const;

export type ErrorEventEventEnum = typeof ErrorEventEventEnum[keyof typeof ErrorEventEventEnum];

export interface ErrorResponse {
    'error': Error;
}
/**
 * The ranking options for the file search. If not specified, the file search tool will use the `auto` ranker and a score_threshold of 0.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
 */
export interface FileSearchRankingOptions {
    /**
     * The ranker to use for the file search. If not specified will use the `auto` ranker.
     */
    'ranker'?: FileSearchRankingOptionsRankerEnum;
    /**
     * The score threshold for the file search. All values must be a floating point number between 0 and 1.
     */
    'score_threshold': number;
}

export const FileSearchRankingOptionsRankerEnum = {
    Auto: 'auto',
    Default20240821: 'default_2024_08_21'
} as const;

export type FileSearchRankingOptionsRankerEnum = typeof FileSearchRankingOptionsRankerEnum[keyof typeof FileSearchRankingOptionsRankerEnum];

export interface FineTuneChatCompletionRequestAssistantMessage {
    'content'?: ChatCompletionRequestAssistantMessageContent | null;
    /**
     * The refusal message by the assistant.
     */
    'refusal'?: string | null;
    /**
     * The role of the messages author, in this case `assistant`.
     */
    'role': FineTuneChatCompletionRequestAssistantMessageRoleEnum;
    /**
     * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
     */
    'name'?: string;
    'audio'?: ChatCompletionRequestAssistantMessageAudio | null;
    /**
     * The tool calls generated by the model, such as function calls.
     */
    'tool_calls'?: Array<ChatCompletionMessageToolCall>;
    /**
     * @deprecated
     */
    'function_call'?: ChatCompletionRequestAssistantMessageFunctionCall | null;
    /**
     * Controls whether the assistant message is trained against (0 or 1)
     */
    'weight'?: FineTuneChatCompletionRequestAssistantMessageWeightEnum;
}

export const FineTuneChatCompletionRequestAssistantMessageRoleEnum = {
    Assistant: 'assistant'
} as const;

export type FineTuneChatCompletionRequestAssistantMessageRoleEnum = typeof FineTuneChatCompletionRequestAssistantMessageRoleEnum[keyof typeof FineTuneChatCompletionRequestAssistantMessageRoleEnum];
export const FineTuneChatCompletionRequestAssistantMessageWeightEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type FineTuneChatCompletionRequestAssistantMessageWeightEnum = typeof FineTuneChatCompletionRequestAssistantMessageWeightEnum[keyof typeof FineTuneChatCompletionRequestAssistantMessageWeightEnum];

/**
 * The per-line training example of a fine-tuning input file for chat models using the supervised method.
 */
export interface FineTuneChatRequestInput {
    'messages'?: Array<FineTuneChatRequestInputMessagesInner>;
    /**
     * A list of tools the model may generate JSON inputs for.
     */
    'tools'?: Array<ChatCompletionTool>;
    /**
     * Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
     */
    'parallel_tool_calls'?: boolean;
    /**
     * A list of functions the model may generate JSON inputs for.
     * @deprecated
     */
    'functions'?: Array<ChatCompletionFunctions>;
}
/**
 * @type FineTuneChatRequestInputMessagesInner
 */
export type FineTuneChatRequestInputMessagesInner = ChatCompletionRequestFunctionMessage | ChatCompletionRequestSystemMessage | ChatCompletionRequestToolMessage | ChatCompletionRequestUserMessage | FineTuneChatCompletionRequestAssistantMessage;

/**
 * The per-line training example of a fine-tuning input file for completions models
 */
export interface FineTuneCompletionRequestInput {
    /**
     * The input prompt for this training example.
     */
    'prompt'?: string;
    /**
     * The desired completion for this training example.
     */
    'completion'?: string;
}
/**
 * Configuration for the DPO fine-tuning method.
 */
export interface FineTuneDPOMethod {
    'hyperparameters'?: FineTuneDPOMethodHyperparameters;
}
/**
 * The hyperparameters used for the fine-tuning job.
 */
export interface FineTuneDPOMethodHyperparameters {
    'beta'?: FineTuneDPOMethodHyperparametersBeta;
    'batch_size'?: FineTuneDPOMethodHyperparametersBatchSize;
    'learning_rate_multiplier'?: FineTuneDPOMethodHyperparametersLearningRateMultiplier;
    'n_epochs'?: FineTuneDPOMethodHyperparametersNEpochs;
}
/**
 * @type FineTuneDPOMethodHyperparametersBatchSize
 * Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance. 
 */
export type FineTuneDPOMethodHyperparametersBatchSize = number | string;

/**
 * @type FineTuneDPOMethodHyperparametersBeta
 * The beta value for the DPO method. A higher beta value will increase the weight of the penalty between the policy and reference model. 
 */
export type FineTuneDPOMethodHyperparametersBeta = number | string;

/**
 * @type FineTuneDPOMethodHyperparametersLearningRateMultiplier
 * Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting. 
 */
export type FineTuneDPOMethodHyperparametersLearningRateMultiplier = number | string;

/**
 * @type FineTuneDPOMethodHyperparametersNEpochs
 * The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset. 
 */
export type FineTuneDPOMethodHyperparametersNEpochs = number | string;

/**
 * The method used for fine-tuning.
 */
export interface FineTuneMethod {
    /**
     * The type of method. Is either `supervised` or `dpo`.
     */
    'type'?: FineTuneMethodTypeEnum;
    'supervised'?: FineTuneSupervisedMethod;
    'dpo'?: FineTuneDPOMethod;
}

export const FineTuneMethodTypeEnum = {
    Supervised: 'supervised',
    Dpo: 'dpo'
} as const;

export type FineTuneMethodTypeEnum = typeof FineTuneMethodTypeEnum[keyof typeof FineTuneMethodTypeEnum];

/**
 * The per-line training example of a fine-tuning input file for chat models using the dpo method.
 */
export interface FineTunePreferenceRequestInput {
    'input'?: FineTunePreferenceRequestInputInput;
    /**
     * The preferred completion message for the output.
     */
    'preferred_completion'?: Array<FineTunePreferenceRequestInputPreferredCompletionInner>;
    /**
     * The non-preferred completion message for the output.
     */
    'non_preferred_completion'?: Array<FineTunePreferenceRequestInputPreferredCompletionInner>;
}
export interface FineTunePreferenceRequestInputInput {
    'messages'?: Array<FineTuneChatRequestInputMessagesInner>;
    /**
     * A list of tools the model may generate JSON inputs for.
     */
    'tools'?: Array<ChatCompletionTool>;
    /**
     * Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
     */
    'parallel_tool_calls'?: boolean;
}
/**
 * @type FineTunePreferenceRequestInputPreferredCompletionInner
 */
export type FineTunePreferenceRequestInputPreferredCompletionInner = ChatCompletionRequestAssistantMessage;

/**
 * Configuration for the supervised fine-tuning method.
 */
export interface FineTuneSupervisedMethod {
    'hyperparameters'?: FineTuneSupervisedMethodHyperparameters;
}
/**
 * The hyperparameters used for the fine-tuning job.
 */
export interface FineTuneSupervisedMethodHyperparameters {
    'batch_size'?: FineTuneDPOMethodHyperparametersBatchSize;
    'learning_rate_multiplier'?: FineTuneDPOMethodHyperparametersLearningRateMultiplier;
    'n_epochs'?: FineTuneDPOMethodHyperparametersNEpochs;
}
export interface FineTuningIntegration {
    /**
     * The type of the integration being enabled for the fine-tuning job
     */
    'type': FineTuningIntegrationTypeEnum;
    'wandb': CreateFineTuningJobRequestIntegrationsInnerWandb;
}

export const FineTuningIntegrationTypeEnum = {
    Wandb: 'wandb'
} as const;

export type FineTuningIntegrationTypeEnum = typeof FineTuningIntegrationTypeEnum[keyof typeof FineTuningIntegrationTypeEnum];

/**
 * The `fine_tuning.job` object represents a fine-tuning job that has been created through the API. 
 */
export interface FineTuningJob {
    /**
     * The object identifier, which can be referenced in the API endpoints.
     */
    'id': string;
    /**
     * The Unix timestamp (in seconds) for when the fine-tuning job was created.
     */
    'created_at': number;
    'error': FineTuningJobError | null;
    /**
     * The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
     */
    'fine_tuned_model': string | null;
    /**
     * The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
     */
    'finished_at': number | null;
    'hyperparameters': FineTuningJobHyperparameters;
    /**
     * The base model that is being fine-tuned.
     */
    'model': string;
    /**
     * The object type, which is always \"fine_tuning.job\".
     */
    'object': FineTuningJobObjectEnum;
    /**
     * The organization that owns the fine-tuning job.
     */
    'organization_id': string;
    /**
     * The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](/docs/api-reference/files/retrieve-contents).
     */
    'result_files': Array<string>;
    /**
     * The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
     */
    'status': FineTuningJobStatusEnum;
    /**
     * The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
     */
    'trained_tokens': number | null;
    /**
     * The file ID used for training. You can retrieve the training data with the [Files API](/docs/api-reference/files/retrieve-contents).
     */
    'training_file': string;
    /**
     * The file ID used for validation. You can retrieve the validation results with the [Files API](/docs/api-reference/files/retrieve-contents).
     */
    'validation_file': string | null;
    /**
     * A list of integrations to enable for this fine-tuning job.
     */
    'integrations'?: Array<FineTuningJobIntegrationsInner> | null;
    /**
     * The seed used for the fine-tuning job.
     */
    'seed': number;
    /**
     * The Unix timestamp (in seconds) for when the fine-tuning job is estimated to finish. The value will be null if the fine-tuning job is not running.
     */
    'estimated_finish'?: number | null;
    'method'?: FineTuneMethod;
}

export const FineTuningJobObjectEnum = {
    FineTuningJob: 'fine_tuning.job'
} as const;

export type FineTuningJobObjectEnum = typeof FineTuningJobObjectEnum[keyof typeof FineTuningJobObjectEnum];
export const FineTuningJobStatusEnum = {
    ValidatingFiles: 'validating_files',
    Queued: 'queued',
    Running: 'running',
    Succeeded: 'succeeded',
    Failed: 'failed',
    Cancelled: 'cancelled'
} as const;

export type FineTuningJobStatusEnum = typeof FineTuningJobStatusEnum[keyof typeof FineTuningJobStatusEnum];

/**
 * The `fine_tuning.job.checkpoint` object represents a model checkpoint for a fine-tuning job that is ready to use. 
 */
export interface FineTuningJobCheckpoint {
    /**
     * The checkpoint identifier, which can be referenced in the API endpoints.
     */
    'id': string;
    /**
     * The Unix timestamp (in seconds) for when the checkpoint was created.
     */
    'created_at': number;
    /**
     * The name of the fine-tuned checkpoint model that is created.
     */
    'fine_tuned_model_checkpoint': string;
    /**
     * The step number that the checkpoint was created at.
     */
    'step_number': number;
    'metrics': FineTuningJobCheckpointMetrics;
    /**
     * The name of the fine-tuning job that this checkpoint was created from.
     */
    'fine_tuning_job_id': string;
    /**
     * The object type, which is always \"fine_tuning.job.checkpoint\".
     */
    'object': FineTuningJobCheckpointObjectEnum;
}

export const FineTuningJobCheckpointObjectEnum = {
    FineTuningJobCheckpoint: 'fine_tuning.job.checkpoint'
} as const;

export type FineTuningJobCheckpointObjectEnum = typeof FineTuningJobCheckpointObjectEnum[keyof typeof FineTuningJobCheckpointObjectEnum];

/**
 * Metrics at the step number during the fine-tuning job.
 */
export interface FineTuningJobCheckpointMetrics {
    'step'?: number;
    'train_loss'?: number;
    'train_mean_token_accuracy'?: number;
    'valid_loss'?: number;
    'valid_mean_token_accuracy'?: number;
    'full_valid_loss'?: number;
    'full_valid_mean_token_accuracy'?: number;
}
/**
 * For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
 */
export interface FineTuningJobError {
    /**
     * A machine-readable error code.
     */
    'code': string;
    /**
     * A human-readable error message.
     */
    'message': string;
    /**
     * The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
     */
    'param': string | null;
}
/**
 * Fine-tuning job event object
 */
export interface FineTuningJobEvent {
    /**
     * The object type, which is always \"fine_tuning.job.event\".
     */
    'object': FineTuningJobEventObjectEnum;
    /**
     * The object identifier.
     */
    'id': string;
    /**
     * The Unix timestamp (in seconds) for when the fine-tuning job was created.
     */
    'created_at': number;
    /**
     * The log level of the event.
     */
    'level': FineTuningJobEventLevelEnum;
    /**
     * The message of the event.
     */
    'message': string;
    /**
     * The type of event.
     */
    'type'?: FineTuningJobEventTypeEnum;
    /**
     * The data associated with the event.
     */
    'data'?: object;
}

export const FineTuningJobEventObjectEnum = {
    FineTuningJobEvent: 'fine_tuning.job.event'
} as const;

export type FineTuningJobEventObjectEnum = typeof FineTuningJobEventObjectEnum[keyof typeof FineTuningJobEventObjectEnum];
export const FineTuningJobEventLevelEnum = {
    Info: 'info',
    Warn: 'warn',
    Error: 'error'
} as const;

export type FineTuningJobEventLevelEnum = typeof FineTuningJobEventLevelEnum[keyof typeof FineTuningJobEventLevelEnum];
export const FineTuningJobEventTypeEnum = {
    Message: 'message',
    Metrics: 'metrics'
} as const;

export type FineTuningJobEventTypeEnum = typeof FineTuningJobEventTypeEnum[keyof typeof FineTuningJobEventTypeEnum];

/**
 * The hyperparameters used for the fine-tuning job. This value will only be returned when running `supervised` jobs.
 */
export interface FineTuningJobHyperparameters {
    'batch_size'?: CreateFineTuningJobRequestHyperparametersBatchSize;
    'learning_rate_multiplier'?: CreateFineTuningJobRequestHyperparametersLearningRateMultiplier;
    'n_epochs'?: CreateFineTuningJobRequestHyperparametersNEpochs;
}
/**
 * @type FineTuningJobIntegrationsInner
 */
export type FineTuningJobIntegrationsInner = FineTuningIntegration;

export interface FunctionObject {
    /**
     * A description of what the function does, used by the model to choose when and how to call the function.
     */
    'description'?: string;
    /**
     * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     */
    'name': string;
    /**
     * The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.   Omitting `parameters` defines a function with an empty parameter list.
     */
    'parameters'?: { [key: string]: any; };
    /**
     * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Learn more about Structured Outputs in the [function calling guide](docs/guides/function-calling).
     */
    'strict'?: boolean | null;
}
/**
 * Represents the url or the content of an image generated by the OpenAI API.
 */
export interface Image {
    /**
     * The base64-encoded JSON of the generated image, if `response_format` is `b64_json`.
     */
    'b64_json'?: string;
    /**
     * The URL of the generated image, if `response_format` is `url` (default).
     */
    'url'?: string;
    /**
     * The prompt that was used to generate the image, if there was any revision to the prompt.
     */
    'revised_prompt'?: string;
}
export interface ImagesResponse {
    'created': number;
    'data': Array<Image>;
}
/**
 * Represents an individual `invite` to the organization.
 */
export interface Invite {
    /**
     * The object type, which is always `organization.invite`
     */
    'object': InviteObjectEnum;
    /**
     * The identifier, which can be referenced in API endpoints
     */
    'id': string;
    /**
     * The email address of the individual to whom the invite was sent
     */
    'email': string;
    /**
     * `owner` or `reader`
     */
    'role': InviteRoleEnum;
    /**
     * `accepted`,`expired`, or `pending`
     */
    'status': InviteStatusEnum;
    /**
     * The Unix timestamp (in seconds) of when the invite was sent.
     */
    'invited_at': number;
    /**
     * The Unix timestamp (in seconds) of when the invite expires.
     */
    'expires_at': number;
    /**
     * The Unix timestamp (in seconds) of when the invite was accepted.
     */
    'accepted_at'?: number;
    /**
     * The projects that were granted membership upon acceptance of the invite.
     */
    'projects'?: Array<InviteProjectsInner>;
}

export const InviteObjectEnum = {
    OrganizationInvite: 'organization.invite'
} as const;

export type InviteObjectEnum = typeof InviteObjectEnum[keyof typeof InviteObjectEnum];
export const InviteRoleEnum = {
    Owner: 'owner',
    Reader: 'reader'
} as const;

export type InviteRoleEnum = typeof InviteRoleEnum[keyof typeof InviteRoleEnum];
export const InviteStatusEnum = {
    Accepted: 'accepted',
    Expired: 'expired',
    Pending: 'pending'
} as const;

export type InviteStatusEnum = typeof InviteStatusEnum[keyof typeof InviteStatusEnum];

export interface InviteDeleteResponse {
    /**
     * The object type, which is always `organization.invite.deleted`
     */
    'object': InviteDeleteResponseObjectEnum;
    'id': string;
    'deleted': boolean;
}

export const InviteDeleteResponseObjectEnum = {
    OrganizationInviteDeleted: 'organization.invite.deleted'
} as const;

export type InviteDeleteResponseObjectEnum = typeof InviteDeleteResponseObjectEnum[keyof typeof InviteDeleteResponseObjectEnum];

export interface InviteListResponse {
    /**
     * The object type, which is always `list`
     */
    'object': InviteListResponseObjectEnum;
    'data': Array<Invite>;
    /**
     * The first `invite_id` in the retrieved `list`
     */
    'first_id'?: string;
    /**
     * The last `invite_id` in the retrieved `list`
     */
    'last_id'?: string;
    /**
     * The `has_more` property is used for pagination to indicate there are additional results.
     */
    'has_more'?: boolean;
}

export const InviteListResponseObjectEnum = {
    List: 'list'
} as const;

export type InviteListResponseObjectEnum = typeof InviteListResponseObjectEnum[keyof typeof InviteListResponseObjectEnum];

export interface InviteProjectsInner {
    /**
     * Project\'s public ID
     */
    'id'?: string;
    /**
     * Project membership role
     */
    'role'?: InviteProjectsInnerRoleEnum;
}

export const InviteProjectsInnerRoleEnum = {
    Member: 'member',
    Owner: 'owner'
} as const;

export type InviteProjectsInnerRoleEnum = typeof InviteProjectsInnerRoleEnum[keyof typeof InviteProjectsInnerRoleEnum];

export interface InviteRequest {
    /**
     * Send an email to this address
     */
    'email': string;
    /**
     * `owner` or `reader`
     */
    'role': InviteRequestRoleEnum;
    /**
     * An array of projects to which membership is granted at the same time the org invite is accepted. If omitted, the user will be invited to the default project for compatibility with legacy behavior.
     */
    'projects'?: Array<InviteRequestProjectsInner>;
}

export const InviteRequestRoleEnum = {
    Reader: 'reader',
    Owner: 'owner'
} as const;

export type InviteRequestRoleEnum = typeof InviteRequestRoleEnum[keyof typeof InviteRequestRoleEnum];

export interface InviteRequestProjectsInner {
    /**
     * Project\'s public ID
     */
    'id': string;
    /**
     * Project membership role
     */
    'role': InviteRequestProjectsInnerRoleEnum;
}

export const InviteRequestProjectsInnerRoleEnum = {
    Member: 'member',
    Owner: 'owner'
} as const;

export type InviteRequestProjectsInnerRoleEnum = typeof InviteRequestProjectsInnerRoleEnum[keyof typeof InviteRequestProjectsInnerRoleEnum];

export interface ListAssistantsResponse {
    'object': string;
    'data': Array<AssistantObject>;
    'first_id': string;
    'last_id': string;
    'has_more': boolean;
}
export interface ListAuditLogsEffectiveAtParameter {
    /**
     * Return only events whose `effective_at` (Unix seconds) is greater than this value.
     */
    'gt'?: number;
    /**
     * Return only events whose `effective_at` (Unix seconds) is greater than or equal to this value.
     */
    'gte'?: number;
    /**
     * Return only events whose `effective_at` (Unix seconds) is less than this value.
     */
    'lt'?: number;
    /**
     * Return only events whose `effective_at` (Unix seconds) is less than or equal to this value.
     */
    'lte'?: number;
}
export interface ListAuditLogsResponse {
    'object': ListAuditLogsResponseObjectEnum;
    'data': Array<AuditLog>;
    'first_id': string;
    'last_id': string;
    'has_more': boolean;
}

export const ListAuditLogsResponseObjectEnum = {
    List: 'list'
} as const;

export type ListAuditLogsResponseObjectEnum = typeof ListAuditLogsResponseObjectEnum[keyof typeof ListAuditLogsResponseObjectEnum];

export interface ListBatchesResponse {
    'data': Array<Batch>;
    'first_id'?: string;
    'last_id'?: string;
    'has_more': boolean;
    'object': ListBatchesResponseObjectEnum;
}

export const ListBatchesResponseObjectEnum = {
    List: 'list'
} as const;

export type ListBatchesResponseObjectEnum = typeof ListBatchesResponseObjectEnum[keyof typeof ListBatchesResponseObjectEnum];

export interface ListFilesResponse {
    'object': string;
    'data': Array<OpenAIFile>;
    'first_id': string;
    'last_id': string;
    'has_more': boolean;
}
export interface ListFineTuningJobCheckpointsResponse {
    'data': Array<FineTuningJobCheckpoint>;
    'object': ListFineTuningJobCheckpointsResponseObjectEnum;
    'first_id'?: string | null;
    'last_id'?: string | null;
    'has_more': boolean;
}

export const ListFineTuningJobCheckpointsResponseObjectEnum = {
    List: 'list'
} as const;

export type ListFineTuningJobCheckpointsResponseObjectEnum = typeof ListFineTuningJobCheckpointsResponseObjectEnum[keyof typeof ListFineTuningJobCheckpointsResponseObjectEnum];

export interface ListFineTuningJobEventsResponse {
    'data': Array<FineTuningJobEvent>;
    'object': ListFineTuningJobEventsResponseObjectEnum;
}

export const ListFineTuningJobEventsResponseObjectEnum = {
    List: 'list'
} as const;

export type ListFineTuningJobEventsResponseObjectEnum = typeof ListFineTuningJobEventsResponseObjectEnum[keyof typeof ListFineTuningJobEventsResponseObjectEnum];

export interface ListMessagesResponse {
    'object': string;
    'data': Array<MessageObject>;
    'first_id': string;
    'last_id': string;
    'has_more': boolean;
}
export interface ListModelsResponse {
    'object': ListModelsResponseObjectEnum;
    'data': Array<Model>;
}

export const ListModelsResponseObjectEnum = {
    List: 'list'
} as const;

export type ListModelsResponseObjectEnum = typeof ListModelsResponseObjectEnum[keyof typeof ListModelsResponseObjectEnum];

export interface ListPaginatedFineTuningJobsResponse {
    'data': Array<FineTuningJob>;
    'has_more': boolean;
    'object': ListPaginatedFineTuningJobsResponseObjectEnum;
}

export const ListPaginatedFineTuningJobsResponseObjectEnum = {
    List: 'list'
} as const;

export type ListPaginatedFineTuningJobsResponseObjectEnum = typeof ListPaginatedFineTuningJobsResponseObjectEnum[keyof typeof ListPaginatedFineTuningJobsResponseObjectEnum];

export interface ListRunStepsResponse {
    'object': string;
    'data': Array<RunStepObject>;
    'first_id': string;
    'last_id': string;
    'has_more': boolean;
}
export interface ListRunsResponse {
    'object': string;
    'data': Array<RunObject>;
    'first_id': string;
    'last_id': string;
    'has_more': boolean;
}
export interface ListThreadsResponse {
    'object': string;
    'data': Array<ThreadObject>;
    'first_id': string;
    'last_id': string;
    'has_more': boolean;
}
export interface ListVectorStoreFilesResponse {
    'object': string;
    'data': Array<VectorStoreFileObject>;
    'first_id': string;
    'last_id': string;
    'has_more': boolean;
}
export interface ListVectorStoresResponse {
    'object': string;
    'data': Array<VectorStoreObject>;
    'first_id': string;
    'last_id': string;
    'has_more': boolean;
}
/**
 * References an image [File](/docs/api-reference/files) in the content of a message.
 */
export interface MessageContentImageFileObject {
    /**
     * Always `image_file`.
     */
    'type': MessageContentImageFileObjectTypeEnum;
    'image_file': MessageContentImageFileObjectImageFile;
}

export const MessageContentImageFileObjectTypeEnum = {
    ImageFile: 'image_file'
} as const;

export type MessageContentImageFileObjectTypeEnum = typeof MessageContentImageFileObjectTypeEnum[keyof typeof MessageContentImageFileObjectTypeEnum];

export interface MessageContentImageFileObjectImageFile {
    /**
     * The [File](/docs/api-reference/files) ID of the image in the message content. Set `purpose=\"vision\"` when uploading the File if you need to later display the file content.
     */
    'file_id': string;
    /**
     * Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
     */
    'detail'?: MessageContentImageFileObjectImageFileDetailEnum;
}

export const MessageContentImageFileObjectImageFileDetailEnum = {
    Auto: 'auto',
    Low: 'low',
    High: 'high'
} as const;

export type MessageContentImageFileObjectImageFileDetailEnum = typeof MessageContentImageFileObjectImageFileDetailEnum[keyof typeof MessageContentImageFileObjectImageFileDetailEnum];

/**
 * References an image URL in the content of a message.
 */
export interface MessageContentImageUrlObject {
    /**
     * The type of the content part.
     */
    'type': MessageContentImageUrlObjectTypeEnum;
    'image_url': MessageContentImageUrlObjectImageUrl;
}

export const MessageContentImageUrlObjectTypeEnum = {
    ImageUrl: 'image_url'
} as const;

export type MessageContentImageUrlObjectTypeEnum = typeof MessageContentImageUrlObjectTypeEnum[keyof typeof MessageContentImageUrlObjectTypeEnum];

export interface MessageContentImageUrlObjectImageUrl {
    /**
     * The external URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp.
     */
    'url': string;
    /**
     * Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`. Default value is `auto`
     */
    'detail'?: MessageContentImageUrlObjectImageUrlDetailEnum;
}

export const MessageContentImageUrlObjectImageUrlDetailEnum = {
    Auto: 'auto',
    Low: 'low',
    High: 'high'
} as const;

export type MessageContentImageUrlObjectImageUrlDetailEnum = typeof MessageContentImageUrlObjectImageUrlDetailEnum[keyof typeof MessageContentImageUrlObjectImageUrlDetailEnum];

/**
 * The refusal content generated by the assistant.
 */
export interface MessageContentRefusalObject {
    /**
     * Always `refusal`.
     */
    'type': MessageContentRefusalObjectTypeEnum;
    'refusal': string;
}

export const MessageContentRefusalObjectTypeEnum = {
    Refusal: 'refusal'
} as const;

export type MessageContentRefusalObjectTypeEnum = typeof MessageContentRefusalObjectTypeEnum[keyof typeof MessageContentRefusalObjectTypeEnum];

/**
 * A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"file_search\" tool to search files.
 */
export interface MessageContentTextAnnotationsFileCitationObject {
    /**
     * Always `file_citation`.
     */
    'type': MessageContentTextAnnotationsFileCitationObjectTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     */
    'text': string;
    'file_citation': MessageContentTextAnnotationsFileCitationObjectFileCitation;
    'start_index': number;
    'end_index': number;
}

export const MessageContentTextAnnotationsFileCitationObjectTypeEnum = {
    FileCitation: 'file_citation'
} as const;

export type MessageContentTextAnnotationsFileCitationObjectTypeEnum = typeof MessageContentTextAnnotationsFileCitationObjectTypeEnum[keyof typeof MessageContentTextAnnotationsFileCitationObjectTypeEnum];

export interface MessageContentTextAnnotationsFileCitationObjectFileCitation {
    /**
     * The ID of the specific File the citation is from.
     */
    'file_id': string;
}
/**
 * A URL for the file that\'s generated when the assistant used the `code_interpreter` tool to generate a file.
 */
export interface MessageContentTextAnnotationsFilePathObject {
    /**
     * Always `file_path`.
     */
    'type': MessageContentTextAnnotationsFilePathObjectTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     */
    'text': string;
    'file_path': MessageContentTextAnnotationsFilePathObjectFilePath;
    'start_index': number;
    'end_index': number;
}

export const MessageContentTextAnnotationsFilePathObjectTypeEnum = {
    FilePath: 'file_path'
} as const;

export type MessageContentTextAnnotationsFilePathObjectTypeEnum = typeof MessageContentTextAnnotationsFilePathObjectTypeEnum[keyof typeof MessageContentTextAnnotationsFilePathObjectTypeEnum];

export interface MessageContentTextAnnotationsFilePathObjectFilePath {
    /**
     * The ID of the file that was generated.
     */
    'file_id': string;
}
/**
 * The text content that is part of a message.
 */
export interface MessageContentTextObject {
    /**
     * Always `text`.
     */
    'type': MessageContentTextObjectTypeEnum;
    'text': MessageContentTextObjectText;
}

export const MessageContentTextObjectTypeEnum = {
    Text: 'text'
} as const;

export type MessageContentTextObjectTypeEnum = typeof MessageContentTextObjectTypeEnum[keyof typeof MessageContentTextObjectTypeEnum];

export interface MessageContentTextObjectText {
    /**
     * The data that makes up the text.
     */
    'value': string;
    'annotations': Array<MessageContentTextObjectTextAnnotationsInner>;
}
/**
 * @type MessageContentTextObjectTextAnnotationsInner
 */
export type MessageContentTextObjectTextAnnotationsInner = MessageContentTextAnnotationsFileCitationObject | MessageContentTextAnnotationsFilePathObject;

/**
 * References an image [File](/docs/api-reference/files) in the content of a message.
 */
export interface MessageDeltaContentImageFileObject {
    /**
     * The index of the content part in the message.
     */
    'index': number;
    /**
     * Always `image_file`.
     */
    'type': MessageDeltaContentImageFileObjectTypeEnum;
    'image_file'?: MessageDeltaContentImageFileObjectImageFile;
}

export const MessageDeltaContentImageFileObjectTypeEnum = {
    ImageFile: 'image_file'
} as const;

export type MessageDeltaContentImageFileObjectTypeEnum = typeof MessageDeltaContentImageFileObjectTypeEnum[keyof typeof MessageDeltaContentImageFileObjectTypeEnum];

export interface MessageDeltaContentImageFileObjectImageFile {
    /**
     * The [File](/docs/api-reference/files) ID of the image in the message content. Set `purpose=\"vision\"` when uploading the File if you need to later display the file content.
     */
    'file_id'?: string;
    /**
     * Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`.
     */
    'detail'?: MessageDeltaContentImageFileObjectImageFileDetailEnum;
}

export const MessageDeltaContentImageFileObjectImageFileDetailEnum = {
    Auto: 'auto',
    Low: 'low',
    High: 'high'
} as const;

export type MessageDeltaContentImageFileObjectImageFileDetailEnum = typeof MessageDeltaContentImageFileObjectImageFileDetailEnum[keyof typeof MessageDeltaContentImageFileObjectImageFileDetailEnum];

/**
 * References an image URL in the content of a message.
 */
export interface MessageDeltaContentImageUrlObject {
    /**
     * The index of the content part in the message.
     */
    'index': number;
    /**
     * Always `image_url`.
     */
    'type': MessageDeltaContentImageUrlObjectTypeEnum;
    'image_url'?: MessageDeltaContentImageUrlObjectImageUrl;
}

export const MessageDeltaContentImageUrlObjectTypeEnum = {
    ImageUrl: 'image_url'
} as const;

export type MessageDeltaContentImageUrlObjectTypeEnum = typeof MessageDeltaContentImageUrlObjectTypeEnum[keyof typeof MessageDeltaContentImageUrlObjectTypeEnum];

export interface MessageDeltaContentImageUrlObjectImageUrl {
    /**
     * The URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp.
     */
    'url'?: string;
    /**
     * Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`.
     */
    'detail'?: MessageDeltaContentImageUrlObjectImageUrlDetailEnum;
}

export const MessageDeltaContentImageUrlObjectImageUrlDetailEnum = {
    Auto: 'auto',
    Low: 'low',
    High: 'high'
} as const;

export type MessageDeltaContentImageUrlObjectImageUrlDetailEnum = typeof MessageDeltaContentImageUrlObjectImageUrlDetailEnum[keyof typeof MessageDeltaContentImageUrlObjectImageUrlDetailEnum];

/**
 * The refusal content that is part of a message.
 */
export interface MessageDeltaContentRefusalObject {
    /**
     * The index of the refusal part in the message.
     */
    'index': number;
    /**
     * Always `refusal`.
     */
    'type': MessageDeltaContentRefusalObjectTypeEnum;
    'refusal'?: string;
}

export const MessageDeltaContentRefusalObjectTypeEnum = {
    Refusal: 'refusal'
} as const;

export type MessageDeltaContentRefusalObjectTypeEnum = typeof MessageDeltaContentRefusalObjectTypeEnum[keyof typeof MessageDeltaContentRefusalObjectTypeEnum];

/**
 * A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"file_search\" tool to search files.
 */
export interface MessageDeltaContentTextAnnotationsFileCitationObject {
    /**
     * The index of the annotation in the text content part.
     */
    'index': number;
    /**
     * Always `file_citation`.
     */
    'type': MessageDeltaContentTextAnnotationsFileCitationObjectTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     */
    'text'?: string;
    'file_citation'?: MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation;
    'start_index'?: number;
    'end_index'?: number;
}

export const MessageDeltaContentTextAnnotationsFileCitationObjectTypeEnum = {
    FileCitation: 'file_citation'
} as const;

export type MessageDeltaContentTextAnnotationsFileCitationObjectTypeEnum = typeof MessageDeltaContentTextAnnotationsFileCitationObjectTypeEnum[keyof typeof MessageDeltaContentTextAnnotationsFileCitationObjectTypeEnum];

export interface MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
    /**
     * The ID of the specific File the citation is from.
     */
    'file_id'?: string;
    /**
     * The specific quote in the file.
     */
    'quote'?: string;
}
/**
 * A URL for the file that\'s generated when the assistant used the `code_interpreter` tool to generate a file.
 */
export interface MessageDeltaContentTextAnnotationsFilePathObject {
    /**
     * The index of the annotation in the text content part.
     */
    'index': number;
    /**
     * Always `file_path`.
     */
    'type': MessageDeltaContentTextAnnotationsFilePathObjectTypeEnum;
    /**
     * The text in the message content that needs to be replaced.
     */
    'text'?: string;
    'file_path'?: MessageDeltaContentTextAnnotationsFilePathObjectFilePath;
    'start_index'?: number;
    'end_index'?: number;
}

export const MessageDeltaContentTextAnnotationsFilePathObjectTypeEnum = {
    FilePath: 'file_path'
} as const;

export type MessageDeltaContentTextAnnotationsFilePathObjectTypeEnum = typeof MessageDeltaContentTextAnnotationsFilePathObjectTypeEnum[keyof typeof MessageDeltaContentTextAnnotationsFilePathObjectTypeEnum];

export interface MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
    /**
     * The ID of the file that was generated.
     */
    'file_id'?: string;
}
/**
 * The text content that is part of a message.
 */
export interface MessageDeltaContentTextObject {
    /**
     * The index of the content part in the message.
     */
    'index': number;
    /**
     * Always `text`.
     */
    'type': MessageDeltaContentTextObjectTypeEnum;
    'text'?: MessageDeltaContentTextObjectText;
}

export const MessageDeltaContentTextObjectTypeEnum = {
    Text: 'text'
} as const;

export type MessageDeltaContentTextObjectTypeEnum = typeof MessageDeltaContentTextObjectTypeEnum[keyof typeof MessageDeltaContentTextObjectTypeEnum];

export interface MessageDeltaContentTextObjectText {
    /**
     * The data that makes up the text.
     */
    'value'?: string;
    'annotations'?: Array<MessageDeltaContentTextObjectTextAnnotationsInner>;
}
/**
 * @type MessageDeltaContentTextObjectTextAnnotationsInner
 */
export type MessageDeltaContentTextObjectTextAnnotationsInner = MessageDeltaContentTextAnnotationsFileCitationObject | MessageDeltaContentTextAnnotationsFilePathObject;

/**
 * Represents a message delta i.e. any changed fields on a message during streaming. 
 */
export interface MessageDeltaObject {
    /**
     * The identifier of the message, which can be referenced in API endpoints.
     */
    'id': string;
    /**
     * The object type, which is always `thread.message.delta`.
     */
    'object': MessageDeltaObjectObjectEnum;
    'delta': MessageDeltaObjectDelta;
}

export const MessageDeltaObjectObjectEnum = {
    ThreadMessageDelta: 'thread.message.delta'
} as const;

export type MessageDeltaObjectObjectEnum = typeof MessageDeltaObjectObjectEnum[keyof typeof MessageDeltaObjectObjectEnum];

/**
 * The delta containing the fields that have changed on the Message.
 */
export interface MessageDeltaObjectDelta {
    /**
     * The entity that produced the message. One of `user` or `assistant`.
     */
    'role'?: MessageDeltaObjectDeltaRoleEnum;
    /**
     * The content of the message in array of text and/or images.
     */
    'content'?: Array<MessageDeltaObjectDeltaContentInner>;
}

export const MessageDeltaObjectDeltaRoleEnum = {
    User: 'user',
    Assistant: 'assistant'
} as const;

export type MessageDeltaObjectDeltaRoleEnum = typeof MessageDeltaObjectDeltaRoleEnum[keyof typeof MessageDeltaObjectDeltaRoleEnum];

/**
 * @type MessageDeltaObjectDeltaContentInner
 */
export type MessageDeltaObjectDeltaContentInner = MessageDeltaContentImageFileObject | MessageDeltaContentImageUrlObject | MessageDeltaContentRefusalObject | MessageDeltaContentTextObject;

/**
 * Represents a message within a [thread](/docs/api-reference/threads).
 */
export interface MessageObject {
    /**
     * The identifier, which can be referenced in API endpoints.
     */
    'id': string;
    /**
     * The object type, which is always `thread.message`.
     */
    'object': MessageObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the message was created.
     */
    'created_at': number;
    /**
     * The [thread](/docs/api-reference/threads) ID that this message belongs to.
     */
    'thread_id': string;
    /**
     * The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
     */
    'status': MessageObjectStatusEnum;
    'incomplete_details': MessageObjectIncompleteDetails | null;
    /**
     * The Unix timestamp (in seconds) for when the message was completed.
     */
    'completed_at': number | null;
    /**
     * The Unix timestamp (in seconds) for when the message was marked as incomplete.
     */
    'incomplete_at': number | null;
    /**
     * The entity that produced the message. One of `user` or `assistant`.
     */
    'role': MessageObjectRoleEnum;
    /**
     * The content of the message in array of text and/or images.
     */
    'content': Array<MessageObjectContentInner>;
    /**
     * If applicable, the ID of the [assistant](/docs/api-reference/assistants) that authored this message.
     */
    'assistant_id': string | null;
    /**
     * The ID of the [run](/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints.
     */
    'run_id': string | null;
    /**
     * A list of files attached to the message, and the tools they were added to.
     */
    'attachments': Array<CreateMessageRequestAttachmentsInner> | null;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata': object | null;
}

export const MessageObjectObjectEnum = {
    ThreadMessage: 'thread.message'
} as const;

export type MessageObjectObjectEnum = typeof MessageObjectObjectEnum[keyof typeof MessageObjectObjectEnum];
export const MessageObjectStatusEnum = {
    InProgress: 'in_progress',
    Incomplete: 'incomplete',
    Completed: 'completed'
} as const;

export type MessageObjectStatusEnum = typeof MessageObjectStatusEnum[keyof typeof MessageObjectStatusEnum];
export const MessageObjectRoleEnum = {
    User: 'user',
    Assistant: 'assistant'
} as const;

export type MessageObjectRoleEnum = typeof MessageObjectRoleEnum[keyof typeof MessageObjectRoleEnum];

/**
 * @type MessageObjectContentInner
 */
export type MessageObjectContentInner = MessageContentImageFileObject | MessageContentImageUrlObject | MessageContentRefusalObject | MessageContentTextObject;

/**
 * On an incomplete message, details about why the message is incomplete.
 */
export interface MessageObjectIncompleteDetails {
    /**
     * The reason the message is incomplete.
     */
    'reason': MessageObjectIncompleteDetailsReasonEnum;
}

export const MessageObjectIncompleteDetailsReasonEnum = {
    ContentFilter: 'content_filter',
    MaxTokens: 'max_tokens',
    RunCancelled: 'run_cancelled',
    RunExpired: 'run_expired',
    RunFailed: 'run_failed'
} as const;

export type MessageObjectIncompleteDetailsReasonEnum = typeof MessageObjectIncompleteDetailsReasonEnum[keyof typeof MessageObjectIncompleteDetailsReasonEnum];

/**
 * The text content that is part of a message.
 */
export interface MessageRequestContentTextObject {
    /**
     * Always `text`.
     */
    'type': MessageRequestContentTextObjectTypeEnum;
    /**
     * Text content to be sent to the model
     */
    'text': string;
}

export const MessageRequestContentTextObjectTypeEnum = {
    Text: 'text'
} as const;

export type MessageRequestContentTextObjectTypeEnum = typeof MessageRequestContentTextObjectTypeEnum[keyof typeof MessageRequestContentTextObjectTypeEnum];

/**
 * @type MessageStreamEvent
 */
export type MessageStreamEvent = MessageStreamEventOneOf | MessageStreamEventOneOf1 | MessageStreamEventOneOf2 | MessageStreamEventOneOf3 | MessageStreamEventOneOf4;

/**
 * Occurs when a [message](/docs/api-reference/messages/object) is created.
 */
export interface MessageStreamEventOneOf {
    'event': MessageStreamEventOneOfEventEnum;
    'data': MessageObject;
}

export const MessageStreamEventOneOfEventEnum = {
    ThreadMessageCreated: 'thread.message.created'
} as const;

export type MessageStreamEventOneOfEventEnum = typeof MessageStreamEventOneOfEventEnum[keyof typeof MessageStreamEventOneOfEventEnum];

/**
 * Occurs when a [message](/docs/api-reference/messages/object) moves to an `in_progress` state.
 */
export interface MessageStreamEventOneOf1 {
    'event': MessageStreamEventOneOf1EventEnum;
    'data': MessageObject;
}

export const MessageStreamEventOneOf1EventEnum = {
    ThreadMessageInProgress: 'thread.message.in_progress'
} as const;

export type MessageStreamEventOneOf1EventEnum = typeof MessageStreamEventOneOf1EventEnum[keyof typeof MessageStreamEventOneOf1EventEnum];

/**
 * Occurs when parts of a [Message](/docs/api-reference/messages/object) are being streamed.
 */
export interface MessageStreamEventOneOf2 {
    'event': MessageStreamEventOneOf2EventEnum;
    'data': MessageDeltaObject;
}

export const MessageStreamEventOneOf2EventEnum = {
    ThreadMessageDelta: 'thread.message.delta'
} as const;

export type MessageStreamEventOneOf2EventEnum = typeof MessageStreamEventOneOf2EventEnum[keyof typeof MessageStreamEventOneOf2EventEnum];

/**
 * Occurs when a [message](/docs/api-reference/messages/object) is completed.
 */
export interface MessageStreamEventOneOf3 {
    'event': MessageStreamEventOneOf3EventEnum;
    'data': MessageObject;
}

export const MessageStreamEventOneOf3EventEnum = {
    ThreadMessageCompleted: 'thread.message.completed'
} as const;

export type MessageStreamEventOneOf3EventEnum = typeof MessageStreamEventOneOf3EventEnum[keyof typeof MessageStreamEventOneOf3EventEnum];

/**
 * Occurs when a [message](/docs/api-reference/messages/object) ends before it is completed.
 */
export interface MessageStreamEventOneOf4 {
    'event': MessageStreamEventOneOf4EventEnum;
    'data': MessageObject;
}

export const MessageStreamEventOneOf4EventEnum = {
    ThreadMessageIncomplete: 'thread.message.incomplete'
} as const;

export type MessageStreamEventOneOf4EventEnum = typeof MessageStreamEventOneOf4EventEnum[keyof typeof MessageStreamEventOneOf4EventEnum];

/**
 * Describes an OpenAI model offering that can be used with the API.
 */
export interface Model {
    /**
     * The model identifier, which can be referenced in the API endpoints.
     */
    'id': string;
    /**
     * The Unix timestamp (in seconds) when the model was created.
     */
    'created': number;
    /**
     * The object type, which is always \"model\".
     */
    'object': ModelObjectEnum;
    /**
     * The organization that owns the model.
     */
    'owned_by': string;
}

export const ModelObjectEnum = {
    Model: 'model'
} as const;

export type ModelObjectEnum = typeof ModelObjectEnum[keyof typeof ModelObjectEnum];

export interface ModelError {
    'code': string | null;
    'message': string;
    'param': string | null;
    'type': string;
}
export interface ModifyAssistantRequest {
    'model'?: string;
    /**
     * The name of the assistant. The maximum length is 256 characters. 
     */
    'name'?: string | null;
    /**
     * The description of the assistant. The maximum length is 512 characters. 
     */
    'description'?: string | null;
    /**
     * The system instructions that the assistant uses. The maximum length is 256,000 characters. 
     */
    'instructions'?: string | null;
    /**
     * A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`. 
     */
    'tools'?: Array<AssistantObjectToolsInner>;
    'tool_resources'?: ModifyAssistantRequestToolResources | null;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata'?: object | null;
    /**
     * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
     */
    'temperature'?: number | null;
    /**
     * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
     */
    'top_p'?: number | null;
    'response_format'?: AssistantsApiResponseFormatOption;
}
/**
 * A set of resources that are used by the assistant\'s tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
 */
export interface ModifyAssistantRequestToolResources {
    'code_interpreter'?: ModifyAssistantRequestToolResourcesCodeInterpreter;
    'file_search'?: ModifyAssistantRequestToolResourcesFileSearch;
}
export interface ModifyAssistantRequestToolResourcesCodeInterpreter {
    /**
     * Overrides the list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool. 
     */
    'file_ids'?: Array<string>;
}
export interface ModifyAssistantRequestToolResourcesFileSearch {
    /**
     * Overrides the [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant. 
     */
    'vector_store_ids'?: Array<string>;
}
export interface ModifyMessageRequest {
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata'?: object | null;
}
export interface ModifyRunRequest {
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata'?: object | null;
}
export interface ModifyThreadRequest {
    'tool_resources'?: ModifyThreadRequestToolResources | null;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata'?: object | null;
}
/**
 * A set of resources that are made available to the assistant\'s tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs. 
 */
export interface ModifyThreadRequestToolResources {
    'code_interpreter'?: CreateAssistantRequestToolResourcesCodeInterpreter;
    'file_search'?: ModifyThreadRequestToolResourcesFileSearch;
}
export interface ModifyThreadRequestToolResourcesFileSearch {
    /**
     * The [vector store](/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread. 
     */
    'vector_store_ids'?: Array<string>;
}
/**
 * The `File` object represents a document that has been uploaded to OpenAI.
 */
export interface OpenAIFile {
    /**
     * The file identifier, which can be referenced in the API endpoints.
     */
    'id': string;
    /**
     * The size of the file, in bytes.
     */
    'bytes': number;
    /**
     * The Unix timestamp (in seconds) for when the file was created.
     */
    'created_at': number;
    /**
     * The name of the file.
     */
    'filename': string;
    /**
     * The object type, which is always `file`.
     */
    'object': OpenAIFileObjectEnum;
    /**
     * The intended purpose of the file. Supported values are `assistants`, `assistants_output`, `batch`, `batch_output`, `fine-tune`, `fine-tune-results` and `vision`.
     */
    'purpose': OpenAIFilePurposeEnum;
    /**
     * Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`.
     * @deprecated
     */
    'status': OpenAIFileStatusEnum;
    /**
     * Deprecated. For details on why a fine-tuning training file failed validation, see the `error` field on `fine_tuning.job`.
     * @deprecated
     */
    'status_details'?: string;
}

export const OpenAIFileObjectEnum = {
    File: 'file'
} as const;

export type OpenAIFileObjectEnum = typeof OpenAIFileObjectEnum[keyof typeof OpenAIFileObjectEnum];
export const OpenAIFilePurposeEnum = {
    Assistants: 'assistants',
    AssistantsOutput: 'assistants_output',
    Batch: 'batch',
    BatchOutput: 'batch_output',
    FineTune: 'fine-tune',
    FineTuneResults: 'fine-tune-results',
    Vision: 'vision'
} as const;

export type OpenAIFilePurposeEnum = typeof OpenAIFilePurposeEnum[keyof typeof OpenAIFilePurposeEnum];
export const OpenAIFileStatusEnum = {
    Uploaded: 'uploaded',
    Processed: 'processed',
    Error: 'error'
} as const;

export type OpenAIFileStatusEnum = typeof OpenAIFileStatusEnum[keyof typeof OpenAIFileStatusEnum];

/**
 * This is returned when the chunking strategy is unknown. Typically, this is because the file was indexed before the `chunking_strategy` concept was introduced in the API.
 */
export interface OtherChunkingStrategyResponseParam {
    /**
     * Always `other`.
     */
    'type': OtherChunkingStrategyResponseParamTypeEnum;
}

export const OtherChunkingStrategyResponseParamTypeEnum = {
    Other: 'other'
} as const;

export type OtherChunkingStrategyResponseParamTypeEnum = typeof OtherChunkingStrategyResponseParamTypeEnum[keyof typeof OtherChunkingStrategyResponseParamTypeEnum];

/**
 * Static predicted output content, such as the content of a text file that is being regenerated. 
 */
export interface PredictionContent {
    /**
     * The type of the predicted content you want to provide. This type is currently always `content`. 
     */
    'type': PredictionContentTypeEnum;
    'content': PredictionContentContent;
}

export const PredictionContentTypeEnum = {
    Content: 'content'
} as const;

export type PredictionContentTypeEnum = typeof PredictionContentTypeEnum[keyof typeof PredictionContentTypeEnum];

/**
 * @type PredictionContentContent
 * The content that should be matched when generating a model response. If generated tokens would match this content, the entire model response can be returned much more quickly. 
 */
export type PredictionContentContent = Array<ChatCompletionRequestMessageContentPartText> | string;

/**
 * Represents an individual project.
 */
export interface Project {
    /**
     * The identifier, which can be referenced in API endpoints
     */
    'id': string;
    /**
     * The object type, which is always `organization.project`
     */
    'object': ProjectObjectEnum;
    /**
     * The name of the project. This appears in reporting.
     */
    'name': string;
    /**
     * The Unix timestamp (in seconds) of when the project was created.
     */
    'created_at': number;
    /**
     * The Unix timestamp (in seconds) of when the project was archived or `null`.
     */
    'archived_at'?: number | null;
    /**
     * `active` or `archived`
     */
    'status': ProjectStatusEnum;
}

export const ProjectObjectEnum = {
    OrganizationProject: 'organization.project'
} as const;

export type ProjectObjectEnum = typeof ProjectObjectEnum[keyof typeof ProjectObjectEnum];
export const ProjectStatusEnum = {
    Active: 'active',
    Archived: 'archived'
} as const;

export type ProjectStatusEnum = typeof ProjectStatusEnum[keyof typeof ProjectStatusEnum];

/**
 * Represents an individual API key in a project.
 */
export interface ProjectApiKey {
    /**
     * The object type, which is always `organization.project.api_key`
     */
    'object': ProjectApiKeyObjectEnum;
    /**
     * The redacted value of the API key
     */
    'redacted_value': string;
    /**
     * The name of the API key
     */
    'name': string;
    /**
     * The Unix timestamp (in seconds) of when the API key was created
     */
    'created_at': number;
    /**
     * The identifier, which can be referenced in API endpoints
     */
    'id': string;
    'owner': ProjectApiKeyOwner;
}

export const ProjectApiKeyObjectEnum = {
    OrganizationProjectApiKey: 'organization.project.api_key'
} as const;

export type ProjectApiKeyObjectEnum = typeof ProjectApiKeyObjectEnum[keyof typeof ProjectApiKeyObjectEnum];

export interface ProjectApiKeyDeleteResponse {
    'object': ProjectApiKeyDeleteResponseObjectEnum;
    'id': string;
    'deleted': boolean;
}

export const ProjectApiKeyDeleteResponseObjectEnum = {
    OrganizationProjectApiKeyDeleted: 'organization.project.api_key.deleted'
} as const;

export type ProjectApiKeyDeleteResponseObjectEnum = typeof ProjectApiKeyDeleteResponseObjectEnum[keyof typeof ProjectApiKeyDeleteResponseObjectEnum];

export interface ProjectApiKeyListResponse {
    'object': ProjectApiKeyListResponseObjectEnum;
    'data': Array<ProjectApiKey>;
    'first_id': string;
    'last_id': string;
    'has_more': boolean;
}

export const ProjectApiKeyListResponseObjectEnum = {
    List: 'list'
} as const;

export type ProjectApiKeyListResponseObjectEnum = typeof ProjectApiKeyListResponseObjectEnum[keyof typeof ProjectApiKeyListResponseObjectEnum];

export interface ProjectApiKeyOwner {
    /**
     * `user` or `service_account`
     */
    'type'?: ProjectApiKeyOwnerTypeEnum;
    'user'?: ProjectUser;
    'service_account'?: ProjectServiceAccount;
}

export const ProjectApiKeyOwnerTypeEnum = {
    User: 'user',
    ServiceAccount: 'service_account'
} as const;

export type ProjectApiKeyOwnerTypeEnum = typeof ProjectApiKeyOwnerTypeEnum[keyof typeof ProjectApiKeyOwnerTypeEnum];

export interface ProjectCreateRequest {
    /**
     * The friendly name of the project, this name appears in reports.
     */
    'name': string;
}
export interface ProjectListResponse {
    'object': ProjectListResponseObjectEnum;
    'data': Array<Project>;
    'first_id': string;
    'last_id': string;
    'has_more': boolean;
}

export const ProjectListResponseObjectEnum = {
    List: 'list'
} as const;

export type ProjectListResponseObjectEnum = typeof ProjectListResponseObjectEnum[keyof typeof ProjectListResponseObjectEnum];

/**
 * Represents a project rate limit config.
 */
export interface ProjectRateLimit {
    /**
     * The object type, which is always `project.rate_limit`
     */
    'object': ProjectRateLimitObjectEnum;
    /**
     * The identifier, which can be referenced in API endpoints.
     */
    'id': string;
    /**
     * The model this rate limit applies to.
     */
    'model': string;
    /**
     * The maximum requests per minute.
     */
    'max_requests_per_1_minute': number;
    /**
     * The maximum tokens per minute.
     */
    'max_tokens_per_1_minute': number;
    /**
     * The maximum images per minute. Only present for relevant models.
     */
    'max_images_per_1_minute'?: number;
    /**
     * The maximum audio megabytes per minute. Only present for relevant models.
     */
    'max_audio_megabytes_per_1_minute'?: number;
    /**
     * The maximum requests per day. Only present for relevant models.
     */
    'max_requests_per_1_day'?: number;
    /**
     * The maximum batch input tokens per day. Only present for relevant models.
     */
    'batch_1_day_max_input_tokens'?: number;
}

export const ProjectRateLimitObjectEnum = {
    ProjectRateLimit: 'project.rate_limit'
} as const;

export type ProjectRateLimitObjectEnum = typeof ProjectRateLimitObjectEnum[keyof typeof ProjectRateLimitObjectEnum];

export interface ProjectRateLimitListResponse {
    'object': ProjectRateLimitListResponseObjectEnum;
    'data': Array<ProjectRateLimit>;
    'first_id': string;
    'last_id': string;
    'has_more': boolean;
}

export const ProjectRateLimitListResponseObjectEnum = {
    List: 'list'
} as const;

export type ProjectRateLimitListResponseObjectEnum = typeof ProjectRateLimitListResponseObjectEnum[keyof typeof ProjectRateLimitListResponseObjectEnum];

export interface ProjectRateLimitUpdateRequest {
    /**
     * The maximum requests per minute.
     */
    'max_requests_per_1_minute'?: number;
    /**
     * The maximum tokens per minute.
     */
    'max_tokens_per_1_minute'?: number;
    /**
     * The maximum images per minute. Only relevant for certain models.
     */
    'max_images_per_1_minute'?: number;
    /**
     * The maximum audio megabytes per minute. Only relevant for certain models.
     */
    'max_audio_megabytes_per_1_minute'?: number;
    /**
     * The maximum requests per day. Only relevant for certain models.
     */
    'max_requests_per_1_day'?: number;
    /**
     * The maximum batch input tokens per day. Only relevant for certain models.
     */
    'batch_1_day_max_input_tokens'?: number;
}
/**
 * Represents an individual service account in a project.
 */
export interface ProjectServiceAccount {
    /**
     * The object type, which is always `organization.project.service_account`
     */
    'object': ProjectServiceAccountObjectEnum;
    /**
     * The identifier, which can be referenced in API endpoints
     */
    'id': string;
    /**
     * The name of the service account
     */
    'name': string;
    /**
     * `owner` or `member`
     */
    'role': ProjectServiceAccountRoleEnum;
    /**
     * The Unix timestamp (in seconds) of when the service account was created
     */
    'created_at': number;
}

export const ProjectServiceAccountObjectEnum = {
    OrganizationProjectServiceAccount: 'organization.project.service_account'
} as const;

export type ProjectServiceAccountObjectEnum = typeof ProjectServiceAccountObjectEnum[keyof typeof ProjectServiceAccountObjectEnum];
export const ProjectServiceAccountRoleEnum = {
    Owner: 'owner',
    Member: 'member'
} as const;

export type ProjectServiceAccountRoleEnum = typeof ProjectServiceAccountRoleEnum[keyof typeof ProjectServiceAccountRoleEnum];

export interface ProjectServiceAccountApiKey {
    /**
     * The object type, which is always `organization.project.service_account.api_key`
     */
    'object': ProjectServiceAccountApiKeyObjectEnum;
    'value': string;
    'name': string;
    'created_at': number;
    'id': string;
}

export const ProjectServiceAccountApiKeyObjectEnum = {
    OrganizationProjectServiceAccountApiKey: 'organization.project.service_account.api_key'
} as const;

export type ProjectServiceAccountApiKeyObjectEnum = typeof ProjectServiceAccountApiKeyObjectEnum[keyof typeof ProjectServiceAccountApiKeyObjectEnum];

export interface ProjectServiceAccountCreateRequest {
    /**
     * The name of the service account being created.
     */
    'name': string;
}
export interface ProjectServiceAccountCreateResponse {
    'object': ProjectServiceAccountCreateResponseObjectEnum;
    'id': string;
    'name': string;
    /**
     * Service accounts can only have one role of type `member`
     */
    'role': ProjectServiceAccountCreateResponseRoleEnum;
    'created_at': number;
    'api_key': ProjectServiceAccountApiKey;
}

export const ProjectServiceAccountCreateResponseObjectEnum = {
    OrganizationProjectServiceAccount: 'organization.project.service_account'
} as const;

export type ProjectServiceAccountCreateResponseObjectEnum = typeof ProjectServiceAccountCreateResponseObjectEnum[keyof typeof ProjectServiceAccountCreateResponseObjectEnum];
export const ProjectServiceAccountCreateResponseRoleEnum = {
    Member: 'member'
} as const;

export type ProjectServiceAccountCreateResponseRoleEnum = typeof ProjectServiceAccountCreateResponseRoleEnum[keyof typeof ProjectServiceAccountCreateResponseRoleEnum];

export interface ProjectServiceAccountDeleteResponse {
    'object': ProjectServiceAccountDeleteResponseObjectEnum;
    'id': string;
    'deleted': boolean;
}

export const ProjectServiceAccountDeleteResponseObjectEnum = {
    OrganizationProjectServiceAccountDeleted: 'organization.project.service_account.deleted'
} as const;

export type ProjectServiceAccountDeleteResponseObjectEnum = typeof ProjectServiceAccountDeleteResponseObjectEnum[keyof typeof ProjectServiceAccountDeleteResponseObjectEnum];

export interface ProjectServiceAccountListResponse {
    'object': ProjectServiceAccountListResponseObjectEnum;
    'data': Array<ProjectServiceAccount>;
    'first_id': string;
    'last_id': string;
    'has_more': boolean;
}

export const ProjectServiceAccountListResponseObjectEnum = {
    List: 'list'
} as const;

export type ProjectServiceAccountListResponseObjectEnum = typeof ProjectServiceAccountListResponseObjectEnum[keyof typeof ProjectServiceAccountListResponseObjectEnum];

export interface ProjectUpdateRequest {
    /**
     * The updated name of the project, this name appears in reports.
     */
    'name': string;
}
/**
 * Represents an individual user in a project.
 */
export interface ProjectUser {
    /**
     * The object type, which is always `organization.project.user`
     */
    'object': ProjectUserObjectEnum;
    /**
     * The identifier, which can be referenced in API endpoints
     */
    'id': string;
    /**
     * The name of the user
     */
    'name': string;
    /**
     * The email address of the user
     */
    'email': string;
    /**
     * `owner` or `member`
     */
    'role': ProjectUserRoleEnum;
    /**
     * The Unix timestamp (in seconds) of when the project was added.
     */
    'added_at': number;
}

export const ProjectUserObjectEnum = {
    OrganizationProjectUser: 'organization.project.user'
} as const;

export type ProjectUserObjectEnum = typeof ProjectUserObjectEnum[keyof typeof ProjectUserObjectEnum];
export const ProjectUserRoleEnum = {
    Owner: 'owner',
    Member: 'member'
} as const;

export type ProjectUserRoleEnum = typeof ProjectUserRoleEnum[keyof typeof ProjectUserRoleEnum];

export interface ProjectUserCreateRequest {
    /**
     * The ID of the user.
     */
    'user_id': string;
    /**
     * `owner` or `member`
     */
    'role': ProjectUserCreateRequestRoleEnum;
}

export const ProjectUserCreateRequestRoleEnum = {
    Owner: 'owner',
    Member: 'member'
} as const;

export type ProjectUserCreateRequestRoleEnum = typeof ProjectUserCreateRequestRoleEnum[keyof typeof ProjectUserCreateRequestRoleEnum];

export interface ProjectUserDeleteResponse {
    'object': ProjectUserDeleteResponseObjectEnum;
    'id': string;
    'deleted': boolean;
}

export const ProjectUserDeleteResponseObjectEnum = {
    OrganizationProjectUserDeleted: 'organization.project.user.deleted'
} as const;

export type ProjectUserDeleteResponseObjectEnum = typeof ProjectUserDeleteResponseObjectEnum[keyof typeof ProjectUserDeleteResponseObjectEnum];

export interface ProjectUserListResponse {
    'object': string;
    'data': Array<ProjectUser>;
    'first_id': string;
    'last_id': string;
    'has_more': boolean;
}
export interface ProjectUserUpdateRequest {
    /**
     * `owner` or `member`
     */
    'role': ProjectUserUpdateRequestRoleEnum;
}

export const ProjectUserUpdateRequestRoleEnum = {
    Owner: 'owner',
    Member: 'member'
} as const;

export type ProjectUserUpdateRequestRoleEnum = typeof ProjectUserUpdateRequestRoleEnum[keyof typeof ProjectUserUpdateRequestRoleEnum];

/**
 * Add a new Item to the Conversation\'s context, including messages, function  calls, and function call responses. This event can be used both to populate a  \"history\" of the conversation and to add new items mid-stream, but has the  current limitation that it cannot populate assistant audio messages.  If successful, the server will respond with a `conversation.item.created`  event, otherwise an `error` event will be sent. 
 */
export interface RealtimeClientEventConversationItemCreate {
    /**
     * Optional client-generated ID used to identify this event.
     */
    'event_id'?: string;
    /**
     * The event type, must be `conversation.item.create`.
     */
    'type': RealtimeClientEventConversationItemCreateTypeEnum;
    /**
     * The ID of the preceding item after which the new item will be inserted.  If not set, the new item will be appended to the end of the conversation.  If set, it allows an item to be inserted mid-conversation. If the ID  cannot be found, an error will be returned and the item will not be added. 
     */
    'previous_item_id'?: string;
    'item': RealtimeConversationItem;
}

export const RealtimeClientEventConversationItemCreateTypeEnum = {
    ConversationItemCreate: 'conversation.item.create'
} as const;

export type RealtimeClientEventConversationItemCreateTypeEnum = typeof RealtimeClientEventConversationItemCreateTypeEnum[keyof typeof RealtimeClientEventConversationItemCreateTypeEnum];

/**
 * Send this event when you want to remove any item from the conversation  history. The server will respond with a `conversation.item.deleted` event,  unless the item does not exist in the conversation history, in which case the  server will respond with an error. 
 */
export interface RealtimeClientEventConversationItemDelete {
    /**
     * Optional client-generated ID used to identify this event.
     */
    'event_id'?: string;
    /**
     * The event type, must be `conversation.item.delete`.
     */
    'type': RealtimeClientEventConversationItemDeleteTypeEnum;
    /**
     * The ID of the item to delete.
     */
    'item_id': string;
}

export const RealtimeClientEventConversationItemDeleteTypeEnum = {
    ConversationItemDelete: 'conversation.item.delete'
} as const;

export type RealtimeClientEventConversationItemDeleteTypeEnum = typeof RealtimeClientEventConversationItemDeleteTypeEnum[keyof typeof RealtimeClientEventConversationItemDeleteTypeEnum];

/**
 * Send this event to truncate a previous assistant messages audio. The server  will produce audio faster than realtime, so this event is useful when the user  interrupts to truncate audio that has already been sent to the client but not  yet played. This will synchronize the server\'s understanding of the audio with  the client\'s playback.  Truncating audio will delete the server-side text transcript to ensure there  is not text in the context that hasn\'t been heard by the user.  If successful, the server will respond with a `conversation.item.truncated`  event.  
 */
export interface RealtimeClientEventConversationItemTruncate {
    /**
     * Optional client-generated ID used to identify this event.
     */
    'event_id'?: string;
    /**
     * The event type, must be `conversation.item.truncate`.
     */
    'type': RealtimeClientEventConversationItemTruncateTypeEnum;
    /**
     * The ID of the assistant message item to truncate. Only assistant message  items can be truncated. 
     */
    'item_id': string;
    /**
     * The index of the content part to truncate. Set this to 0.
     */
    'content_index': number;
    /**
     * Inclusive duration up to which audio is truncated, in milliseconds. If  the audio_end_ms is greater than the actual audio duration, the server  will respond with an error. 
     */
    'audio_end_ms': number;
}

export const RealtimeClientEventConversationItemTruncateTypeEnum = {
    ConversationItemTruncate: 'conversation.item.truncate'
} as const;

export type RealtimeClientEventConversationItemTruncateTypeEnum = typeof RealtimeClientEventConversationItemTruncateTypeEnum[keyof typeof RealtimeClientEventConversationItemTruncateTypeEnum];

/**
 * Send this event to append audio bytes to the input audio buffer. The audio  buffer is temporary storage you can write to and later commit. In Server VAD  mode, the audio buffer is used to detect speech and the server will decide  when to commit. When Server VAD is disabled, you must commit the audio buffer manually.  The client may choose how much audio to place in each event up to a maximum  of 15 MiB, for example streaming smaller chunks from the client may allow the  VAD to be more responsive. Unlike made other client events, the server will  not send a confirmation response to this event. 
 */
export interface RealtimeClientEventInputAudioBufferAppend {
    /**
     * Optional client-generated ID used to identify this event.
     */
    'event_id'?: string;
    /**
     * The event type, must be `input_audio_buffer.append`.
     */
    'type': RealtimeClientEventInputAudioBufferAppendTypeEnum;
    /**
     * Base64-encoded audio bytes. This must be in the format specified by the  `input_audio_format` field in the session configuration. 
     */
    'audio': string;
}

export const RealtimeClientEventInputAudioBufferAppendTypeEnum = {
    InputAudioBufferAppend: 'input_audio_buffer.append'
} as const;

export type RealtimeClientEventInputAudioBufferAppendTypeEnum = typeof RealtimeClientEventInputAudioBufferAppendTypeEnum[keyof typeof RealtimeClientEventInputAudioBufferAppendTypeEnum];

/**
 * Send this event to clear the audio bytes in the buffer. The server will  respond with an `input_audio_buffer.cleared` event. 
 */
export interface RealtimeClientEventInputAudioBufferClear {
    /**
     * Optional client-generated ID used to identify this event.
     */
    'event_id'?: string;
    /**
     * The event type, must be `input_audio_buffer.clear`.
     */
    'type': RealtimeClientEventInputAudioBufferClearTypeEnum;
}

export const RealtimeClientEventInputAudioBufferClearTypeEnum = {
    InputAudioBufferClear: 'input_audio_buffer.clear'
} as const;

export type RealtimeClientEventInputAudioBufferClearTypeEnum = typeof RealtimeClientEventInputAudioBufferClearTypeEnum[keyof typeof RealtimeClientEventInputAudioBufferClearTypeEnum];

/**
 * Send this event to commit the user input audio buffer, which will create a  new user message item in the conversation. This event will produce an error  if the input audio buffer is empty. When in Server VAD mode, the client does  not need to send this event, the server will commit the audio buffer  automatically.  Committing the input audio buffer will trigger input audio transcription  (if enabled in session configuration), but it will not create a response  from the model. The server will respond with an `input_audio_buffer.committed`  event. 
 */
export interface RealtimeClientEventInputAudioBufferCommit {
    /**
     * Optional client-generated ID used to identify this event.
     */
    'event_id'?: string;
    /**
     * The event type, must be `input_audio_buffer.commit`.
     */
    'type': RealtimeClientEventInputAudioBufferCommitTypeEnum;
}

export const RealtimeClientEventInputAudioBufferCommitTypeEnum = {
    InputAudioBufferCommit: 'input_audio_buffer.commit'
} as const;

export type RealtimeClientEventInputAudioBufferCommitTypeEnum = typeof RealtimeClientEventInputAudioBufferCommitTypeEnum[keyof typeof RealtimeClientEventInputAudioBufferCommitTypeEnum];

/**
 * Send this event to cancel an in-progress response. The server will respond  with a `response.cancelled` event or an error if there is no response to  cancel. 
 */
export interface RealtimeClientEventResponseCancel {
    /**
     * Optional client-generated ID used to identify this event.
     */
    'event_id'?: string;
    /**
     * The event type, must be `response.cancel`.
     */
    'type': RealtimeClientEventResponseCancelTypeEnum;
    /**
     * A specific response ID to cancel - if not provided, will cancel an  in-progress response in the default conversation. 
     */
    'response_id'?: string;
}

export const RealtimeClientEventResponseCancelTypeEnum = {
    ResponseCancel: 'response.cancel'
} as const;

export type RealtimeClientEventResponseCancelTypeEnum = typeof RealtimeClientEventResponseCancelTypeEnum[keyof typeof RealtimeClientEventResponseCancelTypeEnum];

/**
 * This event instructs the server to create a Response, which means triggering  model inference. When in Server VAD mode, the server will create Responses  automatically.  A Response will include at least one Item, and may have two, in which case  the second will be a function call. These Items will be appended to the  conversation history.  The server will respond with a `response.created` event, events for Items  and content created, and finally a `response.done` event to indicate the  Response is complete.  The `response.create` event includes inference configuration like  `instructions`, and `temperature`. These fields will override the Session\'s  configuration for this Response only. 
 */
export interface RealtimeClientEventResponseCreate {
    /**
     * Optional client-generated ID used to identify this event.
     */
    'event_id'?: string;
    /**
     * The event type, must be `response.create`.
     */
    'type': RealtimeClientEventResponseCreateTypeEnum;
    'response'?: RealtimeResponseCreateParams;
}

export const RealtimeClientEventResponseCreateTypeEnum = {
    ResponseCreate: 'response.create'
} as const;

export type RealtimeClientEventResponseCreateTypeEnum = typeof RealtimeClientEventResponseCreateTypeEnum[keyof typeof RealtimeClientEventResponseCreateTypeEnum];

/**
 * Send this event to update the sessions default configuration. The client may  send this event at any time to update the session configuration, and any  field may be updated at any time, except for \"voice\". The server will respond  with a `session.updated` event that shows the full effective configuration.  Only fields that are present are updated, thus the correct way to clear a  field like \"instructions\" is to pass an empty string. 
 */
export interface RealtimeClientEventSessionUpdate {
    /**
     * Optional client-generated ID used to identify this event.
     */
    'event_id'?: string;
    /**
     * The event type, must be `session.update`.
     */
    'type': RealtimeClientEventSessionUpdateTypeEnum;
    'session': RealtimeSessionCreateRequest;
}

export const RealtimeClientEventSessionUpdateTypeEnum = {
    SessionUpdate: 'session.update'
} as const;

export type RealtimeClientEventSessionUpdateTypeEnum = typeof RealtimeClientEventSessionUpdateTypeEnum[keyof typeof RealtimeClientEventSessionUpdateTypeEnum];

/**
 * The item to add to the conversation.
 */
export interface RealtimeConversationItem {
    /**
     * The unique ID of the item, this can be generated by the client to help  manage server-side context, but is not required because the server will  generate one if not provided. 
     */
    'id'?: string;
    /**
     * The type of the item (`message`, `function_call`, `function_call_output`). 
     */
    'type'?: RealtimeConversationItemTypeEnum;
    /**
     * Identifier for the API object being returned - always `realtime.item`. 
     */
    'object'?: RealtimeConversationItemObjectEnum;
    /**
     * The status of the item (`completed`, `incomplete`). These have no effect  on the conversation, but are accepted for consistency with the  `conversation.item.created` event. 
     */
    'status'?: RealtimeConversationItemStatusEnum;
    /**
     * The role of the message sender (`user`, `assistant`, `system`), only  applicable for `message` items. 
     */
    'role'?: RealtimeConversationItemRoleEnum;
    /**
     * The content of the message, applicable for `message` items.  - Message items of role `system` support only `input_text` content - Message items of role `user` support `input_text` and `input_audio`    content - Message items of role `assistant` support `text` content. 
     */
    'content'?: Array<RealtimeConversationItemContentInner>;
    /**
     * The ID of the function call (for `function_call` and  `function_call_output` items). If passed on a `function_call_output`  item, the server will check that a `function_call` item with the same  ID exists in the conversation history. 
     */
    'call_id'?: string;
    /**
     * The name of the function being called (for `function_call` items). 
     */
    'name'?: string;
    /**
     * The arguments of the function call (for `function_call` items). 
     */
    'arguments'?: string;
    /**
     * The output of the function call (for `function_call_output` items). 
     */
    'output'?: string;
}

export const RealtimeConversationItemTypeEnum = {
    Message: 'message',
    FunctionCall: 'function_call',
    FunctionCallOutput: 'function_call_output'
} as const;

export type RealtimeConversationItemTypeEnum = typeof RealtimeConversationItemTypeEnum[keyof typeof RealtimeConversationItemTypeEnum];
export const RealtimeConversationItemObjectEnum = {
    RealtimeItem: 'realtime.item'
} as const;

export type RealtimeConversationItemObjectEnum = typeof RealtimeConversationItemObjectEnum[keyof typeof RealtimeConversationItemObjectEnum];
export const RealtimeConversationItemStatusEnum = {
    Completed: 'completed',
    Incomplete: 'incomplete'
} as const;

export type RealtimeConversationItemStatusEnum = typeof RealtimeConversationItemStatusEnum[keyof typeof RealtimeConversationItemStatusEnum];
export const RealtimeConversationItemRoleEnum = {
    User: 'user',
    Assistant: 'assistant',
    System: 'system'
} as const;

export type RealtimeConversationItemRoleEnum = typeof RealtimeConversationItemRoleEnum[keyof typeof RealtimeConversationItemRoleEnum];

export interface RealtimeConversationItemContentInner {
    /**
     * The content type (`input_text`, `input_audio`, `item_reference`, `text`). 
     */
    'type'?: RealtimeConversationItemContentInnerTypeEnum;
    /**
     * The text content, used for `input_text` and `text` content types. 
     */
    'text'?: string;
    /**
     * ID of a previous conversation item to reference (for `item_reference` content types in `response.create` events). These can reference both client and server created items. 
     */
    'id'?: string;
    /**
     * Base64-encoded audio bytes, used for `input_audio` content type. 
     */
    'audio'?: string;
    /**
     * The transcript of the audio, used for `input_audio` content type. 
     */
    'transcript'?: string;
}

export const RealtimeConversationItemContentInnerTypeEnum = {
    InputAudio: 'input_audio',
    InputText: 'input_text',
    ItemReference: 'item_reference',
    Text: 'text'
} as const;

export type RealtimeConversationItemContentInnerTypeEnum = typeof RealtimeConversationItemContentInnerTypeEnum[keyof typeof RealtimeConversationItemContentInnerTypeEnum];

/**
 * The response resource.
 */
export interface RealtimeResponse {
    /**
     * The unique ID of the response.
     */
    'id'?: string;
    /**
     * The object type, must be `realtime.response`.
     */
    'object'?: RealtimeResponseObjectEnum;
    /**
     * The final status of the response (`completed`, `cancelled`, `failed`, or  `incomplete`). 
     */
    'status'?: RealtimeResponseStatusEnum;
    'status_details'?: RealtimeResponseStatusDetails;
    /**
     * The list of output items generated by the response.
     */
    'output'?: Array<RealtimeConversationItem>;
    /**
     * Developer-provided string key-value pairs associated with this response. 
     */
    'metadata'?: object | null;
    'usage'?: RealtimeResponseUsage;
}

export const RealtimeResponseObjectEnum = {
    RealtimeResponse: 'realtime.response'
} as const;

export type RealtimeResponseObjectEnum = typeof RealtimeResponseObjectEnum[keyof typeof RealtimeResponseObjectEnum];
export const RealtimeResponseStatusEnum = {
    Completed: 'completed',
    Cancelled: 'cancelled',
    Failed: 'failed',
    Incomplete: 'incomplete'
} as const;

export type RealtimeResponseStatusEnum = typeof RealtimeResponseStatusEnum[keyof typeof RealtimeResponseStatusEnum];

/**
 * Create a new Realtime response with these parameters
 */
export interface RealtimeResponseCreateParams {
    /**
     * The set of modalities the model can respond with. To disable audio, set this to [\"text\"]. 
     */
    'modalities'?: Array<RealtimeResponseCreateParamsModalitiesEnum>;
    /**
     * The default system instructions (i.e. system message) prepended to model  calls. This field allows the client to guide the model on desired  responses. The model can be instructed on response content and format,  (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good  responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion  into your voice\", \"laugh frequently\"). The instructions are not guaranteed  to be followed by the model, but they provide guidance to the model on the  desired behavior.  Note that the server sets default instructions which will be used if this  field is not set and are visible in the `session.created` event at the  start of the session. 
     */
    'instructions'?: string;
    /**
     * The voice the model uses to respond. Voice cannot be changed during the  session once the model has responded with audio at least once. Current  voice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`,  `shimmer` and `verse`. 
     */
    'voice'?: RealtimeResponseCreateParamsVoiceEnum;
    /**
     * The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
     */
    'output_audio_format'?: RealtimeResponseCreateParamsOutputAudioFormatEnum;
    /**
     * Tools (functions) available to the model.
     */
    'tools'?: Array<RealtimeResponseCreateParamsToolsInner>;
    /**
     * How the model chooses tools. Options are `auto`, `none`, `required`, or  specify a function, like `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}`. 
     */
    'tool_choice'?: string;
    /**
     * Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8. 
     */
    'temperature'?: number;
    'max_response_output_tokens'?: RealtimeResponseCreateParamsMaxResponseOutputTokens;
    'conversation'?: RealtimeResponseCreateParamsConversation;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata'?: object | null;
    /**
     * Input items to include in the prompt for the model. Creates a new context for this response, without including the default conversation. Can include references to items from the default conversation. 
     */
    'input'?: Array<RealtimeConversationItem>;
}

export const RealtimeResponseCreateParamsModalitiesEnum = {
    Text: 'text',
    Audio: 'audio'
} as const;

export type RealtimeResponseCreateParamsModalitiesEnum = typeof RealtimeResponseCreateParamsModalitiesEnum[keyof typeof RealtimeResponseCreateParamsModalitiesEnum];
export const RealtimeResponseCreateParamsVoiceEnum = {
    Alloy: 'alloy',
    Ash: 'ash',
    Ballad: 'ballad',
    Coral: 'coral',
    Echo: 'echo',
    Sage: 'sage',
    Shimmer: 'shimmer',
    Verse: 'verse'
} as const;

export type RealtimeResponseCreateParamsVoiceEnum = typeof RealtimeResponseCreateParamsVoiceEnum[keyof typeof RealtimeResponseCreateParamsVoiceEnum];
export const RealtimeResponseCreateParamsOutputAudioFormatEnum = {
    Pcm16: 'pcm16',
    G711Ulaw: 'g711_ulaw',
    G711Alaw: 'g711_alaw'
} as const;

export type RealtimeResponseCreateParamsOutputAudioFormatEnum = typeof RealtimeResponseCreateParamsOutputAudioFormatEnum[keyof typeof RealtimeResponseCreateParamsOutputAudioFormatEnum];

/**
 * @type RealtimeResponseCreateParamsConversation
 * Controls which conversation the response is added to. Currently supports `auto` and `none`, with `auto` as the default value. The `auto` value means that the contents of the response will be added to the default conversation. Set this to `none` to create an out-of-band response which  will not add items to default conversation. 
 */
export type RealtimeResponseCreateParamsConversation = string;

/**
 * @type RealtimeResponseCreateParamsMaxResponseOutputTokens
 * Maximum number of output tokens for a single assistant response, inclusive of tool calls. Provide an integer between 1 and 4096 to limit output tokens, or `inf` for the maximum available tokens for a given model. Defaults to `inf`. 
 */
export type RealtimeResponseCreateParamsMaxResponseOutputTokens = number | string;

export interface RealtimeResponseCreateParamsToolsInner {
    /**
     * The type of the tool, i.e. `function`.
     */
    'type'?: RealtimeResponseCreateParamsToolsInnerTypeEnum;
    /**
     * The name of the function.
     */
    'name'?: string;
    /**
     * The description of the function, including guidance on when and how  to call it, and guidance about what to tell the user when calling  (if anything). 
     */
    'description'?: string;
    /**
     * Parameters of the function in JSON Schema.
     */
    'parameters'?: object;
}

export const RealtimeResponseCreateParamsToolsInnerTypeEnum = {
    Function: 'function'
} as const;

export type RealtimeResponseCreateParamsToolsInnerTypeEnum = typeof RealtimeResponseCreateParamsToolsInnerTypeEnum[keyof typeof RealtimeResponseCreateParamsToolsInnerTypeEnum];

/**
 * Additional details about the status.
 */
export interface RealtimeResponseStatusDetails {
    /**
     * The type of error that caused the response to fail, corresponding  with the `status` field (`completed`, `cancelled`, `incomplete`,  `failed`). 
     */
    'type'?: RealtimeResponseStatusDetailsTypeEnum;
    /**
     * The reason the Response did not complete. For a `cancelled` Response,  one of `turn_detected` (the server VAD detected a new start of speech)  or `client_cancelled` (the client sent a cancel event). For an  `incomplete` Response, one of `max_output_tokens` or `content_filter`  (the server-side safety filter activated and cut off the response). 
     */
    'reason'?: RealtimeResponseStatusDetailsReasonEnum;
    'error'?: RealtimeResponseStatusDetailsError;
}

export const RealtimeResponseStatusDetailsTypeEnum = {
    Completed: 'completed',
    Cancelled: 'cancelled',
    Failed: 'failed',
    Incomplete: 'incomplete'
} as const;

export type RealtimeResponseStatusDetailsTypeEnum = typeof RealtimeResponseStatusDetailsTypeEnum[keyof typeof RealtimeResponseStatusDetailsTypeEnum];
export const RealtimeResponseStatusDetailsReasonEnum = {
    TurnDetected: 'turn_detected',
    ClientCancelled: 'client_cancelled',
    MaxOutputTokens: 'max_output_tokens',
    ContentFilter: 'content_filter'
} as const;

export type RealtimeResponseStatusDetailsReasonEnum = typeof RealtimeResponseStatusDetailsReasonEnum[keyof typeof RealtimeResponseStatusDetailsReasonEnum];

/**
 * A description of the error that caused the response to fail,  populated when the `status` is `failed`. 
 */
export interface RealtimeResponseStatusDetailsError {
    /**
     * The type of error.
     */
    'type'?: string;
    /**
     * Error code, if any.
     */
    'code'?: string;
}
/**
 * Usage statistics for the Response, this will correspond to billing. A  Realtime API session will maintain a conversation context and append new  Items to the Conversation, thus output from previous turns (text and  audio tokens) will become the input for later turns. 
 */
export interface RealtimeResponseUsage {
    /**
     * The total number of tokens in the Response including input and output  text and audio tokens. 
     */
    'total_tokens'?: number;
    /**
     * The number of input tokens used in the Response, including text and  audio tokens. 
     */
    'input_tokens'?: number;
    /**
     * The number of output tokens sent in the Response, including text and  audio tokens. 
     */
    'output_tokens'?: number;
    'input_token_details'?: RealtimeResponseUsageInputTokenDetails;
    'output_token_details'?: RealtimeResponseUsageOutputTokenDetails;
}
/**
 * Details about the input tokens used in the Response.
 */
export interface RealtimeResponseUsageInputTokenDetails {
    /**
     * The number of cached tokens used in the Response.
     */
    'cached_tokens'?: number;
    /**
     * The number of text tokens used in the Response.
     */
    'text_tokens'?: number;
    /**
     * The number of audio tokens used in the Response.
     */
    'audio_tokens'?: number;
}
/**
 * Details about the output tokens used in the Response.
 */
export interface RealtimeResponseUsageOutputTokenDetails {
    /**
     * The number of text tokens used in the Response.
     */
    'text_tokens'?: number;
    /**
     * The number of audio tokens used in the Response.
     */
    'audio_tokens'?: number;
}
/**
 * Returned when a conversation is created. Emitted right after session creation. 
 */
export interface RealtimeServerEventConversationCreated {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `conversation.created`.
     */
    'type': RealtimeServerEventConversationCreatedTypeEnum;
    'conversation': RealtimeServerEventConversationCreatedConversation;
}

export const RealtimeServerEventConversationCreatedTypeEnum = {
    ConversationCreated: 'conversation.created'
} as const;

export type RealtimeServerEventConversationCreatedTypeEnum = typeof RealtimeServerEventConversationCreatedTypeEnum[keyof typeof RealtimeServerEventConversationCreatedTypeEnum];

/**
 * The conversation resource.
 */
export interface RealtimeServerEventConversationCreatedConversation {
    /**
     * The unique ID of the conversation.
     */
    'id'?: string;
    /**
     * The object type, must be `realtime.conversation`.
     */
    'object'?: string;
}
/**
 * Returned when a conversation item is created. There are several scenarios that  produce this event:   - The server is generating a Response, which if successful will produce      either one or two Items, which will be of type `message`      (role `assistant`) or type `function_call`.   - The input audio buffer has been committed, either by the client or the      server (in `server_vad` mode). The server will take the content of the      input audio buffer and add it to a new user message Item.   - The client has sent a `conversation.item.create` event to add a new Item      to the Conversation. 
 */
export interface RealtimeServerEventConversationItemCreated {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `conversation.item.created`.
     */
    'type': RealtimeServerEventConversationItemCreatedTypeEnum;
    /**
     * The ID of the preceding item in the Conversation context, allows the  client to understand the order of the conversation. 
     */
    'previous_item_id': string;
    'item': RealtimeConversationItem;
}

export const RealtimeServerEventConversationItemCreatedTypeEnum = {
    ConversationItemCreated: 'conversation.item.created'
} as const;

export type RealtimeServerEventConversationItemCreatedTypeEnum = typeof RealtimeServerEventConversationItemCreatedTypeEnum[keyof typeof RealtimeServerEventConversationItemCreatedTypeEnum];

/**
 * Returned when an item in the conversation is deleted by the client with a  `conversation.item.delete` event. This event is used to synchronize the  server\'s understanding of the conversation history with the client\'s view. 
 */
export interface RealtimeServerEventConversationItemDeleted {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `conversation.item.deleted`.
     */
    'type': RealtimeServerEventConversationItemDeletedTypeEnum;
    /**
     * The ID of the item that was deleted.
     */
    'item_id': string;
}

export const RealtimeServerEventConversationItemDeletedTypeEnum = {
    ConversationItemDeleted: 'conversation.item.deleted'
} as const;

export type RealtimeServerEventConversationItemDeletedTypeEnum = typeof RealtimeServerEventConversationItemDeletedTypeEnum[keyof typeof RealtimeServerEventConversationItemDeletedTypeEnum];

/**
 * This event is the output of audio transcription for user audio written to the  user audio buffer. Transcription begins when the input audio buffer is  committed by the client or server (in `server_vad` mode). Transcription runs  asynchronously with Response creation, so this event may come before or after  the Response events.  Realtime API models accept audio natively, and thus input transcription is a  separate process run on a separate ASR (Automatic Speech Recognition) model,  currently always `whisper-1`. Thus the transcript may diverge somewhat from  the model\'s interpretation, and should be treated as a rough guide. 
 */
export interface RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `conversation.item.input_audio_transcription.completed`. 
     */
    'type': RealtimeServerEventConversationItemInputAudioTranscriptionCompletedTypeEnum;
    /**
     * The ID of the user message item containing the audio.
     */
    'item_id': string;
    /**
     * The index of the content part containing the audio.
     */
    'content_index': number;
    /**
     * The transcribed text.
     */
    'transcript': string;
}

export const RealtimeServerEventConversationItemInputAudioTranscriptionCompletedTypeEnum = {
    ConversationItemInputAudioTranscriptionCompleted: 'conversation.item.input_audio_transcription.completed'
} as const;

export type RealtimeServerEventConversationItemInputAudioTranscriptionCompletedTypeEnum = typeof RealtimeServerEventConversationItemInputAudioTranscriptionCompletedTypeEnum[keyof typeof RealtimeServerEventConversationItemInputAudioTranscriptionCompletedTypeEnum];

/**
 * Returned when input audio transcription is configured, and a transcription  request for a user message failed. These events are separate from other  `error` events so that the client can identify the related Item. 
 */
export interface RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `conversation.item.input_audio_transcription.failed`. 
     */
    'type': RealtimeServerEventConversationItemInputAudioTranscriptionFailedTypeEnum;
    /**
     * The ID of the user message item.
     */
    'item_id': string;
    /**
     * The index of the content part containing the audio.
     */
    'content_index': number;
    'error': RealtimeServerEventConversationItemInputAudioTranscriptionFailedError;
}

export const RealtimeServerEventConversationItemInputAudioTranscriptionFailedTypeEnum = {
    ConversationItemInputAudioTranscriptionFailed: 'conversation.item.input_audio_transcription.failed'
} as const;

export type RealtimeServerEventConversationItemInputAudioTranscriptionFailedTypeEnum = typeof RealtimeServerEventConversationItemInputAudioTranscriptionFailedTypeEnum[keyof typeof RealtimeServerEventConversationItemInputAudioTranscriptionFailedTypeEnum];

/**
 * Details of the transcription error.
 */
export interface RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
    /**
     * The type of error.
     */
    'type'?: string;
    /**
     * Error code, if any.
     */
    'code'?: string;
    /**
     * A human-readable error message.
     */
    'message'?: string;
    /**
     * Parameter related to the error, if any.
     */
    'param'?: string;
}
/**
 * Returned when an earlier assistant audio message item is truncated by the  client with a `conversation.item.truncate` event. This event is used to  synchronize the server\'s understanding of the audio with the client\'s playback.  This action will truncate the audio and remove the server-side text transcript  to ensure there is no text in the context that hasn\'t been heard by the user. 
 */
export interface RealtimeServerEventConversationItemTruncated {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `conversation.item.truncated`.
     */
    'type': RealtimeServerEventConversationItemTruncatedTypeEnum;
    /**
     * The ID of the assistant message item that was truncated.
     */
    'item_id': string;
    /**
     * The index of the content part that was truncated.
     */
    'content_index': number;
    /**
     * The duration up to which the audio was truncated, in milliseconds. 
     */
    'audio_end_ms': number;
}

export const RealtimeServerEventConversationItemTruncatedTypeEnum = {
    ConversationItemTruncated: 'conversation.item.truncated'
} as const;

export type RealtimeServerEventConversationItemTruncatedTypeEnum = typeof RealtimeServerEventConversationItemTruncatedTypeEnum[keyof typeof RealtimeServerEventConversationItemTruncatedTypeEnum];

/**
 * Returned when an error occurs, which could be a client problem or a server  problem. Most errors are recoverable and the session will stay open, we  recommend to implementors to monitor and log error messages by default. 
 */
export interface RealtimeServerEventError {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `error`.
     */
    'type': RealtimeServerEventErrorTypeEnum;
    'error': RealtimeServerEventErrorError;
}

export const RealtimeServerEventErrorTypeEnum = {
    Error: 'error'
} as const;

export type RealtimeServerEventErrorTypeEnum = typeof RealtimeServerEventErrorTypeEnum[keyof typeof RealtimeServerEventErrorTypeEnum];

/**
 * Details of the error.
 */
export interface RealtimeServerEventErrorError {
    /**
     * The type of error (e.g., \"invalid_request_error\", \"server_error\"). 
     */
    'type': string;
    /**
     * Error code, if any.
     */
    'code'?: string | null;
    /**
     * A human-readable error message.
     */
    'message': string;
    /**
     * Parameter related to the error, if any.
     */
    'param'?: string | null;
    /**
     * The event_id of the client event that caused the error, if applicable. 
     */
    'event_id'?: string | null;
}
/**
 * Returned when the input audio buffer is cleared by the client with a  `input_audio_buffer.clear` event. 
 */
export interface RealtimeServerEventInputAudioBufferCleared {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `input_audio_buffer.cleared`.
     */
    'type': RealtimeServerEventInputAudioBufferClearedTypeEnum;
}

export const RealtimeServerEventInputAudioBufferClearedTypeEnum = {
    InputAudioBufferCleared: 'input_audio_buffer.cleared'
} as const;

export type RealtimeServerEventInputAudioBufferClearedTypeEnum = typeof RealtimeServerEventInputAudioBufferClearedTypeEnum[keyof typeof RealtimeServerEventInputAudioBufferClearedTypeEnum];

/**
 * Returned when an input audio buffer is committed, either by the client or  automatically in server VAD mode. The `item_id` property is the ID of the user message item that will be created, thus a `conversation.item.created` event  will also be sent to the client. 
 */
export interface RealtimeServerEventInputAudioBufferCommitted {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `input_audio_buffer.committed`.
     */
    'type': RealtimeServerEventInputAudioBufferCommittedTypeEnum;
    /**
     * The ID of the preceding item after which the new item will be inserted. 
     */
    'previous_item_id': string;
    /**
     * The ID of the user message item that will be created.
     */
    'item_id': string;
}

export const RealtimeServerEventInputAudioBufferCommittedTypeEnum = {
    InputAudioBufferCommitted: 'input_audio_buffer.committed'
} as const;

export type RealtimeServerEventInputAudioBufferCommittedTypeEnum = typeof RealtimeServerEventInputAudioBufferCommittedTypeEnum[keyof typeof RealtimeServerEventInputAudioBufferCommittedTypeEnum];

/**
 * Sent by the server when in `server_vad` mode to indicate that speech has been  detected in the audio buffer. This can happen any time audio is added to the  buffer (unless speech is already detected). The client may want to use this  event to interrupt audio playback or provide visual feedback to the user.   The client should expect to receive a `input_audio_buffer.speech_stopped` event  when speech stops. The `item_id` property is the ID of the user message item  that will be created when speech stops and will also be included in the  `input_audio_buffer.speech_stopped` event (unless the client manually commits  the audio buffer during VAD activation). 
 */
export interface RealtimeServerEventInputAudioBufferSpeechStarted {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `input_audio_buffer.speech_started`.
     */
    'type': RealtimeServerEventInputAudioBufferSpeechStartedTypeEnum;
    /**
     * Milliseconds from the start of all audio written to the buffer during the  session when speech was first detected. This will correspond to the  beginning of audio sent to the model, and thus includes the  `prefix_padding_ms` configured in the Session. 
     */
    'audio_start_ms': number;
    /**
     * The ID of the user message item that will be created when speech stops. 
     */
    'item_id': string;
}

export const RealtimeServerEventInputAudioBufferSpeechStartedTypeEnum = {
    InputAudioBufferSpeechStarted: 'input_audio_buffer.speech_started'
} as const;

export type RealtimeServerEventInputAudioBufferSpeechStartedTypeEnum = typeof RealtimeServerEventInputAudioBufferSpeechStartedTypeEnum[keyof typeof RealtimeServerEventInputAudioBufferSpeechStartedTypeEnum];

/**
 * Returned in `server_vad` mode when the server detects the end of speech in  the audio buffer. The server will also send an `conversation.item.created`  event with the user message item that is created from the audio buffer. 
 */
export interface RealtimeServerEventInputAudioBufferSpeechStopped {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `input_audio_buffer.speech_stopped`.
     */
    'type': RealtimeServerEventInputAudioBufferSpeechStoppedTypeEnum;
    /**
     * Milliseconds since the session started when speech stopped. This will  correspond to the end of audio sent to the model, and thus includes the  `min_silence_duration_ms` configured in the Session. 
     */
    'audio_end_ms': number;
    /**
     * The ID of the user message item that will be created.
     */
    'item_id': string;
}

export const RealtimeServerEventInputAudioBufferSpeechStoppedTypeEnum = {
    InputAudioBufferSpeechStopped: 'input_audio_buffer.speech_stopped'
} as const;

export type RealtimeServerEventInputAudioBufferSpeechStoppedTypeEnum = typeof RealtimeServerEventInputAudioBufferSpeechStoppedTypeEnum[keyof typeof RealtimeServerEventInputAudioBufferSpeechStoppedTypeEnum];

/**
 * Emitted at the beginning of a Response to indicate the updated rate limits.  When a Response is created some tokens will be \"reserved\" for the output  tokens, the rate limits shown here reflect that reservation, which is then  adjusted accordingly once the Response is completed. 
 */
export interface RealtimeServerEventRateLimitsUpdated {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `rate_limits.updated`.
     */
    'type': RealtimeServerEventRateLimitsUpdatedTypeEnum;
    /**
     * List of rate limit information.
     */
    'rate_limits': Array<RealtimeServerEventRateLimitsUpdatedRateLimitsInner>;
}

export const RealtimeServerEventRateLimitsUpdatedTypeEnum = {
    RateLimitsUpdated: 'rate_limits.updated'
} as const;

export type RealtimeServerEventRateLimitsUpdatedTypeEnum = typeof RealtimeServerEventRateLimitsUpdatedTypeEnum[keyof typeof RealtimeServerEventRateLimitsUpdatedTypeEnum];

export interface RealtimeServerEventRateLimitsUpdatedRateLimitsInner {
    /**
     * The name of the rate limit (`requests`, `tokens`). 
     */
    'name'?: RealtimeServerEventRateLimitsUpdatedRateLimitsInnerNameEnum;
    /**
     * The maximum allowed value for the rate limit.
     */
    'limit'?: number;
    /**
     * The remaining value before the limit is reached.
     */
    'remaining'?: number;
    /**
     * Seconds until the rate limit resets.
     */
    'reset_seconds'?: number;
}

export const RealtimeServerEventRateLimitsUpdatedRateLimitsInnerNameEnum = {
    Requests: 'requests',
    Tokens: 'tokens'
} as const;

export type RealtimeServerEventRateLimitsUpdatedRateLimitsInnerNameEnum = typeof RealtimeServerEventRateLimitsUpdatedRateLimitsInnerNameEnum[keyof typeof RealtimeServerEventRateLimitsUpdatedRateLimitsInnerNameEnum];

/**
 * Returned when the model-generated audio is updated.
 */
export interface RealtimeServerEventResponseAudioDelta {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `response.audio.delta`.
     */
    'type': RealtimeServerEventResponseAudioDeltaTypeEnum;
    /**
     * The ID of the response.
     */
    'response_id': string;
    /**
     * The ID of the item.
     */
    'item_id': string;
    /**
     * The index of the output item in the response.
     */
    'output_index': number;
    /**
     * The index of the content part in the item\'s content array.
     */
    'content_index': number;
    /**
     * Base64-encoded audio data delta.
     */
    'delta': string;
}

export const RealtimeServerEventResponseAudioDeltaTypeEnum = {
    ResponseAudioDelta: 'response.audio.delta'
} as const;

export type RealtimeServerEventResponseAudioDeltaTypeEnum = typeof RealtimeServerEventResponseAudioDeltaTypeEnum[keyof typeof RealtimeServerEventResponseAudioDeltaTypeEnum];

/**
 * Returned when the model-generated audio is done. Also emitted when a Response is interrupted, incomplete, or cancelled. 
 */
export interface RealtimeServerEventResponseAudioDone {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `response.audio.done`.
     */
    'type': RealtimeServerEventResponseAudioDoneTypeEnum;
    /**
     * The ID of the response.
     */
    'response_id': string;
    /**
     * The ID of the item.
     */
    'item_id': string;
    /**
     * The index of the output item in the response.
     */
    'output_index': number;
    /**
     * The index of the content part in the item\'s content array.
     */
    'content_index': number;
}

export const RealtimeServerEventResponseAudioDoneTypeEnum = {
    ResponseAudioDone: 'response.audio.done'
} as const;

export type RealtimeServerEventResponseAudioDoneTypeEnum = typeof RealtimeServerEventResponseAudioDoneTypeEnum[keyof typeof RealtimeServerEventResponseAudioDoneTypeEnum];

/**
 * Returned when the model-generated transcription of audio output is updated. 
 */
export interface RealtimeServerEventResponseAudioTranscriptDelta {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `response.audio_transcript.delta`.
     */
    'type': RealtimeServerEventResponseAudioTranscriptDeltaTypeEnum;
    /**
     * The ID of the response.
     */
    'response_id': string;
    /**
     * The ID of the item.
     */
    'item_id': string;
    /**
     * The index of the output item in the response.
     */
    'output_index': number;
    /**
     * The index of the content part in the item\'s content array.
     */
    'content_index': number;
    /**
     * The transcript delta.
     */
    'delta': string;
}

export const RealtimeServerEventResponseAudioTranscriptDeltaTypeEnum = {
    ResponseAudioTranscriptDelta: 'response.audio_transcript.delta'
} as const;

export type RealtimeServerEventResponseAudioTranscriptDeltaTypeEnum = typeof RealtimeServerEventResponseAudioTranscriptDeltaTypeEnum[keyof typeof RealtimeServerEventResponseAudioTranscriptDeltaTypeEnum];

/**
 * Returned when the model-generated transcription of audio output is done streaming. Also emitted when a Response is interrupted, incomplete, or cancelled. 
 */
export interface RealtimeServerEventResponseAudioTranscriptDone {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `response.audio_transcript.done`.
     */
    'type': RealtimeServerEventResponseAudioTranscriptDoneTypeEnum;
    /**
     * The ID of the response.
     */
    'response_id': string;
    /**
     * The ID of the item.
     */
    'item_id': string;
    /**
     * The index of the output item in the response.
     */
    'output_index': number;
    /**
     * The index of the content part in the item\'s content array.
     */
    'content_index': number;
    /**
     * The final transcript of the audio.
     */
    'transcript': string;
}

export const RealtimeServerEventResponseAudioTranscriptDoneTypeEnum = {
    ResponseAudioTranscriptDone: 'response.audio_transcript.done'
} as const;

export type RealtimeServerEventResponseAudioTranscriptDoneTypeEnum = typeof RealtimeServerEventResponseAudioTranscriptDoneTypeEnum[keyof typeof RealtimeServerEventResponseAudioTranscriptDoneTypeEnum];

/**
 * Returned when a new content part is added to an assistant message item during response generation. 
 */
export interface RealtimeServerEventResponseContentPartAdded {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `response.content_part.added`.
     */
    'type': RealtimeServerEventResponseContentPartAddedTypeEnum;
    /**
     * The ID of the response.
     */
    'response_id': string;
    /**
     * The ID of the item to which the content part was added.
     */
    'item_id': string;
    /**
     * The index of the output item in the response.
     */
    'output_index': number;
    /**
     * The index of the content part in the item\'s content array.
     */
    'content_index': number;
    'part': RealtimeServerEventResponseContentPartAddedPart;
}

export const RealtimeServerEventResponseContentPartAddedTypeEnum = {
    ResponseContentPartAdded: 'response.content_part.added'
} as const;

export type RealtimeServerEventResponseContentPartAddedTypeEnum = typeof RealtimeServerEventResponseContentPartAddedTypeEnum[keyof typeof RealtimeServerEventResponseContentPartAddedTypeEnum];

/**
 * The content part that was added.
 */
export interface RealtimeServerEventResponseContentPartAddedPart {
    /**
     * The content type (\"text\", \"audio\").
     */
    'type'?: RealtimeServerEventResponseContentPartAddedPartTypeEnum;
    /**
     * The text content (if type is \"text\").
     */
    'text'?: string;
    /**
     * Base64-encoded audio data (if type is \"audio\").
     */
    'audio'?: string;
    /**
     * The transcript of the audio (if type is \"audio\").
     */
    'transcript'?: string;
}

export const RealtimeServerEventResponseContentPartAddedPartTypeEnum = {
    Audio: 'audio',
    Text: 'text'
} as const;

export type RealtimeServerEventResponseContentPartAddedPartTypeEnum = typeof RealtimeServerEventResponseContentPartAddedPartTypeEnum[keyof typeof RealtimeServerEventResponseContentPartAddedPartTypeEnum];

/**
 * Returned when a content part is done streaming in an assistant message item. Also emitted when a Response is interrupted, incomplete, or cancelled. 
 */
export interface RealtimeServerEventResponseContentPartDone {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `response.content_part.done`.
     */
    'type': RealtimeServerEventResponseContentPartDoneTypeEnum;
    /**
     * The ID of the response.
     */
    'response_id': string;
    /**
     * The ID of the item.
     */
    'item_id': string;
    /**
     * The index of the output item in the response.
     */
    'output_index': number;
    /**
     * The index of the content part in the item\'s content array.
     */
    'content_index': number;
    'part': RealtimeServerEventResponseContentPartDonePart;
}

export const RealtimeServerEventResponseContentPartDoneTypeEnum = {
    ResponseContentPartDone: 'response.content_part.done'
} as const;

export type RealtimeServerEventResponseContentPartDoneTypeEnum = typeof RealtimeServerEventResponseContentPartDoneTypeEnum[keyof typeof RealtimeServerEventResponseContentPartDoneTypeEnum];

/**
 * The content part that is done.
 */
export interface RealtimeServerEventResponseContentPartDonePart {
    /**
     * The content type (\"text\", \"audio\").
     */
    'type'?: RealtimeServerEventResponseContentPartDonePartTypeEnum;
    /**
     * The text content (if type is \"text\").
     */
    'text'?: string;
    /**
     * Base64-encoded audio data (if type is \"audio\").
     */
    'audio'?: string;
    /**
     * The transcript of the audio (if type is \"audio\").
     */
    'transcript'?: string;
}

export const RealtimeServerEventResponseContentPartDonePartTypeEnum = {
    Audio: 'audio',
    Text: 'text'
} as const;

export type RealtimeServerEventResponseContentPartDonePartTypeEnum = typeof RealtimeServerEventResponseContentPartDonePartTypeEnum[keyof typeof RealtimeServerEventResponseContentPartDonePartTypeEnum];

/**
 * Returned when a new Response is created. The first event of response creation, where the response is in an initial state of `in_progress`. 
 */
export interface RealtimeServerEventResponseCreated {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `response.created`.
     */
    'type': RealtimeServerEventResponseCreatedTypeEnum;
    'response': RealtimeResponse;
}

export const RealtimeServerEventResponseCreatedTypeEnum = {
    ResponseCreated: 'response.created'
} as const;

export type RealtimeServerEventResponseCreatedTypeEnum = typeof RealtimeServerEventResponseCreatedTypeEnum[keyof typeof RealtimeServerEventResponseCreatedTypeEnum];

/**
 * Returned when a Response is done streaming. Always emitted, no matter the  final state. The Response object included in the `response.done` event will  include all output Items in the Response but will omit the raw audio data. 
 */
export interface RealtimeServerEventResponseDone {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `response.done`.
     */
    'type': RealtimeServerEventResponseDoneTypeEnum;
    'response': RealtimeResponse;
}

export const RealtimeServerEventResponseDoneTypeEnum = {
    ResponseDone: 'response.done'
} as const;

export type RealtimeServerEventResponseDoneTypeEnum = typeof RealtimeServerEventResponseDoneTypeEnum[keyof typeof RealtimeServerEventResponseDoneTypeEnum];

/**
 * Returned when the model-generated function call arguments are updated. 
 */
export interface RealtimeServerEventResponseFunctionCallArgumentsDelta {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `response.function_call_arguments.delta`. 
     */
    'type': RealtimeServerEventResponseFunctionCallArgumentsDeltaTypeEnum;
    /**
     * The ID of the response.
     */
    'response_id': string;
    /**
     * The ID of the function call item.
     */
    'item_id': string;
    /**
     * The index of the output item in the response.
     */
    'output_index': number;
    /**
     * The ID of the function call.
     */
    'call_id': string;
    /**
     * The arguments delta as a JSON string.
     */
    'delta': string;
}

export const RealtimeServerEventResponseFunctionCallArgumentsDeltaTypeEnum = {
    ResponseFunctionCallArgumentsDelta: 'response.function_call_arguments.delta'
} as const;

export type RealtimeServerEventResponseFunctionCallArgumentsDeltaTypeEnum = typeof RealtimeServerEventResponseFunctionCallArgumentsDeltaTypeEnum[keyof typeof RealtimeServerEventResponseFunctionCallArgumentsDeltaTypeEnum];

/**
 * Returned when the model-generated function call arguments are done streaming. Also emitted when a Response is interrupted, incomplete, or cancelled. 
 */
export interface RealtimeServerEventResponseFunctionCallArgumentsDone {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `response.function_call_arguments.done`. 
     */
    'type': RealtimeServerEventResponseFunctionCallArgumentsDoneTypeEnum;
    /**
     * The ID of the response.
     */
    'response_id': string;
    /**
     * The ID of the function call item.
     */
    'item_id': string;
    /**
     * The index of the output item in the response.
     */
    'output_index': number;
    /**
     * The ID of the function call.
     */
    'call_id': string;
    /**
     * The final arguments as a JSON string.
     */
    'arguments': string;
}

export const RealtimeServerEventResponseFunctionCallArgumentsDoneTypeEnum = {
    ResponseFunctionCallArgumentsDone: 'response.function_call_arguments.done'
} as const;

export type RealtimeServerEventResponseFunctionCallArgumentsDoneTypeEnum = typeof RealtimeServerEventResponseFunctionCallArgumentsDoneTypeEnum[keyof typeof RealtimeServerEventResponseFunctionCallArgumentsDoneTypeEnum];

/**
 * Returned when a new Item is created during Response generation.
 */
export interface RealtimeServerEventResponseOutputItemAdded {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `response.output_item.added`.
     */
    'type': RealtimeServerEventResponseOutputItemAddedTypeEnum;
    /**
     * The ID of the Response to which the item belongs.
     */
    'response_id': string;
    /**
     * The index of the output item in the Response.
     */
    'output_index': number;
    'item': RealtimeConversationItem;
}

export const RealtimeServerEventResponseOutputItemAddedTypeEnum = {
    ResponseOutputItemAdded: 'response.output_item.added'
} as const;

export type RealtimeServerEventResponseOutputItemAddedTypeEnum = typeof RealtimeServerEventResponseOutputItemAddedTypeEnum[keyof typeof RealtimeServerEventResponseOutputItemAddedTypeEnum];

/**
 * Returned when an Item is done streaming. Also emitted when a Response is  interrupted, incomplete, or cancelled. 
 */
export interface RealtimeServerEventResponseOutputItemDone {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `response.output_item.done`.
     */
    'type': RealtimeServerEventResponseOutputItemDoneTypeEnum;
    /**
     * The ID of the Response to which the item belongs.
     */
    'response_id': string;
    /**
     * The index of the output item in the Response.
     */
    'output_index': number;
    'item': RealtimeConversationItem;
}

export const RealtimeServerEventResponseOutputItemDoneTypeEnum = {
    ResponseOutputItemDone: 'response.output_item.done'
} as const;

export type RealtimeServerEventResponseOutputItemDoneTypeEnum = typeof RealtimeServerEventResponseOutputItemDoneTypeEnum[keyof typeof RealtimeServerEventResponseOutputItemDoneTypeEnum];

/**
 * Returned when the text value of a \"text\" content part is updated.
 */
export interface RealtimeServerEventResponseTextDelta {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `response.text.delta`.
     */
    'type': RealtimeServerEventResponseTextDeltaTypeEnum;
    /**
     * The ID of the response.
     */
    'response_id': string;
    /**
     * The ID of the item.
     */
    'item_id': string;
    /**
     * The index of the output item in the response.
     */
    'output_index': number;
    /**
     * The index of the content part in the item\'s content array.
     */
    'content_index': number;
    /**
     * The text delta.
     */
    'delta': string;
}

export const RealtimeServerEventResponseTextDeltaTypeEnum = {
    ResponseTextDelta: 'response.text.delta'
} as const;

export type RealtimeServerEventResponseTextDeltaTypeEnum = typeof RealtimeServerEventResponseTextDeltaTypeEnum[keyof typeof RealtimeServerEventResponseTextDeltaTypeEnum];

/**
 * Returned when the text value of a \"text\" content part is done streaming. Also emitted when a Response is interrupted, incomplete, or cancelled. 
 */
export interface RealtimeServerEventResponseTextDone {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `response.text.done`.
     */
    'type': RealtimeServerEventResponseTextDoneTypeEnum;
    /**
     * The ID of the response.
     */
    'response_id': string;
    /**
     * The ID of the item.
     */
    'item_id': string;
    /**
     * The index of the output item in the response.
     */
    'output_index': number;
    /**
     * The index of the content part in the item\'s content array.
     */
    'content_index': number;
    /**
     * The final text content.
     */
    'text': string;
}

export const RealtimeServerEventResponseTextDoneTypeEnum = {
    ResponseTextDone: 'response.text.done'
} as const;

export type RealtimeServerEventResponseTextDoneTypeEnum = typeof RealtimeServerEventResponseTextDoneTypeEnum[keyof typeof RealtimeServerEventResponseTextDoneTypeEnum];

/**
 * Returned when a Session is created. Emitted automatically when a new  connection is established as the first server event. This event will contain  the default Session configuration. 
 */
export interface RealtimeServerEventSessionCreated {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `session.created`.
     */
    'type': RealtimeServerEventSessionCreatedTypeEnum;
    'session': RealtimeSession;
}

export const RealtimeServerEventSessionCreatedTypeEnum = {
    SessionCreated: 'session.created'
} as const;

export type RealtimeServerEventSessionCreatedTypeEnum = typeof RealtimeServerEventSessionCreatedTypeEnum[keyof typeof RealtimeServerEventSessionCreatedTypeEnum];

/**
 * Returned when a session is updated with a `session.update` event, unless  there is an error. 
 */
export interface RealtimeServerEventSessionUpdated {
    /**
     * The unique ID of the server event.
     */
    'event_id': string;
    /**
     * The event type, must be `session.updated`.
     */
    'type': RealtimeServerEventSessionUpdatedTypeEnum;
    'session': RealtimeSession;
}

export const RealtimeServerEventSessionUpdatedTypeEnum = {
    SessionUpdated: 'session.updated'
} as const;

export type RealtimeServerEventSessionUpdatedTypeEnum = typeof RealtimeServerEventSessionUpdatedTypeEnum[keyof typeof RealtimeServerEventSessionUpdatedTypeEnum];

/**
 * Realtime session object configuration.
 */
export interface RealtimeSession {
    /**
     * Unique identifier for the session object. 
     */
    'id'?: string;
    /**
     * The set of modalities the model can respond with. To disable audio, set this to [\"text\"]. 
     */
    'modalities'?: Array<RealtimeSessionModalitiesEnum>;
    'model'?: RealtimeSessionModel;
    /**
     * The default system instructions (i.e. system message) prepended to model  calls. This field allows the client to guide the model on desired  responses. The model can be instructed on response content and format,  (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good  responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion  into your voice\", \"laugh frequently\"). The instructions are not guaranteed  to be followed by the model, but they provide guidance to the model on the  desired behavior.  Note that the server sets default instructions which will be used if this  field is not set and are visible in the `session.created` event at the  start of the session. 
     */
    'instructions'?: string;
    /**
     * The voice the model uses to respond. Voice cannot be changed during the  session once the model has responded with audio at least once. Current  voice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`,  `shimmer` and `verse`. 
     */
    'voice'?: RealtimeSessionVoiceEnum;
    /**
     * The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
     */
    'input_audio_format'?: RealtimeSessionInputAudioFormatEnum;
    /**
     * The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
     */
    'output_audio_format'?: RealtimeSessionOutputAudioFormatEnum;
    'input_audio_transcription'?: RealtimeSessionInputAudioTranscription;
    'turn_detection'?: RealtimeSessionTurnDetection | null;
    /**
     * Tools (functions) available to the model.
     */
    'tools'?: Array<RealtimeResponseCreateParamsToolsInner>;
    /**
     * How the model chooses tools. Options are `auto`, `none`, `required`, or  specify a function. 
     */
    'tool_choice'?: string;
    /**
     * Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8. 
     */
    'temperature'?: number;
    'max_response_output_tokens'?: RealtimeResponseCreateParamsMaxResponseOutputTokens;
}

export const RealtimeSessionModalitiesEnum = {
    Text: 'text',
    Audio: 'audio'
} as const;

export type RealtimeSessionModalitiesEnum = typeof RealtimeSessionModalitiesEnum[keyof typeof RealtimeSessionModalitiesEnum];
export const RealtimeSessionVoiceEnum = {
    Alloy: 'alloy',
    Ash: 'ash',
    Ballad: 'ballad',
    Coral: 'coral',
    Echo: 'echo',
    Sage: 'sage',
    Shimmer: 'shimmer',
    Verse: 'verse'
} as const;

export type RealtimeSessionVoiceEnum = typeof RealtimeSessionVoiceEnum[keyof typeof RealtimeSessionVoiceEnum];
export const RealtimeSessionInputAudioFormatEnum = {
    Pcm16: 'pcm16',
    G711Ulaw: 'g711_ulaw',
    G711Alaw: 'g711_alaw'
} as const;

export type RealtimeSessionInputAudioFormatEnum = typeof RealtimeSessionInputAudioFormatEnum[keyof typeof RealtimeSessionInputAudioFormatEnum];
export const RealtimeSessionOutputAudioFormatEnum = {
    Pcm16: 'pcm16',
    G711Ulaw: 'g711_ulaw',
    G711Alaw: 'g711_alaw'
} as const;

export type RealtimeSessionOutputAudioFormatEnum = typeof RealtimeSessionOutputAudioFormatEnum[keyof typeof RealtimeSessionOutputAudioFormatEnum];

/**
 * Realtime session object configuration.
 */
export interface RealtimeSessionCreateRequest {
    /**
     * The set of modalities the model can respond with. To disable audio, set this to [\"text\"]. 
     */
    'modalities'?: Array<RealtimeSessionCreateRequestModalitiesEnum>;
    /**
     * The Realtime model used for this session. 
     */
    'model': RealtimeSessionCreateRequestModelEnum;
    /**
     * The default system instructions (i.e. system message) prepended to model  calls. This field allows the client to guide the model on desired  responses. The model can be instructed on response content and format,  (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good  responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion  into your voice\", \"laugh frequently\"). The instructions are not guaranteed  to be followed by the model, but they provide guidance to the model on the  desired behavior.  Note that the server sets default instructions which will be used if this  field is not set and are visible in the `session.created` event at the  start of the session. 
     */
    'instructions'?: string;
    /**
     * The voice the model uses to respond. Voice cannot be changed during the  session once the model has responded with audio at least once. Current  voice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`,  `shimmer` and `verse`. 
     */
    'voice'?: RealtimeSessionCreateRequestVoiceEnum;
    /**
     * The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
     */
    'input_audio_format'?: RealtimeSessionCreateRequestInputAudioFormatEnum;
    /**
     * The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
     */
    'output_audio_format'?: RealtimeSessionCreateRequestOutputAudioFormatEnum;
    'input_audio_transcription'?: RealtimeSessionInputAudioTranscription;
    'turn_detection'?: RealtimeSessionCreateRequestTurnDetection;
    /**
     * Tools (functions) available to the model.
     */
    'tools'?: Array<RealtimeResponseCreateParamsToolsInner>;
    /**
     * How the model chooses tools. Options are `auto`, `none`, `required`, or  specify a function. 
     */
    'tool_choice'?: string;
    /**
     * Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8. 
     */
    'temperature'?: number;
    'max_response_output_tokens'?: RealtimeResponseCreateParamsMaxResponseOutputTokens;
}

export const RealtimeSessionCreateRequestModalitiesEnum = {
    Text: 'text',
    Audio: 'audio'
} as const;

export type RealtimeSessionCreateRequestModalitiesEnum = typeof RealtimeSessionCreateRequestModalitiesEnum[keyof typeof RealtimeSessionCreateRequestModalitiesEnum];
export const RealtimeSessionCreateRequestModelEnum = {
    Gpt4oRealtimePreview: 'gpt-4o-realtime-preview',
    Gpt4oRealtimePreview20241001: 'gpt-4o-realtime-preview-2024-10-01',
    Gpt4oRealtimePreview20241217: 'gpt-4o-realtime-preview-2024-12-17',
    Gpt4oMiniRealtimePreview: 'gpt-4o-mini-realtime-preview',
    Gpt4oMiniRealtimePreview20241217: 'gpt-4o-mini-realtime-preview-2024-12-17'
} as const;

export type RealtimeSessionCreateRequestModelEnum = typeof RealtimeSessionCreateRequestModelEnum[keyof typeof RealtimeSessionCreateRequestModelEnum];
export const RealtimeSessionCreateRequestVoiceEnum = {
    Alloy: 'alloy',
    Ash: 'ash',
    Ballad: 'ballad',
    Coral: 'coral',
    Echo: 'echo',
    Sage: 'sage',
    Shimmer: 'shimmer',
    Verse: 'verse'
} as const;

export type RealtimeSessionCreateRequestVoiceEnum = typeof RealtimeSessionCreateRequestVoiceEnum[keyof typeof RealtimeSessionCreateRequestVoiceEnum];
export const RealtimeSessionCreateRequestInputAudioFormatEnum = {
    Pcm16: 'pcm16',
    G711Ulaw: 'g711_ulaw',
    G711Alaw: 'g711_alaw'
} as const;

export type RealtimeSessionCreateRequestInputAudioFormatEnum = typeof RealtimeSessionCreateRequestInputAudioFormatEnum[keyof typeof RealtimeSessionCreateRequestInputAudioFormatEnum];
export const RealtimeSessionCreateRequestOutputAudioFormatEnum = {
    Pcm16: 'pcm16',
    G711Ulaw: 'g711_ulaw',
    G711Alaw: 'g711_alaw'
} as const;

export type RealtimeSessionCreateRequestOutputAudioFormatEnum = typeof RealtimeSessionCreateRequestOutputAudioFormatEnum[keyof typeof RealtimeSessionCreateRequestOutputAudioFormatEnum];

/**
 * Configuration for turn detection. Can be set to `null` to turn off. Server  VAD means that the model will detect the start and end of speech based on  audio volume and respond at the end of user speech. 
 */
export interface RealtimeSessionCreateRequestTurnDetection {
    /**
     * Type of turn detection, only `server_vad` is currently supported. 
     */
    'type'?: string;
    /**
     * Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A  higher threshold will require louder audio to activate the model, and  thus might perform better in noisy environments. 
     */
    'threshold'?: number;
    /**
     * Amount of audio to include before the VAD detected speech (in  milliseconds). Defaults to 300ms. 
     */
    'prefix_padding_ms'?: number;
    /**
     * Duration of silence to detect speech stop (in milliseconds). Defaults  to 500ms. With shorter values the model will respond more quickly,  but may jump in on short pauses from the user. 
     */
    'silence_duration_ms'?: number;
    /**
     * Whether or not to automatically generate a response when VAD is enabled. `true` by default. 
     */
    'create_response'?: boolean;
}
/**
 * A new Realtime session configuration, with an ephermeral key. Default TTL for keys is one minute. 
 */
export interface RealtimeSessionCreateResponse {
    'client_secret'?: RealtimeSessionCreateResponseClientSecret;
    /**
     * The set of modalities the model can respond with. To disable audio, set this to [\"text\"]. 
     */
    'modalities'?: Array<RealtimeSessionCreateResponseModalitiesEnum>;
    /**
     * The default system instructions (i.e. system message) prepended to model  calls. This field allows the client to guide the model on desired  responses. The model can be instructed on response content and format,  (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good  responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion  into your voice\", \"laugh frequently\"). The instructions are not guaranteed  to be followed by the model, but they provide guidance to the model on the  desired behavior.  Note that the server sets default instructions which will be used if this  field is not set and are visible in the `session.created` event at the  start of the session. 
     */
    'instructions'?: string;
    /**
     * The voice the model uses to respond. Voice cannot be changed during the  session once the model has responded with audio at least once. Current  voice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`,  `shimmer` and `verse`. 
     */
    'voice'?: RealtimeSessionCreateResponseVoiceEnum;
    /**
     * The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
     */
    'input_audio_format'?: string;
    /**
     * The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. 
     */
    'output_audio_format'?: string;
    'input_audio_transcription'?: RealtimeSessionInputAudioTranscription;
    'turn_detection'?: RealtimeSessionCreateResponseTurnDetection;
    /**
     * Tools (functions) available to the model.
     */
    'tools'?: Array<RealtimeResponseCreateParamsToolsInner>;
    /**
     * How the model chooses tools. Options are `auto`, `none`, `required`, or  specify a function. 
     */
    'tool_choice'?: string;
    /**
     * Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8. 
     */
    'temperature'?: number;
    'max_response_output_tokens'?: RealtimeResponseCreateParamsMaxResponseOutputTokens;
}

export const RealtimeSessionCreateResponseModalitiesEnum = {
    Text: 'text',
    Audio: 'audio'
} as const;

export type RealtimeSessionCreateResponseModalitiesEnum = typeof RealtimeSessionCreateResponseModalitiesEnum[keyof typeof RealtimeSessionCreateResponseModalitiesEnum];
export const RealtimeSessionCreateResponseVoiceEnum = {
    Alloy: 'alloy',
    Ash: 'ash',
    Ballad: 'ballad',
    Coral: 'coral',
    Echo: 'echo',
    Sage: 'sage',
    Shimmer: 'shimmer',
    Verse: 'verse'
} as const;

export type RealtimeSessionCreateResponseVoiceEnum = typeof RealtimeSessionCreateResponseVoiceEnum[keyof typeof RealtimeSessionCreateResponseVoiceEnum];

/**
 * Ephemeral key returned by the API.
 */
export interface RealtimeSessionCreateResponseClientSecret {
    /**
     * Ephemeral key usable in client environments to authenticate connections to the Realtime API. Use this in client-side environments rather than a standard API token, which should only be used server-side. 
     */
    'value'?: string;
    /**
     * Timestamp for when the token expires. Currently, all tokens expire after one minute. 
     */
    'expires_at'?: number;
}
/**
 * Configuration for turn detection. Can be set to `null` to turn off. Server  VAD means that the model will detect the start and end of speech based on  audio volume and respond at the end of user speech. 
 */
export interface RealtimeSessionCreateResponseTurnDetection {
    /**
     * Type of turn detection, only `server_vad` is currently supported. 
     */
    'type'?: string;
    /**
     * Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A  higher threshold will require louder audio to activate the model, and  thus might perform better in noisy environments. 
     */
    'threshold'?: number;
    /**
     * Amount of audio to include before the VAD detected speech (in  milliseconds). Defaults to 300ms. 
     */
    'prefix_padding_ms'?: number;
    /**
     * Duration of silence to detect speech stop (in milliseconds). Defaults  to 500ms. With shorter values the model will respond more quickly,  but may jump in on short pauses from the user. 
     */
    'silence_duration_ms'?: number;
}
/**
 * Configuration for input audio transcription, defaults to off and can be  set to `null` to turn off once on. Input audio transcription is not native  to the model, since the model consumes audio directly. Transcription runs  asynchronously through Whisper and should be treated as rough guidance  rather than the representation understood by the model. 
 */
export interface RealtimeSessionInputAudioTranscription {
    /**
     * The model to use for transcription, `whisper-1` is the only currently  supported model. 
     */
    'model'?: string;
}
/**
 * The Realtime model used for this session. 
 */
export interface RealtimeSessionModel {
}
/**
 * Configuration for turn detection. Can be set to `null` to turn off. Server  VAD means that the model will detect the start and end of speech based on  audio volume and respond at the end of user speech. 
 */
export interface RealtimeSessionTurnDetection {
    /**
     * Type of turn detection, only `server_vad` is currently supported. 
     */
    'type'?: RealtimeSessionTurnDetectionTypeEnum;
    /**
     * Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A  higher threshold will require louder audio to activate the model, and  thus might perform better in noisy environments. 
     */
    'threshold'?: number;
    /**
     * Amount of audio to include before the VAD detected speech (in  milliseconds). Defaults to 300ms. 
     */
    'prefix_padding_ms'?: number;
    /**
     * Duration of silence to detect speech stop (in milliseconds). Defaults  to 500ms. With shorter values the model will respond more quickly,  but may jump in on short pauses from the user. 
     */
    'silence_duration_ms'?: number;
}

export const RealtimeSessionTurnDetectionTypeEnum = {
    ServerVad: 'server_vad'
} as const;

export type RealtimeSessionTurnDetectionTypeEnum = typeof RealtimeSessionTurnDetectionTypeEnum[keyof typeof RealtimeSessionTurnDetectionTypeEnum];

export interface ResponseFormatJsonObject {
    /**
     * The type of response format being defined: `json_object`
     */
    'type': ResponseFormatJsonObjectTypeEnum;
}

export const ResponseFormatJsonObjectTypeEnum = {
    JsonObject: 'json_object'
} as const;

export type ResponseFormatJsonObjectTypeEnum = typeof ResponseFormatJsonObjectTypeEnum[keyof typeof ResponseFormatJsonObjectTypeEnum];

export interface ResponseFormatJsonSchema {
    /**
     * The type of response format being defined: `json_schema`
     */
    'type': ResponseFormatJsonSchemaTypeEnum;
    'json_schema': ResponseFormatJsonSchemaJsonSchema;
}

export const ResponseFormatJsonSchemaTypeEnum = {
    JsonSchema: 'json_schema'
} as const;

export type ResponseFormatJsonSchemaTypeEnum = typeof ResponseFormatJsonSchemaTypeEnum[keyof typeof ResponseFormatJsonSchemaTypeEnum];

export interface ResponseFormatJsonSchemaJsonSchema {
    /**
     * A description of what the response format is for, used by the model to determine how to respond in the format.
     */
    'description'?: string;
    /**
     * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     */
    'name': string;
    /**
     * The schema for the response format, described as a JSON Schema object.
     */
    'schema'?: { [key: string]: any; };
    /**
     * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. To learn more, read the [Structured Outputs guide](/docs/guides/structured-outputs).
     */
    'strict'?: boolean | null;
}
export interface ResponseFormatText {
    /**
     * The type of response format being defined: `text`
     */
    'type': ResponseFormatTextTypeEnum;
}

export const ResponseFormatTextTypeEnum = {
    Text: 'text'
} as const;

export type ResponseFormatTextTypeEnum = typeof ResponseFormatTextTypeEnum[keyof typeof ResponseFormatTextTypeEnum];

/**
 * Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
 */
export interface RunCompletionUsage {
    /**
     * Number of completion tokens used over the course of the run.
     */
    'completion_tokens': number;
    /**
     * Number of prompt tokens used over the course of the run.
     */
    'prompt_tokens': number;
    /**
     * Total number of tokens used (prompt + completion).
     */
    'total_tokens': number;
}
/**
 * Represents an execution run on a [thread](/docs/api-reference/threads).
 */
export interface RunObject {
    /**
     * The identifier, which can be referenced in API endpoints.
     */
    'id': string;
    /**
     * The object type, which is always `thread.run`.
     */
    'object': RunObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the run was created.
     */
    'created_at': number;
    /**
     * The ID of the [thread](/docs/api-reference/threads) that was executed on as a part of this run.
     */
    'thread_id': string;
    /**
     * The ID of the [assistant](/docs/api-reference/assistants) used for execution of this run.
     */
    'assistant_id': string;
    /**
     * The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`.
     */
    'status': RunObjectStatusEnum;
    'required_action': RunObjectRequiredAction | null;
    'last_error': RunObjectLastError | null;
    /**
     * The Unix timestamp (in seconds) for when the run will expire.
     */
    'expires_at': number | null;
    /**
     * The Unix timestamp (in seconds) for when the run was started.
     */
    'started_at': number | null;
    /**
     * The Unix timestamp (in seconds) for when the run was cancelled.
     */
    'cancelled_at': number | null;
    /**
     * The Unix timestamp (in seconds) for when the run failed.
     */
    'failed_at': number | null;
    /**
     * The Unix timestamp (in seconds) for when the run was completed.
     */
    'completed_at': number | null;
    'incomplete_details': RunObjectIncompleteDetails | null;
    /**
     * The model that the [assistant](/docs/api-reference/assistants) used for this run.
     */
    'model': string;
    /**
     * The instructions that the [assistant](/docs/api-reference/assistants) used for this run.
     */
    'instructions': string;
    /**
     * The list of tools that the [assistant](/docs/api-reference/assistants) used for this run.
     */
    'tools': Array<AssistantObjectToolsInner>;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata': object | null;
    'usage': RunCompletionUsage | null;
    /**
     * The sampling temperature used for this run. If not set, defaults to 1.
     */
    'temperature'?: number | null;
    /**
     * The nucleus sampling value used for this run. If not set, defaults to 1.
     */
    'top_p'?: number | null;
    /**
     * The maximum number of prompt tokens specified to have been used over the course of the run. 
     */
    'max_prompt_tokens': number | null;
    /**
     * The maximum number of completion tokens specified to have been used over the course of the run. 
     */
    'max_completion_tokens': number | null;
    'truncation_strategy': TruncationObject;
    'tool_choice': AssistantsApiToolChoiceOption;
    /**
     * Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
     */
    'parallel_tool_calls': boolean;
    'response_format': AssistantsApiResponseFormatOption;
}

export const RunObjectObjectEnum = {
    ThreadRun: 'thread.run'
} as const;

export type RunObjectObjectEnum = typeof RunObjectObjectEnum[keyof typeof RunObjectObjectEnum];
export const RunObjectStatusEnum = {
    Queued: 'queued',
    InProgress: 'in_progress',
    RequiresAction: 'requires_action',
    Cancelling: 'cancelling',
    Cancelled: 'cancelled',
    Failed: 'failed',
    Completed: 'completed',
    Incomplete: 'incomplete',
    Expired: 'expired'
} as const;

export type RunObjectStatusEnum = typeof RunObjectStatusEnum[keyof typeof RunObjectStatusEnum];

/**
 * Details on why the run is incomplete. Will be `null` if the run is not incomplete.
 */
export interface RunObjectIncompleteDetails {
    /**
     * The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run.
     */
    'reason'?: RunObjectIncompleteDetailsReasonEnum;
}

export const RunObjectIncompleteDetailsReasonEnum = {
    MaxCompletionTokens: 'max_completion_tokens',
    MaxPromptTokens: 'max_prompt_tokens'
} as const;

export type RunObjectIncompleteDetailsReasonEnum = typeof RunObjectIncompleteDetailsReasonEnum[keyof typeof RunObjectIncompleteDetailsReasonEnum];

/**
 * The last error associated with this run. Will be `null` if there are no errors.
 */
export interface RunObjectLastError {
    /**
     * One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
     */
    'code': RunObjectLastErrorCodeEnum;
    /**
     * A human-readable description of the error.
     */
    'message': string;
}

export const RunObjectLastErrorCodeEnum = {
    ServerError: 'server_error',
    RateLimitExceeded: 'rate_limit_exceeded',
    InvalidPrompt: 'invalid_prompt'
} as const;

export type RunObjectLastErrorCodeEnum = typeof RunObjectLastErrorCodeEnum[keyof typeof RunObjectLastErrorCodeEnum];

/**
 * Details on the action required to continue the run. Will be `null` if no action is required.
 */
export interface RunObjectRequiredAction {
    /**
     * For now, this is always `submit_tool_outputs`.
     */
    'type': RunObjectRequiredActionTypeEnum;
    'submit_tool_outputs': RunObjectRequiredActionSubmitToolOutputs;
}

export const RunObjectRequiredActionTypeEnum = {
    SubmitToolOutputs: 'submit_tool_outputs'
} as const;

export type RunObjectRequiredActionTypeEnum = typeof RunObjectRequiredActionTypeEnum[keyof typeof RunObjectRequiredActionTypeEnum];

/**
 * Details on the tool outputs needed for this run to continue.
 */
export interface RunObjectRequiredActionSubmitToolOutputs {
    /**
     * A list of the relevant tool calls.
     */
    'tool_calls': Array<RunToolCallObject>;
}
/**
 * Usage statistics related to the run step. This value will be `null` while the run step\'s status is `in_progress`.
 */
export interface RunStepCompletionUsage {
    /**
     * Number of completion tokens used over the course of the run step.
     */
    'completion_tokens': number;
    /**
     * Number of prompt tokens used over the course of the run step.
     */
    'prompt_tokens': number;
    /**
     * Total number of tokens used (prompt + completion).
     */
    'total_tokens': number;
}
/**
 * Represents a run step delta i.e. any changed fields on a run step during streaming. 
 */
export interface RunStepDeltaObject {
    /**
     * The identifier of the run step, which can be referenced in API endpoints.
     */
    'id': string;
    /**
     * The object type, which is always `thread.run.step.delta`.
     */
    'object': RunStepDeltaObjectObjectEnum;
    'delta': RunStepDeltaObjectDelta;
}

export const RunStepDeltaObjectObjectEnum = {
    ThreadRunStepDelta: 'thread.run.step.delta'
} as const;

export type RunStepDeltaObjectObjectEnum = typeof RunStepDeltaObjectObjectEnum[keyof typeof RunStepDeltaObjectObjectEnum];

/**
 * The delta containing the fields that have changed on the run step.
 */
export interface RunStepDeltaObjectDelta {
    'step_details'?: RunStepDeltaObjectDeltaStepDetails;
}
/**
 * @type RunStepDeltaObjectDeltaStepDetails
 * The details of the run step.
 */
export type RunStepDeltaObjectDeltaStepDetails = RunStepDeltaStepDetailsMessageCreationObject | RunStepDeltaStepDetailsToolCallsObject;

/**
 * Details of the message creation by the run step.
 */
export interface RunStepDeltaStepDetailsMessageCreationObject {
    /**
     * Always `message_creation`.
     */
    'type': RunStepDeltaStepDetailsMessageCreationObjectTypeEnum;
    'message_creation'?: RunStepDeltaStepDetailsMessageCreationObjectMessageCreation;
}

export const RunStepDeltaStepDetailsMessageCreationObjectTypeEnum = {
    MessageCreation: 'message_creation'
} as const;

export type RunStepDeltaStepDetailsMessageCreationObjectTypeEnum = typeof RunStepDeltaStepDetailsMessageCreationObjectTypeEnum[keyof typeof RunStepDeltaStepDetailsMessageCreationObjectTypeEnum];

export interface RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
    /**
     * The ID of the message that was created by this run step.
     */
    'message_id'?: string;
}
/**
 * Details of the Code Interpreter tool call the run step was involved in.
 */
export interface RunStepDeltaStepDetailsToolCallsCodeObject {
    /**
     * The index of the tool call in the tool calls array.
     */
    'index': number;
    /**
     * The ID of the tool call.
     */
    'id'?: string;
    /**
     * The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
     */
    'type': RunStepDeltaStepDetailsToolCallsCodeObjectTypeEnum;
    'code_interpreter'?: RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter;
}

export const RunStepDeltaStepDetailsToolCallsCodeObjectTypeEnum = {
    CodeInterpreter: 'code_interpreter'
} as const;

export type RunStepDeltaStepDetailsToolCallsCodeObjectTypeEnum = typeof RunStepDeltaStepDetailsToolCallsCodeObjectTypeEnum[keyof typeof RunStepDeltaStepDetailsToolCallsCodeObjectTypeEnum];

/**
 * The Code Interpreter tool call definition.
 */
export interface RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
    /**
     * The input to the Code Interpreter tool call.
     */
    'input'?: string;
    /**
     * The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
     */
    'outputs'?: Array<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>;
}
/**
 * @type RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
 */
export type RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner = RunStepDeltaStepDetailsToolCallsCodeOutputImageObject | RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject;

export interface RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    /**
     * The index of the output in the outputs array.
     */
    'index': number;
    /**
     * Always `image`.
     */
    'type': RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectTypeEnum;
    'image'?: RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage;
}

export const RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectTypeEnum = {
    Image: 'image'
} as const;

export type RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectTypeEnum = typeof RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectTypeEnum[keyof typeof RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectTypeEnum];

export interface RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
    /**
     * The [file](/docs/api-reference/files) ID of the image.
     */
    'file_id'?: string;
}
/**
 * Text output from the Code Interpreter tool call as part of a run step.
 */
export interface RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    /**
     * The index of the output in the outputs array.
     */
    'index': number;
    /**
     * Always `logs`.
     */
    'type': RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectTypeEnum;
    /**
     * The text output from the Code Interpreter tool call.
     */
    'logs'?: string;
}

export const RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectTypeEnum = {
    Logs: 'logs'
} as const;

export type RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectTypeEnum = typeof RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectTypeEnum[keyof typeof RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectTypeEnum];

export interface RunStepDeltaStepDetailsToolCallsFileSearchObject {
    /**
     * The index of the tool call in the tool calls array.
     */
    'index': number;
    /**
     * The ID of the tool call object.
     */
    'id'?: string;
    /**
     * The type of tool call. This is always going to be `file_search` for this type of tool call.
     */
    'type': RunStepDeltaStepDetailsToolCallsFileSearchObjectTypeEnum;
    /**
     * For now, this is always going to be an empty object.
     */
    'file_search': object;
}

export const RunStepDeltaStepDetailsToolCallsFileSearchObjectTypeEnum = {
    FileSearch: 'file_search'
} as const;

export type RunStepDeltaStepDetailsToolCallsFileSearchObjectTypeEnum = typeof RunStepDeltaStepDetailsToolCallsFileSearchObjectTypeEnum[keyof typeof RunStepDeltaStepDetailsToolCallsFileSearchObjectTypeEnum];

export interface RunStepDeltaStepDetailsToolCallsFunctionObject {
    /**
     * The index of the tool call in the tool calls array.
     */
    'index': number;
    /**
     * The ID of the tool call object.
     */
    'id'?: string;
    /**
     * The type of tool call. This is always going to be `function` for this type of tool call.
     */
    'type': RunStepDeltaStepDetailsToolCallsFunctionObjectTypeEnum;
    'function'?: RunStepDeltaStepDetailsToolCallsFunctionObjectFunction;
}

export const RunStepDeltaStepDetailsToolCallsFunctionObjectTypeEnum = {
    Function: 'function'
} as const;

export type RunStepDeltaStepDetailsToolCallsFunctionObjectTypeEnum = typeof RunStepDeltaStepDetailsToolCallsFunctionObjectTypeEnum[keyof typeof RunStepDeltaStepDetailsToolCallsFunctionObjectTypeEnum];

/**
 * The definition of the function that was called.
 */
export interface RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
    /**
     * The name of the function.
     */
    'name'?: string;
    /**
     * The arguments passed to the function.
     */
    'arguments'?: string;
    /**
     * The output of the function. This will be `null` if the outputs have not been [submitted](/docs/api-reference/runs/submitToolOutputs) yet.
     */
    'output'?: string | null;
}
/**
 * Details of the tool call.
 */
export interface RunStepDeltaStepDetailsToolCallsObject {
    /**
     * Always `tool_calls`.
     */
    'type': RunStepDeltaStepDetailsToolCallsObjectTypeEnum;
    /**
     * An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`. 
     */
    'tool_calls'?: Array<RunStepDeltaStepDetailsToolCallsObjectToolCallsInner>;
}

export const RunStepDeltaStepDetailsToolCallsObjectTypeEnum = {
    ToolCalls: 'tool_calls'
} as const;

export type RunStepDeltaStepDetailsToolCallsObjectTypeEnum = typeof RunStepDeltaStepDetailsToolCallsObjectTypeEnum[keyof typeof RunStepDeltaStepDetailsToolCallsObjectTypeEnum];

/**
 * @type RunStepDeltaStepDetailsToolCallsObjectToolCallsInner
 */
export type RunStepDeltaStepDetailsToolCallsObjectToolCallsInner = RunStepDeltaStepDetailsToolCallsCodeObject | RunStepDeltaStepDetailsToolCallsFileSearchObject | RunStepDeltaStepDetailsToolCallsFunctionObject;

/**
 * Details of the message creation by the run step.
 */
export interface RunStepDetailsMessageCreationObject {
    /**
     * Always `message_creation`.
     */
    'type': RunStepDetailsMessageCreationObjectTypeEnum;
    'message_creation': RunStepDetailsMessageCreationObjectMessageCreation;
}

export const RunStepDetailsMessageCreationObjectTypeEnum = {
    MessageCreation: 'message_creation'
} as const;

export type RunStepDetailsMessageCreationObjectTypeEnum = typeof RunStepDetailsMessageCreationObjectTypeEnum[keyof typeof RunStepDetailsMessageCreationObjectTypeEnum];

export interface RunStepDetailsMessageCreationObjectMessageCreation {
    /**
     * The ID of the message that was created by this run step.
     */
    'message_id': string;
}
/**
 * Details of the Code Interpreter tool call the run step was involved in.
 */
export interface RunStepDetailsToolCallsCodeObject {
    /**
     * The ID of the tool call.
     */
    'id': string;
    /**
     * The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
     */
    'type': RunStepDetailsToolCallsCodeObjectTypeEnum;
    'code_interpreter': RunStepDetailsToolCallsCodeObjectCodeInterpreter;
}

export const RunStepDetailsToolCallsCodeObjectTypeEnum = {
    CodeInterpreter: 'code_interpreter'
} as const;

export type RunStepDetailsToolCallsCodeObjectTypeEnum = typeof RunStepDetailsToolCallsCodeObjectTypeEnum[keyof typeof RunStepDetailsToolCallsCodeObjectTypeEnum];

/**
 * The Code Interpreter tool call definition.
 */
export interface RunStepDetailsToolCallsCodeObjectCodeInterpreter {
    /**
     * The input to the Code Interpreter tool call.
     */
    'input': string;
    /**
     * The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
     */
    'outputs': Array<RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner>;
}
/**
 * @type RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
 */
export type RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner = RunStepDetailsToolCallsCodeOutputImageObject | RunStepDetailsToolCallsCodeOutputLogsObject;

export interface RunStepDetailsToolCallsCodeOutputImageObject {
    /**
     * Always `image`.
     */
    'type': RunStepDetailsToolCallsCodeOutputImageObjectTypeEnum;
    'image': RunStepDetailsToolCallsCodeOutputImageObjectImage;
}

export const RunStepDetailsToolCallsCodeOutputImageObjectTypeEnum = {
    Image: 'image'
} as const;

export type RunStepDetailsToolCallsCodeOutputImageObjectTypeEnum = typeof RunStepDetailsToolCallsCodeOutputImageObjectTypeEnum[keyof typeof RunStepDetailsToolCallsCodeOutputImageObjectTypeEnum];

export interface RunStepDetailsToolCallsCodeOutputImageObjectImage {
    /**
     * The [file](/docs/api-reference/files) ID of the image.
     */
    'file_id': string;
}
/**
 * Text output from the Code Interpreter tool call as part of a run step.
 */
export interface RunStepDetailsToolCallsCodeOutputLogsObject {
    /**
     * Always `logs`.
     */
    'type': RunStepDetailsToolCallsCodeOutputLogsObjectTypeEnum;
    /**
     * The text output from the Code Interpreter tool call.
     */
    'logs': string;
}

export const RunStepDetailsToolCallsCodeOutputLogsObjectTypeEnum = {
    Logs: 'logs'
} as const;

export type RunStepDetailsToolCallsCodeOutputLogsObjectTypeEnum = typeof RunStepDetailsToolCallsCodeOutputLogsObjectTypeEnum[keyof typeof RunStepDetailsToolCallsCodeOutputLogsObjectTypeEnum];

export interface RunStepDetailsToolCallsFileSearchObject {
    /**
     * The ID of the tool call object.
     */
    'id': string;
    /**
     * The type of tool call. This is always going to be `file_search` for this type of tool call.
     */
    'type': RunStepDetailsToolCallsFileSearchObjectTypeEnum;
    'file_search': RunStepDetailsToolCallsFileSearchObjectFileSearch;
}

export const RunStepDetailsToolCallsFileSearchObjectTypeEnum = {
    FileSearch: 'file_search'
} as const;

export type RunStepDetailsToolCallsFileSearchObjectTypeEnum = typeof RunStepDetailsToolCallsFileSearchObjectTypeEnum[keyof typeof RunStepDetailsToolCallsFileSearchObjectTypeEnum];

/**
 * For now, this is always going to be an empty object.
 */
export interface RunStepDetailsToolCallsFileSearchObjectFileSearch {
    'ranking_options'?: RunStepDetailsToolCallsFileSearchRankingOptionsObject;
    /**
     * The results of the file search.
     */
    'results'?: Array<RunStepDetailsToolCallsFileSearchResultObject>;
}
/**
 * The ranking options for the file search.
 */
export interface RunStepDetailsToolCallsFileSearchRankingOptionsObject {
    /**
     * The ranker used for the file search.
     */
    'ranker': RunStepDetailsToolCallsFileSearchRankingOptionsObjectRankerEnum;
    /**
     * The score threshold for the file search. All values must be a floating point number between 0 and 1.
     */
    'score_threshold': number;
}

export const RunStepDetailsToolCallsFileSearchRankingOptionsObjectRankerEnum = {
    Default20240821: 'default_2024_08_21'
} as const;

export type RunStepDetailsToolCallsFileSearchRankingOptionsObjectRankerEnum = typeof RunStepDetailsToolCallsFileSearchRankingOptionsObjectRankerEnum[keyof typeof RunStepDetailsToolCallsFileSearchRankingOptionsObjectRankerEnum];

/**
 * A result instance of the file search.
 */
export interface RunStepDetailsToolCallsFileSearchResultObject {
    /**
     * The ID of the file that result was found in.
     */
    'file_id': string;
    /**
     * The name of the file that result was found in.
     */
    'file_name': string;
    /**
     * The score of the result. All values must be a floating point number between 0 and 1.
     */
    'score': number;
    /**
     * The content of the result that was found. The content is only included if requested via the include query parameter.
     */
    'content'?: Array<RunStepDetailsToolCallsFileSearchResultObjectContentInner>;
}
export interface RunStepDetailsToolCallsFileSearchResultObjectContentInner {
    /**
     * The type of the content.
     */
    'type'?: RunStepDetailsToolCallsFileSearchResultObjectContentInnerTypeEnum;
    /**
     * The text content of the file.
     */
    'text'?: string;
}

export const RunStepDetailsToolCallsFileSearchResultObjectContentInnerTypeEnum = {
    Text: 'text'
} as const;

export type RunStepDetailsToolCallsFileSearchResultObjectContentInnerTypeEnum = typeof RunStepDetailsToolCallsFileSearchResultObjectContentInnerTypeEnum[keyof typeof RunStepDetailsToolCallsFileSearchResultObjectContentInnerTypeEnum];

export interface RunStepDetailsToolCallsFunctionObject {
    /**
     * The ID of the tool call object.
     */
    'id': string;
    /**
     * The type of tool call. This is always going to be `function` for this type of tool call.
     */
    'type': RunStepDetailsToolCallsFunctionObjectTypeEnum;
    'function': RunStepDetailsToolCallsFunctionObjectFunction;
}

export const RunStepDetailsToolCallsFunctionObjectTypeEnum = {
    Function: 'function'
} as const;

export type RunStepDetailsToolCallsFunctionObjectTypeEnum = typeof RunStepDetailsToolCallsFunctionObjectTypeEnum[keyof typeof RunStepDetailsToolCallsFunctionObjectTypeEnum];

/**
 * The definition of the function that was called.
 */
export interface RunStepDetailsToolCallsFunctionObjectFunction {
    /**
     * The name of the function.
     */
    'name': string;
    /**
     * The arguments passed to the function.
     */
    'arguments': string;
    /**
     * The output of the function. This will be `null` if the outputs have not been [submitted](/docs/api-reference/runs/submitToolOutputs) yet.
     */
    'output': string | null;
}
/**
 * Details of the tool call.
 */
export interface RunStepDetailsToolCallsObject {
    /**
     * Always `tool_calls`.
     */
    'type': RunStepDetailsToolCallsObjectTypeEnum;
    /**
     * An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`. 
     */
    'tool_calls': Array<RunStepDetailsToolCallsObjectToolCallsInner>;
}

export const RunStepDetailsToolCallsObjectTypeEnum = {
    ToolCalls: 'tool_calls'
} as const;

export type RunStepDetailsToolCallsObjectTypeEnum = typeof RunStepDetailsToolCallsObjectTypeEnum[keyof typeof RunStepDetailsToolCallsObjectTypeEnum];

/**
 * @type RunStepDetailsToolCallsObjectToolCallsInner
 */
export type RunStepDetailsToolCallsObjectToolCallsInner = RunStepDetailsToolCallsCodeObject | RunStepDetailsToolCallsFileSearchObject | RunStepDetailsToolCallsFunctionObject;

/**
 * Represents a step in execution of a run. 
 */
export interface RunStepObject {
    /**
     * The identifier of the run step, which can be referenced in API endpoints.
     */
    'id': string;
    /**
     * The object type, which is always `thread.run.step`.
     */
    'object': RunStepObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the run step was created.
     */
    'created_at': number;
    /**
     * The ID of the [assistant](/docs/api-reference/assistants) associated with the run step.
     */
    'assistant_id': string;
    /**
     * The ID of the [thread](/docs/api-reference/threads) that was run.
     */
    'thread_id': string;
    /**
     * The ID of the [run](/docs/api-reference/runs) that this run step is a part of.
     */
    'run_id': string;
    /**
     * The type of run step, which can be either `message_creation` or `tool_calls`.
     */
    'type': RunStepObjectTypeEnum;
    /**
     * The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
     */
    'status': RunStepObjectStatusEnum;
    'step_details': RunStepObjectStepDetails;
    'last_error': RunStepObjectLastError | null;
    /**
     * The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
     */
    'expired_at': number | null;
    /**
     * The Unix timestamp (in seconds) for when the run step was cancelled.
     */
    'cancelled_at': number | null;
    /**
     * The Unix timestamp (in seconds) for when the run step failed.
     */
    'failed_at': number | null;
    /**
     * The Unix timestamp (in seconds) for when the run step completed.
     */
    'completed_at': number | null;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata': object | null;
    'usage': RunStepCompletionUsage | null;
}

export const RunStepObjectObjectEnum = {
    ThreadRunStep: 'thread.run.step'
} as const;

export type RunStepObjectObjectEnum = typeof RunStepObjectObjectEnum[keyof typeof RunStepObjectObjectEnum];
export const RunStepObjectTypeEnum = {
    MessageCreation: 'message_creation',
    ToolCalls: 'tool_calls'
} as const;

export type RunStepObjectTypeEnum = typeof RunStepObjectTypeEnum[keyof typeof RunStepObjectTypeEnum];
export const RunStepObjectStatusEnum = {
    InProgress: 'in_progress',
    Cancelled: 'cancelled',
    Failed: 'failed',
    Completed: 'completed',
    Expired: 'expired'
} as const;

export type RunStepObjectStatusEnum = typeof RunStepObjectStatusEnum[keyof typeof RunStepObjectStatusEnum];

/**
 * The last error associated with this run step. Will be `null` if there are no errors.
 */
export interface RunStepObjectLastError {
    /**
     * One of `server_error` or `rate_limit_exceeded`.
     */
    'code': RunStepObjectLastErrorCodeEnum;
    /**
     * A human-readable description of the error.
     */
    'message': string;
}

export const RunStepObjectLastErrorCodeEnum = {
    ServerError: 'server_error',
    RateLimitExceeded: 'rate_limit_exceeded'
} as const;

export type RunStepObjectLastErrorCodeEnum = typeof RunStepObjectLastErrorCodeEnum[keyof typeof RunStepObjectLastErrorCodeEnum];

/**
 * @type RunStepObjectStepDetails
 * The details of the run step.
 */
export type RunStepObjectStepDetails = RunStepDetailsMessageCreationObject | RunStepDetailsToolCallsObject;

/**
 * @type RunStepStreamEvent
 */
export type RunStepStreamEvent = RunStepStreamEventOneOf | RunStepStreamEventOneOf1 | RunStepStreamEventOneOf2 | RunStepStreamEventOneOf3 | RunStepStreamEventOneOf4 | RunStepStreamEventOneOf5 | RunStepStreamEventOneOf6;

/**
 * Occurs when a [run step](/docs/api-reference/run-steps/step-object) is created.
 */
export interface RunStepStreamEventOneOf {
    'event': RunStepStreamEventOneOfEventEnum;
    'data': RunStepObject;
}

export const RunStepStreamEventOneOfEventEnum = {
    ThreadRunStepCreated: 'thread.run.step.created'
} as const;

export type RunStepStreamEventOneOfEventEnum = typeof RunStepStreamEventOneOfEventEnum[keyof typeof RunStepStreamEventOneOfEventEnum];

/**
 * Occurs when a [run step](/docs/api-reference/run-steps/step-object) moves to an `in_progress` state.
 */
export interface RunStepStreamEventOneOf1 {
    'event': RunStepStreamEventOneOf1EventEnum;
    'data': RunStepObject;
}

export const RunStepStreamEventOneOf1EventEnum = {
    ThreadRunStepInProgress: 'thread.run.step.in_progress'
} as const;

export type RunStepStreamEventOneOf1EventEnum = typeof RunStepStreamEventOneOf1EventEnum[keyof typeof RunStepStreamEventOneOf1EventEnum];

/**
 * Occurs when parts of a [run step](/docs/api-reference/run-steps/step-object) are being streamed.
 */
export interface RunStepStreamEventOneOf2 {
    'event': RunStepStreamEventOneOf2EventEnum;
    'data': RunStepDeltaObject;
}

export const RunStepStreamEventOneOf2EventEnum = {
    ThreadRunStepDelta: 'thread.run.step.delta'
} as const;

export type RunStepStreamEventOneOf2EventEnum = typeof RunStepStreamEventOneOf2EventEnum[keyof typeof RunStepStreamEventOneOf2EventEnum];

/**
 * Occurs when a [run step](/docs/api-reference/run-steps/step-object) is completed.
 */
export interface RunStepStreamEventOneOf3 {
    'event': RunStepStreamEventOneOf3EventEnum;
    'data': RunStepObject;
}

export const RunStepStreamEventOneOf3EventEnum = {
    ThreadRunStepCompleted: 'thread.run.step.completed'
} as const;

export type RunStepStreamEventOneOf3EventEnum = typeof RunStepStreamEventOneOf3EventEnum[keyof typeof RunStepStreamEventOneOf3EventEnum];

/**
 * Occurs when a [run step](/docs/api-reference/run-steps/step-object) fails.
 */
export interface RunStepStreamEventOneOf4 {
    'event': RunStepStreamEventOneOf4EventEnum;
    'data': RunStepObject;
}

export const RunStepStreamEventOneOf4EventEnum = {
    ThreadRunStepFailed: 'thread.run.step.failed'
} as const;

export type RunStepStreamEventOneOf4EventEnum = typeof RunStepStreamEventOneOf4EventEnum[keyof typeof RunStepStreamEventOneOf4EventEnum];

/**
 * Occurs when a [run step](/docs/api-reference/run-steps/step-object) is cancelled.
 */
export interface RunStepStreamEventOneOf5 {
    'event': RunStepStreamEventOneOf5EventEnum;
    'data': RunStepObject;
}

export const RunStepStreamEventOneOf5EventEnum = {
    ThreadRunStepCancelled: 'thread.run.step.cancelled'
} as const;

export type RunStepStreamEventOneOf5EventEnum = typeof RunStepStreamEventOneOf5EventEnum[keyof typeof RunStepStreamEventOneOf5EventEnum];

/**
 * Occurs when a [run step](/docs/api-reference/run-steps/step-object) expires.
 */
export interface RunStepStreamEventOneOf6 {
    'event': RunStepStreamEventOneOf6EventEnum;
    'data': RunStepObject;
}

export const RunStepStreamEventOneOf6EventEnum = {
    ThreadRunStepExpired: 'thread.run.step.expired'
} as const;

export type RunStepStreamEventOneOf6EventEnum = typeof RunStepStreamEventOneOf6EventEnum[keyof typeof RunStepStreamEventOneOf6EventEnum];

/**
 * @type RunStreamEvent
 */
export type RunStreamEvent = RunStreamEventOneOf | RunStreamEventOneOf1 | RunStreamEventOneOf2 | RunStreamEventOneOf3 | RunStreamEventOneOf4 | RunStreamEventOneOf5 | RunStreamEventOneOf6 | RunStreamEventOneOf7 | RunStreamEventOneOf8 | RunStreamEventOneOf9;

/**
 * Occurs when a new [run](/docs/api-reference/runs/object) is created.
 */
export interface RunStreamEventOneOf {
    'event': RunStreamEventOneOfEventEnum;
    'data': RunObject;
}

export const RunStreamEventOneOfEventEnum = {
    ThreadRunCreated: 'thread.run.created'
} as const;

export type RunStreamEventOneOfEventEnum = typeof RunStreamEventOneOfEventEnum[keyof typeof RunStreamEventOneOfEventEnum];

/**
 * Occurs when a [run](/docs/api-reference/runs/object) moves to a `queued` status.
 */
export interface RunStreamEventOneOf1 {
    'event': RunStreamEventOneOf1EventEnum;
    'data': RunObject;
}

export const RunStreamEventOneOf1EventEnum = {
    ThreadRunQueued: 'thread.run.queued'
} as const;

export type RunStreamEventOneOf1EventEnum = typeof RunStreamEventOneOf1EventEnum[keyof typeof RunStreamEventOneOf1EventEnum];

/**
 * Occurs when a [run](/docs/api-reference/runs/object) moves to an `in_progress` status.
 */
export interface RunStreamEventOneOf2 {
    'event': RunStreamEventOneOf2EventEnum;
    'data': RunObject;
}

export const RunStreamEventOneOf2EventEnum = {
    ThreadRunInProgress: 'thread.run.in_progress'
} as const;

export type RunStreamEventOneOf2EventEnum = typeof RunStreamEventOneOf2EventEnum[keyof typeof RunStreamEventOneOf2EventEnum];

/**
 * Occurs when a [run](/docs/api-reference/runs/object) moves to a `requires_action` status.
 */
export interface RunStreamEventOneOf3 {
    'event': RunStreamEventOneOf3EventEnum;
    'data': RunObject;
}

export const RunStreamEventOneOf3EventEnum = {
    ThreadRunRequiresAction: 'thread.run.requires_action'
} as const;

export type RunStreamEventOneOf3EventEnum = typeof RunStreamEventOneOf3EventEnum[keyof typeof RunStreamEventOneOf3EventEnum];

/**
 * Occurs when a [run](/docs/api-reference/runs/object) is completed.
 */
export interface RunStreamEventOneOf4 {
    'event': RunStreamEventOneOf4EventEnum;
    'data': RunObject;
}

export const RunStreamEventOneOf4EventEnum = {
    ThreadRunCompleted: 'thread.run.completed'
} as const;

export type RunStreamEventOneOf4EventEnum = typeof RunStreamEventOneOf4EventEnum[keyof typeof RunStreamEventOneOf4EventEnum];

/**
 * Occurs when a [run](/docs/api-reference/runs/object) ends with status `incomplete`.
 */
export interface RunStreamEventOneOf5 {
    'event': RunStreamEventOneOf5EventEnum;
    'data': RunObject;
}

export const RunStreamEventOneOf5EventEnum = {
    ThreadRunIncomplete: 'thread.run.incomplete'
} as const;

export type RunStreamEventOneOf5EventEnum = typeof RunStreamEventOneOf5EventEnum[keyof typeof RunStreamEventOneOf5EventEnum];

/**
 * Occurs when a [run](/docs/api-reference/runs/object) fails.
 */
export interface RunStreamEventOneOf6 {
    'event': RunStreamEventOneOf6EventEnum;
    'data': RunObject;
}

export const RunStreamEventOneOf6EventEnum = {
    ThreadRunFailed: 'thread.run.failed'
} as const;

export type RunStreamEventOneOf6EventEnum = typeof RunStreamEventOneOf6EventEnum[keyof typeof RunStreamEventOneOf6EventEnum];

/**
 * Occurs when a [run](/docs/api-reference/runs/object) moves to a `cancelling` status.
 */
export interface RunStreamEventOneOf7 {
    'event': RunStreamEventOneOf7EventEnum;
    'data': RunObject;
}

export const RunStreamEventOneOf7EventEnum = {
    ThreadRunCancelling: 'thread.run.cancelling'
} as const;

export type RunStreamEventOneOf7EventEnum = typeof RunStreamEventOneOf7EventEnum[keyof typeof RunStreamEventOneOf7EventEnum];

/**
 * Occurs when a [run](/docs/api-reference/runs/object) is cancelled.
 */
export interface RunStreamEventOneOf8 {
    'event': RunStreamEventOneOf8EventEnum;
    'data': RunObject;
}

export const RunStreamEventOneOf8EventEnum = {
    ThreadRunCancelled: 'thread.run.cancelled'
} as const;

export type RunStreamEventOneOf8EventEnum = typeof RunStreamEventOneOf8EventEnum[keyof typeof RunStreamEventOneOf8EventEnum];

/**
 * Occurs when a [run](/docs/api-reference/runs/object) expires.
 */
export interface RunStreamEventOneOf9 {
    'event': RunStreamEventOneOf9EventEnum;
    'data': RunObject;
}

export const RunStreamEventOneOf9EventEnum = {
    ThreadRunExpired: 'thread.run.expired'
} as const;

export type RunStreamEventOneOf9EventEnum = typeof RunStreamEventOneOf9EventEnum[keyof typeof RunStreamEventOneOf9EventEnum];

/**
 * Tool call objects
 */
export interface RunToolCallObject {
    /**
     * The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](/docs/api-reference/runs/submitToolOutputs) endpoint.
     */
    'id': string;
    /**
     * The type of tool call the output is required for. For now, this is always `function`.
     */
    'type': RunToolCallObjectTypeEnum;
    'function': RunToolCallObjectFunction;
}

export const RunToolCallObjectTypeEnum = {
    Function: 'function'
} as const;

export type RunToolCallObjectTypeEnum = typeof RunToolCallObjectTypeEnum[keyof typeof RunToolCallObjectTypeEnum];

/**
 * The function definition.
 */
export interface RunToolCallObjectFunction {
    /**
     * The name of the function.
     */
    'name': string;
    /**
     * The arguments that the model expects you to pass to the function.
     */
    'arguments': string;
}
export interface StaticChunkingStrategy {
    /**
     * Always `static`.
     */
    'type': StaticChunkingStrategyTypeEnum;
    'static': StaticChunkingStrategyStatic;
}

export const StaticChunkingStrategyTypeEnum = {
    Static: 'static'
} as const;

export type StaticChunkingStrategyTypeEnum = typeof StaticChunkingStrategyTypeEnum[keyof typeof StaticChunkingStrategyTypeEnum];

export interface StaticChunkingStrategyRequestParam {
    /**
     * Always `static`.
     */
    'type': StaticChunkingStrategyRequestParamTypeEnum;
    'static': StaticChunkingStrategy;
}

export const StaticChunkingStrategyRequestParamTypeEnum = {
    Static: 'static'
} as const;

export type StaticChunkingStrategyRequestParamTypeEnum = typeof StaticChunkingStrategyRequestParamTypeEnum[keyof typeof StaticChunkingStrategyRequestParamTypeEnum];

export interface StaticChunkingStrategyResponseParam {
    /**
     * Always `static`.
     */
    'type': StaticChunkingStrategyResponseParamTypeEnum;
    'static': StaticChunkingStrategy;
}

export const StaticChunkingStrategyResponseParamTypeEnum = {
    Static: 'static'
} as const;

export type StaticChunkingStrategyResponseParamTypeEnum = typeof StaticChunkingStrategyResponseParamTypeEnum[keyof typeof StaticChunkingStrategyResponseParamTypeEnum];

export interface StaticChunkingStrategyStatic {
    /**
     * The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`.
     */
    'max_chunk_size_tokens': number;
    /**
     * The number of tokens that overlap between chunks. The default value is `400`.  Note that the overlap must not exceed half of `max_chunk_size_tokens`. 
     */
    'chunk_overlap_tokens': number;
}
export interface SubmitToolOutputsRunRequest {
    /**
     * A list of tools for which the outputs are being submitted.
     */
    'tool_outputs': Array<SubmitToolOutputsRunRequestToolOutputsInner>;
    /**
     * If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message. 
     */
    'stream'?: boolean | null;
}
export interface SubmitToolOutputsRunRequestToolOutputsInner {
    /**
     * The ID of the tool call in the `required_action` object within the run object the output is being submitted for.
     */
    'tool_call_id'?: string;
    /**
     * The output of the tool call to be submitted to continue the run.
     */
    'output'?: string;
}
/**
 * Represents a thread that contains [messages](/docs/api-reference/messages).
 */
export interface ThreadObject {
    /**
     * The identifier, which can be referenced in API endpoints.
     */
    'id': string;
    /**
     * The object type, which is always `thread`.
     */
    'object': ThreadObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the thread was created.
     */
    'created_at': number;
    'tool_resources': ModifyThreadRequestToolResources | null;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata': object | null;
}

export const ThreadObjectObjectEnum = {
    Thread: 'thread'
} as const;

export type ThreadObjectObjectEnum = typeof ThreadObjectObjectEnum[keyof typeof ThreadObjectObjectEnum];

/**
 * Occurs when a new [thread](/docs/api-reference/threads/object) is created.
 */
export interface ThreadStreamEvent {
    /**
     * Whether to enable input audio transcription.
     */
    'enabled'?: boolean;
    'event': ThreadStreamEventEventEnum;
    'data': ThreadObject;
}

export const ThreadStreamEventEventEnum = {
    ThreadCreated: 'thread.created'
} as const;

export type ThreadStreamEventEventEnum = typeof ThreadStreamEventEventEnum[keyof typeof ThreadStreamEventEventEnum];

export interface TranscriptionSegment {
    /**
     * Unique identifier of the segment.
     */
    'id': number;
    /**
     * Seek offset of the segment.
     */
    'seek': number;
    /**
     * Start time of the segment in seconds.
     */
    'start': number;
    /**
     * End time of the segment in seconds.
     */
    'end': number;
    /**
     * Text content of the segment.
     */
    'text': string;
    /**
     * Array of token IDs for the text content.
     */
    'tokens': Array<number>;
    /**
     * Temperature parameter used for generating the segment.
     */
    'temperature': number;
    /**
     * Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.
     */
    'avg_logprob': number;
    /**
     * Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.
     */
    'compression_ratio': number;
    /**
     * Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent.
     */
    'no_speech_prob': number;
}
export interface TranscriptionWord {
    /**
     * The text content of the word.
     */
    'word': string;
    /**
     * Start time of the word in seconds.
     */
    'start': number;
    /**
     * End time of the word in seconds.
     */
    'end': number;
}
/**
 * Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run.
 */
export interface TruncationObject {
    /**
     * The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`.
     */
    'type': TruncationObjectTypeEnum;
    /**
     * The number of most recent messages from the thread when constructing the context for the run.
     */
    'last_messages'?: number | null;
}

export const TruncationObjectTypeEnum = {
    Auto: 'auto',
    LastMessages: 'last_messages'
} as const;

export type TruncationObjectTypeEnum = typeof TruncationObjectTypeEnum[keyof typeof TruncationObjectTypeEnum];

export interface UpdateVectorStoreRequest {
    /**
     * The name of the vector store.
     */
    'name'?: string | null;
    'expires_after'?: VectorStoreExpirationAfter;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata'?: object | null;
}
/**
 * The Upload object can accept byte chunks in the form of Parts. 
 */
export interface Upload {
    /**
     * The Upload unique identifier, which can be referenced in API endpoints.
     */
    'id': string;
    /**
     * The Unix timestamp (in seconds) for when the Upload was created.
     */
    'created_at': number;
    /**
     * The name of the file to be uploaded.
     */
    'filename': string;
    /**
     * The intended number of bytes to be uploaded.
     */
    'bytes': number;
    /**
     * The intended purpose of the file. [Please refer here](/docs/api-reference/files/object#files/object-purpose) for acceptable values.
     */
    'purpose': string;
    /**
     * The status of the Upload.
     */
    'status': UploadStatusEnum;
    /**
     * The Unix timestamp (in seconds) for when the Upload was created.
     */
    'expires_at': number;
    /**
     * The object type, which is always \"upload\".
     */
    'object'?: UploadObjectEnum;
    'file'?: OpenAIFile;
}

export const UploadStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Cancelled: 'cancelled',
    Expired: 'expired'
} as const;

export type UploadStatusEnum = typeof UploadStatusEnum[keyof typeof UploadStatusEnum];
export const UploadObjectEnum = {
    Upload: 'upload'
} as const;

export type UploadObjectEnum = typeof UploadObjectEnum[keyof typeof UploadObjectEnum];

/**
 * The upload Part represents a chunk of bytes we can add to an Upload object. 
 */
export interface UploadPart {
    /**
     * The upload Part unique identifier, which can be referenced in API endpoints.
     */
    'id': string;
    /**
     * The Unix timestamp (in seconds) for when the Part was created.
     */
    'created_at': number;
    /**
     * The ID of the Upload object that this Part was added to.
     */
    'upload_id': string;
    /**
     * The object type, which is always `upload.part`.
     */
    'object': UploadPartObjectEnum;
}

export const UploadPartObjectEnum = {
    UploadPart: 'upload.part'
} as const;

export type UploadPartObjectEnum = typeof UploadPartObjectEnum[keyof typeof UploadPartObjectEnum];

/**
 * The aggregated audio speeches usage details of the specific time bucket.
 */
export interface UsageAudioSpeechesResult {
    'object': UsageAudioSpeechesResultObjectEnum;
    /**
     * The number of characters processed.
     */
    'characters': number;
    /**
     * The count of requests made to the model.
     */
    'num_model_requests': number;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     */
    'project_id'?: string | null;
    /**
     * When `group_by=user_id`, this field provides the user ID of the grouped usage result.
     */
    'user_id'?: string | null;
    /**
     * When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
     */
    'api_key_id'?: string | null;
    /**
     * When `group_by=model`, this field provides the model name of the grouped usage result.
     */
    'model'?: string | null;
}

export const UsageAudioSpeechesResultObjectEnum = {
    OrganizationUsageAudioSpeechesResult: 'organization.usage.audio_speeches.result'
} as const;

export type UsageAudioSpeechesResultObjectEnum = typeof UsageAudioSpeechesResultObjectEnum[keyof typeof UsageAudioSpeechesResultObjectEnum];

/**
 * The aggregated audio transcriptions usage details of the specific time bucket.
 */
export interface UsageAudioTranscriptionsResult {
    'object': UsageAudioTranscriptionsResultObjectEnum;
    /**
     * The number of seconds processed.
     */
    'seconds': number;
    /**
     * The count of requests made to the model.
     */
    'num_model_requests': number;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     */
    'project_id'?: string | null;
    /**
     * When `group_by=user_id`, this field provides the user ID of the grouped usage result.
     */
    'user_id'?: string | null;
    /**
     * When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
     */
    'api_key_id'?: string | null;
    /**
     * When `group_by=model`, this field provides the model name of the grouped usage result.
     */
    'model'?: string | null;
}

export const UsageAudioTranscriptionsResultObjectEnum = {
    OrganizationUsageAudioTranscriptionsResult: 'organization.usage.audio_transcriptions.result'
} as const;

export type UsageAudioTranscriptionsResultObjectEnum = typeof UsageAudioTranscriptionsResultObjectEnum[keyof typeof UsageAudioTranscriptionsResultObjectEnum];

/**
 * The aggregated code interpreter sessions usage details of the specific time bucket.
 */
export interface UsageCodeInterpreterSessionsResult {
    'object': UsageCodeInterpreterSessionsResultObjectEnum;
    /**
     * The number of code interpreter sessions.
     */
    'sessions': number;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     */
    'project_id'?: string | null;
}

export const UsageCodeInterpreterSessionsResultObjectEnum = {
    OrganizationUsageCodeInterpreterSessionsResult: 'organization.usage.code_interpreter_sessions.result'
} as const;

export type UsageCodeInterpreterSessionsResultObjectEnum = typeof UsageCodeInterpreterSessionsResultObjectEnum[keyof typeof UsageCodeInterpreterSessionsResultObjectEnum];

/**
 * The aggregated completions usage details of the specific time bucket.
 */
export interface UsageCompletionsResult {
    'object': UsageCompletionsResultObjectEnum;
    /**
     * The aggregated number of text input tokens used, including cached tokens. For customers subscribe to scale tier, this includes scale tier tokens.
     */
    'input_tokens': number;
    /**
     * The aggregated number of text input tokens that has been cached from previous requests. For customers subscribe to scale tier, this includes scale tier tokens.
     */
    'input_cached_tokens'?: number;
    /**
     * The aggregated number of text output tokens used. For customers subscribe to scale tier, this includes scale tier tokens.
     */
    'output_tokens': number;
    /**
     * The aggregated number of audio input tokens used, including cached tokens.
     */
    'input_audio_tokens'?: number;
    /**
     * The aggregated number of audio output tokens used.
     */
    'output_audio_tokens'?: number;
    /**
     * The count of requests made to the model.
     */
    'num_model_requests': number;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     */
    'project_id'?: string | null;
    /**
     * When `group_by=user_id`, this field provides the user ID of the grouped usage result.
     */
    'user_id'?: string | null;
    /**
     * When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
     */
    'api_key_id'?: string | null;
    /**
     * When `group_by=model`, this field provides the model name of the grouped usage result.
     */
    'model'?: string | null;
    /**
     * When `group_by=batch`, this field tells whether the grouped usage result is batch or not.
     */
    'batch'?: boolean | null;
}

export const UsageCompletionsResultObjectEnum = {
    OrganizationUsageCompletionsResult: 'organization.usage.completions.result'
} as const;

export type UsageCompletionsResultObjectEnum = typeof UsageCompletionsResultObjectEnum[keyof typeof UsageCompletionsResultObjectEnum];

/**
 * The aggregated embeddings usage details of the specific time bucket.
 */
export interface UsageEmbeddingsResult {
    'object': UsageEmbeddingsResultObjectEnum;
    /**
     * The aggregated number of input tokens used.
     */
    'input_tokens': number;
    /**
     * The count of requests made to the model.
     */
    'num_model_requests': number;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     */
    'project_id'?: string | null;
    /**
     * When `group_by=user_id`, this field provides the user ID of the grouped usage result.
     */
    'user_id'?: string | null;
    /**
     * When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
     */
    'api_key_id'?: string | null;
    /**
     * When `group_by=model`, this field provides the model name of the grouped usage result.
     */
    'model'?: string | null;
}

export const UsageEmbeddingsResultObjectEnum = {
    OrganizationUsageEmbeddingsResult: 'organization.usage.embeddings.result'
} as const;

export type UsageEmbeddingsResultObjectEnum = typeof UsageEmbeddingsResultObjectEnum[keyof typeof UsageEmbeddingsResultObjectEnum];

/**
 * The aggregated images usage details of the specific time bucket.
 */
export interface UsageImagesResult {
    'object': UsageImagesResultObjectEnum;
    /**
     * The number of images processed.
     */
    'images': number;
    /**
     * The count of requests made to the model.
     */
    'num_model_requests': number;
    /**
     * When `group_by=source`, this field provides the source of the grouped usage result, possible values are `image.generation`, `image.edit`, `image.variation`.
     */
    'source'?: string | null;
    /**
     * When `group_by=size`, this field provides the image size of the grouped usage result.
     */
    'size'?: string | null;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     */
    'project_id'?: string | null;
    /**
     * When `group_by=user_id`, this field provides the user ID of the grouped usage result.
     */
    'user_id'?: string | null;
    /**
     * When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
     */
    'api_key_id'?: string | null;
    /**
     * When `group_by=model`, this field provides the model name of the grouped usage result.
     */
    'model'?: string | null;
}

export const UsageImagesResultObjectEnum = {
    OrganizationUsageImagesResult: 'organization.usage.images.result'
} as const;

export type UsageImagesResultObjectEnum = typeof UsageImagesResultObjectEnum[keyof typeof UsageImagesResultObjectEnum];

/**
 * The aggregated moderations usage details of the specific time bucket.
 */
export interface UsageModerationsResult {
    'object': UsageModerationsResultObjectEnum;
    /**
     * The aggregated number of input tokens used.
     */
    'input_tokens': number;
    /**
     * The count of requests made to the model.
     */
    'num_model_requests': number;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     */
    'project_id'?: string | null;
    /**
     * When `group_by=user_id`, this field provides the user ID of the grouped usage result.
     */
    'user_id'?: string | null;
    /**
     * When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result.
     */
    'api_key_id'?: string | null;
    /**
     * When `group_by=model`, this field provides the model name of the grouped usage result.
     */
    'model'?: string | null;
}

export const UsageModerationsResultObjectEnum = {
    OrganizationUsageModerationsResult: 'organization.usage.moderations.result'
} as const;

export type UsageModerationsResultObjectEnum = typeof UsageModerationsResultObjectEnum[keyof typeof UsageModerationsResultObjectEnum];

export interface UsageResponse {
    'object': UsageResponseObjectEnum;
    'data': Array<UsageTimeBucket>;
    'has_more': boolean;
    'next_page': string;
}

export const UsageResponseObjectEnum = {
    Page: 'page'
} as const;

export type UsageResponseObjectEnum = typeof UsageResponseObjectEnum[keyof typeof UsageResponseObjectEnum];

export interface UsageTimeBucket {
    'object': UsageTimeBucketObjectEnum;
    'start_time': number;
    'end_time': number;
    'result': Array<UsageTimeBucketResultInner>;
}

export const UsageTimeBucketObjectEnum = {
    Bucket: 'bucket'
} as const;

export type UsageTimeBucketObjectEnum = typeof UsageTimeBucketObjectEnum[keyof typeof UsageTimeBucketObjectEnum];

/**
 * @type UsageTimeBucketResultInner
 */
export type UsageTimeBucketResultInner = CostsResult | UsageAudioSpeechesResult | UsageAudioTranscriptionsResult | UsageCodeInterpreterSessionsResult | UsageCompletionsResult | UsageEmbeddingsResult | UsageImagesResult | UsageModerationsResult | UsageVectorStoresResult;

/**
 * The aggregated vector stores usage details of the specific time bucket.
 */
export interface UsageVectorStoresResult {
    'object': UsageVectorStoresResultObjectEnum;
    /**
     * The vector stores usage in bytes.
     */
    'usage_bytes': number;
    /**
     * When `group_by=project_id`, this field provides the project ID of the grouped usage result.
     */
    'project_id'?: string | null;
}

export const UsageVectorStoresResultObjectEnum = {
    OrganizationUsageVectorStoresResult: 'organization.usage.vector_stores.result'
} as const;

export type UsageVectorStoresResultObjectEnum = typeof UsageVectorStoresResultObjectEnum[keyof typeof UsageVectorStoresResultObjectEnum];

/**
 * Represents an individual `user` within an organization.
 */
export interface User {
    /**
     * The object type, which is always `organization.user`
     */
    'object': UserObjectEnum;
    /**
     * The identifier, which can be referenced in API endpoints
     */
    'id': string;
    /**
     * The name of the user
     */
    'name': string;
    /**
     * The email address of the user
     */
    'email': string;
    /**
     * `owner` or `reader`
     */
    'role': UserRoleEnum;
    /**
     * The Unix timestamp (in seconds) of when the user was added.
     */
    'added_at': number;
}

export const UserObjectEnum = {
    OrganizationUser: 'organization.user'
} as const;

export type UserObjectEnum = typeof UserObjectEnum[keyof typeof UserObjectEnum];
export const UserRoleEnum = {
    Owner: 'owner',
    Reader: 'reader'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];

export interface UserDeleteResponse {
    'object': UserDeleteResponseObjectEnum;
    'id': string;
    'deleted': boolean;
}

export const UserDeleteResponseObjectEnum = {
    OrganizationUserDeleted: 'organization.user.deleted'
} as const;

export type UserDeleteResponseObjectEnum = typeof UserDeleteResponseObjectEnum[keyof typeof UserDeleteResponseObjectEnum];

export interface UserListResponse {
    'object': UserListResponseObjectEnum;
    'data': Array<User>;
    'first_id': string;
    'last_id': string;
    'has_more': boolean;
}

export const UserListResponseObjectEnum = {
    List: 'list'
} as const;

export type UserListResponseObjectEnum = typeof UserListResponseObjectEnum[keyof typeof UserListResponseObjectEnum];

export interface UserRoleUpdateRequest {
    /**
     * `owner` or `reader`
     */
    'role': UserRoleUpdateRequestRoleEnum;
}

export const UserRoleUpdateRequestRoleEnum = {
    Owner: 'owner',
    Reader: 'reader'
} as const;

export type UserRoleUpdateRequestRoleEnum = typeof UserRoleUpdateRequestRoleEnum[keyof typeof UserRoleUpdateRequestRoleEnum];

/**
 * The expiration policy for a vector store.
 */
export interface VectorStoreExpirationAfter {
    /**
     * Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.
     */
    'anchor': VectorStoreExpirationAfterAnchorEnum;
    /**
     * The number of days after the anchor time that the vector store will expire.
     */
    'days': number;
}

export const VectorStoreExpirationAfterAnchorEnum = {
    LastActiveAt: 'last_active_at'
} as const;

export type VectorStoreExpirationAfterAnchorEnum = typeof VectorStoreExpirationAfterAnchorEnum[keyof typeof VectorStoreExpirationAfterAnchorEnum];

/**
 * A batch of files attached to a vector store.
 */
export interface VectorStoreFileBatchObject {
    /**
     * The identifier, which can be referenced in API endpoints.
     */
    'id': string;
    /**
     * The object type, which is always `vector_store.file_batch`.
     */
    'object': VectorStoreFileBatchObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the vector store files batch was created.
     */
    'created_at': number;
    /**
     * The ID of the [vector store](/docs/api-reference/vector-stores/object) that the [File](/docs/api-reference/files) is attached to.
     */
    'vector_store_id': string;
    /**
     * The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`.
     */
    'status': VectorStoreFileBatchObjectStatusEnum;
    'file_counts': VectorStoreFileBatchObjectFileCounts;
}

export const VectorStoreFileBatchObjectObjectEnum = {
    VectorStoreFilesBatch: 'vector_store.files_batch'
} as const;

export type VectorStoreFileBatchObjectObjectEnum = typeof VectorStoreFileBatchObjectObjectEnum[keyof typeof VectorStoreFileBatchObjectObjectEnum];
export const VectorStoreFileBatchObjectStatusEnum = {
    InProgress: 'in_progress',
    Completed: 'completed',
    Cancelled: 'cancelled',
    Failed: 'failed'
} as const;

export type VectorStoreFileBatchObjectStatusEnum = typeof VectorStoreFileBatchObjectStatusEnum[keyof typeof VectorStoreFileBatchObjectStatusEnum];

export interface VectorStoreFileBatchObjectFileCounts {
    /**
     * The number of files that are currently being processed.
     */
    'in_progress': number;
    /**
     * The number of files that have been processed.
     */
    'completed': number;
    /**
     * The number of files that have failed to process.
     */
    'failed': number;
    /**
     * The number of files that where cancelled.
     */
    'cancelled': number;
    /**
     * The total number of files.
     */
    'total': number;
}
/**
 * A list of files attached to a vector store.
 */
export interface VectorStoreFileObject {
    /**
     * The identifier, which can be referenced in API endpoints.
     */
    'id': string;
    /**
     * The object type, which is always `vector_store.file`.
     */
    'object': VectorStoreFileObjectObjectEnum;
    /**
     * The total vector store usage in bytes. Note that this may be different from the original file size.
     */
    'usage_bytes': number;
    /**
     * The Unix timestamp (in seconds) for when the vector store file was created.
     */
    'created_at': number;
    /**
     * The ID of the [vector store](/docs/api-reference/vector-stores/object) that the [File](/docs/api-reference/files) is attached to.
     */
    'vector_store_id': string;
    /**
     * The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.
     */
    'status': VectorStoreFileObjectStatusEnum;
    'last_error': VectorStoreFileObjectLastError | null;
    'chunking_strategy'?: VectorStoreFileObjectChunkingStrategy;
}

export const VectorStoreFileObjectObjectEnum = {
    VectorStoreFile: 'vector_store.file'
} as const;

export type VectorStoreFileObjectObjectEnum = typeof VectorStoreFileObjectObjectEnum[keyof typeof VectorStoreFileObjectObjectEnum];
export const VectorStoreFileObjectStatusEnum = {
    InProgress: 'in_progress',
    Completed: 'completed',
    Cancelled: 'cancelled',
    Failed: 'failed'
} as const;

export type VectorStoreFileObjectStatusEnum = typeof VectorStoreFileObjectStatusEnum[keyof typeof VectorStoreFileObjectStatusEnum];

/**
 * @type VectorStoreFileObjectChunkingStrategy
 * The strategy used to chunk the file.
 */
export type VectorStoreFileObjectChunkingStrategy = OtherChunkingStrategyResponseParam | StaticChunkingStrategyResponseParam;

/**
 * The last error associated with this vector store file. Will be `null` if there are no errors.
 */
export interface VectorStoreFileObjectLastError {
    /**
     * One of `server_error` or `rate_limit_exceeded`.
     */
    'code': VectorStoreFileObjectLastErrorCodeEnum;
    /**
     * A human-readable description of the error.
     */
    'message': string;
}

export const VectorStoreFileObjectLastErrorCodeEnum = {
    ServerError: 'server_error',
    UnsupportedFile: 'unsupported_file',
    InvalidFile: 'invalid_file'
} as const;

export type VectorStoreFileObjectLastErrorCodeEnum = typeof VectorStoreFileObjectLastErrorCodeEnum[keyof typeof VectorStoreFileObjectLastErrorCodeEnum];

/**
 * A vector store is a collection of processed files can be used by the `file_search` tool.
 */
export interface VectorStoreObject {
    /**
     * The identifier, which can be referenced in API endpoints.
     */
    'id': string;
    /**
     * The object type, which is always `vector_store`.
     */
    'object': VectorStoreObjectObjectEnum;
    /**
     * The Unix timestamp (in seconds) for when the vector store was created.
     */
    'created_at': number;
    /**
     * The name of the vector store.
     */
    'name': string;
    /**
     * The total number of bytes used by the files in the vector store.
     */
    'usage_bytes': number;
    'file_counts': VectorStoreObjectFileCounts;
    /**
     * The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use.
     */
    'status': VectorStoreObjectStatusEnum;
    'expires_after'?: VectorStoreExpirationAfter;
    /**
     * The Unix timestamp (in seconds) for when the vector store will expire.
     */
    'expires_at'?: number | null;
    /**
     * The Unix timestamp (in seconds) for when the vector store was last active.
     */
    'last_active_at': number | null;
    /**
     * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long. 
     */
    'metadata': object | null;
}

export const VectorStoreObjectObjectEnum = {
    VectorStore: 'vector_store'
} as const;

export type VectorStoreObjectObjectEnum = typeof VectorStoreObjectObjectEnum[keyof typeof VectorStoreObjectObjectEnum];
export const VectorStoreObjectStatusEnum = {
    Expired: 'expired',
    InProgress: 'in_progress',
    Completed: 'completed'
} as const;

export type VectorStoreObjectStatusEnum = typeof VectorStoreObjectStatusEnum[keyof typeof VectorStoreObjectStatusEnum];

export interface VectorStoreObjectFileCounts {
    /**
     * The number of files that are currently being processed.
     */
    'in_progress': number;
    /**
     * The number of files that have been successfully processed.
     */
    'completed': number;
    /**
     * The number of files that have failed to process.
     */
    'failed': number;
    /**
     * The number of files that were cancelled.
     */
    'cancelled': number;
    /**
     * The total number of files.
     */
    'total': number;
}

/**
 * AssistantsApi - axios parameter creator
 */
export const AssistantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels a run that is `in_progress`.
         * @param {string} threadId The ID of the thread to which this run belongs.
         * @param {string} runId The ID of the run to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRun: async (threadId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('cancelRun', 'threadId', threadId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('cancelRun', 'runId', runId)
            const localVarPath = `/threads/{thread_id}/runs/{run_id}/cancel`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an assistant with a model and instructions.
         * @param {CreateAssistantRequest} createAssistantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssistant: async (createAssistantRequest: CreateAssistantRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAssistantRequest' is not null or undefined
            assertParamExists('createAssistant', 'createAssistantRequest', createAssistantRequest)
            const localVarPath = `/assistants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAssistantRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a message.
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) to create a message for.
         * @param {CreateMessageRequest} createMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage: async (threadId: string, createMessageRequest: CreateMessageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('createMessage', 'threadId', threadId)
            // verify required parameter 'createMessageRequest' is not null or undefined
            assertParamExists('createMessage', 'createMessageRequest', createMessageRequest)
            const localVarPath = `/threads/{thread_id}/messages`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a run.
         * @param {string} threadId The ID of the thread to run.
         * @param {CreateRunRequest} createRunRequest 
         * @param {Array<CreateRunIncludeEnum>} [include] A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun: async (threadId: string, createRunRequest: CreateRunRequest, include?: Array<CreateRunIncludeEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('createRun', 'threadId', threadId)
            // verify required parameter 'createRunRequest' is not null or undefined
            assertParamExists('createRun', 'createRunRequest', createRunRequest)
            const localVarPath = `/threads/{thread_id}/runs`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include) {
                localVarQueryParameter['include[]'] = include;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRunRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a thread.
         * @param {CreateThreadRequest} [createThreadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThread: async (createThreadRequest?: CreateThreadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/threads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createThreadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a thread and run it in one request.
         * @param {CreateThreadAndRunRequest} createThreadAndRunRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThreadAndRun: async (createThreadAndRunRequest: CreateThreadAndRunRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createThreadAndRunRequest' is not null or undefined
            assertParamExists('createThreadAndRun', 'createThreadAndRunRequest', createThreadAndRunRequest)
            const localVarPath = `/threads/runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createThreadAndRunRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an assistant.
         * @param {string} assistantId The ID of the assistant to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssistant: async (assistantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assistantId' is not null or undefined
            assertParamExists('deleteAssistant', 'assistantId', assistantId)
            const localVarPath = `/assistants/{assistant_id}`
                .replace(`{${"assistant_id"}}`, encodeURIComponent(String(assistantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a message.
         * @param {string} threadId The ID of the thread to which this message belongs.
         * @param {string} messageId The ID of the message to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage: async (threadId: string, messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('deleteMessage', 'threadId', threadId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteMessage', 'messageId', messageId)
            const localVarPath = `/threads/{thread_id}/messages/{message_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a thread.
         * @param {string} threadId The ID of the thread to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThread: async (threadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('deleteThread', 'threadId', threadId)
            const localVarPath = `/threads/{thread_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves an assistant.
         * @param {string} assistantId The ID of the assistant to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssistant: async (assistantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assistantId' is not null or undefined
            assertParamExists('getAssistant', 'assistantId', assistantId)
            const localVarPath = `/assistants/{assistant_id}`
                .replace(`{${"assistant_id"}}`, encodeURIComponent(String(assistantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a message.
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) to which this message belongs.
         * @param {string} messageId The ID of the message to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage: async (threadId: string, messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('getMessage', 'threadId', threadId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getMessage', 'messageId', messageId)
            const localVarPath = `/threads/{thread_id}/messages/{message_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a run.
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) that was run.
         * @param {string} runId The ID of the run to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun: async (threadId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('getRun', 'threadId', threadId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRun', 'runId', runId)
            const localVarPath = `/threads/{thread_id}/runs/{run_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a run step.
         * @param {string} threadId The ID of the thread to which the run and run step belongs.
         * @param {string} runId The ID of the run to which the run step belongs.
         * @param {string} stepId The ID of the run step to retrieve.
         * @param {Array<GetRunStepIncludeEnum>} [include] A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStep: async (threadId: string, runId: string, stepId: string, include?: Array<GetRunStepIncludeEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('getRunStep', 'threadId', threadId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRunStep', 'runId', runId)
            // verify required parameter 'stepId' is not null or undefined
            assertParamExists('getRunStep', 'stepId', stepId)
            const localVarPath = `/threads/{thread_id}/runs/{run_id}/steps/{step_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)))
                .replace(`{${"step_id"}}`, encodeURIComponent(String(stepId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (include) {
                localVarQueryParameter['include[]'] = include;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a thread.
         * @param {string} threadId The ID of the thread to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThread: async (threadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('getThread', 'threadId', threadId)
            const localVarPath = `/threads/{thread_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of assistants.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListAssistantsOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssistants: async (limit?: number, order?: ListAssistantsOrderEnum, after?: string, before?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/assistants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of messages for a given thread.
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) the messages belong to.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListMessagesOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {string} [runId] Filter messages by the run ID that generated them. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages: async (threadId: string, limit?: number, order?: ListMessagesOrderEnum, after?: string, before?: string, runId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('listMessages', 'threadId', threadId)
            const localVarPath = `/threads/{thread_id}/messages`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (runId !== undefined) {
                localVarQueryParameter['run_id'] = runId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of run steps belonging to a run.
         * @param {string} threadId The ID of the thread the run and run steps belong to.
         * @param {string} runId The ID of the run the run steps belong to.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListRunStepsOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {Array<ListRunStepsIncludeEnum>} [include] A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunSteps: async (threadId: string, runId: string, limit?: number, order?: ListRunStepsOrderEnum, after?: string, before?: string, include?: Array<ListRunStepsIncludeEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('listRunSteps', 'threadId', threadId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('listRunSteps', 'runId', runId)
            const localVarPath = `/threads/{thread_id}/runs/{run_id}/steps`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (include) {
                localVarQueryParameter['include[]'] = include;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of runs belonging to a thread.
         * @param {string} threadId The ID of the thread the run belongs to.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListRunsOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns: async (threadId: string, limit?: number, order?: ListRunsOrderEnum, after?: string, before?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('listRuns', 'threadId', threadId)
            const localVarPath = `/threads/{thread_id}/runs`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies an assistant.
         * @param {string} assistantId The ID of the assistant to modify.
         * @param {ModifyAssistantRequest} modifyAssistantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyAssistant: async (assistantId: string, modifyAssistantRequest: ModifyAssistantRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assistantId' is not null or undefined
            assertParamExists('modifyAssistant', 'assistantId', assistantId)
            // verify required parameter 'modifyAssistantRequest' is not null or undefined
            assertParamExists('modifyAssistant', 'modifyAssistantRequest', modifyAssistantRequest)
            const localVarPath = `/assistants/{assistant_id}`
                .replace(`{${"assistant_id"}}`, encodeURIComponent(String(assistantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyAssistantRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a message.
         * @param {string} threadId The ID of the thread to which this message belongs.
         * @param {string} messageId The ID of the message to modify.
         * @param {ModifyMessageRequest} modifyMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyMessage: async (threadId: string, messageId: string, modifyMessageRequest: ModifyMessageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('modifyMessage', 'threadId', threadId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('modifyMessage', 'messageId', messageId)
            // verify required parameter 'modifyMessageRequest' is not null or undefined
            assertParamExists('modifyMessage', 'modifyMessageRequest', modifyMessageRequest)
            const localVarPath = `/threads/{thread_id}/messages/{message_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a run.
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) that was run.
         * @param {string} runId The ID of the run to modify.
         * @param {ModifyRunRequest} modifyRunRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyRun: async (threadId: string, runId: string, modifyRunRequest: ModifyRunRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('modifyRun', 'threadId', threadId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('modifyRun', 'runId', runId)
            // verify required parameter 'modifyRunRequest' is not null or undefined
            assertParamExists('modifyRun', 'modifyRunRequest', modifyRunRequest)
            const localVarPath = `/threads/{thread_id}/runs/{run_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyRunRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a thread.
         * @param {string} threadId The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified.
         * @param {ModifyThreadRequest} modifyThreadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyThread: async (threadId: string, modifyThreadRequest: ModifyThreadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('modifyThread', 'threadId', threadId)
            // verify required parameter 'modifyThreadRequest' is not null or undefined
            assertParamExists('modifyThread', 'modifyThreadRequest', modifyThreadRequest)
            const localVarPath = `/threads/{thread_id}`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyThreadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they\'re all completed. All outputs must be submitted in a single request. 
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) to which this run belongs.
         * @param {string} runId The ID of the run that requires the tool output submission.
         * @param {SubmitToolOutputsRunRequest} submitToolOutputsRunRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitToolOuputsToRun: async (threadId: string, runId: string, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadId' is not null or undefined
            assertParamExists('submitToolOuputsToRun', 'threadId', threadId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('submitToolOuputsToRun', 'runId', runId)
            // verify required parameter 'submitToolOutputsRunRequest' is not null or undefined
            assertParamExists('submitToolOuputsToRun', 'submitToolOutputsRunRequest', submitToolOutputsRunRequest)
            const localVarPath = `/threads/{thread_id}/runs/{run_id}/submit_tool_outputs`
                .replace(`{${"thread_id"}}`, encodeURIComponent(String(threadId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitToolOutputsRunRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssistantsApi - functional programming interface
 */
export const AssistantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssistantsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancels a run that is `in_progress`.
         * @param {string} threadId The ID of the thread to which this run belongs.
         * @param {string} runId The ID of the run to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelRun(threadId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelRun(threadId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.cancelRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an assistant with a model and instructions.
         * @param {CreateAssistantRequest} createAssistantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAssistant(createAssistantRequest: CreateAssistantRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssistantObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAssistant(createAssistantRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.createAssistant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a message.
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) to create a message for.
         * @param {CreateMessageRequest} createMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessage(threadId: string, createMessageRequest: CreateMessageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessage(threadId, createMessageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.createMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a run.
         * @param {string} threadId The ID of the thread to run.
         * @param {CreateRunRequest} createRunRequest 
         * @param {Array<CreateRunIncludeEnum>} [include] A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRun(threadId: string, createRunRequest: CreateRunRequest, include?: Array<CreateRunIncludeEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRun(threadId, createRunRequest, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.createRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a thread.
         * @param {CreateThreadRequest} [createThreadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createThread(createThreadRequest?: CreateThreadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createThread(createThreadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.createThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a thread and run it in one request.
         * @param {CreateThreadAndRunRequest} createThreadAndRunRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createThreadAndRun(createThreadAndRunRequest: CreateThreadAndRunRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createThreadAndRun(createThreadAndRunRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.createThreadAndRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an assistant.
         * @param {string} assistantId The ID of the assistant to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAssistant(assistantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAssistantResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAssistant(assistantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.deleteAssistant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a message.
         * @param {string} threadId The ID of the thread to which this message belongs.
         * @param {string} messageId The ID of the message to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessage(threadId: string, messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessage(threadId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.deleteMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a thread.
         * @param {string} threadId The ID of the thread to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteThread(threadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteThreadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteThread(threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.deleteThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves an assistant.
         * @param {string} assistantId The ID of the assistant to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssistant(assistantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssistantObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssistant(assistantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.getAssistant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a message.
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) to which this message belongs.
         * @param {string} messageId The ID of the message to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessage(threadId: string, messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessage(threadId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.getMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a run.
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) that was run.
         * @param {string} runId The ID of the run to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRun(threadId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRun(threadId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.getRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a run step.
         * @param {string} threadId The ID of the thread to which the run and run step belongs.
         * @param {string} runId The ID of the run to which the run step belongs.
         * @param {string} stepId The ID of the run step to retrieve.
         * @param {Array<GetRunStepIncludeEnum>} [include] A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunStep(threadId: string, runId: string, stepId: string, include?: Array<GetRunStepIncludeEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunStepObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunStep(threadId, runId, stepId, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.getRunStep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a thread.
         * @param {string} threadId The ID of the thread to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThread(threadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThread(threadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.getThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of assistants.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListAssistantsOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAssistants(limit?: number, order?: ListAssistantsOrderEnum, after?: string, before?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAssistantsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAssistants(limit, order, after, before, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.listAssistants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of messages for a given thread.
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) the messages belong to.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListMessagesOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {string} [runId] Filter messages by the run ID that generated them. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMessages(threadId: string, limit?: number, order?: ListMessagesOrderEnum, after?: string, before?: string, runId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMessagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMessages(threadId, limit, order, after, before, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.listMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of run steps belonging to a run.
         * @param {string} threadId The ID of the thread the run and run steps belong to.
         * @param {string} runId The ID of the run the run steps belong to.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListRunStepsOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {Array<ListRunStepsIncludeEnum>} [include] A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRunSteps(threadId: string, runId: string, limit?: number, order?: ListRunStepsOrderEnum, after?: string, before?: string, include?: Array<ListRunStepsIncludeEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRunStepsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRunSteps(threadId, runId, limit, order, after, before, include, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.listRunSteps']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of runs belonging to a thread.
         * @param {string} threadId The ID of the thread the run belongs to.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListRunsOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuns(threadId: string, limit?: number, order?: ListRunsOrderEnum, after?: string, before?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListRunsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuns(threadId, limit, order, after, before, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.listRuns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Modifies an assistant.
         * @param {string} assistantId The ID of the assistant to modify.
         * @param {ModifyAssistantRequest} modifyAssistantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyAssistant(assistantId: string, modifyAssistantRequest: ModifyAssistantRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssistantObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyAssistant(assistantId, modifyAssistantRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.modifyAssistant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Modifies a message.
         * @param {string} threadId The ID of the thread to which this message belongs.
         * @param {string} messageId The ID of the message to modify.
         * @param {ModifyMessageRequest} modifyMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyMessage(threadId: string, messageId: string, modifyMessageRequest: ModifyMessageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyMessage(threadId, messageId, modifyMessageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.modifyMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Modifies a run.
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) that was run.
         * @param {string} runId The ID of the run to modify.
         * @param {ModifyRunRequest} modifyRunRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyRun(threadId: string, runId: string, modifyRunRequest: ModifyRunRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyRun(threadId, runId, modifyRunRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.modifyRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Modifies a thread.
         * @param {string} threadId The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified.
         * @param {ModifyThreadRequest} modifyThreadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyThread(threadId: string, modifyThreadRequest: ModifyThreadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyThread(threadId, modifyThreadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.modifyThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they\'re all completed. All outputs must be submitted in a single request. 
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) to which this run belongs.
         * @param {string} runId The ID of the run that requires the tool output submission.
         * @param {SubmitToolOutputsRunRequest} submitToolOutputsRunRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitToolOuputsToRun(threadId: string, runId: string, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitToolOuputsToRun(threadId, runId, submitToolOutputsRunRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssistantsApi.submitToolOuputsToRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssistantsApi - factory interface
 */
export const AssistantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssistantsApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancels a run that is `in_progress`.
         * @param {string} threadId The ID of the thread to which this run belongs.
         * @param {string} runId The ID of the run to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelRun(threadId: string, runId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunObject> {
            return localVarFp.cancelRun(threadId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an assistant with a model and instructions.
         * @param {CreateAssistantRequest} createAssistantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssistant(createAssistantRequest: CreateAssistantRequest, options?: RawAxiosRequestConfig): AxiosPromise<AssistantObject> {
            return localVarFp.createAssistant(createAssistantRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a message.
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) to create a message for.
         * @param {CreateMessageRequest} createMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage(threadId: string, createMessageRequest: CreateMessageRequest, options?: RawAxiosRequestConfig): AxiosPromise<MessageObject> {
            return localVarFp.createMessage(threadId, createMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a run.
         * @param {string} threadId The ID of the thread to run.
         * @param {CreateRunRequest} createRunRequest 
         * @param {Array<CreateRunIncludeEnum>} [include] A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRun(threadId: string, createRunRequest: CreateRunRequest, include?: Array<CreateRunIncludeEnum>, options?: RawAxiosRequestConfig): AxiosPromise<RunObject> {
            return localVarFp.createRun(threadId, createRunRequest, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a thread.
         * @param {CreateThreadRequest} [createThreadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThread(createThreadRequest?: CreateThreadRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThreadObject> {
            return localVarFp.createThread(createThreadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a thread and run it in one request.
         * @param {CreateThreadAndRunRequest} createThreadAndRunRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThreadAndRun(createThreadAndRunRequest: CreateThreadAndRunRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunObject> {
            return localVarFp.createThreadAndRun(createThreadAndRunRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an assistant.
         * @param {string} assistantId The ID of the assistant to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssistant(assistantId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAssistantResponse> {
            return localVarFp.deleteAssistant(assistantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a message.
         * @param {string} threadId The ID of the thread to which this message belongs.
         * @param {string} messageId The ID of the message to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(threadId: string, messageId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMessageResponse> {
            return localVarFp.deleteMessage(threadId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a thread.
         * @param {string} threadId The ID of the thread to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThread(threadId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteThreadResponse> {
            return localVarFp.deleteThread(threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves an assistant.
         * @param {string} assistantId The ID of the assistant to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssistant(assistantId: string, options?: RawAxiosRequestConfig): AxiosPromise<AssistantObject> {
            return localVarFp.getAssistant(assistantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a message.
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) to which this message belongs.
         * @param {string} messageId The ID of the message to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(threadId: string, messageId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageObject> {
            return localVarFp.getMessage(threadId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a run.
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) that was run.
         * @param {string} runId The ID of the run to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(threadId: string, runId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunObject> {
            return localVarFp.getRun(threadId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a run step.
         * @param {string} threadId The ID of the thread to which the run and run step belongs.
         * @param {string} runId The ID of the run to which the run step belongs.
         * @param {string} stepId The ID of the run step to retrieve.
         * @param {Array<GetRunStepIncludeEnum>} [include] A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStep(threadId: string, runId: string, stepId: string, include?: Array<GetRunStepIncludeEnum>, options?: RawAxiosRequestConfig): AxiosPromise<RunStepObject> {
            return localVarFp.getRunStep(threadId, runId, stepId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a thread.
         * @param {string} threadId The ID of the thread to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThread(threadId: string, options?: RawAxiosRequestConfig): AxiosPromise<ThreadObject> {
            return localVarFp.getThread(threadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of assistants.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListAssistantsOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssistants(limit?: number, order?: ListAssistantsOrderEnum, after?: string, before?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListAssistantsResponse> {
            return localVarFp.listAssistants(limit, order, after, before, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of messages for a given thread.
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) the messages belong to.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListMessagesOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {string} [runId] Filter messages by the run ID that generated them. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages(threadId: string, limit?: number, order?: ListMessagesOrderEnum, after?: string, before?: string, runId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListMessagesResponse> {
            return localVarFp.listMessages(threadId, limit, order, after, before, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of run steps belonging to a run.
         * @param {string} threadId The ID of the thread the run and run steps belong to.
         * @param {string} runId The ID of the run the run steps belong to.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListRunStepsOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {Array<ListRunStepsIncludeEnum>} [include] A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunSteps(threadId: string, runId: string, limit?: number, order?: ListRunStepsOrderEnum, after?: string, before?: string, include?: Array<ListRunStepsIncludeEnum>, options?: RawAxiosRequestConfig): AxiosPromise<ListRunStepsResponse> {
            return localVarFp.listRunSteps(threadId, runId, limit, order, after, before, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of runs belonging to a thread.
         * @param {string} threadId The ID of the thread the run belongs to.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListRunsOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(threadId: string, limit?: number, order?: ListRunsOrderEnum, after?: string, before?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListRunsResponse> {
            return localVarFp.listRuns(threadId, limit, order, after, before, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modifies an assistant.
         * @param {string} assistantId The ID of the assistant to modify.
         * @param {ModifyAssistantRequest} modifyAssistantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyAssistant(assistantId: string, modifyAssistantRequest: ModifyAssistantRequest, options?: RawAxiosRequestConfig): AxiosPromise<AssistantObject> {
            return localVarFp.modifyAssistant(assistantId, modifyAssistantRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modifies a message.
         * @param {string} threadId The ID of the thread to which this message belongs.
         * @param {string} messageId The ID of the message to modify.
         * @param {ModifyMessageRequest} modifyMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyMessage(threadId: string, messageId: string, modifyMessageRequest: ModifyMessageRequest, options?: RawAxiosRequestConfig): AxiosPromise<MessageObject> {
            return localVarFp.modifyMessage(threadId, messageId, modifyMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modifies a run.
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) that was run.
         * @param {string} runId The ID of the run to modify.
         * @param {ModifyRunRequest} modifyRunRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyRun(threadId: string, runId: string, modifyRunRequest: ModifyRunRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunObject> {
            return localVarFp.modifyRun(threadId, runId, modifyRunRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modifies a thread.
         * @param {string} threadId The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified.
         * @param {ModifyThreadRequest} modifyThreadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyThread(threadId: string, modifyThreadRequest: ModifyThreadRequest, options?: RawAxiosRequestConfig): AxiosPromise<ThreadObject> {
            return localVarFp.modifyThread(threadId, modifyThreadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they\'re all completed. All outputs must be submitted in a single request. 
         * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) to which this run belongs.
         * @param {string} runId The ID of the run that requires the tool output submission.
         * @param {SubmitToolOutputsRunRequest} submitToolOutputsRunRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitToolOuputsToRun(threadId: string, runId: string, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunObject> {
            return localVarFp.submitToolOuputsToRun(threadId, runId, submitToolOutputsRunRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssistantsApi - object-oriented interface
 */
export class AssistantsApi extends BaseAPI {
    /**
     * 
     * @summary Cancels a run that is `in_progress`.
     * @param {string} threadId The ID of the thread to which this run belongs.
     * @param {string} runId The ID of the run to cancel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelRun(threadId: string, runId: string, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).cancelRun(threadId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an assistant with a model and instructions.
     * @param {CreateAssistantRequest} createAssistantRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAssistant(createAssistantRequest: CreateAssistantRequest, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).createAssistant(createAssistantRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a message.
     * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) to create a message for.
     * @param {CreateMessageRequest} createMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createMessage(threadId: string, createMessageRequest: CreateMessageRequest, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).createMessage(threadId, createMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a run.
     * @param {string} threadId The ID of the thread to run.
     * @param {CreateRunRequest} createRunRequest 
     * @param {Array<CreateRunIncludeEnum>} [include] A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRun(threadId: string, createRunRequest: CreateRunRequest, include?: Array<CreateRunIncludeEnum>, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).createRun(threadId, createRunRequest, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a thread.
     * @param {CreateThreadRequest} [createThreadRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createThread(createThreadRequest?: CreateThreadRequest, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).createThread(createThreadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a thread and run it in one request.
     * @param {CreateThreadAndRunRequest} createThreadAndRunRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createThreadAndRun(createThreadAndRunRequest: CreateThreadAndRunRequest, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).createThreadAndRun(createThreadAndRunRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an assistant.
     * @param {string} assistantId The ID of the assistant to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAssistant(assistantId: string, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).deleteAssistant(assistantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a message.
     * @param {string} threadId The ID of the thread to which this message belongs.
     * @param {string} messageId The ID of the message to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteMessage(threadId: string, messageId: string, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).deleteMessage(threadId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a thread.
     * @param {string} threadId The ID of the thread to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteThread(threadId: string, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).deleteThread(threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves an assistant.
     * @param {string} assistantId The ID of the assistant to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAssistant(assistantId: string, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).getAssistant(assistantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a message.
     * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) to which this message belongs.
     * @param {string} messageId The ID of the message to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMessage(threadId: string, messageId: string, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).getMessage(threadId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a run.
     * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) that was run.
     * @param {string} runId The ID of the run to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRun(threadId: string, runId: string, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).getRun(threadId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a run step.
     * @param {string} threadId The ID of the thread to which the run and run step belongs.
     * @param {string} runId The ID of the run to which the run step belongs.
     * @param {string} stepId The ID of the run step to retrieve.
     * @param {Array<GetRunStepIncludeEnum>} [include] A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRunStep(threadId: string, runId: string, stepId: string, include?: Array<GetRunStepIncludeEnum>, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).getRunStep(threadId, runId, stepId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a thread.
     * @param {string} threadId The ID of the thread to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getThread(threadId: string, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).getThread(threadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of assistants.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param {ListAssistantsOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listAssistants(limit?: number, order?: ListAssistantsOrderEnum, after?: string, before?: string, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).listAssistants(limit, order, after, before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of messages for a given thread.
     * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) the messages belong to.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param {ListMessagesOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param {string} [runId] Filter messages by the run ID that generated them. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMessages(threadId: string, limit?: number, order?: ListMessagesOrderEnum, after?: string, before?: string, runId?: string, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).listMessages(threadId, limit, order, after, before, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of run steps belonging to a run.
     * @param {string} threadId The ID of the thread the run and run steps belong to.
     * @param {string} runId The ID of the run the run steps belong to.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param {ListRunStepsOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param {Array<ListRunStepsIncludeEnum>} [include] A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listRunSteps(threadId: string, runId: string, limit?: number, order?: ListRunStepsOrderEnum, after?: string, before?: string, include?: Array<ListRunStepsIncludeEnum>, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).listRunSteps(threadId, runId, limit, order, after, before, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of runs belonging to a thread.
     * @param {string} threadId The ID of the thread the run belongs to.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param {ListRunsOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listRuns(threadId: string, limit?: number, order?: ListRunsOrderEnum, after?: string, before?: string, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).listRuns(threadId, limit, order, after, before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modifies an assistant.
     * @param {string} assistantId The ID of the assistant to modify.
     * @param {ModifyAssistantRequest} modifyAssistantRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public modifyAssistant(assistantId: string, modifyAssistantRequest: ModifyAssistantRequest, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).modifyAssistant(assistantId, modifyAssistantRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modifies a message.
     * @param {string} threadId The ID of the thread to which this message belongs.
     * @param {string} messageId The ID of the message to modify.
     * @param {ModifyMessageRequest} modifyMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public modifyMessage(threadId: string, messageId: string, modifyMessageRequest: ModifyMessageRequest, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).modifyMessage(threadId, messageId, modifyMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modifies a run.
     * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) that was run.
     * @param {string} runId The ID of the run to modify.
     * @param {ModifyRunRequest} modifyRunRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public modifyRun(threadId: string, runId: string, modifyRunRequest: ModifyRunRequest, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).modifyRun(threadId, runId, modifyRunRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modifies a thread.
     * @param {string} threadId The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified.
     * @param {ModifyThreadRequest} modifyThreadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public modifyThread(threadId: string, modifyThreadRequest: ModifyThreadRequest, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).modifyThread(threadId, modifyThreadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they\'re all completed. All outputs must be submitted in a single request. 
     * @param {string} threadId The ID of the [thread](/docs/api-reference/threads) to which this run belongs.
     * @param {string} runId The ID of the run that requires the tool output submission.
     * @param {SubmitToolOutputsRunRequest} submitToolOutputsRunRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public submitToolOuputsToRun(threadId: string, runId: string, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest, options?: RawAxiosRequestConfig) {
        return AssistantsApiFp(this.configuration).submitToolOuputsToRun(threadId, runId, submitToolOutputsRunRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const CreateRunIncludeEnum = {
    StepDetailsToolCallsFileSearchResultsContent: 'step_details.tool_calls[*].file_search.results[*].content'
} as const;
export type CreateRunIncludeEnum = typeof CreateRunIncludeEnum[keyof typeof CreateRunIncludeEnum];
export const GetRunStepIncludeEnum = {
    StepDetailsToolCallsFileSearchResultsContent: 'step_details.tool_calls[*].file_search.results[*].content'
} as const;
export type GetRunStepIncludeEnum = typeof GetRunStepIncludeEnum[keyof typeof GetRunStepIncludeEnum];
export const ListAssistantsOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListAssistantsOrderEnum = typeof ListAssistantsOrderEnum[keyof typeof ListAssistantsOrderEnum];
export const ListMessagesOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListMessagesOrderEnum = typeof ListMessagesOrderEnum[keyof typeof ListMessagesOrderEnum];
export const ListRunStepsOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListRunStepsOrderEnum = typeof ListRunStepsOrderEnum[keyof typeof ListRunStepsOrderEnum];
export const ListRunStepsIncludeEnum = {
    StepDetailsToolCallsFileSearchResultsContent: 'step_details.tool_calls[*].file_search.results[*].content'
} as const;
export type ListRunStepsIncludeEnum = typeof ListRunStepsIncludeEnum[keyof typeof ListRunStepsIncludeEnum];
export const ListRunsOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListRunsOrderEnum = typeof ListRunsOrderEnum[keyof typeof ListRunsOrderEnum];


/**
 * AudioApi - axios parameter creator
 */
export const AudioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generates audio from the input text.
         * @param {CreateSpeechRequest} createSpeechRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpeech: async (createSpeechRequest: CreateSpeechRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSpeechRequest' is not null or undefined
            assertParamExists('createSpeech', 'createSpeechRequest', createSpeechRequest)
            const localVarPath = `/audio/speech`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSpeechRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transcribes audio into the input language.
         * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. 
         * @param {CreateTranscriptionRequestModel} model 
         * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency. 
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should match the audio language. 
         * @param {AudioResponseFormat} [responseFormat] 
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. 
         * @param {Array<CreateTranscriptionTimestampGranularitiesEnum>} [timestampGranularities] The timestamp granularities to populate for this transcription. &#x60;response_format&#x60; must be set &#x60;verbose_json&#x60; to use timestamp granularities. Either or both of these options are supported: &#x60;word&#x60;, or &#x60;segment&#x60;. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranscription: async (file: File, model: CreateTranscriptionRequestModel, language?: string, prompt?: string, responseFormat?: AudioResponseFormat, temperature?: number, timestampGranularities?: Array<CreateTranscriptionTimestampGranularitiesEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createTranscription', 'file', file)
            // verify required parameter 'model' is not null or undefined
            assertParamExists('createTranscription', 'model', model)
            const localVarPath = `/audio/transcriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            if (model !== undefined) { 
                localVarFormParams.append('model', new Blob([JSON.stringify(model)], { type: "application/json", }));
            }

            if (language !== undefined) { 
                localVarFormParams.append('language', language as any);
            }

            if (prompt !== undefined) { 
                localVarFormParams.append('prompt', prompt as any);
            }

            if (responseFormat !== undefined) { 
                localVarFormParams.append('response_format', responseFormat as any);
            }

            if (temperature !== undefined) { 
                localVarFormParams.append('temperature', temperature as any);
            }
            if (timestampGranularities) {
                localVarFormParams.append('timestamp_granularities[]', timestampGranularities.join(COLLECTION_FORMATS.csv));
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Translates audio into English.
         * @param {File} file The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. 
         * @param {CreateTranscriptionRequestModel} model 
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should be in English. 
         * @param {AudioResponseFormat} [responseFormat] 
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranslation: async (file: File, model: CreateTranscriptionRequestModel, prompt?: string, responseFormat?: AudioResponseFormat, temperature?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createTranslation', 'file', file)
            // verify required parameter 'model' is not null or undefined
            assertParamExists('createTranslation', 'model', model)
            const localVarPath = `/audio/translations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            if (model !== undefined) { 
                localVarFormParams.append('model', new Blob([JSON.stringify(model)], { type: "application/json", }));
            }

            if (prompt !== undefined) { 
                localVarFormParams.append('prompt', prompt as any);
            }

            if (responseFormat !== undefined) { 
                localVarFormParams.append('response_format', responseFormat as any);
            }

            if (temperature !== undefined) { 
                localVarFormParams.append('temperature', temperature as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudioApi - functional programming interface
 */
export const AudioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AudioApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Generates audio from the input text.
         * @param {CreateSpeechRequest} createSpeechRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSpeech(createSpeechRequest: CreateSpeechRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSpeech(createSpeechRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioApi.createSpeech']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Transcribes audio into the input language.
         * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. 
         * @param {CreateTranscriptionRequestModel} model 
         * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency. 
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should match the audio language. 
         * @param {AudioResponseFormat} [responseFormat] 
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. 
         * @param {Array<CreateTranscriptionTimestampGranularitiesEnum>} [timestampGranularities] The timestamp granularities to populate for this transcription. &#x60;response_format&#x60; must be set &#x60;verbose_json&#x60; to use timestamp granularities. Either or both of these options are supported: &#x60;word&#x60;, or &#x60;segment&#x60;. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTranscription(file: File, model: CreateTranscriptionRequestModel, language?: string, prompt?: string, responseFormat?: AudioResponseFormat, temperature?: number, timestampGranularities?: Array<CreateTranscriptionTimestampGranularitiesEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTranscription200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTranscription(file, model, language, prompt, responseFormat, temperature, timestampGranularities, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioApi.createTranscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Translates audio into English.
         * @param {File} file The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. 
         * @param {CreateTranscriptionRequestModel} model 
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should be in English. 
         * @param {AudioResponseFormat} [responseFormat] 
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTranslation(file: File, model: CreateTranscriptionRequestModel, prompt?: string, responseFormat?: AudioResponseFormat, temperature?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTranslation(file, model, prompt, responseFormat, temperature, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudioApi.createTranslation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AudioApi - factory interface
 */
export const AudioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AudioApiFp(configuration)
    return {
        /**
         * 
         * @summary Generates audio from the input text.
         * @param {CreateSpeechRequest} createSpeechRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpeech(createSpeechRequest: CreateSpeechRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.createSpeech(createSpeechRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transcribes audio into the input language.
         * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. 
         * @param {CreateTranscriptionRequestModel} model 
         * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency. 
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should match the audio language. 
         * @param {AudioResponseFormat} [responseFormat] 
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. 
         * @param {Array<CreateTranscriptionTimestampGranularitiesEnum>} [timestampGranularities] The timestamp granularities to populate for this transcription. &#x60;response_format&#x60; must be set &#x60;verbose_json&#x60; to use timestamp granularities. Either or both of these options are supported: &#x60;word&#x60;, or &#x60;segment&#x60;. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranscription(file: File, model: CreateTranscriptionRequestModel, language?: string, prompt?: string, responseFormat?: AudioResponseFormat, temperature?: number, timestampGranularities?: Array<CreateTranscriptionTimestampGranularitiesEnum>, options?: RawAxiosRequestConfig): AxiosPromise<CreateTranscription200Response> {
            return localVarFp.createTranscription(file, model, language, prompt, responseFormat, temperature, timestampGranularities, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Translates audio into English.
         * @param {File} file The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. 
         * @param {CreateTranscriptionRequestModel} model 
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should be in English. 
         * @param {AudioResponseFormat} [responseFormat] 
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTranslation(file: File, model: CreateTranscriptionRequestModel, prompt?: string, responseFormat?: AudioResponseFormat, temperature?: number, options?: RawAxiosRequestConfig): AxiosPromise<CreateTranslation200Response> {
            return localVarFp.createTranslation(file, model, prompt, responseFormat, temperature, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AudioApi - object-oriented interface
 */
export class AudioApi extends BaseAPI {
    /**
     * 
     * @summary Generates audio from the input text.
     * @param {CreateSpeechRequest} createSpeechRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createSpeech(createSpeechRequest: CreateSpeechRequest, options?: RawAxiosRequestConfig) {
        return AudioApiFp(this.configuration).createSpeech(createSpeechRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transcribes audio into the input language.
     * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. 
     * @param {CreateTranscriptionRequestModel} model 
     * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency. 
     * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should match the audio language. 
     * @param {AudioResponseFormat} [responseFormat] 
     * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. 
     * @param {Array<CreateTranscriptionTimestampGranularitiesEnum>} [timestampGranularities] The timestamp granularities to populate for this transcription. &#x60;response_format&#x60; must be set &#x60;verbose_json&#x60; to use timestamp granularities. Either or both of these options are supported: &#x60;word&#x60;, or &#x60;segment&#x60;. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTranscription(file: File, model: CreateTranscriptionRequestModel, language?: string, prompt?: string, responseFormat?: AudioResponseFormat, temperature?: number, timestampGranularities?: Array<CreateTranscriptionTimestampGranularitiesEnum>, options?: RawAxiosRequestConfig) {
        return AudioApiFp(this.configuration).createTranscription(file, model, language, prompt, responseFormat, temperature, timestampGranularities, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Translates audio into English.
     * @param {File} file The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. 
     * @param {CreateTranscriptionRequestModel} model 
     * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should be in English. 
     * @param {AudioResponseFormat} [responseFormat] 
     * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTranslation(file: File, model: CreateTranscriptionRequestModel, prompt?: string, responseFormat?: AudioResponseFormat, temperature?: number, options?: RawAxiosRequestConfig) {
        return AudioApiFp(this.configuration).createTranslation(file, model, prompt, responseFormat, temperature, options).then((request) => request(this.axios, this.basePath));
    }
}

export const CreateTranscriptionTimestampGranularitiesEnum = {
    Word: 'word',
    Segment: 'segment'
} as const;
export type CreateTranscriptionTimestampGranularitiesEnum = typeof CreateTranscriptionTimestampGranularitiesEnum[keyof typeof CreateTranscriptionTimestampGranularitiesEnum];


/**
 * AuditLogsApi - axios parameter creator
 */
export const AuditLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List user actions and configuration changes within this organization.
         * @param {ListAuditLogsEffectiveAtParameter} [effectiveAt] Return only events whose &#x60;effective_at&#x60; (Unix seconds) is in this range.
         * @param {Array<string>} [projectIds] Return only events for these projects.
         * @param {Array<AuditLogEventType>} [eventTypes] Return only events with a &#x60;type&#x60; in one of these values. For example, &#x60;project.created&#x60;. For all options, see the documentation for the [audit log object](/docs/api-reference/audit-logs/object).
         * @param {Array<string>} [actorIds] Return only events performed by these actors. Can be a user ID, a service account ID, or an api key tracking ID.
         * @param {Array<string>} [actorEmails] Return only events performed by users with these emails.
         * @param {Array<string>} [resourceIds] Return only events performed on these targets. For example, a project ID updated.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuditLogs: async (effectiveAt?: ListAuditLogsEffectiveAtParameter, projectIds?: Array<string>, eventTypes?: Array<AuditLogEventType>, actorIds?: Array<string>, actorEmails?: Array<string>, resourceIds?: Array<string>, limit?: number, after?: string, before?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization/audit_logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (effectiveAt !== undefined) {
                for (const [key, value] of Object.entries(effectiveAt)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (projectIds) {
                localVarQueryParameter['project_ids[]'] = projectIds;
            }

            if (eventTypes) {
                localVarQueryParameter['event_types[]'] = eventTypes;
            }

            if (actorIds) {
                localVarQueryParameter['actor_ids[]'] = actorIds;
            }

            if (actorEmails) {
                localVarQueryParameter['actor_emails[]'] = actorEmails;
            }

            if (resourceIds) {
                localVarQueryParameter['resource_ids[]'] = resourceIds;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditLogsApi - functional programming interface
 */
export const AuditLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List user actions and configuration changes within this organization.
         * @param {ListAuditLogsEffectiveAtParameter} [effectiveAt] Return only events whose &#x60;effective_at&#x60; (Unix seconds) is in this range.
         * @param {Array<string>} [projectIds] Return only events for these projects.
         * @param {Array<AuditLogEventType>} [eventTypes] Return only events with a &#x60;type&#x60; in one of these values. For example, &#x60;project.created&#x60;. For all options, see the documentation for the [audit log object](/docs/api-reference/audit-logs/object).
         * @param {Array<string>} [actorIds] Return only events performed by these actors. Can be a user ID, a service account ID, or an api key tracking ID.
         * @param {Array<string>} [actorEmails] Return only events performed by users with these emails.
         * @param {Array<string>} [resourceIds] Return only events performed on these targets. For example, a project ID updated.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAuditLogs(effectiveAt?: ListAuditLogsEffectiveAtParameter, projectIds?: Array<string>, eventTypes?: Array<AuditLogEventType>, actorIds?: Array<string>, actorEmails?: Array<string>, resourceIds?: Array<string>, limit?: number, after?: string, before?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAuditLogsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAuditLogs(effectiveAt, projectIds, eventTypes, actorIds, actorEmails, resourceIds, limit, after, before, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuditLogsApi.listAuditLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuditLogsApi - factory interface
 */
export const AuditLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditLogsApiFp(configuration)
    return {
        /**
         * 
         * @summary List user actions and configuration changes within this organization.
         * @param {ListAuditLogsEffectiveAtParameter} [effectiveAt] Return only events whose &#x60;effective_at&#x60; (Unix seconds) is in this range.
         * @param {Array<string>} [projectIds] Return only events for these projects.
         * @param {Array<AuditLogEventType>} [eventTypes] Return only events with a &#x60;type&#x60; in one of these values. For example, &#x60;project.created&#x60;. For all options, see the documentation for the [audit log object](/docs/api-reference/audit-logs/object).
         * @param {Array<string>} [actorIds] Return only events performed by these actors. Can be a user ID, a service account ID, or an api key tracking ID.
         * @param {Array<string>} [actorEmails] Return only events performed by users with these emails.
         * @param {Array<string>} [resourceIds] Return only events performed on these targets. For example, a project ID updated.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAuditLogs(effectiveAt?: ListAuditLogsEffectiveAtParameter, projectIds?: Array<string>, eventTypes?: Array<AuditLogEventType>, actorIds?: Array<string>, actorEmails?: Array<string>, resourceIds?: Array<string>, limit?: number, after?: string, before?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListAuditLogsResponse> {
            return localVarFp.listAuditLogs(effectiveAt, projectIds, eventTypes, actorIds, actorEmails, resourceIds, limit, after, before, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuditLogsApi - object-oriented interface
 */
export class AuditLogsApi extends BaseAPI {
    /**
     * 
     * @summary List user actions and configuration changes within this organization.
     * @param {ListAuditLogsEffectiveAtParameter} [effectiveAt] Return only events whose &#x60;effective_at&#x60; (Unix seconds) is in this range.
     * @param {Array<string>} [projectIds] Return only events for these projects.
     * @param {Array<AuditLogEventType>} [eventTypes] Return only events with a &#x60;type&#x60; in one of these values. For example, &#x60;project.created&#x60;. For all options, see the documentation for the [audit log object](/docs/api-reference/audit-logs/object).
     * @param {Array<string>} [actorIds] Return only events performed by these actors. Can be a user ID, a service account ID, or an api key tracking ID.
     * @param {Array<string>} [actorEmails] Return only events performed by users with these emails.
     * @param {Array<string>} [resourceIds] Return only events performed on these targets. For example, a project ID updated.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listAuditLogs(effectiveAt?: ListAuditLogsEffectiveAtParameter, projectIds?: Array<string>, eventTypes?: Array<AuditLogEventType>, actorIds?: Array<string>, actorEmails?: Array<string>, resourceIds?: Array<string>, limit?: number, after?: string, before?: string, options?: RawAxiosRequestConfig) {
        return AuditLogsApiFp(this.configuration).listAuditLogs(effectiveAt, projectIds, eventTypes, actorIds, actorEmails, resourceIds, limit, after, before, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BatchApi - axios parameter creator
 */
export const BatchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancels an in-progress batch. The batch will be in status `cancelling` for up to 10 minutes, before changing to `cancelled`, where it will have partial results (if any) available in the output file.
         * @param {string} batchId The ID of the batch to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelBatch: async (batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('cancelBatch', 'batchId', batchId)
            const localVarPath = `/batches/{batch_id}/cancel`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates and executes a batch from an uploaded file of requests
         * @param {CreateBatchRequest} createBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch: async (createBatchRequest: CreateBatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBatchRequest' is not null or undefined
            assertParamExists('createBatch', 'createBatchRequest', createBatchRequest)
            const localVarPath = `/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List your organization\'s batches.
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches: async (after?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a batch.
         * @param {string} batchId The ID of the batch to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBatch: async (batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('retrieveBatch', 'batchId', batchId)
            const localVarPath = `/batches/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatchApi - functional programming interface
 */
export const BatchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancels an in-progress batch. The batch will be in status `cancelling` for up to 10 minutes, before changing to `cancelled`, where it will have partial results (if any) available in the output file.
         * @param {string} batchId The ID of the batch to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelBatch(batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelBatch(batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchApi.cancelBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates and executes a batch from an uploaded file of requests
         * @param {CreateBatchRequest} createBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatch(createBatchRequest: CreateBatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatch(createBatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchApi.createBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List your organization\'s batches.
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatches(after?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListBatchesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatches(after, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchApi.listBatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a batch.
         * @param {string} batchId The ID of the batch to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveBatch(batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveBatch(batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BatchApi.retrieveBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BatchApi - factory interface
 */
export const BatchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatchApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancels an in-progress batch. The batch will be in status `cancelling` for up to 10 minutes, before changing to `cancelled`, where it will have partial results (if any) available in the output file.
         * @param {string} batchId The ID of the batch to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelBatch(batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<Batch> {
            return localVarFp.cancelBatch(batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates and executes a batch from an uploaded file of requests
         * @param {CreateBatchRequest} createBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatch(createBatchRequest: CreateBatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Batch> {
            return localVarFp.createBatch(createBatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List your organization\'s batches.
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatches(after?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListBatchesResponse> {
            return localVarFp.listBatches(after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a batch.
         * @param {string} batchId The ID of the batch to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBatch(batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<Batch> {
            return localVarFp.retrieveBatch(batchId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BatchApi - object-oriented interface
 */
export class BatchApi extends BaseAPI {
    /**
     * 
     * @summary Cancels an in-progress batch. The batch will be in status `cancelling` for up to 10 minutes, before changing to `cancelled`, where it will have partial results (if any) available in the output file.
     * @param {string} batchId The ID of the batch to cancel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelBatch(batchId: string, options?: RawAxiosRequestConfig) {
        return BatchApiFp(this.configuration).cancelBatch(batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates and executes a batch from an uploaded file of requests
     * @param {CreateBatchRequest} createBatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createBatch(createBatchRequest: CreateBatchRequest, options?: RawAxiosRequestConfig) {
        return BatchApiFp(this.configuration).createBatch(createBatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List your organization\'s batches.
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listBatches(after?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return BatchApiFp(this.configuration).listBatches(after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a batch.
     * @param {string} batchId The ID of the batch to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveBatch(batchId: string, options?: RawAxiosRequestConfig) {
        return BatchApiFp(this.configuration).retrieveBatch(batchId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatApi - axios parameter creator
 */
export const ChatApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a model response for the given chat conversation. Learn more in the [text generation](/docs/guides/text-generation), [vision](/docs/guides/vision), and [audio](/docs/guides/audio) guides.  Parameter support can differ depending on the model used to generate the response, particularly for newer reasoning models. Parameters that are only supported for reasoning models are noted below. For the current state of  unsupported parameters in reasoning models,  [refer to the reasoning guide](/docs/guides/reasoning). 
         * @param {CreateChatCompletionRequest} createChatCompletionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatCompletion: async (createChatCompletionRequest: CreateChatCompletionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createChatCompletionRequest' is not null or undefined
            assertParamExists('createChatCompletion', 'createChatCompletionRequest', createChatCompletionRequest)
            const localVarPath = `/chat/completions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createChatCompletionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatApi - functional programming interface
 */
export const ChatApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a model response for the given chat conversation. Learn more in the [text generation](/docs/guides/text-generation), [vision](/docs/guides/vision), and [audio](/docs/guides/audio) guides.  Parameter support can differ depending on the model used to generate the response, particularly for newer reasoning models. Parameters that are only supported for reasoning models are noted below. For the current state of  unsupported parameters in reasoning models,  [refer to the reasoning guide](/docs/guides/reasoning). 
         * @param {CreateChatCompletionRequest} createChatCompletionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChatCompletion(createChatCompletionRequest: CreateChatCompletionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateChatCompletionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChatCompletion(createChatCompletionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.createChatCompletion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatApi - factory interface
 */
export const ChatApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a model response for the given chat conversation. Learn more in the [text generation](/docs/guides/text-generation), [vision](/docs/guides/vision), and [audio](/docs/guides/audio) guides.  Parameter support can differ depending on the model used to generate the response, particularly for newer reasoning models. Parameters that are only supported for reasoning models are noted below. For the current state of  unsupported parameters in reasoning models,  [refer to the reasoning guide](/docs/guides/reasoning). 
         * @param {CreateChatCompletionRequest} createChatCompletionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatCompletion(createChatCompletionRequest: CreateChatCompletionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateChatCompletionResponse> {
            return localVarFp.createChatCompletion(createChatCompletionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatApi - object-oriented interface
 */
export class ChatApi extends BaseAPI {
    /**
     * 
     * @summary Creates a model response for the given chat conversation. Learn more in the [text generation](/docs/guides/text-generation), [vision](/docs/guides/vision), and [audio](/docs/guides/audio) guides.  Parameter support can differ depending on the model used to generate the response, particularly for newer reasoning models. Parameters that are only supported for reasoning models are noted below. For the current state of  unsupported parameters in reasoning models,  [refer to the reasoning guide](/docs/guides/reasoning). 
     * @param {CreateChatCompletionRequest} createChatCompletionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createChatCompletion(createChatCompletionRequest: CreateChatCompletionRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).createChatCompletion(createChatCompletionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CompletionsApi - axios parameter creator
 */
export const CompletionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a completion for the provided prompt and parameters.
         * @param {CreateCompletionRequest} createCompletionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompletion: async (createCompletionRequest: CreateCompletionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCompletionRequest' is not null or undefined
            assertParamExists('createCompletion', 'createCompletionRequest', createCompletionRequest)
            const localVarPath = `/completions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCompletionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompletionsApi - functional programming interface
 */
export const CompletionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompletionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a completion for the provided prompt and parameters.
         * @param {CreateCompletionRequest} createCompletionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCompletion(createCompletionRequest: CreateCompletionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCompletionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCompletion(createCompletionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompletionsApi.createCompletion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CompletionsApi - factory interface
 */
export const CompletionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompletionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a completion for the provided prompt and parameters.
         * @param {CreateCompletionRequest} createCompletionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompletion(createCompletionRequest: CreateCompletionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateCompletionResponse> {
            return localVarFp.createCompletion(createCompletionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompletionsApi - object-oriented interface
 */
export class CompletionsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a completion for the provided prompt and parameters.
     * @param {CreateCompletionRequest} createCompletionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCompletion(createCompletionRequest: CreateCompletionRequest, options?: RawAxiosRequestConfig) {
        return CompletionsApiFp(this.configuration).createCompletion(createCompletionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new admin-level API key for the organization.
         * @summary Create an organization admin API key
         * @param {AdminApiKeysCreateRequest} adminApiKeysCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiKeysCreate: async (adminApiKeysCreateRequest: AdminApiKeysCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminApiKeysCreateRequest' is not null or undefined
            assertParamExists('adminApiKeysCreate', 'adminApiKeysCreateRequest', adminApiKeysCreateRequest)
            const localVarPath = `/organization/admin_api_keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminApiKeysCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the specified admin API key.
         * @summary Delete an organization admin API key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiKeysDelete: async (keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('adminApiKeysDelete', 'keyId', keyId)
            const localVarPath = `/organization/admin_api_keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details for a specific organization API key by its ID.
         * @summary Retrieve a single organization API key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiKeysGet: async (keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('adminApiKeysGet', 'keyId', keyId)
            const localVarPath = `/organization/admin_api_keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a paginated list of organization admin API keys.
         * @summary List organization API keys
         * @param {string | null} [after] 
         * @param {AdminApiKeysListOrderEnum} [order] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiKeysList: async (after?: string | null, order?: AdminApiKeysListOrderEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization/admin_api_keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new admin-level API key for the organization.
         * @summary Create an organization admin API key
         * @param {AdminApiKeysCreateRequest} adminApiKeysCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminApiKeysCreate(adminApiKeysCreateRequest: AdminApiKeysCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminApiKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminApiKeysCreate(adminApiKeysCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.adminApiKeysCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the specified admin API key.
         * @summary Delete an organization admin API key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminApiKeysDelete(keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminApiKeysDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminApiKeysDelete(keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.adminApiKeysDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details for a specific organization API key by its ID.
         * @summary Retrieve a single organization API key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminApiKeysGet(keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminApiKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminApiKeysGet(keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.adminApiKeysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a paginated list of organization admin API keys.
         * @summary List organization API keys
         * @param {string | null} [after] 
         * @param {AdminApiKeysListOrderEnum} [order] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminApiKeysList(after?: string | null, order?: AdminApiKeysListOrderEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminApiKeysList(after, order, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.adminApiKeysList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Create a new admin-level API key for the organization.
         * @summary Create an organization admin API key
         * @param {AdminApiKeysCreateRequest} adminApiKeysCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiKeysCreate(adminApiKeysCreateRequest: AdminApiKeysCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdminApiKey> {
            return localVarFp.adminApiKeysCreate(adminApiKeysCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the specified admin API key.
         * @summary Delete an organization admin API key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiKeysDelete(keyId: string, options?: RawAxiosRequestConfig): AxiosPromise<AdminApiKeysDelete200Response> {
            return localVarFp.adminApiKeysDelete(keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details for a specific organization API key by its ID.
         * @summary Retrieve a single organization API key
         * @param {string} keyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiKeysGet(keyId: string, options?: RawAxiosRequestConfig): AxiosPromise<AdminApiKey> {
            return localVarFp.adminApiKeysGet(keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a paginated list of organization admin API keys.
         * @summary List organization API keys
         * @param {string | null} [after] 
         * @param {AdminApiKeysListOrderEnum} [order] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiKeysList(after?: string | null, order?: AdminApiKeysListOrderEnum, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyList> {
            return localVarFp.adminApiKeysList(after, order, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * Create a new admin-level API key for the organization.
     * @summary Create an organization admin API key
     * @param {AdminApiKeysCreateRequest} adminApiKeysCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminApiKeysCreate(adminApiKeysCreateRequest: AdminApiKeysCreateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).adminApiKeysCreate(adminApiKeysCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the specified admin API key.
     * @summary Delete an organization admin API key
     * @param {string} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminApiKeysDelete(keyId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).adminApiKeysDelete(keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details for a specific organization API key by its ID.
     * @summary Retrieve a single organization API key
     * @param {string} keyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminApiKeysGet(keyId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).adminApiKeysGet(keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a paginated list of organization admin API keys.
     * @summary List organization API keys
     * @param {string | null} [after] 
     * @param {AdminApiKeysListOrderEnum} [order] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public adminApiKeysList(after?: string | null, order?: AdminApiKeysListOrderEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).adminApiKeysList(after, order, limit, options).then((request) => request(this.axios, this.basePath));
    }
}

export const AdminApiKeysListOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AdminApiKeysListOrderEnum = typeof AdminApiKeysListOrderEnum[keyof typeof AdminApiKeysListOrderEnum];


/**
 * EmbeddingsApi - axios parameter creator
 */
export const EmbeddingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an embedding vector representing the input text.
         * @param {CreateEmbeddingRequest} createEmbeddingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbedding: async (createEmbeddingRequest: CreateEmbeddingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEmbeddingRequest' is not null or undefined
            assertParamExists('createEmbedding', 'createEmbeddingRequest', createEmbeddingRequest)
            const localVarPath = `/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEmbeddingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmbeddingsApi - functional programming interface
 */
export const EmbeddingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmbeddingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates an embedding vector representing the input text.
         * @param {CreateEmbeddingRequest} createEmbeddingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmbedding(createEmbeddingRequest: CreateEmbeddingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateEmbeddingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmbedding(createEmbeddingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmbeddingsApi.createEmbedding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmbeddingsApi - factory interface
 */
export const EmbeddingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmbeddingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates an embedding vector representing the input text.
         * @param {CreateEmbeddingRequest} createEmbeddingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbedding(createEmbeddingRequest: CreateEmbeddingRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateEmbeddingResponse> {
            return localVarFp.createEmbedding(createEmbeddingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmbeddingsApi - object-oriented interface
 */
export class EmbeddingsApi extends BaseAPI {
    /**
     * 
     * @summary Creates an embedding vector representing the input text.
     * @param {CreateEmbeddingRequest} createEmbeddingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createEmbedding(createEmbeddingRequest: CreateEmbeddingRequest, options?: RawAxiosRequestConfig) {
        return EmbeddingsApiFp(this.configuration).createEmbedding(createEmbeddingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesApi - axios parameter creator
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload a file that can be used across various endpoints. Individual files can be up to 512 MB, and the size of all files uploaded by one organization can be up to 100 GB.  The Assistants API supports files up to 2 million tokens and of specific file types. See the [Assistants Tools guide](/docs/assistants/tools) for details.  The Fine-tuning API only supports `.jsonl` files. The input also has certain required formats for fine-tuning [chat](/docs/api-reference/fine-tuning/chat-input) or [completions](/docs/api-reference/fine-tuning/completions-input) models.  The Batch API only supports `.jsonl` files up to 200 MB in size. The input also has a specific required [format](/docs/api-reference/batch/request-input).  Please [contact us](https://help.openai.com/) if you need to increase these storage limits. 
         * @param {File} file The File object (not file name) to be uploaded. 
         * @param {CreateFilePurposeEnum} purpose The intended purpose of the uploaded file.  Use \\\&quot;assistants\\\&quot; for [Assistants](/docs/api-reference/assistants) and [Message](/docs/api-reference/messages) files, \\\&quot;vision\\\&quot; for Assistants image file inputs, \\\&quot;batch\\\&quot; for [Batch API](/docs/guides/batch), and \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tuning). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: async (file: File, purpose: CreateFilePurposeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createFile', 'file', file)
            // verify required parameter 'purpose' is not null or undefined
            assertParamExists('createFile', 'purpose', purpose)
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            if (purpose !== undefined) { 
                localVarFormParams.append('purpose', purpose as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile: async (fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('deleteFile', 'fileId', fileId)
            const localVarPath = `/files/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the contents of the specified file.
         * @param {string} fileId The ID of the file to use for this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('downloadFile', 'fileId', fileId)
            const localVarPath = `/files/{file_id}/content`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of files.
         * @param {string} [purpose] Only return files with the given purpose.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 10,000, and the default is 10,000. 
         * @param {ListFilesOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles: async (purpose?: string, limit?: number, order?: ListFilesOrderEnum, after?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (purpose !== undefined) {
                localVarQueryParameter['purpose'] = purpose;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFile: async (fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('retrieveFile', 'fileId', fileId)
            const localVarPath = `/files/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upload a file that can be used across various endpoints. Individual files can be up to 512 MB, and the size of all files uploaded by one organization can be up to 100 GB.  The Assistants API supports files up to 2 million tokens and of specific file types. See the [Assistants Tools guide](/docs/assistants/tools) for details.  The Fine-tuning API only supports `.jsonl` files. The input also has certain required formats for fine-tuning [chat](/docs/api-reference/fine-tuning/chat-input) or [completions](/docs/api-reference/fine-tuning/completions-input) models.  The Batch API only supports `.jsonl` files up to 200 MB in size. The input also has a specific required [format](/docs/api-reference/batch/request-input).  Please [contact us](https://help.openai.com/) if you need to increase these storage limits. 
         * @param {File} file The File object (not file name) to be uploaded. 
         * @param {CreateFilePurposeEnum} purpose The intended purpose of the uploaded file.  Use \\\&quot;assistants\\\&quot; for [Assistants](/docs/api-reference/assistants) and [Message](/docs/api-reference/messages) files, \\\&quot;vision\\\&quot; for Assistants image file inputs, \\\&quot;batch\\\&quot; for [Batch API](/docs/guides/batch), and \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tuning). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFile(file: File, purpose: CreateFilePurposeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFile(file, purpose, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.createFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFile(fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.deleteFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the contents of the specified file.
         * @param {string} fileId The ID of the file to use for this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.downloadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of files.
         * @param {string} [purpose] Only return files with the given purpose.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 10,000, and the default is 10,000. 
         * @param {ListFilesOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFiles(purpose?: string, limit?: number, order?: ListFilesOrderEnum, after?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFilesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFiles(purpose, limit, order, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.listFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveFile(fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OpenAIFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveFile(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.retrieveFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesApi - factory interface
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @summary Upload a file that can be used across various endpoints. Individual files can be up to 512 MB, and the size of all files uploaded by one organization can be up to 100 GB.  The Assistants API supports files up to 2 million tokens and of specific file types. See the [Assistants Tools guide](/docs/assistants/tools) for details.  The Fine-tuning API only supports `.jsonl` files. The input also has certain required formats for fine-tuning [chat](/docs/api-reference/fine-tuning/chat-input) or [completions](/docs/api-reference/fine-tuning/completions-input) models.  The Batch API only supports `.jsonl` files up to 200 MB in size. The input also has a specific required [format](/docs/api-reference/batch/request-input).  Please [contact us](https://help.openai.com/) if you need to increase these storage limits. 
         * @param {File} file The File object (not file name) to be uploaded. 
         * @param {CreateFilePurposeEnum} purpose The intended purpose of the uploaded file.  Use \\\&quot;assistants\\\&quot; for [Assistants](/docs/api-reference/assistants) and [Message](/docs/api-reference/messages) files, \\\&quot;vision\\\&quot; for Assistants image file inputs, \\\&quot;batch\\\&quot; for [Batch API](/docs/guides/batch), and \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tuning). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(file: File, purpose: CreateFilePurposeEnum, options?: RawAxiosRequestConfig): AxiosPromise<OpenAIFile> {
            return localVarFp.createFile(file, purpose, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFile(fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteFileResponse> {
            return localVarFp.deleteFile(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the contents of the specified file.
         * @param {string} fileId The ID of the file to use for this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.downloadFile(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of files.
         * @param {string} [purpose] Only return files with the given purpose.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 10,000, and the default is 10,000. 
         * @param {ListFilesOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles(purpose?: string, limit?: number, order?: ListFilesOrderEnum, after?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListFilesResponse> {
            return localVarFp.listFiles(purpose, limit, order, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFile(fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<OpenAIFile> {
            return localVarFp.retrieveFile(fileId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @summary Upload a file that can be used across various endpoints. Individual files can be up to 512 MB, and the size of all files uploaded by one organization can be up to 100 GB.  The Assistants API supports files up to 2 million tokens and of specific file types. See the [Assistants Tools guide](/docs/assistants/tools) for details.  The Fine-tuning API only supports `.jsonl` files. The input also has certain required formats for fine-tuning [chat](/docs/api-reference/fine-tuning/chat-input) or [completions](/docs/api-reference/fine-tuning/completions-input) models.  The Batch API only supports `.jsonl` files up to 200 MB in size. The input also has a specific required [format](/docs/api-reference/batch/request-input).  Please [contact us](https://help.openai.com/) if you need to increase these storage limits. 
     * @param {File} file The File object (not file name) to be uploaded. 
     * @param {CreateFilePurposeEnum} purpose The intended purpose of the uploaded file.  Use \\\&quot;assistants\\\&quot; for [Assistants](/docs/api-reference/assistants) and [Message](/docs/api-reference/messages) files, \\\&quot;vision\\\&quot; for Assistants image file inputs, \\\&quot;batch\\\&quot; for [Batch API](/docs/guides/batch), and \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tuning). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFile(file: File, purpose: CreateFilePurposeEnum, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).createFile(file, purpose, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a file.
     * @param {string} fileId The ID of the file to use for this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteFile(fileId: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).deleteFile(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the contents of the specified file.
     * @param {string} fileId The ID of the file to use for this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadFile(fileId: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).downloadFile(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of files.
     * @param {string} [purpose] Only return files with the given purpose.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 10,000, and the default is 10,000. 
     * @param {ListFilesOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFiles(purpose?: string, limit?: number, order?: ListFilesOrderEnum, after?: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).listFiles(purpose, limit, order, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns information about a specific file.
     * @param {string} fileId The ID of the file to use for this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveFile(fileId: string, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).retrieveFile(fileId, options).then((request) => request(this.axios, this.basePath));
    }
}

export const CreateFilePurposeEnum = {
    Assistants: 'assistants',
    Batch: 'batch',
    FineTune: 'fine-tune',
    Vision: 'vision'
} as const;
export type CreateFilePurposeEnum = typeof CreateFilePurposeEnum[keyof typeof CreateFilePurposeEnum];
export const ListFilesOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListFilesOrderEnum = typeof ListFilesOrderEnum[keyof typeof ListFilesOrderEnum];


/**
 * FineTuningApi - axios parameter creator
 */
export const FineTuningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Immediately cancel a fine-tune job. 
         * @param {string} fineTuningJobId The ID of the fine-tuning job to cancel. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFineTuningJob: async (fineTuningJobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fineTuningJobId' is not null or undefined
            assertParamExists('cancelFineTuningJob', 'fineTuningJobId', fineTuningJobId)
            const localVarPath = `/fine_tuning/jobs/{fine_tuning_job_id}/cancel`
                .replace(`{${"fine_tuning_job_id"}}`, encodeURIComponent(String(fineTuningJobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a fine-tuning job which begins the process of creating a new model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
         * @param {CreateFineTuningJobRequest} createFineTuningJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFineTuningJob: async (createFineTuningJobRequest: CreateFineTuningJobRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFineTuningJobRequest' is not null or undefined
            assertParamExists('createFineTuningJob', 'createFineTuningJobRequest', createFineTuningJobRequest)
            const localVarPath = `/fine_tuning/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFineTuningJobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get status updates for a fine-tuning job. 
         * @param {string} fineTuningJobId The ID of the fine-tuning job to get events for. 
         * @param {string} [after] Identifier for the last event from the previous pagination request.
         * @param {number} [limit] Number of events to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTuningEvents: async (fineTuningJobId: string, after?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fineTuningJobId' is not null or undefined
            assertParamExists('listFineTuningEvents', 'fineTuningJobId', fineTuningJobId)
            const localVarPath = `/fine_tuning/jobs/{fine_tuning_job_id}/events`
                .replace(`{${"fine_tuning_job_id"}}`, encodeURIComponent(String(fineTuningJobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List checkpoints for a fine-tuning job. 
         * @param {string} fineTuningJobId The ID of the fine-tuning job to get checkpoints for. 
         * @param {string} [after] Identifier for the last checkpoint ID from the previous pagination request.
         * @param {number} [limit] Number of checkpoints to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTuningJobCheckpoints: async (fineTuningJobId: string, after?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fineTuningJobId' is not null or undefined
            assertParamExists('listFineTuningJobCheckpoints', 'fineTuningJobId', fineTuningJobId)
            const localVarPath = `/fine_tuning/jobs/{fine_tuning_job_id}/checkpoints`
                .replace(`{${"fine_tuning_job_id"}}`, encodeURIComponent(String(fineTuningJobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List your organization\'s fine-tuning jobs 
         * @param {string} [after] Identifier for the last job from the previous pagination request.
         * @param {number} [limit] Number of fine-tuning jobs to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaginatedFineTuningJobs: async (after?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fine_tuning/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get info about a fine-tuning job.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
         * @param {string} fineTuningJobId The ID of the fine-tuning job. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFineTuningJob: async (fineTuningJobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fineTuningJobId' is not null or undefined
            assertParamExists('retrieveFineTuningJob', 'fineTuningJobId', fineTuningJobId)
            const localVarPath = `/fine_tuning/jobs/{fine_tuning_job_id}`
                .replace(`{${"fine_tuning_job_id"}}`, encodeURIComponent(String(fineTuningJobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FineTuningApi - functional programming interface
 */
export const FineTuningApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FineTuningApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Immediately cancel a fine-tune job. 
         * @param {string} fineTuningJobId The ID of the fine-tuning job to cancel. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelFineTuningJob(fineTuningJobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FineTuningJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelFineTuningJob(fineTuningJobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningApi.cancelFineTuningJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a fine-tuning job which begins the process of creating a new model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
         * @param {CreateFineTuningJobRequest} createFineTuningJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFineTuningJob(createFineTuningJobRequest: CreateFineTuningJobRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FineTuningJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFineTuningJob(createFineTuningJobRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningApi.createFineTuningJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get status updates for a fine-tuning job. 
         * @param {string} fineTuningJobId The ID of the fine-tuning job to get events for. 
         * @param {string} [after] Identifier for the last event from the previous pagination request.
         * @param {number} [limit] Number of events to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFineTuningEvents(fineTuningJobId: string, after?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFineTuningJobEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFineTuningEvents(fineTuningJobId, after, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningApi.listFineTuningEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List checkpoints for a fine-tuning job. 
         * @param {string} fineTuningJobId The ID of the fine-tuning job to get checkpoints for. 
         * @param {string} [after] Identifier for the last checkpoint ID from the previous pagination request.
         * @param {number} [limit] Number of checkpoints to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFineTuningJobCheckpoints(fineTuningJobId: string, after?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFineTuningJobCheckpointsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFineTuningJobCheckpoints(fineTuningJobId, after, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningApi.listFineTuningJobCheckpoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List your organization\'s fine-tuning jobs 
         * @param {string} [after] Identifier for the last job from the previous pagination request.
         * @param {number} [limit] Number of fine-tuning jobs to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPaginatedFineTuningJobs(after?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPaginatedFineTuningJobsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPaginatedFineTuningJobs(after, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningApi.listPaginatedFineTuningJobs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get info about a fine-tuning job.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
         * @param {string} fineTuningJobId The ID of the fine-tuning job. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveFineTuningJob(fineTuningJobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FineTuningJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveFineTuningJob(fineTuningJobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FineTuningApi.retrieveFineTuningJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FineTuningApi - factory interface
 */
export const FineTuningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FineTuningApiFp(configuration)
    return {
        /**
         * 
         * @summary Immediately cancel a fine-tune job. 
         * @param {string} fineTuningJobId The ID of the fine-tuning job to cancel. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFineTuningJob(fineTuningJobId: string, options?: RawAxiosRequestConfig): AxiosPromise<FineTuningJob> {
            return localVarFp.cancelFineTuningJob(fineTuningJobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a fine-tuning job which begins the process of creating a new model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
         * @param {CreateFineTuningJobRequest} createFineTuningJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFineTuningJob(createFineTuningJobRequest: CreateFineTuningJobRequest, options?: RawAxiosRequestConfig): AxiosPromise<FineTuningJob> {
            return localVarFp.createFineTuningJob(createFineTuningJobRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get status updates for a fine-tuning job. 
         * @param {string} fineTuningJobId The ID of the fine-tuning job to get events for. 
         * @param {string} [after] Identifier for the last event from the previous pagination request.
         * @param {number} [limit] Number of events to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTuningEvents(fineTuningJobId: string, after?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListFineTuningJobEventsResponse> {
            return localVarFp.listFineTuningEvents(fineTuningJobId, after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List checkpoints for a fine-tuning job. 
         * @param {string} fineTuningJobId The ID of the fine-tuning job to get checkpoints for. 
         * @param {string} [after] Identifier for the last checkpoint ID from the previous pagination request.
         * @param {number} [limit] Number of checkpoints to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFineTuningJobCheckpoints(fineTuningJobId: string, after?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListFineTuningJobCheckpointsResponse> {
            return localVarFp.listFineTuningJobCheckpoints(fineTuningJobId, after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List your organization\'s fine-tuning jobs 
         * @param {string} [after] Identifier for the last job from the previous pagination request.
         * @param {number} [limit] Number of fine-tuning jobs to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaginatedFineTuningJobs(after?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListPaginatedFineTuningJobsResponse> {
            return localVarFp.listPaginatedFineTuningJobs(after, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get info about a fine-tuning job.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
         * @param {string} fineTuningJobId The ID of the fine-tuning job. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFineTuningJob(fineTuningJobId: string, options?: RawAxiosRequestConfig): AxiosPromise<FineTuningJob> {
            return localVarFp.retrieveFineTuningJob(fineTuningJobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FineTuningApi - object-oriented interface
 */
export class FineTuningApi extends BaseAPI {
    /**
     * 
     * @summary Immediately cancel a fine-tune job. 
     * @param {string} fineTuningJobId The ID of the fine-tuning job to cancel. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelFineTuningJob(fineTuningJobId: string, options?: RawAxiosRequestConfig) {
        return FineTuningApiFp(this.configuration).cancelFineTuningJob(fineTuningJobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a fine-tuning job which begins the process of creating a new model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
     * @param {CreateFineTuningJobRequest} createFineTuningJobRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFineTuningJob(createFineTuningJobRequest: CreateFineTuningJobRequest, options?: RawAxiosRequestConfig) {
        return FineTuningApiFp(this.configuration).createFineTuningJob(createFineTuningJobRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get status updates for a fine-tuning job. 
     * @param {string} fineTuningJobId The ID of the fine-tuning job to get events for. 
     * @param {string} [after] Identifier for the last event from the previous pagination request.
     * @param {number} [limit] Number of events to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFineTuningEvents(fineTuningJobId: string, after?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return FineTuningApiFp(this.configuration).listFineTuningEvents(fineTuningJobId, after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List checkpoints for a fine-tuning job. 
     * @param {string} fineTuningJobId The ID of the fine-tuning job to get checkpoints for. 
     * @param {string} [after] Identifier for the last checkpoint ID from the previous pagination request.
     * @param {number} [limit] Number of checkpoints to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFineTuningJobCheckpoints(fineTuningJobId: string, after?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return FineTuningApiFp(this.configuration).listFineTuningJobCheckpoints(fineTuningJobId, after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List your organization\'s fine-tuning jobs 
     * @param {string} [after] Identifier for the last job from the previous pagination request.
     * @param {number} [limit] Number of fine-tuning jobs to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listPaginatedFineTuningJobs(after?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return FineTuningApiFp(this.configuration).listPaginatedFineTuningJobs(after, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get info about a fine-tuning job.  [Learn more about fine-tuning](/docs/guides/fine-tuning) 
     * @param {string} fineTuningJobId The ID of the fine-tuning job. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveFineTuningJob(fineTuningJobId: string, options?: RawAxiosRequestConfig) {
        return FineTuningApiFp(this.configuration).retrieveFineTuningJob(fineTuningJobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImagesApi - axios parameter creator
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an image given a prompt.
         * @param {CreateImageRequest} createImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage: async (createImageRequest: CreateImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createImageRequest' is not null or undefined
            assertParamExists('createImage', 'createImageRequest', createImageRequest)
            const localVarPath = `/images/generations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
         * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
         * @param {CreateImageEditRequestModel | null} [model] 
         * @param {number | null} [n] The number of images to generate. Must be between 1 and 10.
         * @param {CreateImageEditSizeEnum} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {CreateImageEditResponseFormatEnum} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;. URLs are only valid for 60 minutes after the image has been generated.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageEdit: async (image: File, prompt: string, mask?: File, model?: CreateImageEditRequestModel | null, n?: number | null, size?: CreateImageEditSizeEnum, responseFormat?: CreateImageEditResponseFormatEnum, user?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'image' is not null or undefined
            assertParamExists('createImageEdit', 'image', image)
            // verify required parameter 'prompt' is not null or undefined
            assertParamExists('createImageEdit', 'prompt', prompt)
            const localVarPath = `/images/edits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }

            if (prompt !== undefined) { 
                localVarFormParams.append('prompt', prompt as any);
            }

            if (mask !== undefined) { 
                localVarFormParams.append('mask', mask as any);
            }

            if (model !== undefined) { 
                localVarFormParams.append('model', new Blob([JSON.stringify(model)], { type: "application/json", }));
            }

            if (n !== undefined) { 
                localVarFormParams.append('n', n as any);
            }

            if (size !== undefined) { 
                localVarFormParams.append('size', size as any);
            }

            if (responseFormat !== undefined) { 
                localVarFormParams.append('response_format', responseFormat as any);
            }

            if (user !== undefined) { 
                localVarFormParams.append('user', user as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a variation of a given image.
         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
         * @param {CreateImageEditRequestModel | null} [model] 
         * @param {number | null} [n] The number of images to generate. Must be between 1 and 10. For &#x60;dall-e-3&#x60;, only &#x60;n&#x3D;1&#x60; is supported.
         * @param {CreateImageVariationResponseFormatEnum} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;. URLs are only valid for 60 minutes after the image has been generated.
         * @param {CreateImageVariationSizeEnum} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageVariation: async (image: File, model?: CreateImageEditRequestModel | null, n?: number | null, responseFormat?: CreateImageVariationResponseFormatEnum, size?: CreateImageVariationSizeEnum, user?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'image' is not null or undefined
            assertParamExists('createImageVariation', 'image', image)
            const localVarPath = `/images/variations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }

            if (model !== undefined) { 
                localVarFormParams.append('model', new Blob([JSON.stringify(model)], { type: "application/json", }));
            }

            if (n !== undefined) { 
                localVarFormParams.append('n', n as any);
            }

            if (responseFormat !== undefined) { 
                localVarFormParams.append('response_format', responseFormat as any);
            }

            if (size !== undefined) { 
                localVarFormParams.append('size', size as any);
            }

            if (user !== undefined) { 
                localVarFormParams.append('user', user as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates an image given a prompt.
         * @param {CreateImageRequest} createImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImage(createImageRequest: CreateImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImage(createImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.createImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
         * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
         * @param {CreateImageEditRequestModel | null} [model] 
         * @param {number | null} [n] The number of images to generate. Must be between 1 and 10.
         * @param {CreateImageEditSizeEnum} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {CreateImageEditResponseFormatEnum} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;. URLs are only valid for 60 minutes after the image has been generated.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImageEdit(image: File, prompt: string, mask?: File, model?: CreateImageEditRequestModel | null, n?: number | null, size?: CreateImageEditSizeEnum, responseFormat?: CreateImageEditResponseFormatEnum, user?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImageEdit(image, prompt, mask, model, n, size, responseFormat, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.createImageEdit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a variation of a given image.
         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
         * @param {CreateImageEditRequestModel | null} [model] 
         * @param {number | null} [n] The number of images to generate. Must be between 1 and 10. For &#x60;dall-e-3&#x60;, only &#x60;n&#x3D;1&#x60; is supported.
         * @param {CreateImageVariationResponseFormatEnum} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;. URLs are only valid for 60 minutes after the image has been generated.
         * @param {CreateImageVariationSizeEnum} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImageVariation(image: File, model?: CreateImageEditRequestModel | null, n?: number | null, responseFormat?: CreateImageVariationResponseFormatEnum, size?: CreateImageVariationSizeEnum, user?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImageVariation(image, model, n, responseFormat, size, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImagesApi.createImageVariation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImagesApi - factory interface
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates an image given a prompt.
         * @param {CreateImageRequest} createImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImage(createImageRequest: CreateImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImagesResponse> {
            return localVarFp.createImage(createImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
         * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
         * @param {CreateImageEditRequestModel | null} [model] 
         * @param {number | null} [n] The number of images to generate. Must be between 1 and 10.
         * @param {CreateImageEditSizeEnum} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {CreateImageEditResponseFormatEnum} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;. URLs are only valid for 60 minutes after the image has been generated.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageEdit(image: File, prompt: string, mask?: File, model?: CreateImageEditRequestModel | null, n?: number | null, size?: CreateImageEditSizeEnum, responseFormat?: CreateImageEditResponseFormatEnum, user?: string, options?: RawAxiosRequestConfig): AxiosPromise<ImagesResponse> {
            return localVarFp.createImageEdit(image, prompt, mask, model, n, size, responseFormat, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a variation of a given image.
         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
         * @param {CreateImageEditRequestModel | null} [model] 
         * @param {number | null} [n] The number of images to generate. Must be between 1 and 10. For &#x60;dall-e-3&#x60;, only &#x60;n&#x3D;1&#x60; is supported.
         * @param {CreateImageVariationResponseFormatEnum} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;. URLs are only valid for 60 minutes after the image has been generated.
         * @param {CreateImageVariationSizeEnum} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageVariation(image: File, model?: CreateImageEditRequestModel | null, n?: number | null, responseFormat?: CreateImageVariationResponseFormatEnum, size?: CreateImageVariationSizeEnum, user?: string, options?: RawAxiosRequestConfig): AxiosPromise<ImagesResponse> {
            return localVarFp.createImageVariation(image, model, n, responseFormat, size, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 */
export class ImagesApi extends BaseAPI {
    /**
     * 
     * @summary Creates an image given a prompt.
     * @param {CreateImageRequest} createImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createImage(createImageRequest: CreateImageRequest, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).createImage(createImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an edited or extended image given an original image and a prompt.
     * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
     * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
     * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
     * @param {CreateImageEditRequestModel | null} [model] 
     * @param {number | null} [n] The number of images to generate. Must be between 1 and 10.
     * @param {CreateImageEditSizeEnum} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
     * @param {CreateImageEditResponseFormatEnum} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;. URLs are only valid for 60 minutes after the image has been generated.
     * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createImageEdit(image: File, prompt: string, mask?: File, model?: CreateImageEditRequestModel | null, n?: number | null, size?: CreateImageEditSizeEnum, responseFormat?: CreateImageEditResponseFormatEnum, user?: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).createImageEdit(image, prompt, mask, model, n, size, responseFormat, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a variation of a given image.
     * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
     * @param {CreateImageEditRequestModel | null} [model] 
     * @param {number | null} [n] The number of images to generate. Must be between 1 and 10. For &#x60;dall-e-3&#x60;, only &#x60;n&#x3D;1&#x60; is supported.
     * @param {CreateImageVariationResponseFormatEnum} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;. URLs are only valid for 60 minutes after the image has been generated.
     * @param {CreateImageVariationSizeEnum} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
     * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids). 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createImageVariation(image: File, model?: CreateImageEditRequestModel | null, n?: number | null, responseFormat?: CreateImageVariationResponseFormatEnum, size?: CreateImageVariationSizeEnum, user?: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).createImageVariation(image, model, n, responseFormat, size, user, options).then((request) => request(this.axios, this.basePath));
    }
}

export const CreateImageEditSizeEnum = {
    _256x256: '256x256',
    _512x512: '512x512',
    _1024x1024: '1024x1024'
} as const;
export type CreateImageEditSizeEnum = typeof CreateImageEditSizeEnum[keyof typeof CreateImageEditSizeEnum];
export const CreateImageEditResponseFormatEnum = {
    Url: 'url',
    B64Json: 'b64_json'
} as const;
export type CreateImageEditResponseFormatEnum = typeof CreateImageEditResponseFormatEnum[keyof typeof CreateImageEditResponseFormatEnum];
export const CreateImageVariationResponseFormatEnum = {
    Url: 'url',
    B64Json: 'b64_json'
} as const;
export type CreateImageVariationResponseFormatEnum = typeof CreateImageVariationResponseFormatEnum[keyof typeof CreateImageVariationResponseFormatEnum];
export const CreateImageVariationSizeEnum = {
    _256x256: '256x256',
    _512x512: '512x512',
    _1024x1024: '1024x1024'
} as const;
export type CreateImageVariationSizeEnum = typeof CreateImageVariationSizeEnum[keyof typeof CreateImageVariationSizeEnum];


/**
 * InvitesApi - axios parameter creator
 */
export const InvitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an invite. If the invite has already been accepted, it cannot be deleted.
         * @param {string} inviteId The ID of the invite to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvite: async (inviteId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('deleteInvite', 'inviteId', inviteId)
            const localVarPath = `/organization/invites/{invite_id}`
                .replace(`{${"invite_id"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an invite for a user to the organization. The invite must be accepted by the user before they have access to the organization.
         * @param {InviteRequest} inviteRequest The invite request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser: async (inviteRequest: InviteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteRequest' is not null or undefined
            assertParamExists('inviteUser', 'inviteRequest', inviteRequest)
            const localVarPath = `/organization/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of invites in the organization.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvites: async (limit?: number, after?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves an invite.
         * @param {string} inviteId The ID of the invite to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveInvite: async (inviteId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteId' is not null or undefined
            assertParamExists('retrieveInvite', 'inviteId', inviteId)
            const localVarPath = `/organization/invites/{invite_id}`
                .replace(`{${"invite_id"}}`, encodeURIComponent(String(inviteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitesApi - functional programming interface
 */
export const InvitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete an invite. If the invite has already been accepted, it cannot be deleted.
         * @param {string} inviteId The ID of the invite to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvite(inviteId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvite(inviteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitesApi.deleteInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an invite for a user to the organization. The invite must be accepted by the user before they have access to the organization.
         * @param {InviteRequest} inviteRequest The invite request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUser(inviteRequest: InviteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUser(inviteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitesApi.inviteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of invites in the organization.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInvites(limit?: number, after?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInvites(limit, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitesApi.listInvites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves an invite.
         * @param {string} inviteId The ID of the invite to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveInvite(inviteId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveInvite(inviteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvitesApi.retrieveInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvitesApi - factory interface
 */
export const InvitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete an invite. If the invite has already been accepted, it cannot be deleted.
         * @param {string} inviteId The ID of the invite to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvite(inviteId: string, options?: RawAxiosRequestConfig): AxiosPromise<InviteDeleteResponse> {
            return localVarFp.deleteInvite(inviteId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an invite for a user to the organization. The invite must be accepted by the user before they have access to the organization.
         * @param {InviteRequest} inviteRequest The invite request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser(inviteRequest: InviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<Invite> {
            return localVarFp.inviteUser(inviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of invites in the organization.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInvites(limit?: number, after?: string, options?: RawAxiosRequestConfig): AxiosPromise<InviteListResponse> {
            return localVarFp.listInvites(limit, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves an invite.
         * @param {string} inviteId The ID of the invite to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveInvite(inviteId: string, options?: RawAxiosRequestConfig): AxiosPromise<Invite> {
            return localVarFp.retrieveInvite(inviteId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitesApi - object-oriented interface
 */
export class InvitesApi extends BaseAPI {
    /**
     * 
     * @summary Delete an invite. If the invite has already been accepted, it cannot be deleted.
     * @param {string} inviteId The ID of the invite to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteInvite(inviteId: string, options?: RawAxiosRequestConfig) {
        return InvitesApiFp(this.configuration).deleteInvite(inviteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an invite for a user to the organization. The invite must be accepted by the user before they have access to the organization.
     * @param {InviteRequest} inviteRequest The invite request payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public inviteUser(inviteRequest: InviteRequest, options?: RawAxiosRequestConfig) {
        return InvitesApiFp(this.configuration).inviteUser(inviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of invites in the organization.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listInvites(limit?: number, after?: string, options?: RawAxiosRequestConfig) {
        return InvitesApiFp(this.configuration).listInvites(limit, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves an invite.
     * @param {string} inviteId The ID of the invite to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveInvite(inviteId: string, options?: RawAxiosRequestConfig) {
        return InvitesApiFp(this.configuration).retrieveInvite(inviteId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModelsApi - axios parameter creator
 */
export const ModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization to delete a model.
         * @param {string} model The model to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel: async (model: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'model' is not null or undefined
            assertParamExists('deleteModel', 'model', model)
            const localVarPath = `/models/{model}`
                .replace(`{${"model"}}`, encodeURIComponent(String(model)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @param {string} model The ID of the model to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveModel: async (model: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'model' is not null or undefined
            assertParamExists('retrieveModel', 'model', model)
            const localVarPath = `/models/{model}`
                .replace(`{${"model"}}`, encodeURIComponent(String(model)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelsApi - functional programming interface
 */
export const ModelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization to delete a model.
         * @param {string} model The model to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModel(model: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteModelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteModel(model, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelsApi.deleteModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModels(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListModelsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModels(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelsApi.listModels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @param {string} model The ID of the model to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveModel(model: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Model>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveModel(model, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelsApi.retrieveModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModelsApi - factory interface
 */
export const ModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization to delete a model.
         * @param {string} model The model to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel(model: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteModelResponse> {
            return localVarFp.deleteModel(model, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(options?: RawAxiosRequestConfig): AxiosPromise<ListModelsResponse> {
            return localVarFp.listModels(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @param {string} model The ID of the model to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveModel(model: string, options?: RawAxiosRequestConfig): AxiosPromise<Model> {
            return localVarFp.retrieveModel(model, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelsApi - object-oriented interface
 */
export class ModelsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a fine-tuned model. You must have the Owner role in your organization to delete a model.
     * @param {string} model The model to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteModel(model: string, options?: RawAxiosRequestConfig) {
        return ModelsApiFp(this.configuration).deleteModel(model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listModels(options?: RawAxiosRequestConfig) {
        return ModelsApiFp(this.configuration).listModels(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
     * @param {string} model The ID of the model to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveModel(model: string, options?: RawAxiosRequestConfig) {
        return ModelsApiFp(this.configuration).retrieveModel(model, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModerationsApi - axios parameter creator
 */
export const ModerationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Classifies if text and/or image inputs are potentially harmful. Learn more in the [moderation guide](/docs/guides/moderation). 
         * @param {CreateModerationRequest} createModerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModeration: async (createModerationRequest: CreateModerationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createModerationRequest' is not null or undefined
            assertParamExists('createModeration', 'createModerationRequest', createModerationRequest)
            const localVarPath = `/moderations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createModerationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModerationsApi - functional programming interface
 */
export const ModerationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModerationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Classifies if text and/or image inputs are potentially harmful. Learn more in the [moderation guide](/docs/guides/moderation). 
         * @param {CreateModerationRequest} createModerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModeration(createModerationRequest: CreateModerationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateModerationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createModeration(createModerationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModerationsApi.createModeration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModerationsApi - factory interface
 */
export const ModerationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModerationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Classifies if text and/or image inputs are potentially harmful. Learn more in the [moderation guide](/docs/guides/moderation). 
         * @param {CreateModerationRequest} createModerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModeration(createModerationRequest: CreateModerationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateModerationResponse> {
            return localVarFp.createModeration(createModerationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModerationsApi - object-oriented interface
 */
export class ModerationsApi extends BaseAPI {
    /**
     * 
     * @summary Classifies if text and/or image inputs are potentially harmful. Learn more in the [moderation guide](/docs/guides/moderation). 
     * @param {CreateModerationRequest} createModerationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createModeration(createModerationRequest: CreateModerationRequest, options?: RawAxiosRequestConfig) {
        return ModerationsApiFp(this.configuration).createModeration(createModerationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Archives a project in the organization. Archived projects cannot be used or updated.
         * @param {string} projectId The ID of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('archiveProject', 'projectId', projectId)
            const localVarPath = `/organization/projects/{project_id}/archive`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new project in the organization. Projects can be created and archived, but cannot be deleted.
         * @param {ProjectCreateRequest} projectCreateRequest The project create request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (projectCreateRequest: ProjectCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectCreateRequest' is not null or undefined
            assertParamExists('createProject', 'projectCreateRequest', projectCreateRequest)
            const localVarPath = `/organization/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new service account in the project. This also returns an unredacted API key for the service account.
         * @param {string} projectId The ID of the project.
         * @param {ProjectServiceAccountCreateRequest} projectServiceAccountCreateRequest The project service account create request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectServiceAccount: async (projectId: string, projectServiceAccountCreateRequest: ProjectServiceAccountCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectServiceAccount', 'projectId', projectId)
            // verify required parameter 'projectServiceAccountCreateRequest' is not null or undefined
            assertParamExists('createProjectServiceAccount', 'projectServiceAccountCreateRequest', projectServiceAccountCreateRequest)
            const localVarPath = `/organization/projects/{project_id}/service_accounts`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectServiceAccountCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a user to the project. Users must already be members of the organization to be added to a project.
         * @param {string} projectId The ID of the project.
         * @param {ProjectUserCreateRequest} projectUserCreateRequest The project user create request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectUser: async (projectId: string, projectUserCreateRequest: ProjectUserCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createProjectUser', 'projectId', projectId)
            // verify required parameter 'projectUserCreateRequest' is not null or undefined
            assertParamExists('createProjectUser', 'projectUserCreateRequest', projectUserCreateRequest)
            const localVarPath = `/organization/projects/{project_id}/users`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectUserCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an API key from the project.
         * @param {string} projectId The ID of the project.
         * @param {string} keyId The ID of the API key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectApiKey: async (projectId: string, keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectApiKey', 'projectId', projectId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('deleteProjectApiKey', 'keyId', keyId)
            const localVarPath = `/organization/projects/{project_id}/api_keys/{key_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a service account from the project.
         * @param {string} projectId The ID of the project.
         * @param {string} serviceAccountId The ID of the service account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectServiceAccount: async (projectId: string, serviceAccountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectServiceAccount', 'projectId', projectId)
            // verify required parameter 'serviceAccountId' is not null or undefined
            assertParamExists('deleteProjectServiceAccount', 'serviceAccountId', serviceAccountId)
            const localVarPath = `/organization/projects/{project_id}/service_accounts/{service_account_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"service_account_id"}}`, encodeURIComponent(String(serviceAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a user from the project.
         * @param {string} projectId The ID of the project.
         * @param {string} userId The ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectUser: async (projectId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProjectUser', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteProjectUser', 'userId', userId)
            const localVarPath = `/organization/projects/{project_id}/users/{user_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of API keys in the project.
         * @param {string} projectId The ID of the project.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectApiKeys: async (projectId: string, limit?: number, after?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectApiKeys', 'projectId', projectId)
            const localVarPath = `/organization/projects/{project_id}/api_keys`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the rate limits per model for a project.
         * @param {string} projectId The ID of the project.
         * @param {number} [limit] A limit on the number of objects to be returned. The default is 100. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, beginning with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectRateLimits: async (projectId: string, limit?: number, after?: string, before?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectRateLimits', 'projectId', projectId)
            const localVarPath = `/organization/projects/{project_id}/rate_limits`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of service accounts in the project.
         * @param {string} projectId The ID of the project.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectServiceAccounts: async (projectId: string, limit?: number, after?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectServiceAccounts', 'projectId', projectId)
            const localVarPath = `/organization/projects/{project_id}/service_accounts`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of users in the project.
         * @param {string} projectId The ID of the project.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectUsers: async (projectId: string, limit?: number, after?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listProjectUsers', 'projectId', projectId)
            const localVarPath = `/organization/projects/{project_id}/users`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of projects.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {boolean} [includeArchived] If &#x60;true&#x60; returns all projects including those that have been &#x60;archived&#x60;. Archived projects are not included by default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects: async (limit?: number, after?: string, includeArchived?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (includeArchived !== undefined) {
                localVarQueryParameter['include_archived'] = includeArchived;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a project in the organization.
         * @param {string} projectId The ID of the project.
         * @param {ProjectUpdateRequest} projectUpdateRequest The project update request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProject: async (projectId: string, projectUpdateRequest: ProjectUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('modifyProject', 'projectId', projectId)
            // verify required parameter 'projectUpdateRequest' is not null or undefined
            assertParamExists('modifyProject', 'projectUpdateRequest', projectUpdateRequest)
            const localVarPath = `/organization/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a user\'s role in the project.
         * @param {string} projectId The ID of the project.
         * @param {string} userId The ID of the user.
         * @param {ProjectUserUpdateRequest} projectUserUpdateRequest The project user update request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProjectUser: async (projectId: string, userId: string, projectUserUpdateRequest: ProjectUserUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('modifyProjectUser', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('modifyProjectUser', 'userId', userId)
            // verify required parameter 'projectUserUpdateRequest' is not null or undefined
            assertParamExists('modifyProjectUser', 'projectUserUpdateRequest', projectUserUpdateRequest)
            const localVarPath = `/organization/projects/{project_id}/users/{user_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectUserUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a project.
         * @param {string} projectId The ID of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProject: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('retrieveProject', 'projectId', projectId)
            const localVarPath = `/organization/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves an API key in the project.
         * @param {string} projectId The ID of the project.
         * @param {string} keyId The ID of the API key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProjectApiKey: async (projectId: string, keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('retrieveProjectApiKey', 'projectId', projectId)
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('retrieveProjectApiKey', 'keyId', keyId)
            const localVarPath = `/organization/projects/{project_id}/api_keys/{key_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a service account in the project.
         * @param {string} projectId The ID of the project.
         * @param {string} serviceAccountId The ID of the service account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProjectServiceAccount: async (projectId: string, serviceAccountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('retrieveProjectServiceAccount', 'projectId', projectId)
            // verify required parameter 'serviceAccountId' is not null or undefined
            assertParamExists('retrieveProjectServiceAccount', 'serviceAccountId', serviceAccountId)
            const localVarPath = `/organization/projects/{project_id}/service_accounts/{service_account_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"service_account_id"}}`, encodeURIComponent(String(serviceAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a user in the project.
         * @param {string} projectId The ID of the project.
         * @param {string} userId The ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProjectUser: async (projectId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('retrieveProjectUser', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('retrieveProjectUser', 'userId', userId)
            const localVarPath = `/organization/projects/{project_id}/users/{user_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a project rate limit.
         * @param {string} projectId The ID of the project.
         * @param {string} rateLimitId The ID of the rate limit.
         * @param {ProjectRateLimitUpdateRequest} projectRateLimitUpdateRequest The project rate limit update request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectRateLimits: async (projectId: string, rateLimitId: string, projectRateLimitUpdateRequest: ProjectRateLimitUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProjectRateLimits', 'projectId', projectId)
            // verify required parameter 'rateLimitId' is not null or undefined
            assertParamExists('updateProjectRateLimits', 'rateLimitId', rateLimitId)
            // verify required parameter 'projectRateLimitUpdateRequest' is not null or undefined
            assertParamExists('updateProjectRateLimits', 'projectRateLimitUpdateRequest', projectRateLimitUpdateRequest)
            const localVarPath = `/organization/projects/{project_id}/rate_limits/{rate_limit_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"rate_limit_id"}}`, encodeURIComponent(String(rateLimitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectRateLimitUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Archives a project in the organization. Archived projects cannot be used or updated.
         * @param {string} projectId The ID of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveProject(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveProject(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.archiveProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new project in the organization. Projects can be created and archived, but cannot be deleted.
         * @param {ProjectCreateRequest} projectCreateRequest The project create request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(projectCreateRequest: ProjectCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(projectCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.createProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a new service account in the project. This also returns an unredacted API key for the service account.
         * @param {string} projectId The ID of the project.
         * @param {ProjectServiceAccountCreateRequest} projectServiceAccountCreateRequest The project service account create request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectServiceAccount(projectId: string, projectServiceAccountCreateRequest: ProjectServiceAccountCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectServiceAccountCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectServiceAccount(projectId, projectServiceAccountCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.createProjectServiceAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Adds a user to the project. Users must already be members of the organization to be added to a project.
         * @param {string} projectId The ID of the project.
         * @param {ProjectUserCreateRequest} projectUserCreateRequest The project user create request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProjectUser(projectId: string, projectUserCreateRequest: ProjectUserCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProjectUser(projectId, projectUserCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.createProjectUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes an API key from the project.
         * @param {string} projectId The ID of the project.
         * @param {string} keyId The ID of the API key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectApiKey(projectId: string, keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectApiKeyDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectApiKey(projectId, keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.deleteProjectApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a service account from the project.
         * @param {string} projectId The ID of the project.
         * @param {string} serviceAccountId The ID of the service account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectServiceAccount(projectId: string, serviceAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectServiceAccountDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectServiceAccount(projectId, serviceAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.deleteProjectServiceAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a user from the project.
         * @param {string} projectId The ID of the project.
         * @param {string} userId The ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProjectUser(projectId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectUserDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProjectUser(projectId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.deleteProjectUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of API keys in the project.
         * @param {string} projectId The ID of the project.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectApiKeys(projectId: string, limit?: number, after?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectApiKeyListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectApiKeys(projectId, limit, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.listProjectApiKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the rate limits per model for a project.
         * @param {string} projectId The ID of the project.
         * @param {number} [limit] A limit on the number of objects to be returned. The default is 100. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, beginning with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectRateLimits(projectId: string, limit?: number, after?: string, before?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectRateLimitListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectRateLimits(projectId, limit, after, before, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.listProjectRateLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of service accounts in the project.
         * @param {string} projectId The ID of the project.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectServiceAccounts(projectId: string, limit?: number, after?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectServiceAccountListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectServiceAccounts(projectId, limit, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.listProjectServiceAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of users in the project.
         * @param {string} projectId The ID of the project.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjectUsers(projectId: string, limit?: number, after?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectUserListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjectUsers(projectId, limit, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.listProjectUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of projects.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {boolean} [includeArchived] If &#x60;true&#x60; returns all projects including those that have been &#x60;archived&#x60;. Archived projects are not included by default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProjects(limit?: number, after?: string, includeArchived?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProjects(limit, after, includeArchived, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.listProjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Modifies a project in the organization.
         * @param {string} projectId The ID of the project.
         * @param {ProjectUpdateRequest} projectUpdateRequest The project update request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyProject(projectId: string, projectUpdateRequest: ProjectUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyProject(projectId, projectUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.modifyProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Modifies a user\'s role in the project.
         * @param {string} projectId The ID of the project.
         * @param {string} userId The ID of the user.
         * @param {ProjectUserUpdateRequest} projectUserUpdateRequest The project user update request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyProjectUser(projectId: string, userId: string, projectUserUpdateRequest: ProjectUserUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyProjectUser(projectId, userId, projectUserUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.modifyProjectUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a project.
         * @param {string} projectId The ID of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveProject(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveProject(projectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.retrieveProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves an API key in the project.
         * @param {string} projectId The ID of the project.
         * @param {string} keyId The ID of the API key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveProjectApiKey(projectId: string, keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectApiKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveProjectApiKey(projectId, keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.retrieveProjectApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a service account in the project.
         * @param {string} projectId The ID of the project.
         * @param {string} serviceAccountId The ID of the service account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveProjectServiceAccount(projectId: string, serviceAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectServiceAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveProjectServiceAccount(projectId, serviceAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.retrieveProjectServiceAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a user in the project.
         * @param {string} projectId The ID of the project.
         * @param {string} userId The ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveProjectUser(projectId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveProjectUser(projectId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.retrieveProjectUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a project rate limit.
         * @param {string} projectId The ID of the project.
         * @param {string} rateLimitId The ID of the rate limit.
         * @param {ProjectRateLimitUpdateRequest} projectRateLimitUpdateRequest The project rate limit update request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProjectRateLimits(projectId: string, rateLimitId: string, projectRateLimitUpdateRequest: ProjectRateLimitUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectRateLimit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProjectRateLimits(projectId, rateLimitId, projectRateLimitUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.updateProjectRateLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Archives a project in the organization. Archived projects cannot be used or updated.
         * @param {string} projectId The ID of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProject(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.archiveProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new project in the organization. Projects can be created and archived, but cannot be deleted.
         * @param {ProjectCreateRequest} projectCreateRequest The project create request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(projectCreateRequest: ProjectCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.createProject(projectCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new service account in the project. This also returns an unredacted API key for the service account.
         * @param {string} projectId The ID of the project.
         * @param {ProjectServiceAccountCreateRequest} projectServiceAccountCreateRequest The project service account create request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectServiceAccount(projectId: string, projectServiceAccountCreateRequest: ProjectServiceAccountCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectServiceAccountCreateResponse> {
            return localVarFp.createProjectServiceAccount(projectId, projectServiceAccountCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a user to the project. Users must already be members of the organization to be added to a project.
         * @param {string} projectId The ID of the project.
         * @param {ProjectUserCreateRequest} projectUserCreateRequest The project user create request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectUser(projectId: string, projectUserCreateRequest: ProjectUserCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectUser> {
            return localVarFp.createProjectUser(projectId, projectUserCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an API key from the project.
         * @param {string} projectId The ID of the project.
         * @param {string} keyId The ID of the API key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectApiKey(projectId: string, keyId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectApiKeyDeleteResponse> {
            return localVarFp.deleteProjectApiKey(projectId, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a service account from the project.
         * @param {string} projectId The ID of the project.
         * @param {string} serviceAccountId The ID of the service account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectServiceAccount(projectId: string, serviceAccountId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectServiceAccountDeleteResponse> {
            return localVarFp.deleteProjectServiceAccount(projectId, serviceAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a user from the project.
         * @param {string} projectId The ID of the project.
         * @param {string} userId The ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectUser(projectId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectUserDeleteResponse> {
            return localVarFp.deleteProjectUser(projectId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of API keys in the project.
         * @param {string} projectId The ID of the project.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectApiKeys(projectId: string, limit?: number, after?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectApiKeyListResponse> {
            return localVarFp.listProjectApiKeys(projectId, limit, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the rate limits per model for a project.
         * @param {string} projectId The ID of the project.
         * @param {number} [limit] A limit on the number of objects to be returned. The default is 100. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, beginning with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectRateLimits(projectId: string, limit?: number, after?: string, before?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectRateLimitListResponse> {
            return localVarFp.listProjectRateLimits(projectId, limit, after, before, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of service accounts in the project.
         * @param {string} projectId The ID of the project.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectServiceAccounts(projectId: string, limit?: number, after?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectServiceAccountListResponse> {
            return localVarFp.listProjectServiceAccounts(projectId, limit, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of users in the project.
         * @param {string} projectId The ID of the project.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjectUsers(projectId: string, limit?: number, after?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectUserListResponse> {
            return localVarFp.listProjectUsers(projectId, limit, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of projects.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {boolean} [includeArchived] If &#x60;true&#x60; returns all projects including those that have been &#x60;archived&#x60;. Archived projects are not included by default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProjects(limit?: number, after?: string, includeArchived?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ProjectListResponse> {
            return localVarFp.listProjects(limit, after, includeArchived, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modifies a project in the organization.
         * @param {string} projectId The ID of the project.
         * @param {ProjectUpdateRequest} projectUpdateRequest The project update request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProject(projectId: string, projectUpdateRequest: ProjectUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.modifyProject(projectId, projectUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modifies a user\'s role in the project.
         * @param {string} projectId The ID of the project.
         * @param {string} userId The ID of the user.
         * @param {ProjectUserUpdateRequest} projectUserUpdateRequest The project user update request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProjectUser(projectId: string, userId: string, projectUserUpdateRequest: ProjectUserUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectUser> {
            return localVarFp.modifyProjectUser(projectId, userId, projectUserUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a project.
         * @param {string} projectId The ID of the project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProject(projectId: string, options?: RawAxiosRequestConfig): AxiosPromise<Project> {
            return localVarFp.retrieveProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves an API key in the project.
         * @param {string} projectId The ID of the project.
         * @param {string} keyId The ID of the API key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProjectApiKey(projectId: string, keyId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectApiKey> {
            return localVarFp.retrieveProjectApiKey(projectId, keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a service account in the project.
         * @param {string} projectId The ID of the project.
         * @param {string} serviceAccountId The ID of the service account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProjectServiceAccount(projectId: string, serviceAccountId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectServiceAccount> {
            return localVarFp.retrieveProjectServiceAccount(projectId, serviceAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a user in the project.
         * @param {string} projectId The ID of the project.
         * @param {string} userId The ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProjectUser(projectId: string, userId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProjectUser> {
            return localVarFp.retrieveProjectUser(projectId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a project rate limit.
         * @param {string} projectId The ID of the project.
         * @param {string} rateLimitId The ID of the rate limit.
         * @param {ProjectRateLimitUpdateRequest} projectRateLimitUpdateRequest The project rate limit update request payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectRateLimits(projectId: string, rateLimitId: string, projectRateLimitUpdateRequest: ProjectRateLimitUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProjectRateLimit> {
            return localVarFp.updateProjectRateLimits(projectId, rateLimitId, projectRateLimitUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Archives a project in the organization. Archived projects cannot be used or updated.
     * @param {string} projectId The ID of the project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public archiveProject(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).archiveProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new project in the organization. Projects can be created and archived, but cannot be deleted.
     * @param {ProjectCreateRequest} projectCreateRequest The project create request payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProject(projectCreateRequest: ProjectCreateRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProject(projectCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new service account in the project. This also returns an unredacted API key for the service account.
     * @param {string} projectId The ID of the project.
     * @param {ProjectServiceAccountCreateRequest} projectServiceAccountCreateRequest The project service account create request payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProjectServiceAccount(projectId: string, projectServiceAccountCreateRequest: ProjectServiceAccountCreateRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProjectServiceAccount(projectId, projectServiceAccountCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a user to the project. Users must already be members of the organization to be added to a project.
     * @param {string} projectId The ID of the project.
     * @param {ProjectUserCreateRequest} projectUserCreateRequest The project user create request payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProjectUser(projectId: string, projectUserCreateRequest: ProjectUserCreateRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).createProjectUser(projectId, projectUserCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an API key from the project.
     * @param {string} projectId The ID of the project.
     * @param {string} keyId The ID of the API key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteProjectApiKey(projectId: string, keyId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteProjectApiKey(projectId, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a service account from the project.
     * @param {string} projectId The ID of the project.
     * @param {string} serviceAccountId The ID of the service account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteProjectServiceAccount(projectId: string, serviceAccountId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteProjectServiceAccount(projectId, serviceAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a user from the project.
     * @param {string} projectId The ID of the project.
     * @param {string} userId The ID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteProjectUser(projectId: string, userId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).deleteProjectUser(projectId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of API keys in the project.
     * @param {string} projectId The ID of the project.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProjectApiKeys(projectId: string, limit?: number, after?: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProjectApiKeys(projectId, limit, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the rate limits per model for a project.
     * @param {string} projectId The ID of the project.
     * @param {number} [limit] A limit on the number of objects to be returned. The default is 100. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, beginning with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProjectRateLimits(projectId: string, limit?: number, after?: string, before?: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProjectRateLimits(projectId, limit, after, before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of service accounts in the project.
     * @param {string} projectId The ID of the project.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProjectServiceAccounts(projectId: string, limit?: number, after?: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProjectServiceAccounts(projectId, limit, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of users in the project.
     * @param {string} projectId The ID of the project.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProjectUsers(projectId: string, limit?: number, after?: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProjectUsers(projectId, limit, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of projects.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {boolean} [includeArchived] If &#x60;true&#x60; returns all projects including those that have been &#x60;archived&#x60;. Archived projects are not included by default.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProjects(limit?: number, after?: string, includeArchived?: boolean, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).listProjects(limit, after, includeArchived, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modifies a project in the organization.
     * @param {string} projectId The ID of the project.
     * @param {ProjectUpdateRequest} projectUpdateRequest The project update request payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public modifyProject(projectId: string, projectUpdateRequest: ProjectUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).modifyProject(projectId, projectUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modifies a user\'s role in the project.
     * @param {string} projectId The ID of the project.
     * @param {string} userId The ID of the user.
     * @param {ProjectUserUpdateRequest} projectUserUpdateRequest The project user update request payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public modifyProjectUser(projectId: string, userId: string, projectUserUpdateRequest: ProjectUserUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).modifyProjectUser(projectId, userId, projectUserUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a project.
     * @param {string} projectId The ID of the project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveProject(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).retrieveProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves an API key in the project.
     * @param {string} projectId The ID of the project.
     * @param {string} keyId The ID of the API key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveProjectApiKey(projectId: string, keyId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).retrieveProjectApiKey(projectId, keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a service account in the project.
     * @param {string} projectId The ID of the project.
     * @param {string} serviceAccountId The ID of the service account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveProjectServiceAccount(projectId: string, serviceAccountId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).retrieveProjectServiceAccount(projectId, serviceAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a user in the project.
     * @param {string} projectId The ID of the project.
     * @param {string} userId The ID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveProjectUser(projectId: string, userId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).retrieveProjectUser(projectId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a project rate limit.
     * @param {string} projectId The ID of the project.
     * @param {string} rateLimitId The ID of the rate limit.
     * @param {ProjectRateLimitUpdateRequest} projectRateLimitUpdateRequest The project rate limit update request payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateProjectRateLimits(projectId: string, rateLimitId: string, projectRateLimitUpdateRequest: ProjectRateLimitUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).updateProjectRateLimits(projectId, rateLimitId, projectRateLimitUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RealtimeApi - axios parameter creator
 */
export const RealtimeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an ephemeral API token for use in client-side applications with the Realtime API. Can be configured with the same session parameters as the `session.update` client event.  It responds with a session object, plus a `client_secret` key which contains a usable ephemeral API token that can be used to authenticate browser clients for the Realtime API. 
         * @param {RealtimeSessionCreateRequest} realtimeSessionCreateRequest Create an ephemeral API key with the given session configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRealtimeSession: async (realtimeSessionCreateRequest: RealtimeSessionCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'realtimeSessionCreateRequest' is not null or undefined
            assertParamExists('createRealtimeSession', 'realtimeSessionCreateRequest', realtimeSessionCreateRequest)
            const localVarPath = `/realtime/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(realtimeSessionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RealtimeApi - functional programming interface
 */
export const RealtimeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RealtimeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an ephemeral API token for use in client-side applications with the Realtime API. Can be configured with the same session parameters as the `session.update` client event.  It responds with a session object, plus a `client_secret` key which contains a usable ephemeral API token that can be used to authenticate browser clients for the Realtime API. 
         * @param {RealtimeSessionCreateRequest} realtimeSessionCreateRequest Create an ephemeral API key with the given session configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRealtimeSession(realtimeSessionCreateRequest: RealtimeSessionCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealtimeSessionCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRealtimeSession(realtimeSessionCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealtimeApi.createRealtimeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RealtimeApi - factory interface
 */
export const RealtimeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RealtimeApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an ephemeral API token for use in client-side applications with the Realtime API. Can be configured with the same session parameters as the `session.update` client event.  It responds with a session object, plus a `client_secret` key which contains a usable ephemeral API token that can be used to authenticate browser clients for the Realtime API. 
         * @param {RealtimeSessionCreateRequest} realtimeSessionCreateRequest Create an ephemeral API key with the given session configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRealtimeSession(realtimeSessionCreateRequest: RealtimeSessionCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<RealtimeSessionCreateResponse> {
            return localVarFp.createRealtimeSession(realtimeSessionCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RealtimeApi - object-oriented interface
 */
export class RealtimeApi extends BaseAPI {
    /**
     * 
     * @summary Create an ephemeral API token for use in client-side applications with the Realtime API. Can be configured with the same session parameters as the `session.update` client event.  It responds with a session object, plus a `client_secret` key which contains a usable ephemeral API token that can be used to authenticate browser clients for the Realtime API. 
     * @param {RealtimeSessionCreateRequest} realtimeSessionCreateRequest Create an ephemeral API key with the given session configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRealtimeSession(realtimeSessionCreateRequest: RealtimeSessionCreateRequest, options?: RawAxiosRequestConfig) {
        return RealtimeApiFp(this.configuration).createRealtimeSession(realtimeSessionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UploadsApi - axios parameter creator
 */
export const UploadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a [Part](/docs/api-reference/uploads/part-object) to an [Upload](/docs/api-reference/uploads/object) object. A Part represents a chunk of bytes from the file you are trying to upload.   Each Part can be at most 64 MB, and you can add Parts until you hit the Upload maximum of 8 GB.  It is possible to add multiple Parts in parallel. You can decide the intended order of the Parts when you [complete the Upload](/docs/api-reference/uploads/complete). 
         * @param {string} uploadId The ID of the Upload. 
         * @param {File} data The chunk of bytes for this Part. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUploadPart: async (uploadId: string, data: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadId' is not null or undefined
            assertParamExists('addUploadPart', 'uploadId', uploadId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('addUploadPart', 'data', data)
            const localVarPath = `/uploads/{upload_id}/parts`
                .replace(`{${"upload_id"}}`, encodeURIComponent(String(uploadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels the Upload. No Parts may be added after an Upload is cancelled. 
         * @param {string} uploadId The ID of the Upload. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelUpload: async (uploadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadId' is not null or undefined
            assertParamExists('cancelUpload', 'uploadId', uploadId)
            const localVarPath = `/uploads/{upload_id}/cancel`
                .replace(`{${"upload_id"}}`, encodeURIComponent(String(uploadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Completes the [Upload](/docs/api-reference/uploads/object).   Within the returned Upload object, there is a nested [File](/docs/api-reference/files/object) object that is ready to use in the rest of the platform.  You can specify the order of the Parts by passing in an ordered list of the Part IDs.  The number of bytes uploaded upon completion must match the number of bytes initially specified when creating the Upload object. No Parts may be added after an Upload is completed. 
         * @param {string} uploadId The ID of the Upload. 
         * @param {CompleteUploadRequest} completeUploadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeUpload: async (uploadId: string, completeUploadRequest: CompleteUploadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadId' is not null or undefined
            assertParamExists('completeUpload', 'uploadId', uploadId)
            // verify required parameter 'completeUploadRequest' is not null or undefined
            assertParamExists('completeUpload', 'completeUploadRequest', completeUploadRequest)
            const localVarPath = `/uploads/{upload_id}/complete`
                .replace(`{${"upload_id"}}`, encodeURIComponent(String(uploadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeUploadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an intermediate [Upload](/docs/api-reference/uploads/object) object that you can add [Parts](/docs/api-reference/uploads/part-object) to. Currently, an Upload can accept at most 8 GB in total and expires after an hour after you create it.  Once you complete the Upload, we will create a [File](/docs/api-reference/files/object) object that contains all the parts you uploaded. This File is usable in the rest of our platform as a regular File object.  For certain `purpose`s, the correct `mime_type` must be specified. Please refer to documentation for the supported MIME types for your use case: - [Assistants](/docs/assistants/tools/file-search#supported-files)  For guidance on the proper filename extensions for each purpose, please follow the documentation on [creating a File](/docs/api-reference/files/create). 
         * @param {CreateUploadRequest} createUploadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpload: async (createUploadRequest: CreateUploadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUploadRequest' is not null or undefined
            assertParamExists('createUpload', 'createUploadRequest', createUploadRequest)
            const localVarPath = `/uploads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUploadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadsApi - functional programming interface
 */
export const UploadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds a [Part](/docs/api-reference/uploads/part-object) to an [Upload](/docs/api-reference/uploads/object) object. A Part represents a chunk of bytes from the file you are trying to upload.   Each Part can be at most 64 MB, and you can add Parts until you hit the Upload maximum of 8 GB.  It is possible to add multiple Parts in parallel. You can decide the intended order of the Parts when you [complete the Upload](/docs/api-reference/uploads/complete). 
         * @param {string} uploadId The ID of the Upload. 
         * @param {File} data The chunk of bytes for this Part. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUploadPart(uploadId: string, data: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadPart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUploadPart(uploadId, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadsApi.addUploadPart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cancels the Upload. No Parts may be added after an Upload is cancelled. 
         * @param {string} uploadId The ID of the Upload. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelUpload(uploadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Upload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelUpload(uploadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadsApi.cancelUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Completes the [Upload](/docs/api-reference/uploads/object).   Within the returned Upload object, there is a nested [File](/docs/api-reference/files/object) object that is ready to use in the rest of the platform.  You can specify the order of the Parts by passing in an ordered list of the Part IDs.  The number of bytes uploaded upon completion must match the number of bytes initially specified when creating the Upload object. No Parts may be added after an Upload is completed. 
         * @param {string} uploadId The ID of the Upload. 
         * @param {CompleteUploadRequest} completeUploadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeUpload(uploadId: string, completeUploadRequest: CompleteUploadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Upload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeUpload(uploadId, completeUploadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadsApi.completeUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates an intermediate [Upload](/docs/api-reference/uploads/object) object that you can add [Parts](/docs/api-reference/uploads/part-object) to. Currently, an Upload can accept at most 8 GB in total and expires after an hour after you create it.  Once you complete the Upload, we will create a [File](/docs/api-reference/files/object) object that contains all the parts you uploaded. This File is usable in the rest of our platform as a regular File object.  For certain `purpose`s, the correct `mime_type` must be specified. Please refer to documentation for the supported MIME types for your use case: - [Assistants](/docs/assistants/tools/file-search#supported-files)  For guidance on the proper filename extensions for each purpose, please follow the documentation on [creating a File](/docs/api-reference/files/create). 
         * @param {CreateUploadRequest} createUploadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUpload(createUploadRequest: CreateUploadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Upload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUpload(createUploadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadsApi.createUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UploadsApi - factory interface
 */
export const UploadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadsApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds a [Part](/docs/api-reference/uploads/part-object) to an [Upload](/docs/api-reference/uploads/object) object. A Part represents a chunk of bytes from the file you are trying to upload.   Each Part can be at most 64 MB, and you can add Parts until you hit the Upload maximum of 8 GB.  It is possible to add multiple Parts in parallel. You can decide the intended order of the Parts when you [complete the Upload](/docs/api-reference/uploads/complete). 
         * @param {string} uploadId The ID of the Upload. 
         * @param {File} data The chunk of bytes for this Part. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUploadPart(uploadId: string, data: File, options?: RawAxiosRequestConfig): AxiosPromise<UploadPart> {
            return localVarFp.addUploadPart(uploadId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancels the Upload. No Parts may be added after an Upload is cancelled. 
         * @param {string} uploadId The ID of the Upload. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelUpload(uploadId: string, options?: RawAxiosRequestConfig): AxiosPromise<Upload> {
            return localVarFp.cancelUpload(uploadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Completes the [Upload](/docs/api-reference/uploads/object).   Within the returned Upload object, there is a nested [File](/docs/api-reference/files/object) object that is ready to use in the rest of the platform.  You can specify the order of the Parts by passing in an ordered list of the Part IDs.  The number of bytes uploaded upon completion must match the number of bytes initially specified when creating the Upload object. No Parts may be added after an Upload is completed. 
         * @param {string} uploadId The ID of the Upload. 
         * @param {CompleteUploadRequest} completeUploadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeUpload(uploadId: string, completeUploadRequest: CompleteUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<Upload> {
            return localVarFp.completeUpload(uploadId, completeUploadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an intermediate [Upload](/docs/api-reference/uploads/object) object that you can add [Parts](/docs/api-reference/uploads/part-object) to. Currently, an Upload can accept at most 8 GB in total and expires after an hour after you create it.  Once you complete the Upload, we will create a [File](/docs/api-reference/files/object) object that contains all the parts you uploaded. This File is usable in the rest of our platform as a regular File object.  For certain `purpose`s, the correct `mime_type` must be specified. Please refer to documentation for the supported MIME types for your use case: - [Assistants](/docs/assistants/tools/file-search#supported-files)  For guidance on the proper filename extensions for each purpose, please follow the documentation on [creating a File](/docs/api-reference/files/create). 
         * @param {CreateUploadRequest} createUploadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpload(createUploadRequest: CreateUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<Upload> {
            return localVarFp.createUpload(createUploadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadsApi - object-oriented interface
 */
export class UploadsApi extends BaseAPI {
    /**
     * 
     * @summary Adds a [Part](/docs/api-reference/uploads/part-object) to an [Upload](/docs/api-reference/uploads/object) object. A Part represents a chunk of bytes from the file you are trying to upload.   Each Part can be at most 64 MB, and you can add Parts until you hit the Upload maximum of 8 GB.  It is possible to add multiple Parts in parallel. You can decide the intended order of the Parts when you [complete the Upload](/docs/api-reference/uploads/complete). 
     * @param {string} uploadId The ID of the Upload. 
     * @param {File} data The chunk of bytes for this Part. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addUploadPart(uploadId: string, data: File, options?: RawAxiosRequestConfig) {
        return UploadsApiFp(this.configuration).addUploadPart(uploadId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancels the Upload. No Parts may be added after an Upload is cancelled. 
     * @param {string} uploadId The ID of the Upload. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelUpload(uploadId: string, options?: RawAxiosRequestConfig) {
        return UploadsApiFp(this.configuration).cancelUpload(uploadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Completes the [Upload](/docs/api-reference/uploads/object).   Within the returned Upload object, there is a nested [File](/docs/api-reference/files/object) object that is ready to use in the rest of the platform.  You can specify the order of the Parts by passing in an ordered list of the Part IDs.  The number of bytes uploaded upon completion must match the number of bytes initially specified when creating the Upload object. No Parts may be added after an Upload is completed. 
     * @param {string} uploadId The ID of the Upload. 
     * @param {CompleteUploadRequest} completeUploadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public completeUpload(uploadId: string, completeUploadRequest: CompleteUploadRequest, options?: RawAxiosRequestConfig) {
        return UploadsApiFp(this.configuration).completeUpload(uploadId, completeUploadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an intermediate [Upload](/docs/api-reference/uploads/object) object that you can add [Parts](/docs/api-reference/uploads/part-object) to. Currently, an Upload can accept at most 8 GB in total and expires after an hour after you create it.  Once you complete the Upload, we will create a [File](/docs/api-reference/files/object) object that contains all the parts you uploaded. This File is usable in the rest of our platform as a regular File object.  For certain `purpose`s, the correct `mime_type` must be specified. Please refer to documentation for the supported MIME types for your use case: - [Assistants](/docs/assistants/tools/file-search#supported-files)  For guidance on the proper filename extensions for each purpose, please follow the documentation on [creating a File](/docs/api-reference/files/create). 
     * @param {CreateUploadRequest} createUploadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUpload(createUploadRequest: CreateUploadRequest, options?: RawAxiosRequestConfig) {
        return UploadsApiFp(this.configuration).createUpload(createUploadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsageApi - axios parameter creator
 */
export const UsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get audio speeches usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageAudioSpeechesBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {Array<UsageAudioSpeechesGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageAudioSpeeches: async (startTime: number, endTime?: number, bucketWidth?: UsageAudioSpeechesBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageAudioSpeechesGroupByEnum>, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('usageAudioSpeeches', 'startTime', startTime)
            const localVarPath = `/organization/usage/audio_speeches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = bucketWidth;
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }

            if (apiKeyIds) {
                localVarQueryParameter['api_key_ids'] = apiKeyIds;
            }

            if (models) {
                localVarQueryParameter['models'] = models;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get audio transcriptions usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageAudioTranscriptionsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {Array<UsageAudioTranscriptionsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageAudioTranscriptions: async (startTime: number, endTime?: number, bucketWidth?: UsageAudioTranscriptionsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageAudioTranscriptionsGroupByEnum>, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('usageAudioTranscriptions', 'startTime', startTime)
            const localVarPath = `/organization/usage/audio_transcriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = bucketWidth;
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }

            if (apiKeyIds) {
                localVarQueryParameter['api_key_ids'] = apiKeyIds;
            }

            if (models) {
                localVarQueryParameter['models'] = models;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get code interpreter sessions usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageCodeInterpreterSessionsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<UsageCodeInterpreterSessionsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageCodeInterpreterSessions: async (startTime: number, endTime?: number, bucketWidth?: UsageCodeInterpreterSessionsBucketWidthEnum, projectIds?: Array<string>, groupBy?: Array<UsageCodeInterpreterSessionsGroupByEnum>, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('usageCodeInterpreterSessions', 'startTime', startTime)
            const localVarPath = `/organization/usage/code_interpreter_sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = bucketWidth;
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get completions usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageCompletionsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {boolean} [batch] If &#x60;true&#x60;, return batch jobs only. If &#x60;false&#x60;, return non-batch jobs only. By default, return both. 
         * @param {Array<UsageCompletionsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;batch&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageCompletions: async (startTime: number, endTime?: number, bucketWidth?: UsageCompletionsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, batch?: boolean, groupBy?: Array<UsageCompletionsGroupByEnum>, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('usageCompletions', 'startTime', startTime)
            const localVarPath = `/organization/usage/completions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = bucketWidth;
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }

            if (apiKeyIds) {
                localVarQueryParameter['api_key_ids'] = apiKeyIds;
            }

            if (models) {
                localVarQueryParameter['models'] = models;
            }

            if (batch !== undefined) {
                localVarQueryParameter['batch'] = batch;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get costs details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageCostsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently only &#x60;1d&#x60; is supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only costs for these projects.
         * @param {Array<UsageCostsGroupByEnum>} [groupBy] Group the costs by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;line_item&#x60; and any combination of them.
         * @param {number} [limit] A limit on the number of buckets to be returned. Limit can range between 1 and 180, and the default is 7. 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageCosts: async (startTime: number, endTime?: number, bucketWidth?: UsageCostsBucketWidthEnum, projectIds?: Array<string>, groupBy?: Array<UsageCostsGroupByEnum>, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('usageCosts', 'startTime', startTime)
            const localVarPath = `/organization/costs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = bucketWidth;
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get embeddings usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageEmbeddingsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {Array<UsageEmbeddingsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageEmbeddings: async (startTime: number, endTime?: number, bucketWidth?: UsageEmbeddingsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageEmbeddingsGroupByEnum>, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('usageEmbeddings', 'startTime', startTime)
            const localVarPath = `/organization/usage/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = bucketWidth;
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }

            if (apiKeyIds) {
                localVarQueryParameter['api_key_ids'] = apiKeyIds;
            }

            if (models) {
                localVarQueryParameter['models'] = models;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get images usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageImagesBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<UsageImagesSourcesEnum>} [sources] Return only usages for these sources. Possible values are &#x60;image.generation&#x60;, &#x60;image.edit&#x60;, &#x60;image.variation&#x60; or any combination of them.
         * @param {Array<UsageImagesSizesEnum>} [sizes] Return only usages for these image sizes. Possible values are &#x60;256x256&#x60;, &#x60;512x512&#x60;, &#x60;1024x1024&#x60;, &#x60;1792x1792&#x60;, &#x60;1024x1792&#x60; or any combination of them.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {Array<UsageImagesGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;size&#x60;, &#x60;source&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageImages: async (startTime: number, endTime?: number, bucketWidth?: UsageImagesBucketWidthEnum, sources?: Array<UsageImagesSourcesEnum>, sizes?: Array<UsageImagesSizesEnum>, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageImagesGroupByEnum>, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('usageImages', 'startTime', startTime)
            const localVarPath = `/organization/usage/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = bucketWidth;
            }

            if (sources) {
                localVarQueryParameter['sources'] = sources;
            }

            if (sizes) {
                localVarQueryParameter['sizes'] = sizes;
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }

            if (apiKeyIds) {
                localVarQueryParameter['api_key_ids'] = apiKeyIds;
            }

            if (models) {
                localVarQueryParameter['models'] = models;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get moderations usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageModerationsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {Array<UsageModerationsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageModerations: async (startTime: number, endTime?: number, bucketWidth?: UsageModerationsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageModerationsGroupByEnum>, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('usageModerations', 'startTime', startTime)
            const localVarPath = `/organization/usage/moderations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = bucketWidth;
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }

            if (apiKeyIds) {
                localVarQueryParameter['api_key_ids'] = apiKeyIds;
            }

            if (models) {
                localVarQueryParameter['models'] = models;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get vector stores usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageVectorStoresBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<UsageVectorStoresGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageVectorStores: async (startTime: number, endTime?: number, bucketWidth?: UsageVectorStoresBucketWidthEnum, projectIds?: Array<string>, groupBy?: Array<UsageVectorStoresGroupByEnum>, limit?: number, page?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startTime' is not null or undefined
            assertParamExists('usageVectorStores', 'startTime', startTime)
            const localVarPath = `/organization/usage/vector_stores`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = endTime;
            }

            if (bucketWidth !== undefined) {
                localVarQueryParameter['bucket_width'] = bucketWidth;
            }

            if (projectIds) {
                localVarQueryParameter['project_ids'] = projectIds;
            }

            if (groupBy) {
                localVarQueryParameter['group_by'] = groupBy;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsageApi - functional programming interface
 */
export const UsageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get audio speeches usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageAudioSpeechesBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {Array<UsageAudioSpeechesGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usageAudioSpeeches(startTime: number, endTime?: number, bucketWidth?: UsageAudioSpeechesBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageAudioSpeechesGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usageAudioSpeeches(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.usageAudioSpeeches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get audio transcriptions usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageAudioTranscriptionsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {Array<UsageAudioTranscriptionsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usageAudioTranscriptions(startTime: number, endTime?: number, bucketWidth?: UsageAudioTranscriptionsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageAudioTranscriptionsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usageAudioTranscriptions(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.usageAudioTranscriptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get code interpreter sessions usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageCodeInterpreterSessionsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<UsageCodeInterpreterSessionsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usageCodeInterpreterSessions(startTime: number, endTime?: number, bucketWidth?: UsageCodeInterpreterSessionsBucketWidthEnum, projectIds?: Array<string>, groupBy?: Array<UsageCodeInterpreterSessionsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usageCodeInterpreterSessions(startTime, endTime, bucketWidth, projectIds, groupBy, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.usageCodeInterpreterSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get completions usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageCompletionsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {boolean} [batch] If &#x60;true&#x60;, return batch jobs only. If &#x60;false&#x60;, return non-batch jobs only. By default, return both. 
         * @param {Array<UsageCompletionsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;batch&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usageCompletions(startTime: number, endTime?: number, bucketWidth?: UsageCompletionsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, batch?: boolean, groupBy?: Array<UsageCompletionsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usageCompletions(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, batch, groupBy, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.usageCompletions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get costs details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageCostsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently only &#x60;1d&#x60; is supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only costs for these projects.
         * @param {Array<UsageCostsGroupByEnum>} [groupBy] Group the costs by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;line_item&#x60; and any combination of them.
         * @param {number} [limit] A limit on the number of buckets to be returned. Limit can range between 1 and 180, and the default is 7. 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usageCosts(startTime: number, endTime?: number, bucketWidth?: UsageCostsBucketWidthEnum, projectIds?: Array<string>, groupBy?: Array<UsageCostsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usageCosts(startTime, endTime, bucketWidth, projectIds, groupBy, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.usageCosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get embeddings usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageEmbeddingsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {Array<UsageEmbeddingsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usageEmbeddings(startTime: number, endTime?: number, bucketWidth?: UsageEmbeddingsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageEmbeddingsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usageEmbeddings(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.usageEmbeddings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get images usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageImagesBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<UsageImagesSourcesEnum>} [sources] Return only usages for these sources. Possible values are &#x60;image.generation&#x60;, &#x60;image.edit&#x60;, &#x60;image.variation&#x60; or any combination of them.
         * @param {Array<UsageImagesSizesEnum>} [sizes] Return only usages for these image sizes. Possible values are &#x60;256x256&#x60;, &#x60;512x512&#x60;, &#x60;1024x1024&#x60;, &#x60;1792x1792&#x60;, &#x60;1024x1792&#x60; or any combination of them.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {Array<UsageImagesGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;size&#x60;, &#x60;source&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usageImages(startTime: number, endTime?: number, bucketWidth?: UsageImagesBucketWidthEnum, sources?: Array<UsageImagesSourcesEnum>, sizes?: Array<UsageImagesSizesEnum>, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageImagesGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usageImages(startTime, endTime, bucketWidth, sources, sizes, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.usageImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get moderations usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageModerationsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {Array<UsageModerationsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usageModerations(startTime: number, endTime?: number, bucketWidth?: UsageModerationsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageModerationsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usageModerations(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.usageModerations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get vector stores usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageVectorStoresBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<UsageVectorStoresGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usageVectorStores(startTime: number, endTime?: number, bucketWidth?: UsageVectorStoresBucketWidthEnum, projectIds?: Array<string>, groupBy?: Array<UsageVectorStoresGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usageVectorStores(startTime, endTime, bucketWidth, projectIds, groupBy, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsageApi.usageVectorStores']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsageApi - factory interface
 */
export const UsageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsageApiFp(configuration)
    return {
        /**
         * 
         * @summary Get audio speeches usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageAudioSpeechesBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {Array<UsageAudioSpeechesGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageAudioSpeeches(startTime: number, endTime?: number, bucketWidth?: UsageAudioSpeechesBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageAudioSpeechesGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsageResponse> {
            return localVarFp.usageAudioSpeeches(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get audio transcriptions usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageAudioTranscriptionsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {Array<UsageAudioTranscriptionsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageAudioTranscriptions(startTime: number, endTime?: number, bucketWidth?: UsageAudioTranscriptionsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageAudioTranscriptionsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsageResponse> {
            return localVarFp.usageAudioTranscriptions(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get code interpreter sessions usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageCodeInterpreterSessionsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<UsageCodeInterpreterSessionsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageCodeInterpreterSessions(startTime: number, endTime?: number, bucketWidth?: UsageCodeInterpreterSessionsBucketWidthEnum, projectIds?: Array<string>, groupBy?: Array<UsageCodeInterpreterSessionsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsageResponse> {
            return localVarFp.usageCodeInterpreterSessions(startTime, endTime, bucketWidth, projectIds, groupBy, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get completions usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageCompletionsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {boolean} [batch] If &#x60;true&#x60;, return batch jobs only. If &#x60;false&#x60;, return non-batch jobs only. By default, return both. 
         * @param {Array<UsageCompletionsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;batch&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageCompletions(startTime: number, endTime?: number, bucketWidth?: UsageCompletionsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, batch?: boolean, groupBy?: Array<UsageCompletionsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsageResponse> {
            return localVarFp.usageCompletions(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, batch, groupBy, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get costs details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageCostsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently only &#x60;1d&#x60; is supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only costs for these projects.
         * @param {Array<UsageCostsGroupByEnum>} [groupBy] Group the costs by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;line_item&#x60; and any combination of them.
         * @param {number} [limit] A limit on the number of buckets to be returned. Limit can range between 1 and 180, and the default is 7. 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageCosts(startTime: number, endTime?: number, bucketWidth?: UsageCostsBucketWidthEnum, projectIds?: Array<string>, groupBy?: Array<UsageCostsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsageResponse> {
            return localVarFp.usageCosts(startTime, endTime, bucketWidth, projectIds, groupBy, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get embeddings usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageEmbeddingsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {Array<UsageEmbeddingsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageEmbeddings(startTime: number, endTime?: number, bucketWidth?: UsageEmbeddingsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageEmbeddingsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsageResponse> {
            return localVarFp.usageEmbeddings(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get images usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageImagesBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<UsageImagesSourcesEnum>} [sources] Return only usages for these sources. Possible values are &#x60;image.generation&#x60;, &#x60;image.edit&#x60;, &#x60;image.variation&#x60; or any combination of them.
         * @param {Array<UsageImagesSizesEnum>} [sizes] Return only usages for these image sizes. Possible values are &#x60;256x256&#x60;, &#x60;512x512&#x60;, &#x60;1024x1024&#x60;, &#x60;1792x1792&#x60;, &#x60;1024x1792&#x60; or any combination of them.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {Array<UsageImagesGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;size&#x60;, &#x60;source&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageImages(startTime: number, endTime?: number, bucketWidth?: UsageImagesBucketWidthEnum, sources?: Array<UsageImagesSourcesEnum>, sizes?: Array<UsageImagesSizesEnum>, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageImagesGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsageResponse> {
            return localVarFp.usageImages(startTime, endTime, bucketWidth, sources, sizes, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get moderations usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageModerationsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<string>} [userIds] Return only usage for these users.
         * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
         * @param {Array<string>} [models] Return only usage for these models.
         * @param {Array<UsageModerationsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageModerations(startTime: number, endTime?: number, bucketWidth?: UsageModerationsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageModerationsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsageResponse> {
            return localVarFp.usageModerations(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get vector stores usage details for the organization.
         * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
         * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
         * @param {UsageVectorStoresBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
         * @param {Array<string>} [projectIds] Return only usage for these projects.
         * @param {Array<UsageVectorStoresGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;.
         * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
         * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usageVectorStores(startTime: number, endTime?: number, bucketWidth?: UsageVectorStoresBucketWidthEnum, projectIds?: Array<string>, groupBy?: Array<UsageVectorStoresGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsageResponse> {
            return localVarFp.usageVectorStores(startTime, endTime, bucketWidth, projectIds, groupBy, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsageApi - object-oriented interface
 */
export class UsageApi extends BaseAPI {
    /**
     * 
     * @summary Get audio speeches usage details for the organization.
     * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
     * @param {UsageAudioSpeechesBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param {Array<string>} [projectIds] Return only usage for these projects.
     * @param {Array<string>} [userIds] Return only usage for these users.
     * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
     * @param {Array<string>} [models] Return only usage for these models.
     * @param {Array<UsageAudioSpeechesGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
     * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usageAudioSpeeches(startTime: number, endTime?: number, bucketWidth?: UsageAudioSpeechesBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageAudioSpeechesGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).usageAudioSpeeches(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get audio transcriptions usage details for the organization.
     * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
     * @param {UsageAudioTranscriptionsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param {Array<string>} [projectIds] Return only usage for these projects.
     * @param {Array<string>} [userIds] Return only usage for these users.
     * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
     * @param {Array<string>} [models] Return only usage for these models.
     * @param {Array<UsageAudioTranscriptionsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
     * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usageAudioTranscriptions(startTime: number, endTime?: number, bucketWidth?: UsageAudioTranscriptionsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageAudioTranscriptionsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).usageAudioTranscriptions(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get code interpreter sessions usage details for the organization.
     * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
     * @param {UsageCodeInterpreterSessionsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param {Array<string>} [projectIds] Return only usage for these projects.
     * @param {Array<UsageCodeInterpreterSessionsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;.
     * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usageCodeInterpreterSessions(startTime: number, endTime?: number, bucketWidth?: UsageCodeInterpreterSessionsBucketWidthEnum, projectIds?: Array<string>, groupBy?: Array<UsageCodeInterpreterSessionsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).usageCodeInterpreterSessions(startTime, endTime, bucketWidth, projectIds, groupBy, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get completions usage details for the organization.
     * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
     * @param {UsageCompletionsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param {Array<string>} [projectIds] Return only usage for these projects.
     * @param {Array<string>} [userIds] Return only usage for these users.
     * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
     * @param {Array<string>} [models] Return only usage for these models.
     * @param {boolean} [batch] If &#x60;true&#x60;, return batch jobs only. If &#x60;false&#x60;, return non-batch jobs only. By default, return both. 
     * @param {Array<UsageCompletionsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;batch&#x60; or any combination of them.
     * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usageCompletions(startTime: number, endTime?: number, bucketWidth?: UsageCompletionsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, batch?: boolean, groupBy?: Array<UsageCompletionsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).usageCompletions(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, batch, groupBy, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get costs details for the organization.
     * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
     * @param {UsageCostsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently only &#x60;1d&#x60; is supported, default to &#x60;1d&#x60;.
     * @param {Array<string>} [projectIds] Return only costs for these projects.
     * @param {Array<UsageCostsGroupByEnum>} [groupBy] Group the costs by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;line_item&#x60; and any combination of them.
     * @param {number} [limit] A limit on the number of buckets to be returned. Limit can range between 1 and 180, and the default is 7. 
     * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usageCosts(startTime: number, endTime?: number, bucketWidth?: UsageCostsBucketWidthEnum, projectIds?: Array<string>, groupBy?: Array<UsageCostsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).usageCosts(startTime, endTime, bucketWidth, projectIds, groupBy, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get embeddings usage details for the organization.
     * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
     * @param {UsageEmbeddingsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param {Array<string>} [projectIds] Return only usage for these projects.
     * @param {Array<string>} [userIds] Return only usage for these users.
     * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
     * @param {Array<string>} [models] Return only usage for these models.
     * @param {Array<UsageEmbeddingsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
     * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usageEmbeddings(startTime: number, endTime?: number, bucketWidth?: UsageEmbeddingsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageEmbeddingsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).usageEmbeddings(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get images usage details for the organization.
     * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
     * @param {UsageImagesBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param {Array<UsageImagesSourcesEnum>} [sources] Return only usages for these sources. Possible values are &#x60;image.generation&#x60;, &#x60;image.edit&#x60;, &#x60;image.variation&#x60; or any combination of them.
     * @param {Array<UsageImagesSizesEnum>} [sizes] Return only usages for these image sizes. Possible values are &#x60;256x256&#x60;, &#x60;512x512&#x60;, &#x60;1024x1024&#x60;, &#x60;1792x1792&#x60;, &#x60;1024x1792&#x60; or any combination of them.
     * @param {Array<string>} [projectIds] Return only usage for these projects.
     * @param {Array<string>} [userIds] Return only usage for these users.
     * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
     * @param {Array<string>} [models] Return only usage for these models.
     * @param {Array<UsageImagesGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;size&#x60;, &#x60;source&#x60; or any combination of them.
     * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usageImages(startTime: number, endTime?: number, bucketWidth?: UsageImagesBucketWidthEnum, sources?: Array<UsageImagesSourcesEnum>, sizes?: Array<UsageImagesSizesEnum>, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageImagesGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).usageImages(startTime, endTime, bucketWidth, sources, sizes, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get moderations usage details for the organization.
     * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
     * @param {UsageModerationsBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param {Array<string>} [projectIds] Return only usage for these projects.
     * @param {Array<string>} [userIds] Return only usage for these users.
     * @param {Array<string>} [apiKeyIds] Return only usage for these API keys.
     * @param {Array<string>} [models] Return only usage for these models.
     * @param {Array<UsageModerationsGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
     * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usageModerations(startTime: number, endTime?: number, bucketWidth?: UsageModerationsBucketWidthEnum, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<UsageModerationsGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).usageModerations(startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get vector stores usage details for the organization.
     * @param {number} startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param {number} [endTime] End time (Unix seconds) of the query time range, exclusive.
     * @param {UsageVectorStoresBucketWidthEnum} [bucketWidth] Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param {Array<string>} [projectIds] Return only usage for these projects.
     * @param {Array<UsageVectorStoresGroupByEnum>} [groupBy] Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;.
     * @param {number} [limit] Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param {string} [page] A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public usageVectorStores(startTime: number, endTime?: number, bucketWidth?: UsageVectorStoresBucketWidthEnum, projectIds?: Array<string>, groupBy?: Array<UsageVectorStoresGroupByEnum>, limit?: number, page?: string, options?: RawAxiosRequestConfig) {
        return UsageApiFp(this.configuration).usageVectorStores(startTime, endTime, bucketWidth, projectIds, groupBy, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}

export const UsageAudioSpeechesBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageAudioSpeechesBucketWidthEnum = typeof UsageAudioSpeechesBucketWidthEnum[keyof typeof UsageAudioSpeechesBucketWidthEnum];
export const UsageAudioSpeechesGroupByEnum = {
    ProjectId: 'project_id',
    UserId: 'user_id',
    ApiKeyId: 'api_key_id',
    Model: 'model'
} as const;
export type UsageAudioSpeechesGroupByEnum = typeof UsageAudioSpeechesGroupByEnum[keyof typeof UsageAudioSpeechesGroupByEnum];
export const UsageAudioTranscriptionsBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageAudioTranscriptionsBucketWidthEnum = typeof UsageAudioTranscriptionsBucketWidthEnum[keyof typeof UsageAudioTranscriptionsBucketWidthEnum];
export const UsageAudioTranscriptionsGroupByEnum = {
    ProjectId: 'project_id',
    UserId: 'user_id',
    ApiKeyId: 'api_key_id',
    Model: 'model'
} as const;
export type UsageAudioTranscriptionsGroupByEnum = typeof UsageAudioTranscriptionsGroupByEnum[keyof typeof UsageAudioTranscriptionsGroupByEnum];
export const UsageCodeInterpreterSessionsBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageCodeInterpreterSessionsBucketWidthEnum = typeof UsageCodeInterpreterSessionsBucketWidthEnum[keyof typeof UsageCodeInterpreterSessionsBucketWidthEnum];
export const UsageCodeInterpreterSessionsGroupByEnum = {
    ProjectId: 'project_id'
} as const;
export type UsageCodeInterpreterSessionsGroupByEnum = typeof UsageCodeInterpreterSessionsGroupByEnum[keyof typeof UsageCodeInterpreterSessionsGroupByEnum];
export const UsageCompletionsBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageCompletionsBucketWidthEnum = typeof UsageCompletionsBucketWidthEnum[keyof typeof UsageCompletionsBucketWidthEnum];
export const UsageCompletionsGroupByEnum = {
    ProjectId: 'project_id',
    UserId: 'user_id',
    ApiKeyId: 'api_key_id',
    Model: 'model',
    Batch: 'batch'
} as const;
export type UsageCompletionsGroupByEnum = typeof UsageCompletionsGroupByEnum[keyof typeof UsageCompletionsGroupByEnum];
export const UsageCostsBucketWidthEnum = {
    _1d: '1d'
} as const;
export type UsageCostsBucketWidthEnum = typeof UsageCostsBucketWidthEnum[keyof typeof UsageCostsBucketWidthEnum];
export const UsageCostsGroupByEnum = {
    ProjectId: 'project_id',
    LineItem: 'line_item'
} as const;
export type UsageCostsGroupByEnum = typeof UsageCostsGroupByEnum[keyof typeof UsageCostsGroupByEnum];
export const UsageEmbeddingsBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageEmbeddingsBucketWidthEnum = typeof UsageEmbeddingsBucketWidthEnum[keyof typeof UsageEmbeddingsBucketWidthEnum];
export const UsageEmbeddingsGroupByEnum = {
    ProjectId: 'project_id',
    UserId: 'user_id',
    ApiKeyId: 'api_key_id',
    Model: 'model'
} as const;
export type UsageEmbeddingsGroupByEnum = typeof UsageEmbeddingsGroupByEnum[keyof typeof UsageEmbeddingsGroupByEnum];
export const UsageImagesBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageImagesBucketWidthEnum = typeof UsageImagesBucketWidthEnum[keyof typeof UsageImagesBucketWidthEnum];
export const UsageImagesSourcesEnum = {
    ImageGeneration: 'image.generation',
    ImageEdit: 'image.edit',
    ImageVariation: 'image.variation'
} as const;
export type UsageImagesSourcesEnum = typeof UsageImagesSourcesEnum[keyof typeof UsageImagesSourcesEnum];
export const UsageImagesSizesEnum = {
    _256x256: '256x256',
    _512x512: '512x512',
    _1024x1024: '1024x1024',
    _1792x1792: '1792x1792',
    _1024x1792: '1024x1792'
} as const;
export type UsageImagesSizesEnum = typeof UsageImagesSizesEnum[keyof typeof UsageImagesSizesEnum];
export const UsageImagesGroupByEnum = {
    ProjectId: 'project_id',
    UserId: 'user_id',
    ApiKeyId: 'api_key_id',
    Model: 'model',
    Size: 'size',
    Source: 'source'
} as const;
export type UsageImagesGroupByEnum = typeof UsageImagesGroupByEnum[keyof typeof UsageImagesGroupByEnum];
export const UsageModerationsBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageModerationsBucketWidthEnum = typeof UsageModerationsBucketWidthEnum[keyof typeof UsageModerationsBucketWidthEnum];
export const UsageModerationsGroupByEnum = {
    ProjectId: 'project_id',
    UserId: 'user_id',
    ApiKeyId: 'api_key_id',
    Model: 'model'
} as const;
export type UsageModerationsGroupByEnum = typeof UsageModerationsGroupByEnum[keyof typeof UsageModerationsGroupByEnum];
export const UsageVectorStoresBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageVectorStoresBucketWidthEnum = typeof UsageVectorStoresBucketWidthEnum[keyof typeof UsageVectorStoresBucketWidthEnum];
export const UsageVectorStoresGroupByEnum = {
    ProjectId: 'project_id'
} as const;
export type UsageVectorStoresGroupByEnum = typeof UsageVectorStoresGroupByEnum[keyof typeof UsageVectorStoresGroupByEnum];


/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a user from the organization.
         * @param {string} userId The ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/organization/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all of the users in the organization.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (limit?: number, after?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a user\'s role in the organization.
         * @param {string} userId The ID of the user.
         * @param {UserRoleUpdateRequest} userRoleUpdateRequest The new user role to modify. This must be one of &#x60;owner&#x60; or &#x60;member&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUser: async (userId: string, userRoleUpdateRequest: UserRoleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('modifyUser', 'userId', userId)
            // verify required parameter 'userRoleUpdateRequest' is not null or undefined
            assertParamExists('modifyUser', 'userRoleUpdateRequest', userRoleUpdateRequest)
            const localVarPath = `/organization/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a user by their identifier.
         * @param {string} userId The ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('retrieveUser', 'userId', userId)
            const localVarPath = `/organization/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes a user from the organization.
         * @param {string} userId The ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all of the users in the organization.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(limit?: number, after?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(limit, after, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Modifies a user\'s role in the organization.
         * @param {string} userId The ID of the user.
         * @param {UserRoleUpdateRequest} userRoleUpdateRequest The new user role to modify. This must be one of &#x60;owner&#x60; or &#x60;member&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyUser(userId: string, userRoleUpdateRequest: UserRoleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyUser(userId, userRoleUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.modifyUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a user by their identifier.
         * @param {string} userId The ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.retrieveUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes a user from the organization.
         * @param {string} userId The ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDeleteResponse> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all of the users in the organization.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(limit?: number, after?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserListResponse> {
            return localVarFp.listUsers(limit, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modifies a user\'s role in the organization.
         * @param {string} userId The ID of the user.
         * @param {UserRoleUpdateRequest} userRoleUpdateRequest The new user role to modify. This must be one of &#x60;owner&#x60; or &#x60;member&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUser(userId: string, userRoleUpdateRequest: UserRoleUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.modifyUser(userId, userRoleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a user by their identifier.
         * @param {string} userId The ID of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.retrieveUser(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a user from the organization.
     * @param {string} userId The ID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUser(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all of the users in the organization.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listUsers(limit?: number, after?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsers(limit, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modifies a user\'s role in the organization.
     * @param {string} userId The ID of the user.
     * @param {UserRoleUpdateRequest} userRoleUpdateRequest The new user role to modify. This must be one of &#x60;owner&#x60; or &#x60;member&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public modifyUser(userId: string, userRoleUpdateRequest: UserRoleUpdateRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).modifyUser(userId, userRoleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a user by their identifier.
     * @param {string} userId The ID of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveUser(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).retrieveUser(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VectorStoresApi - axios parameter creator
 */
export const VectorStoresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
         * @param {string} vectorStoreId The ID of the vector store that the file batch belongs to.
         * @param {string} batchId The ID of the file batch to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelVectorStoreFileBatch: async (vectorStoreId: string, batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vectorStoreId' is not null or undefined
            assertParamExists('cancelVectorStoreFileBatch', 'vectorStoreId', vectorStoreId)
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('cancelVectorStoreFileBatch', 'batchId', batchId)
            const localVarPath = `/vector_stores/{vector_store_id}/file_batches/{batch_id}/cancel`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)))
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a vector store.
         * @param {CreateVectorStoreRequest} createVectorStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVectorStore: async (createVectorStoreRequest: CreateVectorStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVectorStoreRequest' is not null or undefined
            assertParamExists('createVectorStore', 'createVectorStoreRequest', createVectorStoreRequest)
            const localVarPath = `/vector_stores`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVectorStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
         * @param {string} vectorStoreId The ID of the vector store for which to create a File. 
         * @param {CreateVectorStoreFileRequest} createVectorStoreFileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVectorStoreFile: async (vectorStoreId: string, createVectorStoreFileRequest: CreateVectorStoreFileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vectorStoreId' is not null or undefined
            assertParamExists('createVectorStoreFile', 'vectorStoreId', vectorStoreId)
            // verify required parameter 'createVectorStoreFileRequest' is not null or undefined
            assertParamExists('createVectorStoreFile', 'createVectorStoreFileRequest', createVectorStoreFileRequest)
            const localVarPath = `/vector_stores/{vector_store_id}/files`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVectorStoreFileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a vector store file batch.
         * @param {string} vectorStoreId The ID of the vector store for which to create a File Batch. 
         * @param {CreateVectorStoreFileBatchRequest} createVectorStoreFileBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVectorStoreFileBatch: async (vectorStoreId: string, createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vectorStoreId' is not null or undefined
            assertParamExists('createVectorStoreFileBatch', 'vectorStoreId', vectorStoreId)
            // verify required parameter 'createVectorStoreFileBatchRequest' is not null or undefined
            assertParamExists('createVectorStoreFileBatch', 'createVectorStoreFileBatchRequest', createVectorStoreFileBatchRequest)
            const localVarPath = `/vector_stores/{vector_store_id}/file_batches`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVectorStoreFileBatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a vector store.
         * @param {string} vectorStoreId The ID of the vector store to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVectorStore: async (vectorStoreId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vectorStoreId' is not null or undefined
            assertParamExists('deleteVectorStore', 'vectorStoreId', vectorStoreId)
            const localVarPath = `/vector_stores/{vector_store_id}`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
         * @param {string} vectorStoreId The ID of the vector store that the file belongs to.
         * @param {string} fileId The ID of the file to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVectorStoreFile: async (vectorStoreId: string, fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vectorStoreId' is not null or undefined
            assertParamExists('deleteVectorStoreFile', 'vectorStoreId', vectorStoreId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('deleteVectorStoreFile', 'fileId', fileId)
            const localVarPath = `/vector_stores/{vector_store_id}/files/{file_id}`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a vector store.
         * @param {string} vectorStoreId The ID of the vector store to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVectorStore: async (vectorStoreId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vectorStoreId' is not null or undefined
            assertParamExists('getVectorStore', 'vectorStoreId', vectorStoreId)
            const localVarPath = `/vector_stores/{vector_store_id}`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a vector store file.
         * @param {string} vectorStoreId The ID of the vector store that the file belongs to.
         * @param {string} fileId The ID of the file being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVectorStoreFile: async (vectorStoreId: string, fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vectorStoreId' is not null or undefined
            assertParamExists('getVectorStoreFile', 'vectorStoreId', vectorStoreId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getVectorStoreFile', 'fileId', fileId)
            const localVarPath = `/vector_stores/{vector_store_id}/files/{file_id}`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a vector store file batch.
         * @param {string} vectorStoreId The ID of the vector store that the file batch belongs to.
         * @param {string} batchId The ID of the file batch being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVectorStoreFileBatch: async (vectorStoreId: string, batchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vectorStoreId' is not null or undefined
            assertParamExists('getVectorStoreFileBatch', 'vectorStoreId', vectorStoreId)
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('getVectorStoreFileBatch', 'batchId', batchId)
            const localVarPath = `/vector_stores/{vector_store_id}/file_batches/{batch_id}`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)))
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of vector store files in a batch.
         * @param {string} vectorStoreId The ID of the vector store that the files belong to.
         * @param {string} batchId The ID of the file batch that the files belong to.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListFilesInVectorStoreBatchOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {ListFilesInVectorStoreBatchFilterEnum} [filter] Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFilesInVectorStoreBatch: async (vectorStoreId: string, batchId: string, limit?: number, order?: ListFilesInVectorStoreBatchOrderEnum, after?: string, before?: string, filter?: ListFilesInVectorStoreBatchFilterEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vectorStoreId' is not null or undefined
            assertParamExists('listFilesInVectorStoreBatch', 'vectorStoreId', vectorStoreId)
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('listFilesInVectorStoreBatch', 'batchId', batchId)
            const localVarPath = `/vector_stores/{vector_store_id}/file_batches/{batch_id}/files`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)))
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of vector store files.
         * @param {string} vectorStoreId The ID of the vector store that the files belong to.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListVectorStoreFilesOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {ListVectorStoreFilesFilterEnum} [filter] Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVectorStoreFiles: async (vectorStoreId: string, limit?: number, order?: ListVectorStoreFilesOrderEnum, after?: string, before?: string, filter?: ListVectorStoreFilesFilterEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vectorStoreId' is not null or undefined
            assertParamExists('listVectorStoreFiles', 'vectorStoreId', vectorStoreId)
            const localVarPath = `/vector_stores/{vector_store_id}/files`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of vector stores.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListVectorStoresOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVectorStores: async (limit?: number, order?: ListVectorStoresOrderEnum, after?: string, before?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vector_stores`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modifies a vector store.
         * @param {string} vectorStoreId The ID of the vector store to modify.
         * @param {UpdateVectorStoreRequest} updateVectorStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyVectorStore: async (vectorStoreId: string, updateVectorStoreRequest: UpdateVectorStoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vectorStoreId' is not null or undefined
            assertParamExists('modifyVectorStore', 'vectorStoreId', vectorStoreId)
            // verify required parameter 'updateVectorStoreRequest' is not null or undefined
            assertParamExists('modifyVectorStore', 'updateVectorStoreRequest', updateVectorStoreRequest)
            const localVarPath = `/vector_stores/{vector_store_id}`
                .replace(`{${"vector_store_id"}}`, encodeURIComponent(String(vectorStoreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateVectorStoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VectorStoresApi - functional programming interface
 */
export const VectorStoresApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VectorStoresApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
         * @param {string} vectorStoreId The ID of the vector store that the file batch belongs to.
         * @param {string} batchId The ID of the file batch to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelVectorStoreFileBatch(vectorStoreId: string, batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VectorStoreFileBatchObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelVectorStoreFileBatch(vectorStoreId, batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorStoresApi.cancelVectorStoreFileBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a vector store.
         * @param {CreateVectorStoreRequest} createVectorStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVectorStore(createVectorStoreRequest: CreateVectorStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VectorStoreObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVectorStore(createVectorStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorStoresApi.createVectorStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
         * @param {string} vectorStoreId The ID of the vector store for which to create a File. 
         * @param {CreateVectorStoreFileRequest} createVectorStoreFileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVectorStoreFile(vectorStoreId: string, createVectorStoreFileRequest: CreateVectorStoreFileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VectorStoreFileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVectorStoreFile(vectorStoreId, createVectorStoreFileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorStoresApi.createVectorStoreFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a vector store file batch.
         * @param {string} vectorStoreId The ID of the vector store for which to create a File Batch. 
         * @param {CreateVectorStoreFileBatchRequest} createVectorStoreFileBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVectorStoreFileBatch(vectorStoreId: string, createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VectorStoreFileBatchObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVectorStoreFileBatch(vectorStoreId, createVectorStoreFileBatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorStoresApi.createVectorStoreFileBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a vector store.
         * @param {string} vectorStoreId The ID of the vector store to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVectorStore(vectorStoreId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteVectorStoreResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVectorStore(vectorStoreId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorStoresApi.deleteVectorStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
         * @param {string} vectorStoreId The ID of the vector store that the file belongs to.
         * @param {string} fileId The ID of the file to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVectorStoreFile(vectorStoreId: string, fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteVectorStoreFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVectorStoreFile(vectorStoreId, fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorStoresApi.deleteVectorStoreFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a vector store.
         * @param {string} vectorStoreId The ID of the vector store to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVectorStore(vectorStoreId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VectorStoreObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVectorStore(vectorStoreId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorStoresApi.getVectorStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a vector store file.
         * @param {string} vectorStoreId The ID of the vector store that the file belongs to.
         * @param {string} fileId The ID of the file being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVectorStoreFile(vectorStoreId: string, fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VectorStoreFileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVectorStoreFile(vectorStoreId, fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorStoresApi.getVectorStoreFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a vector store file batch.
         * @param {string} vectorStoreId The ID of the vector store that the file batch belongs to.
         * @param {string} batchId The ID of the file batch being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVectorStoreFileBatch(vectorStoreId: string, batchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VectorStoreFileBatchObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVectorStoreFileBatch(vectorStoreId, batchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorStoresApi.getVectorStoreFileBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of vector store files in a batch.
         * @param {string} vectorStoreId The ID of the vector store that the files belong to.
         * @param {string} batchId The ID of the file batch that the files belong to.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListFilesInVectorStoreBatchOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {ListFilesInVectorStoreBatchFilterEnum} [filter] Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFilesInVectorStoreBatch(vectorStoreId: string, batchId: string, limit?: number, order?: ListFilesInVectorStoreBatchOrderEnum, after?: string, before?: string, filter?: ListFilesInVectorStoreBatchFilterEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListVectorStoreFilesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFilesInVectorStoreBatch(vectorStoreId, batchId, limit, order, after, before, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorStoresApi.listFilesInVectorStoreBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of vector store files.
         * @param {string} vectorStoreId The ID of the vector store that the files belong to.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListVectorStoreFilesOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {ListVectorStoreFilesFilterEnum} [filter] Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVectorStoreFiles(vectorStoreId: string, limit?: number, order?: ListVectorStoreFilesOrderEnum, after?: string, before?: string, filter?: ListVectorStoreFilesFilterEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListVectorStoreFilesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVectorStoreFiles(vectorStoreId, limit, order, after, before, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorStoresApi.listVectorStoreFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of vector stores.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListVectorStoresOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVectorStores(limit?: number, order?: ListVectorStoresOrderEnum, after?: string, before?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListVectorStoresResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVectorStores(limit, order, after, before, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorStoresApi.listVectorStores']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Modifies a vector store.
         * @param {string} vectorStoreId The ID of the vector store to modify.
         * @param {UpdateVectorStoreRequest} updateVectorStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyVectorStore(vectorStoreId: string, updateVectorStoreRequest: UpdateVectorStoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VectorStoreObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyVectorStore(vectorStoreId, updateVectorStoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorStoresApi.modifyVectorStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VectorStoresApi - factory interface
 */
export const VectorStoresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VectorStoresApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
         * @param {string} vectorStoreId The ID of the vector store that the file batch belongs to.
         * @param {string} batchId The ID of the file batch to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelVectorStoreFileBatch(vectorStoreId: string, batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<VectorStoreFileBatchObject> {
            return localVarFp.cancelVectorStoreFileBatch(vectorStoreId, batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a vector store.
         * @param {CreateVectorStoreRequest} createVectorStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVectorStore(createVectorStoreRequest: CreateVectorStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<VectorStoreObject> {
            return localVarFp.createVectorStore(createVectorStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
         * @param {string} vectorStoreId The ID of the vector store for which to create a File. 
         * @param {CreateVectorStoreFileRequest} createVectorStoreFileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVectorStoreFile(vectorStoreId: string, createVectorStoreFileRequest: CreateVectorStoreFileRequest, options?: RawAxiosRequestConfig): AxiosPromise<VectorStoreFileObject> {
            return localVarFp.createVectorStoreFile(vectorStoreId, createVectorStoreFileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a vector store file batch.
         * @param {string} vectorStoreId The ID of the vector store for which to create a File Batch. 
         * @param {CreateVectorStoreFileBatchRequest} createVectorStoreFileBatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVectorStoreFileBatch(vectorStoreId: string, createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<VectorStoreFileBatchObject> {
            return localVarFp.createVectorStoreFileBatch(vectorStoreId, createVectorStoreFileBatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a vector store.
         * @param {string} vectorStoreId The ID of the vector store to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVectorStore(vectorStoreId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteVectorStoreResponse> {
            return localVarFp.deleteVectorStore(vectorStoreId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
         * @param {string} vectorStoreId The ID of the vector store that the file belongs to.
         * @param {string} fileId The ID of the file to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVectorStoreFile(vectorStoreId: string, fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteVectorStoreFileResponse> {
            return localVarFp.deleteVectorStoreFile(vectorStoreId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a vector store.
         * @param {string} vectorStoreId The ID of the vector store to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVectorStore(vectorStoreId: string, options?: RawAxiosRequestConfig): AxiosPromise<VectorStoreObject> {
            return localVarFp.getVectorStore(vectorStoreId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a vector store file.
         * @param {string} vectorStoreId The ID of the vector store that the file belongs to.
         * @param {string} fileId The ID of the file being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVectorStoreFile(vectorStoreId: string, fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<VectorStoreFileObject> {
            return localVarFp.getVectorStoreFile(vectorStoreId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a vector store file batch.
         * @param {string} vectorStoreId The ID of the vector store that the file batch belongs to.
         * @param {string} batchId The ID of the file batch being retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVectorStoreFileBatch(vectorStoreId: string, batchId: string, options?: RawAxiosRequestConfig): AxiosPromise<VectorStoreFileBatchObject> {
            return localVarFp.getVectorStoreFileBatch(vectorStoreId, batchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of vector store files in a batch.
         * @param {string} vectorStoreId The ID of the vector store that the files belong to.
         * @param {string} batchId The ID of the file batch that the files belong to.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListFilesInVectorStoreBatchOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {ListFilesInVectorStoreBatchFilterEnum} [filter] Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFilesInVectorStoreBatch(vectorStoreId: string, batchId: string, limit?: number, order?: ListFilesInVectorStoreBatchOrderEnum, after?: string, before?: string, filter?: ListFilesInVectorStoreBatchFilterEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListVectorStoreFilesResponse> {
            return localVarFp.listFilesInVectorStoreBatch(vectorStoreId, batchId, limit, order, after, before, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of vector store files.
         * @param {string} vectorStoreId The ID of the vector store that the files belong to.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListVectorStoreFilesOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {ListVectorStoreFilesFilterEnum} [filter] Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVectorStoreFiles(vectorStoreId: string, limit?: number, order?: ListVectorStoreFilesOrderEnum, after?: string, before?: string, filter?: ListVectorStoreFilesFilterEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListVectorStoreFilesResponse> {
            return localVarFp.listVectorStoreFiles(vectorStoreId, limit, order, after, before, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of vector stores.
         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
         * @param {ListVectorStoresOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
         * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
         * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVectorStores(limit?: number, order?: ListVectorStoresOrderEnum, after?: string, before?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListVectorStoresResponse> {
            return localVarFp.listVectorStores(limit, order, after, before, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modifies a vector store.
         * @param {string} vectorStoreId The ID of the vector store to modify.
         * @param {UpdateVectorStoreRequest} updateVectorStoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyVectorStore(vectorStoreId: string, updateVectorStoreRequest: UpdateVectorStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<VectorStoreObject> {
            return localVarFp.modifyVectorStore(vectorStoreId, updateVectorStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VectorStoresApi - object-oriented interface
 */
export class VectorStoresApi extends BaseAPI {
    /**
     * 
     * @summary Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
     * @param {string} vectorStoreId The ID of the vector store that the file batch belongs to.
     * @param {string} batchId The ID of the file batch to cancel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelVectorStoreFileBatch(vectorStoreId: string, batchId: string, options?: RawAxiosRequestConfig) {
        return VectorStoresApiFp(this.configuration).cancelVectorStoreFileBatch(vectorStoreId, batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a vector store.
     * @param {CreateVectorStoreRequest} createVectorStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createVectorStore(createVectorStoreRequest: CreateVectorStoreRequest, options?: RawAxiosRequestConfig) {
        return VectorStoresApiFp(this.configuration).createVectorStore(createVectorStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
     * @param {string} vectorStoreId The ID of the vector store for which to create a File. 
     * @param {CreateVectorStoreFileRequest} createVectorStoreFileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createVectorStoreFile(vectorStoreId: string, createVectorStoreFileRequest: CreateVectorStoreFileRequest, options?: RawAxiosRequestConfig) {
        return VectorStoresApiFp(this.configuration).createVectorStoreFile(vectorStoreId, createVectorStoreFileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a vector store file batch.
     * @param {string} vectorStoreId The ID of the vector store for which to create a File Batch. 
     * @param {CreateVectorStoreFileBatchRequest} createVectorStoreFileBatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createVectorStoreFileBatch(vectorStoreId: string, createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest, options?: RawAxiosRequestConfig) {
        return VectorStoresApiFp(this.configuration).createVectorStoreFileBatch(vectorStoreId, createVectorStoreFileBatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a vector store.
     * @param {string} vectorStoreId The ID of the vector store to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteVectorStore(vectorStoreId: string, options?: RawAxiosRequestConfig) {
        return VectorStoresApiFp(this.configuration).deleteVectorStore(vectorStoreId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
     * @param {string} vectorStoreId The ID of the vector store that the file belongs to.
     * @param {string} fileId The ID of the file to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteVectorStoreFile(vectorStoreId: string, fileId: string, options?: RawAxiosRequestConfig) {
        return VectorStoresApiFp(this.configuration).deleteVectorStoreFile(vectorStoreId, fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a vector store.
     * @param {string} vectorStoreId The ID of the vector store to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVectorStore(vectorStoreId: string, options?: RawAxiosRequestConfig) {
        return VectorStoresApiFp(this.configuration).getVectorStore(vectorStoreId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a vector store file.
     * @param {string} vectorStoreId The ID of the vector store that the file belongs to.
     * @param {string} fileId The ID of the file being retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVectorStoreFile(vectorStoreId: string, fileId: string, options?: RawAxiosRequestConfig) {
        return VectorStoresApiFp(this.configuration).getVectorStoreFile(vectorStoreId, fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a vector store file batch.
     * @param {string} vectorStoreId The ID of the vector store that the file batch belongs to.
     * @param {string} batchId The ID of the file batch being retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVectorStoreFileBatch(vectorStoreId: string, batchId: string, options?: RawAxiosRequestConfig) {
        return VectorStoresApiFp(this.configuration).getVectorStoreFileBatch(vectorStoreId, batchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of vector store files in a batch.
     * @param {string} vectorStoreId The ID of the vector store that the files belong to.
     * @param {string} batchId The ID of the file batch that the files belong to.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param {ListFilesInVectorStoreBatchOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param {ListFilesInVectorStoreBatchFilterEnum} [filter] Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFilesInVectorStoreBatch(vectorStoreId: string, batchId: string, limit?: number, order?: ListFilesInVectorStoreBatchOrderEnum, after?: string, before?: string, filter?: ListFilesInVectorStoreBatchFilterEnum, options?: RawAxiosRequestConfig) {
        return VectorStoresApiFp(this.configuration).listFilesInVectorStoreBatch(vectorStoreId, batchId, limit, order, after, before, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of vector store files.
     * @param {string} vectorStoreId The ID of the vector store that the files belong to.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param {ListVectorStoreFilesOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param {ListVectorStoreFilesFilterEnum} [filter] Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listVectorStoreFiles(vectorStoreId: string, limit?: number, order?: ListVectorStoreFilesOrderEnum, after?: string, before?: string, filter?: ListVectorStoreFilesFilterEnum, options?: RawAxiosRequestConfig) {
        return VectorStoresApiFp(this.configuration).listVectorStoreFiles(vectorStoreId, limit, order, after, before, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of vector stores.
     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param {ListVectorStoresOrderEnum} [order] Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param {string} [after] A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param {string} [before] A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listVectorStores(limit?: number, order?: ListVectorStoresOrderEnum, after?: string, before?: string, options?: RawAxiosRequestConfig) {
        return VectorStoresApiFp(this.configuration).listVectorStores(limit, order, after, before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modifies a vector store.
     * @param {string} vectorStoreId The ID of the vector store to modify.
     * @param {UpdateVectorStoreRequest} updateVectorStoreRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public modifyVectorStore(vectorStoreId: string, updateVectorStoreRequest: UpdateVectorStoreRequest, options?: RawAxiosRequestConfig) {
        return VectorStoresApiFp(this.configuration).modifyVectorStore(vectorStoreId, updateVectorStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListFilesInVectorStoreBatchOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListFilesInVectorStoreBatchOrderEnum = typeof ListFilesInVectorStoreBatchOrderEnum[keyof typeof ListFilesInVectorStoreBatchOrderEnum];
export const ListFilesInVectorStoreBatchFilterEnum = {
    InProgress: 'in_progress',
    Completed: 'completed',
    Failed: 'failed',
    Cancelled: 'cancelled'
} as const;
export type ListFilesInVectorStoreBatchFilterEnum = typeof ListFilesInVectorStoreBatchFilterEnum[keyof typeof ListFilesInVectorStoreBatchFilterEnum];
export const ListVectorStoreFilesOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListVectorStoreFilesOrderEnum = typeof ListVectorStoreFilesOrderEnum[keyof typeof ListVectorStoreFilesOrderEnum];
export const ListVectorStoreFilesFilterEnum = {
    InProgress: 'in_progress',
    Completed: 'completed',
    Failed: 'failed',
    Cancelled: 'cancelled'
} as const;
export type ListVectorStoreFilesFilterEnum = typeof ListVectorStoreFilesFilterEnum[keyof typeof ListVectorStoreFilesFilterEnum];
export const ListVectorStoresOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListVectorStoresOrderEnum = typeof ListVectorStoresOrderEnum[keyof typeof ListVectorStoresOrderEnum];


