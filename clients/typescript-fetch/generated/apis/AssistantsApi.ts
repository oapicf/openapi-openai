/* tslint:disable */
/* eslint-disable */
/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AssistantFileObject,
  AssistantObject,
  CreateAssistantFileRequest,
  CreateAssistantRequest,
  CreateMessageRequest,
  CreateRunRequest,
  CreateThreadAndRunRequest,
  CreateThreadRequest,
  DeleteAssistantFileResponse,
  DeleteAssistantResponse,
  DeleteThreadResponse,
  ListAssistantFilesResponse,
  ListAssistantsResponse,
  ListMessageFilesResponse,
  ListMessagesResponse,
  ListRunStepsResponse,
  ListRunsResponse,
  MessageFileObject,
  MessageObject,
  ModifyAssistantRequest,
  ModifyMessageRequest,
  ModifyRunRequest,
  ModifyThreadRequest,
  RunObject,
  RunStepObject,
  SubmitToolOutputsRunRequest,
  ThreadObject,
} from '../models/index';
import {
    AssistantFileObjectFromJSON,
    AssistantFileObjectToJSON,
    AssistantObjectFromJSON,
    AssistantObjectToJSON,
    CreateAssistantFileRequestFromJSON,
    CreateAssistantFileRequestToJSON,
    CreateAssistantRequestFromJSON,
    CreateAssistantRequestToJSON,
    CreateMessageRequestFromJSON,
    CreateMessageRequestToJSON,
    CreateRunRequestFromJSON,
    CreateRunRequestToJSON,
    CreateThreadAndRunRequestFromJSON,
    CreateThreadAndRunRequestToJSON,
    CreateThreadRequestFromJSON,
    CreateThreadRequestToJSON,
    DeleteAssistantFileResponseFromJSON,
    DeleteAssistantFileResponseToJSON,
    DeleteAssistantResponseFromJSON,
    DeleteAssistantResponseToJSON,
    DeleteThreadResponseFromJSON,
    DeleteThreadResponseToJSON,
    ListAssistantFilesResponseFromJSON,
    ListAssistantFilesResponseToJSON,
    ListAssistantsResponseFromJSON,
    ListAssistantsResponseToJSON,
    ListMessageFilesResponseFromJSON,
    ListMessageFilesResponseToJSON,
    ListMessagesResponseFromJSON,
    ListMessagesResponseToJSON,
    ListRunStepsResponseFromJSON,
    ListRunStepsResponseToJSON,
    ListRunsResponseFromJSON,
    ListRunsResponseToJSON,
    MessageFileObjectFromJSON,
    MessageFileObjectToJSON,
    MessageObjectFromJSON,
    MessageObjectToJSON,
    ModifyAssistantRequestFromJSON,
    ModifyAssistantRequestToJSON,
    ModifyMessageRequestFromJSON,
    ModifyMessageRequestToJSON,
    ModifyRunRequestFromJSON,
    ModifyRunRequestToJSON,
    ModifyThreadRequestFromJSON,
    ModifyThreadRequestToJSON,
    RunObjectFromJSON,
    RunObjectToJSON,
    RunStepObjectFromJSON,
    RunStepObjectToJSON,
    SubmitToolOutputsRunRequestFromJSON,
    SubmitToolOutputsRunRequestToJSON,
    ThreadObjectFromJSON,
    ThreadObjectToJSON,
} from '../models/index';

export interface CancelRunRequest {
    threadId: string;
    runId: string;
}

export interface CreateAssistantOperationRequest {
    createAssistantRequest: CreateAssistantRequest;
}

export interface CreateAssistantFileOperationRequest {
    assistantId: string;
    createAssistantFileRequest: CreateAssistantFileRequest;
}

export interface CreateMessageOperationRequest {
    threadId: string;
    createMessageRequest: CreateMessageRequest;
}

export interface CreateRunOperationRequest {
    threadId: string;
    createRunRequest: CreateRunRequest;
}

export interface CreateThreadOperationRequest {
    createThreadRequest?: CreateThreadRequest;
}

export interface CreateThreadAndRunOperationRequest {
    createThreadAndRunRequest: CreateThreadAndRunRequest;
}

export interface DeleteAssistantRequest {
    assistantId: string;
}

export interface DeleteAssistantFileRequest {
    assistantId: string;
    fileId: string;
}

export interface DeleteThreadRequest {
    threadId: string;
}

export interface GetAssistantRequest {
    assistantId: string;
}

export interface GetAssistantFileRequest {
    assistantId: string;
    fileId: string;
}

export interface GetMessageRequest {
    threadId: string;
    messageId: string;
}

export interface GetMessageFileRequest {
    threadId: string;
    messageId: string;
    fileId: string;
}

export interface GetRunRequest {
    threadId: string;
    runId: string;
}

export interface GetRunStepRequest {
    threadId: string;
    runId: string;
    stepId: string;
}

export interface GetThreadRequest {
    threadId: string;
}

export interface ListAssistantFilesRequest {
    assistantId: string;
    limit?: number;
    order?: ListAssistantFilesOrderEnum;
    after?: string;
    before?: string;
}

export interface ListAssistantsRequest {
    limit?: number;
    order?: ListAssistantsOrderEnum;
    after?: string;
    before?: string;
}

export interface ListMessageFilesRequest {
    threadId: string;
    messageId: string;
    limit?: number;
    order?: ListMessageFilesOrderEnum;
    after?: string;
    before?: string;
}

export interface ListMessagesRequest {
    threadId: string;
    limit?: number;
    order?: ListMessagesOrderEnum;
    after?: string;
    before?: string;
    runId?: string;
}

export interface ListRunStepsRequest {
    threadId: string;
    runId: string;
    limit?: number;
    order?: ListRunStepsOrderEnum;
    after?: string;
    before?: string;
}

export interface ListRunsRequest {
    threadId: string;
    limit?: number;
    order?: ListRunsOrderEnum;
    after?: string;
    before?: string;
}

export interface ModifyAssistantOperationRequest {
    assistantId: string;
    modifyAssistantRequest: ModifyAssistantRequest;
}

export interface ModifyMessageOperationRequest {
    threadId: string;
    messageId: string;
    modifyMessageRequest: ModifyMessageRequest;
}

export interface ModifyRunOperationRequest {
    threadId: string;
    runId: string;
    modifyRunRequest: ModifyRunRequest;
}

export interface ModifyThreadOperationRequest {
    threadId: string;
    modifyThreadRequest: ModifyThreadRequest;
}

export interface SubmitToolOuputsToRunRequest {
    threadId: string;
    runId: string;
    submitToolOutputsRunRequest: SubmitToolOutputsRunRequest;
}

/**
 * 
 */
export class AssistantsApi extends runtime.BaseAPI {

    /**
     * Cancels a run that is `in_progress`.
     */
    async cancelRunRaw(requestParameters: CancelRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RunObject>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling cancelRun().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling cancelRun().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}/runs/{run_id}/cancel`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))).replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters['runId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RunObjectFromJSON(jsonValue));
    }

    /**
     * Cancels a run that is `in_progress`.
     */
    async cancelRun(requestParameters: CancelRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RunObject> {
        const response = await this.cancelRunRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an assistant with a model and instructions.
     */
    async createAssistantRaw(requestParameters: CreateAssistantOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AssistantObject>> {
        if (requestParameters['createAssistantRequest'] == null) {
            throw new runtime.RequiredError(
                'createAssistantRequest',
                'Required parameter "createAssistantRequest" was null or undefined when calling createAssistant().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/assistants`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateAssistantRequestToJSON(requestParameters['createAssistantRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AssistantObjectFromJSON(jsonValue));
    }

    /**
     * Create an assistant with a model and instructions.
     */
    async createAssistant(requestParameters: CreateAssistantOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AssistantObject> {
        const response = await this.createAssistantRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants).
     */
    async createAssistantFileRaw(requestParameters: CreateAssistantFileOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AssistantFileObject>> {
        if (requestParameters['assistantId'] == null) {
            throw new runtime.RequiredError(
                'assistantId',
                'Required parameter "assistantId" was null or undefined when calling createAssistantFile().'
            );
        }

        if (requestParameters['createAssistantFileRequest'] == null) {
            throw new runtime.RequiredError(
                'createAssistantFileRequest',
                'Required parameter "createAssistantFileRequest" was null or undefined when calling createAssistantFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/assistants/{assistant_id}/files`.replace(`{${"assistant_id"}}`, encodeURIComponent(String(requestParameters['assistantId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateAssistantFileRequestToJSON(requestParameters['createAssistantFileRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AssistantFileObjectFromJSON(jsonValue));
    }

    /**
     * Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants).
     */
    async createAssistantFile(requestParameters: CreateAssistantFileOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AssistantFileObject> {
        const response = await this.createAssistantFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a message.
     */
    async createMessageRaw(requestParameters: CreateMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageObject>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling createMessage().'
            );
        }

        if (requestParameters['createMessageRequest'] == null) {
            throw new runtime.RequiredError(
                'createMessageRequest',
                'Required parameter "createMessageRequest" was null or undefined when calling createMessage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}/messages`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateMessageRequestToJSON(requestParameters['createMessageRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MessageObjectFromJSON(jsonValue));
    }

    /**
     * Create a message.
     */
    async createMessage(requestParameters: CreateMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageObject> {
        const response = await this.createMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a run.
     */
    async createRunRaw(requestParameters: CreateRunOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RunObject>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling createRun().'
            );
        }

        if (requestParameters['createRunRequest'] == null) {
            throw new runtime.RequiredError(
                'createRunRequest',
                'Required parameter "createRunRequest" was null or undefined when calling createRun().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}/runs`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateRunRequestToJSON(requestParameters['createRunRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RunObjectFromJSON(jsonValue));
    }

    /**
     * Create a run.
     */
    async createRun(requestParameters: CreateRunOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RunObject> {
        const response = await this.createRunRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a thread.
     */
    async createThreadRaw(requestParameters: CreateThreadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ThreadObject>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateThreadRequestToJSON(requestParameters['createThreadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ThreadObjectFromJSON(jsonValue));
    }

    /**
     * Create a thread.
     */
    async createThread(requestParameters: CreateThreadOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ThreadObject> {
        const response = await this.createThreadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a thread and run it in one request.
     */
    async createThreadAndRunRaw(requestParameters: CreateThreadAndRunOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RunObject>> {
        if (requestParameters['createThreadAndRunRequest'] == null) {
            throw new runtime.RequiredError(
                'createThreadAndRunRequest',
                'Required parameter "createThreadAndRunRequest" was null or undefined when calling createThreadAndRun().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/runs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateThreadAndRunRequestToJSON(requestParameters['createThreadAndRunRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RunObjectFromJSON(jsonValue));
    }

    /**
     * Create a thread and run it in one request.
     */
    async createThreadAndRun(requestParameters: CreateThreadAndRunOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RunObject> {
        const response = await this.createThreadAndRunRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an assistant.
     */
    async deleteAssistantRaw(requestParameters: DeleteAssistantRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteAssistantResponse>> {
        if (requestParameters['assistantId'] == null) {
            throw new runtime.RequiredError(
                'assistantId',
                'Required parameter "assistantId" was null or undefined when calling deleteAssistant().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/assistants/{assistant_id}`.replace(`{${"assistant_id"}}`, encodeURIComponent(String(requestParameters['assistantId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteAssistantResponseFromJSON(jsonValue));
    }

    /**
     * Delete an assistant.
     */
    async deleteAssistant(requestParameters: DeleteAssistantRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteAssistantResponse> {
        const response = await this.deleteAssistantRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an assistant file.
     */
    async deleteAssistantFileRaw(requestParameters: DeleteAssistantFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteAssistantFileResponse>> {
        if (requestParameters['assistantId'] == null) {
            throw new runtime.RequiredError(
                'assistantId',
                'Required parameter "assistantId" was null or undefined when calling deleteAssistantFile().'
            );
        }

        if (requestParameters['fileId'] == null) {
            throw new runtime.RequiredError(
                'fileId',
                'Required parameter "fileId" was null or undefined when calling deleteAssistantFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/assistants/{assistant_id}/files/{file_id}`.replace(`{${"assistant_id"}}`, encodeURIComponent(String(requestParameters['assistantId']))).replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters['fileId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteAssistantFileResponseFromJSON(jsonValue));
    }

    /**
     * Delete an assistant file.
     */
    async deleteAssistantFile(requestParameters: DeleteAssistantFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteAssistantFileResponse> {
        const response = await this.deleteAssistantFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a thread.
     */
    async deleteThreadRaw(requestParameters: DeleteThreadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteThreadResponse>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling deleteThread().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteThreadResponseFromJSON(jsonValue));
    }

    /**
     * Delete a thread.
     */
    async deleteThread(requestParameters: DeleteThreadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteThreadResponse> {
        const response = await this.deleteThreadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves an assistant.
     */
    async getAssistantRaw(requestParameters: GetAssistantRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AssistantObject>> {
        if (requestParameters['assistantId'] == null) {
            throw new runtime.RequiredError(
                'assistantId',
                'Required parameter "assistantId" was null or undefined when calling getAssistant().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/assistants/{assistant_id}`.replace(`{${"assistant_id"}}`, encodeURIComponent(String(requestParameters['assistantId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AssistantObjectFromJSON(jsonValue));
    }

    /**
     * Retrieves an assistant.
     */
    async getAssistant(requestParameters: GetAssistantRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AssistantObject> {
        const response = await this.getAssistantRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves an AssistantFile.
     */
    async getAssistantFileRaw(requestParameters: GetAssistantFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AssistantFileObject>> {
        if (requestParameters['assistantId'] == null) {
            throw new runtime.RequiredError(
                'assistantId',
                'Required parameter "assistantId" was null or undefined when calling getAssistantFile().'
            );
        }

        if (requestParameters['fileId'] == null) {
            throw new runtime.RequiredError(
                'fileId',
                'Required parameter "fileId" was null or undefined when calling getAssistantFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/assistants/{assistant_id}/files/{file_id}`.replace(`{${"assistant_id"}}`, encodeURIComponent(String(requestParameters['assistantId']))).replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters['fileId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AssistantFileObjectFromJSON(jsonValue));
    }

    /**
     * Retrieves an AssistantFile.
     */
    async getAssistantFile(requestParameters: GetAssistantFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AssistantFileObject> {
        const response = await this.getAssistantFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a message.
     */
    async getMessageRaw(requestParameters: GetMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageObject>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling getMessage().'
            );
        }

        if (requestParameters['messageId'] == null) {
            throw new runtime.RequiredError(
                'messageId',
                'Required parameter "messageId" was null or undefined when calling getMessage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}/messages/{message_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))).replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters['messageId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MessageObjectFromJSON(jsonValue));
    }

    /**
     * Retrieve a message.
     */
    async getMessage(requestParameters: GetMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageObject> {
        const response = await this.getMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a message file.
     */
    async getMessageFileRaw(requestParameters: GetMessageFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageFileObject>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling getMessageFile().'
            );
        }

        if (requestParameters['messageId'] == null) {
            throw new runtime.RequiredError(
                'messageId',
                'Required parameter "messageId" was null or undefined when calling getMessageFile().'
            );
        }

        if (requestParameters['fileId'] == null) {
            throw new runtime.RequiredError(
                'fileId',
                'Required parameter "fileId" was null or undefined when calling getMessageFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}/messages/{message_id}/files/{file_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))).replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters['messageId']))).replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters['fileId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MessageFileObjectFromJSON(jsonValue));
    }

    /**
     * Retrieves a message file.
     */
    async getMessageFile(requestParameters: GetMessageFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageFileObject> {
        const response = await this.getMessageFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a run.
     */
    async getRunRaw(requestParameters: GetRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RunObject>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling getRun().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling getRun().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}/runs/{run_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))).replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters['runId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RunObjectFromJSON(jsonValue));
    }

    /**
     * Retrieves a run.
     */
    async getRun(requestParameters: GetRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RunObject> {
        const response = await this.getRunRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a run step.
     */
    async getRunStepRaw(requestParameters: GetRunStepRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RunStepObject>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling getRunStep().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling getRunStep().'
            );
        }

        if (requestParameters['stepId'] == null) {
            throw new runtime.RequiredError(
                'stepId',
                'Required parameter "stepId" was null or undefined when calling getRunStep().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}/runs/{run_id}/steps/{step_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))).replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters['runId']))).replace(`{${"step_id"}}`, encodeURIComponent(String(requestParameters['stepId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RunStepObjectFromJSON(jsonValue));
    }

    /**
     * Retrieves a run step.
     */
    async getRunStep(requestParameters: GetRunStepRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RunStepObject> {
        const response = await this.getRunStepRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a thread.
     */
    async getThreadRaw(requestParameters: GetThreadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ThreadObject>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling getThread().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ThreadObjectFromJSON(jsonValue));
    }

    /**
     * Retrieves a thread.
     */
    async getThread(requestParameters: GetThreadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ThreadObject> {
        const response = await this.getThreadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of assistant files.
     */
    async listAssistantFilesRaw(requestParameters: ListAssistantFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListAssistantFilesResponse>> {
        if (requestParameters['assistantId'] == null) {
            throw new runtime.RequiredError(
                'assistantId',
                'Required parameter "assistantId" was null or undefined when calling listAssistantFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['after'] != null) {
            queryParameters['after'] = requestParameters['after'];
        }

        if (requestParameters['before'] != null) {
            queryParameters['before'] = requestParameters['before'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/assistants/{assistant_id}/files`.replace(`{${"assistant_id"}}`, encodeURIComponent(String(requestParameters['assistantId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListAssistantFilesResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of assistant files.
     */
    async listAssistantFiles(requestParameters: ListAssistantFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListAssistantFilesResponse> {
        const response = await this.listAssistantFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of assistants.
     */
    async listAssistantsRaw(requestParameters: ListAssistantsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListAssistantsResponse>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['after'] != null) {
            queryParameters['after'] = requestParameters['after'];
        }

        if (requestParameters['before'] != null) {
            queryParameters['before'] = requestParameters['before'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/assistants`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListAssistantsResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of assistants.
     */
    async listAssistants(requestParameters: ListAssistantsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListAssistantsResponse> {
        const response = await this.listAssistantsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of message files.
     */
    async listMessageFilesRaw(requestParameters: ListMessageFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListMessageFilesResponse>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling listMessageFiles().'
            );
        }

        if (requestParameters['messageId'] == null) {
            throw new runtime.RequiredError(
                'messageId',
                'Required parameter "messageId" was null or undefined when calling listMessageFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['after'] != null) {
            queryParameters['after'] = requestParameters['after'];
        }

        if (requestParameters['before'] != null) {
            queryParameters['before'] = requestParameters['before'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}/messages/{message_id}/files`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))).replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters['messageId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListMessageFilesResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of message files.
     */
    async listMessageFiles(requestParameters: ListMessageFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListMessageFilesResponse> {
        const response = await this.listMessageFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of messages for a given thread.
     */
    async listMessagesRaw(requestParameters: ListMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListMessagesResponse>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling listMessages().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['after'] != null) {
            queryParameters['after'] = requestParameters['after'];
        }

        if (requestParameters['before'] != null) {
            queryParameters['before'] = requestParameters['before'];
        }

        if (requestParameters['runId'] != null) {
            queryParameters['run_id'] = requestParameters['runId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}/messages`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListMessagesResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of messages for a given thread.
     */
    async listMessages(requestParameters: ListMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListMessagesResponse> {
        const response = await this.listMessagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of run steps belonging to a run.
     */
    async listRunStepsRaw(requestParameters: ListRunStepsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListRunStepsResponse>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling listRunSteps().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling listRunSteps().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['after'] != null) {
            queryParameters['after'] = requestParameters['after'];
        }

        if (requestParameters['before'] != null) {
            queryParameters['before'] = requestParameters['before'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}/runs/{run_id}/steps`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))).replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters['runId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListRunStepsResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of run steps belonging to a run.
     */
    async listRunSteps(requestParameters: ListRunStepsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListRunStepsResponse> {
        const response = await this.listRunStepsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of runs belonging to a thread.
     */
    async listRunsRaw(requestParameters: ListRunsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListRunsResponse>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling listRuns().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['after'] != null) {
            queryParameters['after'] = requestParameters['after'];
        }

        if (requestParameters['before'] != null) {
            queryParameters['before'] = requestParameters['before'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}/runs`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListRunsResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of runs belonging to a thread.
     */
    async listRuns(requestParameters: ListRunsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListRunsResponse> {
        const response = await this.listRunsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modifies an assistant.
     */
    async modifyAssistantRaw(requestParameters: ModifyAssistantOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AssistantObject>> {
        if (requestParameters['assistantId'] == null) {
            throw new runtime.RequiredError(
                'assistantId',
                'Required parameter "assistantId" was null or undefined when calling modifyAssistant().'
            );
        }

        if (requestParameters['modifyAssistantRequest'] == null) {
            throw new runtime.RequiredError(
                'modifyAssistantRequest',
                'Required parameter "modifyAssistantRequest" was null or undefined when calling modifyAssistant().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/assistants/{assistant_id}`.replace(`{${"assistant_id"}}`, encodeURIComponent(String(requestParameters['assistantId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModifyAssistantRequestToJSON(requestParameters['modifyAssistantRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AssistantObjectFromJSON(jsonValue));
    }

    /**
     * Modifies an assistant.
     */
    async modifyAssistant(requestParameters: ModifyAssistantOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AssistantObject> {
        const response = await this.modifyAssistantRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modifies a message.
     */
    async modifyMessageRaw(requestParameters: ModifyMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageObject>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling modifyMessage().'
            );
        }

        if (requestParameters['messageId'] == null) {
            throw new runtime.RequiredError(
                'messageId',
                'Required parameter "messageId" was null or undefined when calling modifyMessage().'
            );
        }

        if (requestParameters['modifyMessageRequest'] == null) {
            throw new runtime.RequiredError(
                'modifyMessageRequest',
                'Required parameter "modifyMessageRequest" was null or undefined when calling modifyMessage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}/messages/{message_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))).replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters['messageId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModifyMessageRequestToJSON(requestParameters['modifyMessageRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MessageObjectFromJSON(jsonValue));
    }

    /**
     * Modifies a message.
     */
    async modifyMessage(requestParameters: ModifyMessageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageObject> {
        const response = await this.modifyMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modifies a run.
     */
    async modifyRunRaw(requestParameters: ModifyRunOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RunObject>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling modifyRun().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling modifyRun().'
            );
        }

        if (requestParameters['modifyRunRequest'] == null) {
            throw new runtime.RequiredError(
                'modifyRunRequest',
                'Required parameter "modifyRunRequest" was null or undefined when calling modifyRun().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}/runs/{run_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))).replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters['runId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModifyRunRequestToJSON(requestParameters['modifyRunRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RunObjectFromJSON(jsonValue));
    }

    /**
     * Modifies a run.
     */
    async modifyRun(requestParameters: ModifyRunOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RunObject> {
        const response = await this.modifyRunRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modifies a thread.
     */
    async modifyThreadRaw(requestParameters: ModifyThreadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ThreadObject>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling modifyThread().'
            );
        }

        if (requestParameters['modifyThreadRequest'] == null) {
            throw new runtime.RequiredError(
                'modifyThreadRequest',
                'Required parameter "modifyThreadRequest" was null or undefined when calling modifyThread().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModifyThreadRequestToJSON(requestParameters['modifyThreadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ThreadObjectFromJSON(jsonValue));
    }

    /**
     * Modifies a thread.
     */
    async modifyThread(requestParameters: ModifyThreadOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ThreadObject> {
        const response = await this.modifyThreadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they\'re all completed. All outputs must be submitted in a single request. 
     */
    async submitToolOuputsToRunRaw(requestParameters: SubmitToolOuputsToRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RunObject>> {
        if (requestParameters['threadId'] == null) {
            throw new runtime.RequiredError(
                'threadId',
                'Required parameter "threadId" was null or undefined when calling submitToolOuputsToRun().'
            );
        }

        if (requestParameters['runId'] == null) {
            throw new runtime.RequiredError(
                'runId',
                'Required parameter "runId" was null or undefined when calling submitToolOuputsToRun().'
            );
        }

        if (requestParameters['submitToolOutputsRunRequest'] == null) {
            throw new runtime.RequiredError(
                'submitToolOutputsRunRequest',
                'Required parameter "submitToolOutputsRunRequest" was null or undefined when calling submitToolOuputsToRun().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/threads/{thread_id}/runs/{run_id}/submit_tool_outputs`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters['threadId']))).replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters['runId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SubmitToolOutputsRunRequestToJSON(requestParameters['submitToolOutputsRunRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RunObjectFromJSON(jsonValue));
    }

    /**
     * When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they\'re all completed. All outputs must be submitted in a single request. 
     */
    async submitToolOuputsToRun(requestParameters: SubmitToolOuputsToRunRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RunObject> {
        const response = await this.submitToolOuputsToRunRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ListAssistantFilesOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListAssistantFilesOrderEnum = typeof ListAssistantFilesOrderEnum[keyof typeof ListAssistantFilesOrderEnum];
/**
 * @export
 */
export const ListAssistantsOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListAssistantsOrderEnum = typeof ListAssistantsOrderEnum[keyof typeof ListAssistantsOrderEnum];
/**
 * @export
 */
export const ListMessageFilesOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListMessageFilesOrderEnum = typeof ListMessageFilesOrderEnum[keyof typeof ListMessageFilesOrderEnum];
/**
 * @export
 */
export const ListMessagesOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListMessagesOrderEnum = typeof ListMessagesOrderEnum[keyof typeof ListMessagesOrderEnum];
/**
 * @export
 */
export const ListRunStepsOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListRunStepsOrderEnum = typeof ListRunStepsOrderEnum[keyof typeof ListRunStepsOrderEnum];
/**
 * @export
 */
export const ListRunsOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListRunsOrderEnum = typeof ListRunsOrderEnum[keyof typeof ListRunsOrderEnum];
