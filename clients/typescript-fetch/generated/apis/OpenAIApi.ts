/* tslint:disable */
/* eslint-disable */
/**
 * OpenAI API
 * APIs for sampling from and fine-tuning language models
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateChatCompletionRequest,
  CreateChatCompletionResponse,
  CreateCompletionRequest,
  CreateCompletionResponse,
  CreateEditRequest,
  CreateEditResponse,
  CreateEmbeddingRequest,
  CreateEmbeddingResponse,
  CreateFineTuneRequest,
  CreateImageRequest,
  CreateModerationRequest,
  CreateModerationResponse,
  CreateTranscriptionRequestModel,
  CreateTranscriptionResponse,
  CreateTranslationResponse,
  DeleteFileResponse,
  DeleteModelResponse,
  FineTune,
  ImagesResponse,
  ListFilesResponse,
  ListFineTuneEventsResponse,
  ListFineTunesResponse,
  ListModelsResponse,
  Model,
  OpenAIFile,
} from '../models/index';
import {
    CreateChatCompletionRequestFromJSON,
    CreateChatCompletionRequestToJSON,
    CreateChatCompletionResponseFromJSON,
    CreateChatCompletionResponseToJSON,
    CreateCompletionRequestFromJSON,
    CreateCompletionRequestToJSON,
    CreateCompletionResponseFromJSON,
    CreateCompletionResponseToJSON,
    CreateEditRequestFromJSON,
    CreateEditRequestToJSON,
    CreateEditResponseFromJSON,
    CreateEditResponseToJSON,
    CreateEmbeddingRequestFromJSON,
    CreateEmbeddingRequestToJSON,
    CreateEmbeddingResponseFromJSON,
    CreateEmbeddingResponseToJSON,
    CreateFineTuneRequestFromJSON,
    CreateFineTuneRequestToJSON,
    CreateImageRequestFromJSON,
    CreateImageRequestToJSON,
    CreateModerationRequestFromJSON,
    CreateModerationRequestToJSON,
    CreateModerationResponseFromJSON,
    CreateModerationResponseToJSON,
    CreateTranscriptionRequestModelFromJSON,
    CreateTranscriptionRequestModelToJSON,
    CreateTranscriptionResponseFromJSON,
    CreateTranscriptionResponseToJSON,
    CreateTranslationResponseFromJSON,
    CreateTranslationResponseToJSON,
    DeleteFileResponseFromJSON,
    DeleteFileResponseToJSON,
    DeleteModelResponseFromJSON,
    DeleteModelResponseToJSON,
    FineTuneFromJSON,
    FineTuneToJSON,
    ImagesResponseFromJSON,
    ImagesResponseToJSON,
    ListFilesResponseFromJSON,
    ListFilesResponseToJSON,
    ListFineTuneEventsResponseFromJSON,
    ListFineTuneEventsResponseToJSON,
    ListFineTunesResponseFromJSON,
    ListFineTunesResponseToJSON,
    ListModelsResponseFromJSON,
    ListModelsResponseToJSON,
    ModelFromJSON,
    ModelToJSON,
    OpenAIFileFromJSON,
    OpenAIFileToJSON,
} from '../models/index';

export interface CancelFineTuneRequest {
    fineTuneId: string;
}

export interface CreateChatCompletionOperationRequest {
    createChatCompletionRequest: CreateChatCompletionRequest;
}

export interface CreateCompletionOperationRequest {
    createCompletionRequest: CreateCompletionRequest;
}

export interface CreateEditOperationRequest {
    createEditRequest: CreateEditRequest;
}

export interface CreateEmbeddingOperationRequest {
    createEmbeddingRequest: CreateEmbeddingRequest;
}

export interface CreateFileRequest {
    file: Blob;
    purpose: string;
}

export interface CreateFineTuneOperationRequest {
    createFineTuneRequest: CreateFineTuneRequest;
}

export interface CreateImageOperationRequest {
    createImageRequest: CreateImageRequest;
}

export interface CreateImageEditRequest {
    image: Blob;
    prompt: string;
    mask?: Blob;
    n?: number;
    size?: CreateImageEditSizeEnum;
    responseFormat?: CreateImageEditResponseFormatEnum;
    user?: string;
}

export interface CreateImageVariationRequest {
    image: Blob;
    n?: number;
    size?: CreateImageVariationSizeEnum;
    responseFormat?: CreateImageVariationResponseFormatEnum;
    user?: string;
}

export interface CreateModerationOperationRequest {
    createModerationRequest: CreateModerationRequest;
}

export interface CreateTranscriptionRequest {
    file: Blob;
    model: CreateTranscriptionRequestModel;
    prompt?: string;
    responseFormat?: string;
    temperature?: number;
    language?: string;
}

export interface CreateTranslationRequest {
    file: Blob;
    model: CreateTranscriptionRequestModel;
    prompt?: string;
    responseFormat?: string;
    temperature?: number;
}

export interface DeleteFileRequest {
    fileId: string;
}

export interface DeleteModelRequest {
    model: string;
}

export interface DownloadFileRequest {
    fileId: string;
}

export interface ListFineTuneEventsRequest {
    fineTuneId: string;
    stream?: boolean;
}

export interface RetrieveFileRequest {
    fileId: string;
}

export interface RetrieveFineTuneRequest {
    fineTuneId: string;
}

export interface RetrieveModelRequest {
    model: string;
}

/**
 * 
 */
export class OpenAIApi extends runtime.BaseAPI {

    /**
     * Immediately cancel a fine-tune job. 
     */
    async cancelFineTuneRaw(requestParameters: CancelFineTuneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FineTune>> {
        if (requestParameters['fineTuneId'] == null) {
            throw new runtime.RequiredError(
                'fineTuneId',
                'Required parameter "fineTuneId" was null or undefined when calling cancelFineTune().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/fine-tunes/{fine_tune_id}/cancel`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(requestParameters['fineTuneId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FineTuneFromJSON(jsonValue));
    }

    /**
     * Immediately cancel a fine-tune job. 
     */
    async cancelFineTune(requestParameters: CancelFineTuneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FineTune> {
        const response = await this.cancelFineTuneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a model response for the given chat conversation.
     */
    async createChatCompletionRaw(requestParameters: CreateChatCompletionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateChatCompletionResponse>> {
        if (requestParameters['createChatCompletionRequest'] == null) {
            throw new runtime.RequiredError(
                'createChatCompletionRequest',
                'Required parameter "createChatCompletionRequest" was null or undefined when calling createChatCompletion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/chat/completions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateChatCompletionRequestToJSON(requestParameters['createChatCompletionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateChatCompletionResponseFromJSON(jsonValue));
    }

    /**
     * Creates a model response for the given chat conversation.
     */
    async createChatCompletion(requestParameters: CreateChatCompletionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateChatCompletionResponse> {
        const response = await this.createChatCompletionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a completion for the provided prompt and parameters.
     */
    async createCompletionRaw(requestParameters: CreateCompletionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateCompletionResponse>> {
        if (requestParameters['createCompletionRequest'] == null) {
            throw new runtime.RequiredError(
                'createCompletionRequest',
                'Required parameter "createCompletionRequest" was null or undefined when calling createCompletion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/completions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateCompletionRequestToJSON(requestParameters['createCompletionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateCompletionResponseFromJSON(jsonValue));
    }

    /**
     * Creates a completion for the provided prompt and parameters.
     */
    async createCompletion(requestParameters: CreateCompletionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateCompletionResponse> {
        const response = await this.createCompletionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new edit for the provided input, instruction, and parameters.
     */
    async createEditRaw(requestParameters: CreateEditOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateEditResponse>> {
        if (requestParameters['createEditRequest'] == null) {
            throw new runtime.RequiredError(
                'createEditRequest',
                'Required parameter "createEditRequest" was null or undefined when calling createEdit().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/edits`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateEditRequestToJSON(requestParameters['createEditRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateEditResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new edit for the provided input, instruction, and parameters.
     */
    async createEdit(requestParameters: CreateEditOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateEditResponse> {
        const response = await this.createEditRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates an embedding vector representing the input text.
     */
    async createEmbeddingRaw(requestParameters: CreateEmbeddingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateEmbeddingResponse>> {
        if (requestParameters['createEmbeddingRequest'] == null) {
            throw new runtime.RequiredError(
                'createEmbeddingRequest',
                'Required parameter "createEmbeddingRequest" was null or undefined when calling createEmbedding().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/embeddings`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateEmbeddingRequestToJSON(requestParameters['createEmbeddingRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateEmbeddingResponseFromJSON(jsonValue));
    }

    /**
     * Creates an embedding vector representing the input text.
     */
    async createEmbedding(requestParameters: CreateEmbeddingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateEmbeddingResponse> {
        const response = await this.createEmbeddingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit. 
     */
    async createFileRaw(requestParameters: CreateFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OpenAIFile>> {
        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling createFile().'
            );
        }

        if (requestParameters['purpose'] == null) {
            throw new runtime.RequiredError(
                'purpose',
                'Required parameter "purpose" was null or undefined when calling createFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['purpose'] != null) {
            formParams.append('purpose', requestParameters['purpose'] as any);
        }

        const response = await this.request({
            path: `/files`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenAIFileFromJSON(jsonValue));
    }

    /**
     * Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit. 
     */
    async createFile(requestParameters: CreateFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OpenAIFile> {
        const response = await this.createFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning) 
     */
    async createFineTuneRaw(requestParameters: CreateFineTuneOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FineTune>> {
        if (requestParameters['createFineTuneRequest'] == null) {
            throw new runtime.RequiredError(
                'createFineTuneRequest',
                'Required parameter "createFineTuneRequest" was null or undefined when calling createFineTune().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/fine-tunes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateFineTuneRequestToJSON(requestParameters['createFineTuneRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FineTuneFromJSON(jsonValue));
    }

    /**
     * Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning) 
     */
    async createFineTune(requestParameters: CreateFineTuneOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FineTune> {
        const response = await this.createFineTuneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates an image given a prompt.
     */
    async createImageRaw(requestParameters: CreateImageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImagesResponse>> {
        if (requestParameters['createImageRequest'] == null) {
            throw new runtime.RequiredError(
                'createImageRequest',
                'Required parameter "createImageRequest" was null or undefined when calling createImage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/images/generations`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateImageRequestToJSON(requestParameters['createImageRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImagesResponseFromJSON(jsonValue));
    }

    /**
     * Creates an image given a prompt.
     */
    async createImage(requestParameters: CreateImageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImagesResponse> {
        const response = await this.createImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates an edited or extended image given an original image and a prompt.
     */
    async createImageEditRaw(requestParameters: CreateImageEditRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImagesResponse>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling createImageEdit().'
            );
        }

        if (requestParameters['prompt'] == null) {
            throw new runtime.RequiredError(
                'prompt',
                'Required parameter "prompt" was null or undefined when calling createImageEdit().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        if (requestParameters['mask'] != null) {
            formParams.append('mask', requestParameters['mask'] as any);
        }

        if (requestParameters['prompt'] != null) {
            formParams.append('prompt', requestParameters['prompt'] as any);
        }

        if (requestParameters['n'] != null) {
            formParams.append('n', requestParameters['n'] as any);
        }

        if (requestParameters['size'] != null) {
            formParams.append('size', requestParameters['size'] as any);
        }

        if (requestParameters['responseFormat'] != null) {
            formParams.append('response_format', requestParameters['responseFormat'] as any);
        }

        if (requestParameters['user'] != null) {
            formParams.append('user', requestParameters['user'] as any);
        }

        const response = await this.request({
            path: `/images/edits`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImagesResponseFromJSON(jsonValue));
    }

    /**
     * Creates an edited or extended image given an original image and a prompt.
     */
    async createImageEdit(requestParameters: CreateImageEditRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImagesResponse> {
        const response = await this.createImageEditRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a variation of a given image.
     */
    async createImageVariationRaw(requestParameters: CreateImageVariationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImagesResponse>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling createImageVariation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        if (requestParameters['n'] != null) {
            formParams.append('n', requestParameters['n'] as any);
        }

        if (requestParameters['size'] != null) {
            formParams.append('size', requestParameters['size'] as any);
        }

        if (requestParameters['responseFormat'] != null) {
            formParams.append('response_format', requestParameters['responseFormat'] as any);
        }

        if (requestParameters['user'] != null) {
            formParams.append('user', requestParameters['user'] as any);
        }

        const response = await this.request({
            path: `/images/variations`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImagesResponseFromJSON(jsonValue));
    }

    /**
     * Creates a variation of a given image.
     */
    async createImageVariation(requestParameters: CreateImageVariationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImagesResponse> {
        const response = await this.createImageVariationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Classifies if text violates OpenAI\'s Content Policy
     */
    async createModerationRaw(requestParameters: CreateModerationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateModerationResponse>> {
        if (requestParameters['createModerationRequest'] == null) {
            throw new runtime.RequiredError(
                'createModerationRequest',
                'Required parameter "createModerationRequest" was null or undefined when calling createModeration().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/moderations`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateModerationRequestToJSON(requestParameters['createModerationRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateModerationResponseFromJSON(jsonValue));
    }

    /**
     * Classifies if text violates OpenAI\'s Content Policy
     */
    async createModeration(requestParameters: CreateModerationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateModerationResponse> {
        const response = await this.createModerationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Transcribes audio into the input language.
     */
    async createTranscriptionRaw(requestParameters: CreateTranscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTranscriptionResponse>> {
        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling createTranscription().'
            );
        }

        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling createTranscription().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['model'] != null) {
            formParams.append('model', new Blob([JSON.stringify(CreateTranscriptionRequestModelToJSON(requestParameters['model']))], { type: "application/json", }));
                    }

        if (requestParameters['prompt'] != null) {
            formParams.append('prompt', requestParameters['prompt'] as any);
        }

        if (requestParameters['responseFormat'] != null) {
            formParams.append('response_format', requestParameters['responseFormat'] as any);
        }

        if (requestParameters['temperature'] != null) {
            formParams.append('temperature', requestParameters['temperature'] as any);
        }

        if (requestParameters['language'] != null) {
            formParams.append('language', requestParameters['language'] as any);
        }

        const response = await this.request({
            path: `/audio/transcriptions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTranscriptionResponseFromJSON(jsonValue));
    }

    /**
     * Transcribes audio into the input language.
     */
    async createTranscription(requestParameters: CreateTranscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTranscriptionResponse> {
        const response = await this.createTranscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Translates audio into English.
     */
    async createTranslationRaw(requestParameters: CreateTranslationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTranslationResponse>> {
        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling createTranslation().'
            );
        }

        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling createTranslation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['model'] != null) {
            formParams.append('model', new Blob([JSON.stringify(CreateTranscriptionRequestModelToJSON(requestParameters['model']))], { type: "application/json", }));
                    }

        if (requestParameters['prompt'] != null) {
            formParams.append('prompt', requestParameters['prompt'] as any);
        }

        if (requestParameters['responseFormat'] != null) {
            formParams.append('response_format', requestParameters['responseFormat'] as any);
        }

        if (requestParameters['temperature'] != null) {
            formParams.append('temperature', requestParameters['temperature'] as any);
        }

        const response = await this.request({
            path: `/audio/translations`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTranslationResponseFromJSON(jsonValue));
    }

    /**
     * Translates audio into English.
     */
    async createTranslation(requestParameters: CreateTranslationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTranslationResponse> {
        const response = await this.createTranslationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a file.
     */
    async deleteFileRaw(requestParameters: DeleteFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteFileResponse>> {
        if (requestParameters['fileId'] == null) {
            throw new runtime.RequiredError(
                'fileId',
                'Required parameter "fileId" was null or undefined when calling deleteFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/files/{file_id}`.replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters['fileId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteFileResponseFromJSON(jsonValue));
    }

    /**
     * Delete a file.
     */
    async deleteFile(requestParameters: DeleteFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteFileResponse> {
        const response = await this.deleteFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a fine-tuned model. You must have the Owner role in your organization.
     */
    async deleteModelRaw(requestParameters: DeleteModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteModelResponse>> {
        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling deleteModel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/models/{model}`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters['model']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteModelResponseFromJSON(jsonValue));
    }

    /**
     * Delete a fine-tuned model. You must have the Owner role in your organization.
     */
    async deleteModel(requestParameters: DeleteModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteModelResponse> {
        const response = await this.deleteModelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the contents of the specified file
     */
    async downloadFileRaw(requestParameters: DownloadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['fileId'] == null) {
            throw new runtime.RequiredError(
                'fileId',
                'Required parameter "fileId" was null or undefined when calling downloadFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/files/{file_id}/content`.replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters['fileId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Returns the contents of the specified file
     */
    async downloadFile(requestParameters: DownloadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.downloadFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of files that belong to the user\'s organization.
     */
    async listFilesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListFilesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/files`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListFilesResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of files that belong to the user\'s organization.
     */
    async listFiles(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListFilesResponse> {
        const response = await this.listFilesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get fine-grained status updates for a fine-tune job. 
     */
    async listFineTuneEventsRaw(requestParameters: ListFineTuneEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListFineTuneEventsResponse>> {
        if (requestParameters['fineTuneId'] == null) {
            throw new runtime.RequiredError(
                'fineTuneId',
                'Required parameter "fineTuneId" was null or undefined when calling listFineTuneEvents().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['stream'] != null) {
            queryParameters['stream'] = requestParameters['stream'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/fine-tunes/{fine_tune_id}/events`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(requestParameters['fineTuneId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListFineTuneEventsResponseFromJSON(jsonValue));
    }

    /**
     * Get fine-grained status updates for a fine-tune job. 
     */
    async listFineTuneEvents(requestParameters: ListFineTuneEventsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListFineTuneEventsResponse> {
        const response = await this.listFineTuneEventsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List your organization\'s fine-tuning jobs 
     */
    async listFineTunesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListFineTunesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/fine-tunes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListFineTunesResponseFromJSON(jsonValue));
    }

    /**
     * List your organization\'s fine-tuning jobs 
     */
    async listFineTunes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListFineTunesResponse> {
        const response = await this.listFineTunesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists the currently available models, and provides basic information about each one such as the owner and availability.
     */
    async listModelsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListModelsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/models`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListModelsResponseFromJSON(jsonValue));
    }

    /**
     * Lists the currently available models, and provides basic information about each one such as the owner and availability.
     */
    async listModels(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListModelsResponse> {
        const response = await this.listModelsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns information about a specific file.
     */
    async retrieveFileRaw(requestParameters: RetrieveFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OpenAIFile>> {
        if (requestParameters['fileId'] == null) {
            throw new runtime.RequiredError(
                'fileId',
                'Required parameter "fileId" was null or undefined when calling retrieveFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/files/{file_id}`.replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters['fileId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenAIFileFromJSON(jsonValue));
    }

    /**
     * Returns information about a specific file.
     */
    async retrieveFile(requestParameters: RetrieveFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OpenAIFile> {
        const response = await this.retrieveFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning) 
     */
    async retrieveFineTuneRaw(requestParameters: RetrieveFineTuneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FineTune>> {
        if (requestParameters['fineTuneId'] == null) {
            throw new runtime.RequiredError(
                'fineTuneId',
                'Required parameter "fineTuneId" was null or undefined when calling retrieveFineTune().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/fine-tunes/{fine_tune_id}`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(requestParameters['fineTuneId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FineTuneFromJSON(jsonValue));
    }

    /**
     * Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning) 
     */
    async retrieveFineTune(requestParameters: RetrieveFineTuneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FineTune> {
        const response = await this.retrieveFineTuneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
     */
    async retrieveModelRaw(requestParameters: RetrieveModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Model>> {
        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling retrieveModel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/models/{model}`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters['model']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModelFromJSON(jsonValue));
    }

    /**
     * Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
     */
    async retrieveModel(requestParameters: RetrieveModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Model> {
        const response = await this.retrieveModelRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CreateImageEditSizeEnum = {
    _256x256: '256x256',
    _512x512: '512x512',
    _1024x1024: '1024x1024'
} as const;
export type CreateImageEditSizeEnum = typeof CreateImageEditSizeEnum[keyof typeof CreateImageEditSizeEnum];
/**
 * @export
 */
export const CreateImageEditResponseFormatEnum = {
    Url: 'url',
    B64Json: 'b64_json'
} as const;
export type CreateImageEditResponseFormatEnum = typeof CreateImageEditResponseFormatEnum[keyof typeof CreateImageEditResponseFormatEnum];
/**
 * @export
 */
export const CreateImageVariationSizeEnum = {
    _256x256: '256x256',
    _512x512: '512x512',
    _1024x1024: '1024x1024'
} as const;
export type CreateImageVariationSizeEnum = typeof CreateImageVariationSizeEnum[keyof typeof CreateImageVariationSizeEnum];
/**
 * @export
 */
export const CreateImageVariationResponseFormatEnum = {
    Url: 'url',
    B64Json: 'b64_json'
} as const;
export type CreateImageVariationResponseFormatEnum = typeof CreateImageVariationResponseFormatEnum[keyof typeof CreateImageVariationResponseFormatEnum];
