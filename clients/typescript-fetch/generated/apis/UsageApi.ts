/* tslint:disable */
/* eslint-disable */
/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  UsageResponse,
} from '../models/index';
import {
    UsageResponseFromJSON,
    UsageResponseToJSON,
} from '../models/index';

export interface UsageAudioSpeechesRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageAudioSpeechesBucketWidthEnum;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    groupBy?: Array<UsageAudioSpeechesGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageAudioTranscriptionsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageAudioTranscriptionsBucketWidthEnum;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    groupBy?: Array<UsageAudioTranscriptionsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageCodeInterpreterSessionsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageCodeInterpreterSessionsBucketWidthEnum;
    projectIds?: Array<string>;
    groupBy?: Array<UsageCodeInterpreterSessionsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageCompletionsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageCompletionsBucketWidthEnum;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    batch?: boolean;
    groupBy?: Array<UsageCompletionsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageCostsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageCostsBucketWidthEnum;
    projectIds?: Array<string>;
    groupBy?: Array<UsageCostsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageEmbeddingsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageEmbeddingsBucketWidthEnum;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    groupBy?: Array<UsageEmbeddingsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageImagesRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageImagesBucketWidthEnum;
    sources?: Array<UsageImagesSourcesEnum>;
    sizes?: Array<UsageImagesSizesEnum>;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    groupBy?: Array<UsageImagesGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageModerationsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageModerationsBucketWidthEnum;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    groupBy?: Array<UsageModerationsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageVectorStoresRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageVectorStoresBucketWidthEnum;
    projectIds?: Array<string>;
    groupBy?: Array<UsageVectorStoresGroupByEnum>;
    limit?: number;
    page?: string;
}

/**
 * 
 */
export class UsageApi extends runtime.BaseAPI {

    /**
     * Get audio speeches usage details for the organization.
     */
    async usageAudioSpeechesRaw(requestParameters: UsageAudioSpeechesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsageResponse>> {
        if (requestParameters['startTime'] == null) {
            throw new runtime.RequiredError(
                'startTime',
                'Required parameter "startTime" was null or undefined when calling usageAudioSpeeches().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startTime'] != null) {
            queryParameters['start_time'] = requestParameters['startTime'];
        }

        if (requestParameters['endTime'] != null) {
            queryParameters['end_time'] = requestParameters['endTime'];
        }

        if (requestParameters['bucketWidth'] != null) {
            queryParameters['bucket_width'] = requestParameters['bucketWidth'];
        }

        if (requestParameters['projectIds'] != null) {
            queryParameters['project_ids'] = requestParameters['projectIds'];
        }

        if (requestParameters['userIds'] != null) {
            queryParameters['user_ids'] = requestParameters['userIds'];
        }

        if (requestParameters['apiKeyIds'] != null) {
            queryParameters['api_key_ids'] = requestParameters['apiKeyIds'];
        }

        if (requestParameters['models'] != null) {
            queryParameters['models'] = requestParameters['models'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/organization/usage/audio_speeches`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsageResponseFromJSON(jsonValue));
    }

    /**
     * Get audio speeches usage details for the organization.
     */
    async usageAudioSpeeches(requestParameters: UsageAudioSpeechesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsageResponse> {
        const response = await this.usageAudioSpeechesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get audio transcriptions usage details for the organization.
     */
    async usageAudioTranscriptionsRaw(requestParameters: UsageAudioTranscriptionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsageResponse>> {
        if (requestParameters['startTime'] == null) {
            throw new runtime.RequiredError(
                'startTime',
                'Required parameter "startTime" was null or undefined when calling usageAudioTranscriptions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startTime'] != null) {
            queryParameters['start_time'] = requestParameters['startTime'];
        }

        if (requestParameters['endTime'] != null) {
            queryParameters['end_time'] = requestParameters['endTime'];
        }

        if (requestParameters['bucketWidth'] != null) {
            queryParameters['bucket_width'] = requestParameters['bucketWidth'];
        }

        if (requestParameters['projectIds'] != null) {
            queryParameters['project_ids'] = requestParameters['projectIds'];
        }

        if (requestParameters['userIds'] != null) {
            queryParameters['user_ids'] = requestParameters['userIds'];
        }

        if (requestParameters['apiKeyIds'] != null) {
            queryParameters['api_key_ids'] = requestParameters['apiKeyIds'];
        }

        if (requestParameters['models'] != null) {
            queryParameters['models'] = requestParameters['models'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/organization/usage/audio_transcriptions`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsageResponseFromJSON(jsonValue));
    }

    /**
     * Get audio transcriptions usage details for the organization.
     */
    async usageAudioTranscriptions(requestParameters: UsageAudioTranscriptionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsageResponse> {
        const response = await this.usageAudioTranscriptionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get code interpreter sessions usage details for the organization.
     */
    async usageCodeInterpreterSessionsRaw(requestParameters: UsageCodeInterpreterSessionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsageResponse>> {
        if (requestParameters['startTime'] == null) {
            throw new runtime.RequiredError(
                'startTime',
                'Required parameter "startTime" was null or undefined when calling usageCodeInterpreterSessions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startTime'] != null) {
            queryParameters['start_time'] = requestParameters['startTime'];
        }

        if (requestParameters['endTime'] != null) {
            queryParameters['end_time'] = requestParameters['endTime'];
        }

        if (requestParameters['bucketWidth'] != null) {
            queryParameters['bucket_width'] = requestParameters['bucketWidth'];
        }

        if (requestParameters['projectIds'] != null) {
            queryParameters['project_ids'] = requestParameters['projectIds'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/organization/usage/code_interpreter_sessions`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsageResponseFromJSON(jsonValue));
    }

    /**
     * Get code interpreter sessions usage details for the organization.
     */
    async usageCodeInterpreterSessions(requestParameters: UsageCodeInterpreterSessionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsageResponse> {
        const response = await this.usageCodeInterpreterSessionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get completions usage details for the organization.
     */
    async usageCompletionsRaw(requestParameters: UsageCompletionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsageResponse>> {
        if (requestParameters['startTime'] == null) {
            throw new runtime.RequiredError(
                'startTime',
                'Required parameter "startTime" was null or undefined when calling usageCompletions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startTime'] != null) {
            queryParameters['start_time'] = requestParameters['startTime'];
        }

        if (requestParameters['endTime'] != null) {
            queryParameters['end_time'] = requestParameters['endTime'];
        }

        if (requestParameters['bucketWidth'] != null) {
            queryParameters['bucket_width'] = requestParameters['bucketWidth'];
        }

        if (requestParameters['projectIds'] != null) {
            queryParameters['project_ids'] = requestParameters['projectIds'];
        }

        if (requestParameters['userIds'] != null) {
            queryParameters['user_ids'] = requestParameters['userIds'];
        }

        if (requestParameters['apiKeyIds'] != null) {
            queryParameters['api_key_ids'] = requestParameters['apiKeyIds'];
        }

        if (requestParameters['models'] != null) {
            queryParameters['models'] = requestParameters['models'];
        }

        if (requestParameters['batch'] != null) {
            queryParameters['batch'] = requestParameters['batch'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/organization/usage/completions`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsageResponseFromJSON(jsonValue));
    }

    /**
     * Get completions usage details for the organization.
     */
    async usageCompletions(requestParameters: UsageCompletionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsageResponse> {
        const response = await this.usageCompletionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get costs details for the organization.
     */
    async usageCostsRaw(requestParameters: UsageCostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsageResponse>> {
        if (requestParameters['startTime'] == null) {
            throw new runtime.RequiredError(
                'startTime',
                'Required parameter "startTime" was null or undefined when calling usageCosts().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startTime'] != null) {
            queryParameters['start_time'] = requestParameters['startTime'];
        }

        if (requestParameters['endTime'] != null) {
            queryParameters['end_time'] = requestParameters['endTime'];
        }

        if (requestParameters['bucketWidth'] != null) {
            queryParameters['bucket_width'] = requestParameters['bucketWidth'];
        }

        if (requestParameters['projectIds'] != null) {
            queryParameters['project_ids'] = requestParameters['projectIds'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/organization/costs`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsageResponseFromJSON(jsonValue));
    }

    /**
     * Get costs details for the organization.
     */
    async usageCosts(requestParameters: UsageCostsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsageResponse> {
        const response = await this.usageCostsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get embeddings usage details for the organization.
     */
    async usageEmbeddingsRaw(requestParameters: UsageEmbeddingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsageResponse>> {
        if (requestParameters['startTime'] == null) {
            throw new runtime.RequiredError(
                'startTime',
                'Required parameter "startTime" was null or undefined when calling usageEmbeddings().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startTime'] != null) {
            queryParameters['start_time'] = requestParameters['startTime'];
        }

        if (requestParameters['endTime'] != null) {
            queryParameters['end_time'] = requestParameters['endTime'];
        }

        if (requestParameters['bucketWidth'] != null) {
            queryParameters['bucket_width'] = requestParameters['bucketWidth'];
        }

        if (requestParameters['projectIds'] != null) {
            queryParameters['project_ids'] = requestParameters['projectIds'];
        }

        if (requestParameters['userIds'] != null) {
            queryParameters['user_ids'] = requestParameters['userIds'];
        }

        if (requestParameters['apiKeyIds'] != null) {
            queryParameters['api_key_ids'] = requestParameters['apiKeyIds'];
        }

        if (requestParameters['models'] != null) {
            queryParameters['models'] = requestParameters['models'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/organization/usage/embeddings`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsageResponseFromJSON(jsonValue));
    }

    /**
     * Get embeddings usage details for the organization.
     */
    async usageEmbeddings(requestParameters: UsageEmbeddingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsageResponse> {
        const response = await this.usageEmbeddingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get images usage details for the organization.
     */
    async usageImagesRaw(requestParameters: UsageImagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsageResponse>> {
        if (requestParameters['startTime'] == null) {
            throw new runtime.RequiredError(
                'startTime',
                'Required parameter "startTime" was null or undefined when calling usageImages().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startTime'] != null) {
            queryParameters['start_time'] = requestParameters['startTime'];
        }

        if (requestParameters['endTime'] != null) {
            queryParameters['end_time'] = requestParameters['endTime'];
        }

        if (requestParameters['bucketWidth'] != null) {
            queryParameters['bucket_width'] = requestParameters['bucketWidth'];
        }

        if (requestParameters['sources'] != null) {
            queryParameters['sources'] = requestParameters['sources'];
        }

        if (requestParameters['sizes'] != null) {
            queryParameters['sizes'] = requestParameters['sizes'];
        }

        if (requestParameters['projectIds'] != null) {
            queryParameters['project_ids'] = requestParameters['projectIds'];
        }

        if (requestParameters['userIds'] != null) {
            queryParameters['user_ids'] = requestParameters['userIds'];
        }

        if (requestParameters['apiKeyIds'] != null) {
            queryParameters['api_key_ids'] = requestParameters['apiKeyIds'];
        }

        if (requestParameters['models'] != null) {
            queryParameters['models'] = requestParameters['models'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/organization/usage/images`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsageResponseFromJSON(jsonValue));
    }

    /**
     * Get images usage details for the organization.
     */
    async usageImages(requestParameters: UsageImagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsageResponse> {
        const response = await this.usageImagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get moderations usage details for the organization.
     */
    async usageModerationsRaw(requestParameters: UsageModerationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsageResponse>> {
        if (requestParameters['startTime'] == null) {
            throw new runtime.RequiredError(
                'startTime',
                'Required parameter "startTime" was null or undefined when calling usageModerations().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startTime'] != null) {
            queryParameters['start_time'] = requestParameters['startTime'];
        }

        if (requestParameters['endTime'] != null) {
            queryParameters['end_time'] = requestParameters['endTime'];
        }

        if (requestParameters['bucketWidth'] != null) {
            queryParameters['bucket_width'] = requestParameters['bucketWidth'];
        }

        if (requestParameters['projectIds'] != null) {
            queryParameters['project_ids'] = requestParameters['projectIds'];
        }

        if (requestParameters['userIds'] != null) {
            queryParameters['user_ids'] = requestParameters['userIds'];
        }

        if (requestParameters['apiKeyIds'] != null) {
            queryParameters['api_key_ids'] = requestParameters['apiKeyIds'];
        }

        if (requestParameters['models'] != null) {
            queryParameters['models'] = requestParameters['models'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/organization/usage/moderations`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsageResponseFromJSON(jsonValue));
    }

    /**
     * Get moderations usage details for the organization.
     */
    async usageModerations(requestParameters: UsageModerationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsageResponse> {
        const response = await this.usageModerationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get vector stores usage details for the organization.
     */
    async usageVectorStoresRaw(requestParameters: UsageVectorStoresRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsageResponse>> {
        if (requestParameters['startTime'] == null) {
            throw new runtime.RequiredError(
                'startTime',
                'Required parameter "startTime" was null or undefined when calling usageVectorStores().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startTime'] != null) {
            queryParameters['start_time'] = requestParameters['startTime'];
        }

        if (requestParameters['endTime'] != null) {
            queryParameters['end_time'] = requestParameters['endTime'];
        }

        if (requestParameters['bucketWidth'] != null) {
            queryParameters['bucket_width'] = requestParameters['bucketWidth'];
        }

        if (requestParameters['projectIds'] != null) {
            queryParameters['project_ids'] = requestParameters['projectIds'];
        }

        if (requestParameters['groupBy'] != null) {
            queryParameters['group_by'] = requestParameters['groupBy'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/organization/usage/vector_stores`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsageResponseFromJSON(jsonValue));
    }

    /**
     * Get vector stores usage details for the organization.
     */
    async usageVectorStores(requestParameters: UsageVectorStoresRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsageResponse> {
        const response = await this.usageVectorStoresRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const UsageAudioSpeechesBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageAudioSpeechesBucketWidthEnum = typeof UsageAudioSpeechesBucketWidthEnum[keyof typeof UsageAudioSpeechesBucketWidthEnum];
/**
 * @export
 */
export const UsageAudioSpeechesGroupByEnum = {
    ProjectId: 'project_id',
    UserId: 'user_id',
    ApiKeyId: 'api_key_id',
    Model: 'model'
} as const;
export type UsageAudioSpeechesGroupByEnum = typeof UsageAudioSpeechesGroupByEnum[keyof typeof UsageAudioSpeechesGroupByEnum];
/**
 * @export
 */
export const UsageAudioTranscriptionsBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageAudioTranscriptionsBucketWidthEnum = typeof UsageAudioTranscriptionsBucketWidthEnum[keyof typeof UsageAudioTranscriptionsBucketWidthEnum];
/**
 * @export
 */
export const UsageAudioTranscriptionsGroupByEnum = {
    ProjectId: 'project_id',
    UserId: 'user_id',
    ApiKeyId: 'api_key_id',
    Model: 'model'
} as const;
export type UsageAudioTranscriptionsGroupByEnum = typeof UsageAudioTranscriptionsGroupByEnum[keyof typeof UsageAudioTranscriptionsGroupByEnum];
/**
 * @export
 */
export const UsageCodeInterpreterSessionsBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageCodeInterpreterSessionsBucketWidthEnum = typeof UsageCodeInterpreterSessionsBucketWidthEnum[keyof typeof UsageCodeInterpreterSessionsBucketWidthEnum];
/**
 * @export
 */
export const UsageCodeInterpreterSessionsGroupByEnum = {
    ProjectId: 'project_id'
} as const;
export type UsageCodeInterpreterSessionsGroupByEnum = typeof UsageCodeInterpreterSessionsGroupByEnum[keyof typeof UsageCodeInterpreterSessionsGroupByEnum];
/**
 * @export
 */
export const UsageCompletionsBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageCompletionsBucketWidthEnum = typeof UsageCompletionsBucketWidthEnum[keyof typeof UsageCompletionsBucketWidthEnum];
/**
 * @export
 */
export const UsageCompletionsGroupByEnum = {
    ProjectId: 'project_id',
    UserId: 'user_id',
    ApiKeyId: 'api_key_id',
    Model: 'model',
    Batch: 'batch'
} as const;
export type UsageCompletionsGroupByEnum = typeof UsageCompletionsGroupByEnum[keyof typeof UsageCompletionsGroupByEnum];
/**
 * @export
 */
export const UsageCostsBucketWidthEnum = {
    _1d: '1d'
} as const;
export type UsageCostsBucketWidthEnum = typeof UsageCostsBucketWidthEnum[keyof typeof UsageCostsBucketWidthEnum];
/**
 * @export
 */
export const UsageCostsGroupByEnum = {
    ProjectId: 'project_id',
    LineItem: 'line_item'
} as const;
export type UsageCostsGroupByEnum = typeof UsageCostsGroupByEnum[keyof typeof UsageCostsGroupByEnum];
/**
 * @export
 */
export const UsageEmbeddingsBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageEmbeddingsBucketWidthEnum = typeof UsageEmbeddingsBucketWidthEnum[keyof typeof UsageEmbeddingsBucketWidthEnum];
/**
 * @export
 */
export const UsageEmbeddingsGroupByEnum = {
    ProjectId: 'project_id',
    UserId: 'user_id',
    ApiKeyId: 'api_key_id',
    Model: 'model'
} as const;
export type UsageEmbeddingsGroupByEnum = typeof UsageEmbeddingsGroupByEnum[keyof typeof UsageEmbeddingsGroupByEnum];
/**
 * @export
 */
export const UsageImagesBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageImagesBucketWidthEnum = typeof UsageImagesBucketWidthEnum[keyof typeof UsageImagesBucketWidthEnum];
/**
 * @export
 */
export const UsageImagesSourcesEnum = {
    ImageGeneration: 'image.generation',
    ImageEdit: 'image.edit',
    ImageVariation: 'image.variation'
} as const;
export type UsageImagesSourcesEnum = typeof UsageImagesSourcesEnum[keyof typeof UsageImagesSourcesEnum];
/**
 * @export
 */
export const UsageImagesSizesEnum = {
    _256x256: '256x256',
    _512x512: '512x512',
    _1024x1024: '1024x1024',
    _1792x1792: '1792x1792',
    _1024x1792: '1024x1792'
} as const;
export type UsageImagesSizesEnum = typeof UsageImagesSizesEnum[keyof typeof UsageImagesSizesEnum];
/**
 * @export
 */
export const UsageImagesGroupByEnum = {
    ProjectId: 'project_id',
    UserId: 'user_id',
    ApiKeyId: 'api_key_id',
    Model: 'model',
    Size: 'size',
    Source: 'source'
} as const;
export type UsageImagesGroupByEnum = typeof UsageImagesGroupByEnum[keyof typeof UsageImagesGroupByEnum];
/**
 * @export
 */
export const UsageModerationsBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageModerationsBucketWidthEnum = typeof UsageModerationsBucketWidthEnum[keyof typeof UsageModerationsBucketWidthEnum];
/**
 * @export
 */
export const UsageModerationsGroupByEnum = {
    ProjectId: 'project_id',
    UserId: 'user_id',
    ApiKeyId: 'api_key_id',
    Model: 'model'
} as const;
export type UsageModerationsGroupByEnum = typeof UsageModerationsGroupByEnum[keyof typeof UsageModerationsGroupByEnum];
/**
 * @export
 */
export const UsageVectorStoresBucketWidthEnum = {
    _1m: '1m',
    _1h: '1h',
    _1d: '1d'
} as const;
export type UsageVectorStoresBucketWidthEnum = typeof UsageVectorStoresBucketWidthEnum[keyof typeof UsageVectorStoresBucketWidthEnum];
/**
 * @export
 */
export const UsageVectorStoresGroupByEnum = {
    ProjectId: 'project_id'
} as const;
export type UsageVectorStoresGroupByEnum = typeof UsageVectorStoresGroupByEnum[keyof typeof UsageVectorStoresGroupByEnum];
