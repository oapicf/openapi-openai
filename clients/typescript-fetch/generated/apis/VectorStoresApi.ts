/* tslint:disable */
/* eslint-disable */
/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateVectorStoreFileBatchRequest,
  CreateVectorStoreFileRequest,
  CreateVectorStoreRequest,
  DeleteVectorStoreFileResponse,
  DeleteVectorStoreResponse,
  ListVectorStoreFilesResponse,
  ListVectorStoresResponse,
  UpdateVectorStoreRequest,
  VectorStoreFileBatchObject,
  VectorStoreFileObject,
  VectorStoreObject,
} from '../models/index';
import {
    CreateVectorStoreFileBatchRequestFromJSON,
    CreateVectorStoreFileBatchRequestToJSON,
    CreateVectorStoreFileRequestFromJSON,
    CreateVectorStoreFileRequestToJSON,
    CreateVectorStoreRequestFromJSON,
    CreateVectorStoreRequestToJSON,
    DeleteVectorStoreFileResponseFromJSON,
    DeleteVectorStoreFileResponseToJSON,
    DeleteVectorStoreResponseFromJSON,
    DeleteVectorStoreResponseToJSON,
    ListVectorStoreFilesResponseFromJSON,
    ListVectorStoreFilesResponseToJSON,
    ListVectorStoresResponseFromJSON,
    ListVectorStoresResponseToJSON,
    UpdateVectorStoreRequestFromJSON,
    UpdateVectorStoreRequestToJSON,
    VectorStoreFileBatchObjectFromJSON,
    VectorStoreFileBatchObjectToJSON,
    VectorStoreFileObjectFromJSON,
    VectorStoreFileObjectToJSON,
    VectorStoreObjectFromJSON,
    VectorStoreObjectToJSON,
} from '../models/index';

export interface CancelVectorStoreFileBatchRequest {
    vectorStoreId: string;
    batchId: string;
}

export interface CreateVectorStoreOperationRequest {
    createVectorStoreRequest: CreateVectorStoreRequest;
}

export interface CreateVectorStoreFileOperationRequest {
    vectorStoreId: string;
    createVectorStoreFileRequest: CreateVectorStoreFileRequest;
}

export interface CreateVectorStoreFileBatchOperationRequest {
    vectorStoreId: string;
    createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest;
}

export interface DeleteVectorStoreRequest {
    vectorStoreId: string;
}

export interface DeleteVectorStoreFileRequest {
    vectorStoreId: string;
    fileId: string;
}

export interface GetVectorStoreRequest {
    vectorStoreId: string;
}

export interface GetVectorStoreFileRequest {
    vectorStoreId: string;
    fileId: string;
}

export interface GetVectorStoreFileBatchRequest {
    vectorStoreId: string;
    batchId: string;
}

export interface ListFilesInVectorStoreBatchRequest {
    vectorStoreId: string;
    batchId: string;
    limit?: number;
    order?: ListFilesInVectorStoreBatchOrderEnum;
    after?: string;
    before?: string;
    filter?: ListFilesInVectorStoreBatchFilterEnum;
}

export interface ListVectorStoreFilesRequest {
    vectorStoreId: string;
    limit?: number;
    order?: ListVectorStoreFilesOrderEnum;
    after?: string;
    before?: string;
    filter?: ListVectorStoreFilesFilterEnum;
}

export interface ListVectorStoresRequest {
    limit?: number;
    order?: ListVectorStoresOrderEnum;
    after?: string;
    before?: string;
}

export interface ModifyVectorStoreRequest {
    vectorStoreId: string;
    updateVectorStoreRequest: UpdateVectorStoreRequest;
}

/**
 * 
 */
export class VectorStoresApi extends runtime.BaseAPI {

    /**
     * Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
     */
    async cancelVectorStoreFileBatchRaw(requestParameters: CancelVectorStoreFileBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VectorStoreFileBatchObject>> {
        if (requestParameters['vectorStoreId'] == null) {
            throw new runtime.RequiredError(
                'vectorStoreId',
                'Required parameter "vectorStoreId" was null or undefined when calling cancelVectorStoreFileBatch().'
            );
        }

        if (requestParameters['batchId'] == null) {
            throw new runtime.RequiredError(
                'batchId',
                'Required parameter "batchId" was null or undefined when calling cancelVectorStoreFileBatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/vector_stores/{vector_store_id}/file_batches/{batch_id}/cancel`;
        urlPath = urlPath.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters['vectorStoreId'])));
        urlPath = urlPath.replace(`{${"batch_id"}}`, encodeURIComponent(String(requestParameters['batchId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VectorStoreFileBatchObjectFromJSON(jsonValue));
    }

    /**
     * Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
     */
    async cancelVectorStoreFileBatch(requestParameters: CancelVectorStoreFileBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VectorStoreFileBatchObject> {
        const response = await this.cancelVectorStoreFileBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a vector store.
     */
    async createVectorStoreRaw(requestParameters: CreateVectorStoreOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VectorStoreObject>> {
        if (requestParameters['createVectorStoreRequest'] == null) {
            throw new runtime.RequiredError(
                'createVectorStoreRequest',
                'Required parameter "createVectorStoreRequest" was null or undefined when calling createVectorStore().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/vector_stores`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateVectorStoreRequestToJSON(requestParameters['createVectorStoreRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VectorStoreObjectFromJSON(jsonValue));
    }

    /**
     * Create a vector store.
     */
    async createVectorStore(requestParameters: CreateVectorStoreOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VectorStoreObject> {
        const response = await this.createVectorStoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
     */
    async createVectorStoreFileRaw(requestParameters: CreateVectorStoreFileOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VectorStoreFileObject>> {
        if (requestParameters['vectorStoreId'] == null) {
            throw new runtime.RequiredError(
                'vectorStoreId',
                'Required parameter "vectorStoreId" was null or undefined when calling createVectorStoreFile().'
            );
        }

        if (requestParameters['createVectorStoreFileRequest'] == null) {
            throw new runtime.RequiredError(
                'createVectorStoreFileRequest',
                'Required parameter "createVectorStoreFileRequest" was null or undefined when calling createVectorStoreFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/vector_stores/{vector_store_id}/files`;
        urlPath = urlPath.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters['vectorStoreId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateVectorStoreFileRequestToJSON(requestParameters['createVectorStoreFileRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VectorStoreFileObjectFromJSON(jsonValue));
    }

    /**
     * Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
     */
    async createVectorStoreFile(requestParameters: CreateVectorStoreFileOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VectorStoreFileObject> {
        const response = await this.createVectorStoreFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a vector store file batch.
     */
    async createVectorStoreFileBatchRaw(requestParameters: CreateVectorStoreFileBatchOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VectorStoreFileBatchObject>> {
        if (requestParameters['vectorStoreId'] == null) {
            throw new runtime.RequiredError(
                'vectorStoreId',
                'Required parameter "vectorStoreId" was null or undefined when calling createVectorStoreFileBatch().'
            );
        }

        if (requestParameters['createVectorStoreFileBatchRequest'] == null) {
            throw new runtime.RequiredError(
                'createVectorStoreFileBatchRequest',
                'Required parameter "createVectorStoreFileBatchRequest" was null or undefined when calling createVectorStoreFileBatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/vector_stores/{vector_store_id}/file_batches`;
        urlPath = urlPath.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters['vectorStoreId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateVectorStoreFileBatchRequestToJSON(requestParameters['createVectorStoreFileBatchRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VectorStoreFileBatchObjectFromJSON(jsonValue));
    }

    /**
     * Create a vector store file batch.
     */
    async createVectorStoreFileBatch(requestParameters: CreateVectorStoreFileBatchOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VectorStoreFileBatchObject> {
        const response = await this.createVectorStoreFileBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a vector store.
     */
    async deleteVectorStoreRaw(requestParameters: DeleteVectorStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteVectorStoreResponse>> {
        if (requestParameters['vectorStoreId'] == null) {
            throw new runtime.RequiredError(
                'vectorStoreId',
                'Required parameter "vectorStoreId" was null or undefined when calling deleteVectorStore().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/vector_stores/{vector_store_id}`;
        urlPath = urlPath.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters['vectorStoreId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteVectorStoreResponseFromJSON(jsonValue));
    }

    /**
     * Delete a vector store.
     */
    async deleteVectorStore(requestParameters: DeleteVectorStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteVectorStoreResponse> {
        const response = await this.deleteVectorStoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
     */
    async deleteVectorStoreFileRaw(requestParameters: DeleteVectorStoreFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteVectorStoreFileResponse>> {
        if (requestParameters['vectorStoreId'] == null) {
            throw new runtime.RequiredError(
                'vectorStoreId',
                'Required parameter "vectorStoreId" was null or undefined when calling deleteVectorStoreFile().'
            );
        }

        if (requestParameters['fileId'] == null) {
            throw new runtime.RequiredError(
                'fileId',
                'Required parameter "fileId" was null or undefined when calling deleteVectorStoreFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/vector_stores/{vector_store_id}/files/{file_id}`;
        urlPath = urlPath.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters['vectorStoreId'])));
        urlPath = urlPath.replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters['fileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteVectorStoreFileResponseFromJSON(jsonValue));
    }

    /**
     * Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
     */
    async deleteVectorStoreFile(requestParameters: DeleteVectorStoreFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteVectorStoreFileResponse> {
        const response = await this.deleteVectorStoreFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a vector store.
     */
    async getVectorStoreRaw(requestParameters: GetVectorStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VectorStoreObject>> {
        if (requestParameters['vectorStoreId'] == null) {
            throw new runtime.RequiredError(
                'vectorStoreId',
                'Required parameter "vectorStoreId" was null or undefined when calling getVectorStore().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/vector_stores/{vector_store_id}`;
        urlPath = urlPath.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters['vectorStoreId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VectorStoreObjectFromJSON(jsonValue));
    }

    /**
     * Retrieves a vector store.
     */
    async getVectorStore(requestParameters: GetVectorStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VectorStoreObject> {
        const response = await this.getVectorStoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a vector store file.
     */
    async getVectorStoreFileRaw(requestParameters: GetVectorStoreFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VectorStoreFileObject>> {
        if (requestParameters['vectorStoreId'] == null) {
            throw new runtime.RequiredError(
                'vectorStoreId',
                'Required parameter "vectorStoreId" was null or undefined when calling getVectorStoreFile().'
            );
        }

        if (requestParameters['fileId'] == null) {
            throw new runtime.RequiredError(
                'fileId',
                'Required parameter "fileId" was null or undefined when calling getVectorStoreFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/vector_stores/{vector_store_id}/files/{file_id}`;
        urlPath = urlPath.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters['vectorStoreId'])));
        urlPath = urlPath.replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters['fileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VectorStoreFileObjectFromJSON(jsonValue));
    }

    /**
     * Retrieves a vector store file.
     */
    async getVectorStoreFile(requestParameters: GetVectorStoreFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VectorStoreFileObject> {
        const response = await this.getVectorStoreFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a vector store file batch.
     */
    async getVectorStoreFileBatchRaw(requestParameters: GetVectorStoreFileBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VectorStoreFileBatchObject>> {
        if (requestParameters['vectorStoreId'] == null) {
            throw new runtime.RequiredError(
                'vectorStoreId',
                'Required parameter "vectorStoreId" was null or undefined when calling getVectorStoreFileBatch().'
            );
        }

        if (requestParameters['batchId'] == null) {
            throw new runtime.RequiredError(
                'batchId',
                'Required parameter "batchId" was null or undefined when calling getVectorStoreFileBatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/vector_stores/{vector_store_id}/file_batches/{batch_id}`;
        urlPath = urlPath.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters['vectorStoreId'])));
        urlPath = urlPath.replace(`{${"batch_id"}}`, encodeURIComponent(String(requestParameters['batchId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VectorStoreFileBatchObjectFromJSON(jsonValue));
    }

    /**
     * Retrieves a vector store file batch.
     */
    async getVectorStoreFileBatch(requestParameters: GetVectorStoreFileBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VectorStoreFileBatchObject> {
        const response = await this.getVectorStoreFileBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of vector store files in a batch.
     */
    async listFilesInVectorStoreBatchRaw(requestParameters: ListFilesInVectorStoreBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListVectorStoreFilesResponse>> {
        if (requestParameters['vectorStoreId'] == null) {
            throw new runtime.RequiredError(
                'vectorStoreId',
                'Required parameter "vectorStoreId" was null or undefined when calling listFilesInVectorStoreBatch().'
            );
        }

        if (requestParameters['batchId'] == null) {
            throw new runtime.RequiredError(
                'batchId',
                'Required parameter "batchId" was null or undefined when calling listFilesInVectorStoreBatch().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['after'] != null) {
            queryParameters['after'] = requestParameters['after'];
        }

        if (requestParameters['before'] != null) {
            queryParameters['before'] = requestParameters['before'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/vector_stores/{vector_store_id}/file_batches/{batch_id}/files`;
        urlPath = urlPath.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters['vectorStoreId'])));
        urlPath = urlPath.replace(`{${"batch_id"}}`, encodeURIComponent(String(requestParameters['batchId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListVectorStoreFilesResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of vector store files in a batch.
     */
    async listFilesInVectorStoreBatch(requestParameters: ListFilesInVectorStoreBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListVectorStoreFilesResponse> {
        const response = await this.listFilesInVectorStoreBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of vector store files.
     */
    async listVectorStoreFilesRaw(requestParameters: ListVectorStoreFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListVectorStoreFilesResponse>> {
        if (requestParameters['vectorStoreId'] == null) {
            throw new runtime.RequiredError(
                'vectorStoreId',
                'Required parameter "vectorStoreId" was null or undefined when calling listVectorStoreFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['after'] != null) {
            queryParameters['after'] = requestParameters['after'];
        }

        if (requestParameters['before'] != null) {
            queryParameters['before'] = requestParameters['before'];
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/vector_stores/{vector_store_id}/files`;
        urlPath = urlPath.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters['vectorStoreId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListVectorStoreFilesResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of vector store files.
     */
    async listVectorStoreFiles(requestParameters: ListVectorStoreFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListVectorStoreFilesResponse> {
        const response = await this.listVectorStoreFilesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of vector stores.
     */
    async listVectorStoresRaw(requestParameters: ListVectorStoresRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListVectorStoresResponse>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['order'] != null) {
            queryParameters['order'] = requestParameters['order'];
        }

        if (requestParameters['after'] != null) {
            queryParameters['after'] = requestParameters['after'];
        }

        if (requestParameters['before'] != null) {
            queryParameters['before'] = requestParameters['before'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/vector_stores`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListVectorStoresResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of vector stores.
     */
    async listVectorStores(requestParameters: ListVectorStoresRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListVectorStoresResponse> {
        const response = await this.listVectorStoresRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modifies a vector store.
     */
    async modifyVectorStoreRaw(requestParameters: ModifyVectorStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VectorStoreObject>> {
        if (requestParameters['vectorStoreId'] == null) {
            throw new runtime.RequiredError(
                'vectorStoreId',
                'Required parameter "vectorStoreId" was null or undefined when calling modifyVectorStore().'
            );
        }

        if (requestParameters['updateVectorStoreRequest'] == null) {
            throw new runtime.RequiredError(
                'updateVectorStoreRequest',
                'Required parameter "updateVectorStoreRequest" was null or undefined when calling modifyVectorStore().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("ApiKeyAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/vector_stores/{vector_store_id}`;
        urlPath = urlPath.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters['vectorStoreId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateVectorStoreRequestToJSON(requestParameters['updateVectorStoreRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VectorStoreObjectFromJSON(jsonValue));
    }

    /**
     * Modifies a vector store.
     */
    async modifyVectorStore(requestParameters: ModifyVectorStoreRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VectorStoreObject> {
        const response = await this.modifyVectorStoreRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ListFilesInVectorStoreBatchOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListFilesInVectorStoreBatchOrderEnum = typeof ListFilesInVectorStoreBatchOrderEnum[keyof typeof ListFilesInVectorStoreBatchOrderEnum];
/**
 * @export
 */
export const ListFilesInVectorStoreBatchFilterEnum = {
    InProgress: 'in_progress',
    Completed: 'completed',
    Failed: 'failed',
    Cancelled: 'cancelled'
} as const;
export type ListFilesInVectorStoreBatchFilterEnum = typeof ListFilesInVectorStoreBatchFilterEnum[keyof typeof ListFilesInVectorStoreBatchFilterEnum];
/**
 * @export
 */
export const ListVectorStoreFilesOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListVectorStoreFilesOrderEnum = typeof ListVectorStoreFilesOrderEnum[keyof typeof ListVectorStoreFilesOrderEnum];
/**
 * @export
 */
export const ListVectorStoreFilesFilterEnum = {
    InProgress: 'in_progress',
    Completed: 'completed',
    Failed: 'failed',
    Cancelled: 'cancelled'
} as const;
export type ListVectorStoreFilesFilterEnum = typeof ListVectorStoreFilesFilterEnum[keyof typeof ListVectorStoreFilesFilterEnum];
/**
 * @export
 */
export const ListVectorStoresOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ListVectorStoresOrderEnum = typeof ListVectorStoresOrderEnum[keyof typeof ListVectorStoresOrderEnum];
