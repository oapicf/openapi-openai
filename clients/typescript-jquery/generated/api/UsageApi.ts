/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as $ from 'jquery';
import * as models from '../model/models';
import { COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


export class UsageApi {
    protected basePath = 'https://api.openai.com/v1';
    public defaultHeaders: Array<string> = [];
    public defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings = undefined;
    public configuration: Configuration = new Configuration();

    constructor(basePath?: string, configuration?: Configuration, defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
        if (defaultExtraJQueryAjaxSettings) {
            this.defaultExtraJQueryAjaxSettings = defaultExtraJQueryAjaxSettings;
        }
    }

    private extendObj<T1 extends object, T2 extends T1>(objA: T2, objB: T2): T1|T2 {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return objA;
    }

    /**
     * 
     * @summary Get audio speeches usage details for the organization.
     * @param startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param endTime End time (Unix seconds) of the query time range, exclusive.
     * @param bucketWidth Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param projectIds Return only usage for these projects.
     * @param userIds Return only usage for these users.
     * @param apiKeyIds Return only usage for these API keys.
     * @param models Return only usage for these models.
     * @param groupBy Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
     * @param limit Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param page A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     */
    public usageAudioSpeeches(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.UsageResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/organization/usage/audio_speeches';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling usageAudioSpeeches.');
        }

        if (startTime !== null && startTime !== undefined) {
            queryParameters['start_time'] = <string><any>startTime;
        }
        if (endTime !== null && endTime !== undefined) {
            queryParameters['end_time'] = <string><any>endTime;
        }
        if (bucketWidth !== null && bucketWidth !== undefined) {
            queryParameters['bucket_width'] = <string><any>bucketWidth;
        }
        if (projectIds) {
            queryParameters['project_ids'] = [];
            projectIds.forEach((element: any) => {
                queryParameters['project_ids'].push(element);
            });
        }
        if (userIds) {
            queryParameters['user_ids'] = [];
            userIds.forEach((element: any) => {
                queryParameters['user_ids'].push(element);
            });
        }
        if (apiKeyIds) {
            queryParameters['api_key_ids'] = [];
            apiKeyIds.forEach((element: any) => {
                queryParameters['api_key_ids'].push(element);
            });
        }
        if (models) {
            queryParameters['models'] = [];
            models.forEach((element: any) => {
                queryParameters['models'].push(element);
            });
        }
        if (groupBy) {
            queryParameters['group_by'] = [];
            groupBy.forEach((element: any) => {
                queryParameters['group_by'].push(element);
            });
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (page !== null && page !== undefined) {
            queryParameters['page'] = <string><any>page;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.UsageResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.UsageResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Get audio transcriptions usage details for the organization.
     * @param startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param endTime End time (Unix seconds) of the query time range, exclusive.
     * @param bucketWidth Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param projectIds Return only usage for these projects.
     * @param userIds Return only usage for these users.
     * @param apiKeyIds Return only usage for these API keys.
     * @param models Return only usage for these models.
     * @param groupBy Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
     * @param limit Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param page A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     */
    public usageAudioTranscriptions(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.UsageResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/organization/usage/audio_transcriptions';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling usageAudioTranscriptions.');
        }

        if (startTime !== null && startTime !== undefined) {
            queryParameters['start_time'] = <string><any>startTime;
        }
        if (endTime !== null && endTime !== undefined) {
            queryParameters['end_time'] = <string><any>endTime;
        }
        if (bucketWidth !== null && bucketWidth !== undefined) {
            queryParameters['bucket_width'] = <string><any>bucketWidth;
        }
        if (projectIds) {
            queryParameters['project_ids'] = [];
            projectIds.forEach((element: any) => {
                queryParameters['project_ids'].push(element);
            });
        }
        if (userIds) {
            queryParameters['user_ids'] = [];
            userIds.forEach((element: any) => {
                queryParameters['user_ids'].push(element);
            });
        }
        if (apiKeyIds) {
            queryParameters['api_key_ids'] = [];
            apiKeyIds.forEach((element: any) => {
                queryParameters['api_key_ids'].push(element);
            });
        }
        if (models) {
            queryParameters['models'] = [];
            models.forEach((element: any) => {
                queryParameters['models'].push(element);
            });
        }
        if (groupBy) {
            queryParameters['group_by'] = [];
            groupBy.forEach((element: any) => {
                queryParameters['group_by'].push(element);
            });
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (page !== null && page !== undefined) {
            queryParameters['page'] = <string><any>page;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.UsageResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.UsageResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Get code interpreter sessions usage details for the organization.
     * @param startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param endTime End time (Unix seconds) of the query time range, exclusive.
     * @param bucketWidth Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param projectIds Return only usage for these projects.
     * @param groupBy Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;.
     * @param limit Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param page A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     */
    public usageCodeInterpreterSessions(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, groupBy?: Array<'project_id'>, limit?: number, page?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.UsageResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/organization/usage/code_interpreter_sessions';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling usageCodeInterpreterSessions.');
        }

        if (startTime !== null && startTime !== undefined) {
            queryParameters['start_time'] = <string><any>startTime;
        }
        if (endTime !== null && endTime !== undefined) {
            queryParameters['end_time'] = <string><any>endTime;
        }
        if (bucketWidth !== null && bucketWidth !== undefined) {
            queryParameters['bucket_width'] = <string><any>bucketWidth;
        }
        if (projectIds) {
            queryParameters['project_ids'] = [];
            projectIds.forEach((element: any) => {
                queryParameters['project_ids'].push(element);
            });
        }
        if (groupBy) {
            queryParameters['group_by'] = [];
            groupBy.forEach((element: any) => {
                queryParameters['group_by'].push(element);
            });
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (page !== null && page !== undefined) {
            queryParameters['page'] = <string><any>page;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.UsageResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.UsageResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Get completions usage details for the organization.
     * @param startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param endTime End time (Unix seconds) of the query time range, exclusive.
     * @param bucketWidth Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param projectIds Return only usage for these projects.
     * @param userIds Return only usage for these users.
     * @param apiKeyIds Return only usage for these API keys.
     * @param models Return only usage for these models.
     * @param batch If &#x60;true&#x60;, return batch jobs only. If &#x60;false&#x60;, return non-batch jobs only. By default, return both. 
     * @param groupBy Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;batch&#x60; or any combination of them.
     * @param limit Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param page A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     */
    public usageCompletions(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, batch?: boolean, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model' | 'batch'>, limit?: number, page?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.UsageResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/organization/usage/completions';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling usageCompletions.');
        }

        if (startTime !== null && startTime !== undefined) {
            queryParameters['start_time'] = <string><any>startTime;
        }
        if (endTime !== null && endTime !== undefined) {
            queryParameters['end_time'] = <string><any>endTime;
        }
        if (bucketWidth !== null && bucketWidth !== undefined) {
            queryParameters['bucket_width'] = <string><any>bucketWidth;
        }
        if (projectIds) {
            queryParameters['project_ids'] = [];
            projectIds.forEach((element: any) => {
                queryParameters['project_ids'].push(element);
            });
        }
        if (userIds) {
            queryParameters['user_ids'] = [];
            userIds.forEach((element: any) => {
                queryParameters['user_ids'].push(element);
            });
        }
        if (apiKeyIds) {
            queryParameters['api_key_ids'] = [];
            apiKeyIds.forEach((element: any) => {
                queryParameters['api_key_ids'].push(element);
            });
        }
        if (models) {
            queryParameters['models'] = [];
            models.forEach((element: any) => {
                queryParameters['models'].push(element);
            });
        }
        if (batch !== null && batch !== undefined) {
            queryParameters['batch'] = <string><any>batch;
        }
        if (groupBy) {
            queryParameters['group_by'] = [];
            groupBy.forEach((element: any) => {
                queryParameters['group_by'].push(element);
            });
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (page !== null && page !== undefined) {
            queryParameters['page'] = <string><any>page;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.UsageResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.UsageResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Get costs details for the organization.
     * @param startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param endTime End time (Unix seconds) of the query time range, exclusive.
     * @param bucketWidth Width of each time bucket in response. Currently only &#x60;1d&#x60; is supported, default to &#x60;1d&#x60;.
     * @param projectIds Return only costs for these projects.
     * @param groupBy Group the costs by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;line_item&#x60; and any combination of them.
     * @param limit A limit on the number of buckets to be returned. Limit can range between 1 and 180, and the default is 7. 
     * @param page A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     */
    public usageCosts(startTime: number, endTime?: number, bucketWidth?: '1d', projectIds?: Array<string>, groupBy?: Array<'project_id' | 'line_item'>, limit?: number, page?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.UsageResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/organization/costs';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling usageCosts.');
        }

        if (startTime !== null && startTime !== undefined) {
            queryParameters['start_time'] = <string><any>startTime;
        }
        if (endTime !== null && endTime !== undefined) {
            queryParameters['end_time'] = <string><any>endTime;
        }
        if (bucketWidth !== null && bucketWidth !== undefined) {
            queryParameters['bucket_width'] = <string><any>bucketWidth;
        }
        if (projectIds) {
            queryParameters['project_ids'] = [];
            projectIds.forEach((element: any) => {
                queryParameters['project_ids'].push(element);
            });
        }
        if (groupBy) {
            queryParameters['group_by'] = [];
            groupBy.forEach((element: any) => {
                queryParameters['group_by'].push(element);
            });
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (page !== null && page !== undefined) {
            queryParameters['page'] = <string><any>page;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.UsageResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.UsageResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Get embeddings usage details for the organization.
     * @param startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param endTime End time (Unix seconds) of the query time range, exclusive.
     * @param bucketWidth Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param projectIds Return only usage for these projects.
     * @param userIds Return only usage for these users.
     * @param apiKeyIds Return only usage for these API keys.
     * @param models Return only usage for these models.
     * @param groupBy Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
     * @param limit Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param page A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     */
    public usageEmbeddings(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.UsageResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/organization/usage/embeddings';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling usageEmbeddings.');
        }

        if (startTime !== null && startTime !== undefined) {
            queryParameters['start_time'] = <string><any>startTime;
        }
        if (endTime !== null && endTime !== undefined) {
            queryParameters['end_time'] = <string><any>endTime;
        }
        if (bucketWidth !== null && bucketWidth !== undefined) {
            queryParameters['bucket_width'] = <string><any>bucketWidth;
        }
        if (projectIds) {
            queryParameters['project_ids'] = [];
            projectIds.forEach((element: any) => {
                queryParameters['project_ids'].push(element);
            });
        }
        if (userIds) {
            queryParameters['user_ids'] = [];
            userIds.forEach((element: any) => {
                queryParameters['user_ids'].push(element);
            });
        }
        if (apiKeyIds) {
            queryParameters['api_key_ids'] = [];
            apiKeyIds.forEach((element: any) => {
                queryParameters['api_key_ids'].push(element);
            });
        }
        if (models) {
            queryParameters['models'] = [];
            models.forEach((element: any) => {
                queryParameters['models'].push(element);
            });
        }
        if (groupBy) {
            queryParameters['group_by'] = [];
            groupBy.forEach((element: any) => {
                queryParameters['group_by'].push(element);
            });
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (page !== null && page !== undefined) {
            queryParameters['page'] = <string><any>page;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.UsageResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.UsageResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Get images usage details for the organization.
     * @param startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param endTime End time (Unix seconds) of the query time range, exclusive.
     * @param bucketWidth Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param sources Return only usages for these sources. Possible values are &#x60;image.generation&#x60;, &#x60;image.edit&#x60;, &#x60;image.variation&#x60; or any combination of them.
     * @param sizes Return only usages for these image sizes. Possible values are &#x60;256x256&#x60;, &#x60;512x512&#x60;, &#x60;1024x1024&#x60;, &#x60;1792x1792&#x60;, &#x60;1024x1792&#x60; or any combination of them.
     * @param projectIds Return only usage for these projects.
     * @param userIds Return only usage for these users.
     * @param apiKeyIds Return only usage for these API keys.
     * @param models Return only usage for these models.
     * @param groupBy Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60;, &#x60;size&#x60;, &#x60;source&#x60; or any combination of them.
     * @param limit Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param page A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     */
    public usageImages(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', sources?: Array<'image.generation' | 'image.edit' | 'image.variation'>, sizes?: Array<'256x256' | '512x512' | '1024x1024' | '1792x1792' | '1024x1792'>, projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model' | 'size' | 'source'>, limit?: number, page?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.UsageResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/organization/usage/images';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling usageImages.');
        }

        if (startTime !== null && startTime !== undefined) {
            queryParameters['start_time'] = <string><any>startTime;
        }
        if (endTime !== null && endTime !== undefined) {
            queryParameters['end_time'] = <string><any>endTime;
        }
        if (bucketWidth !== null && bucketWidth !== undefined) {
            queryParameters['bucket_width'] = <string><any>bucketWidth;
        }
        if (sources) {
            queryParameters['sources'] = [];
            sources.forEach((element: any) => {
                queryParameters['sources'].push(element);
            });
        }
        if (sizes) {
            queryParameters['sizes'] = [];
            sizes.forEach((element: any) => {
                queryParameters['sizes'].push(element);
            });
        }
        if (projectIds) {
            queryParameters['project_ids'] = [];
            projectIds.forEach((element: any) => {
                queryParameters['project_ids'].push(element);
            });
        }
        if (userIds) {
            queryParameters['user_ids'] = [];
            userIds.forEach((element: any) => {
                queryParameters['user_ids'].push(element);
            });
        }
        if (apiKeyIds) {
            queryParameters['api_key_ids'] = [];
            apiKeyIds.forEach((element: any) => {
                queryParameters['api_key_ids'].push(element);
            });
        }
        if (models) {
            queryParameters['models'] = [];
            models.forEach((element: any) => {
                queryParameters['models'].push(element);
            });
        }
        if (groupBy) {
            queryParameters['group_by'] = [];
            groupBy.forEach((element: any) => {
                queryParameters['group_by'].push(element);
            });
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (page !== null && page !== undefined) {
            queryParameters['page'] = <string><any>page;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.UsageResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.UsageResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Get moderations usage details for the organization.
     * @param startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param endTime End time (Unix seconds) of the query time range, exclusive.
     * @param bucketWidth Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param projectIds Return only usage for these projects.
     * @param userIds Return only usage for these users.
     * @param apiKeyIds Return only usage for these API keys.
     * @param models Return only usage for these models.
     * @param groupBy Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;, &#x60;user_id&#x60;, &#x60;api_key_id&#x60;, &#x60;model&#x60; or any combination of them.
     * @param limit Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param page A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     */
    public usageModerations(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, userIds?: Array<string>, apiKeyIds?: Array<string>, models?: Array<string>, groupBy?: Array<'project_id' | 'user_id' | 'api_key_id' | 'model'>, limit?: number, page?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.UsageResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/organization/usage/moderations';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling usageModerations.');
        }

        if (startTime !== null && startTime !== undefined) {
            queryParameters['start_time'] = <string><any>startTime;
        }
        if (endTime !== null && endTime !== undefined) {
            queryParameters['end_time'] = <string><any>endTime;
        }
        if (bucketWidth !== null && bucketWidth !== undefined) {
            queryParameters['bucket_width'] = <string><any>bucketWidth;
        }
        if (projectIds) {
            queryParameters['project_ids'] = [];
            projectIds.forEach((element: any) => {
                queryParameters['project_ids'].push(element);
            });
        }
        if (userIds) {
            queryParameters['user_ids'] = [];
            userIds.forEach((element: any) => {
                queryParameters['user_ids'].push(element);
            });
        }
        if (apiKeyIds) {
            queryParameters['api_key_ids'] = [];
            apiKeyIds.forEach((element: any) => {
                queryParameters['api_key_ids'].push(element);
            });
        }
        if (models) {
            queryParameters['models'] = [];
            models.forEach((element: any) => {
                queryParameters['models'].push(element);
            });
        }
        if (groupBy) {
            queryParameters['group_by'] = [];
            groupBy.forEach((element: any) => {
                queryParameters['group_by'].push(element);
            });
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (page !== null && page !== undefined) {
            queryParameters['page'] = <string><any>page;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.UsageResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.UsageResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Get vector stores usage details for the organization.
     * @param startTime Start time (Unix seconds) of the query time range, inclusive.
     * @param endTime End time (Unix seconds) of the query time range, exclusive.
     * @param bucketWidth Width of each time bucket in response. Currently &#x60;1m&#x60;, &#x60;1h&#x60; and &#x60;1d&#x60; are supported, default to &#x60;1d&#x60;.
     * @param projectIds Return only usage for these projects.
     * @param groupBy Group the usage data by the specified fields. Support fields include &#x60;project_id&#x60;.
     * @param limit Specifies the number of buckets to return. - &#x60;bucket_width&#x3D;1d&#x60;: default: 7, max: 31 - &#x60;bucket_width&#x3D;1h&#x60;: default: 24, max: 168 - &#x60;bucket_width&#x3D;1m&#x60;: default: 60, max: 1440 
     * @param page A cursor for use in pagination. Corresponding to the &#x60;next_page&#x60; field from the previous response.
     */
    public usageVectorStores(startTime: number, endTime?: number, bucketWidth?: '1m' | '1h' | '1d', projectIds?: Array<string>, groupBy?: Array<'project_id'>, limit?: number, page?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.UsageResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/organization/usage/vector_stores';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling usageVectorStores.');
        }

        if (startTime !== null && startTime !== undefined) {
            queryParameters['start_time'] = <string><any>startTime;
        }
        if (endTime !== null && endTime !== undefined) {
            queryParameters['end_time'] = <string><any>endTime;
        }
        if (bucketWidth !== null && bucketWidth !== undefined) {
            queryParameters['bucket_width'] = <string><any>bucketWidth;
        }
        if (projectIds) {
            queryParameters['project_ids'] = [];
            projectIds.forEach((element: any) => {
                queryParameters['project_ids'].push(element);
            });
        }
        if (groupBy) {
            queryParameters['group_by'] = [];
            groupBy.forEach((element: any) => {
                queryParameters['group_by'].push(element);
            });
        }
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (page !== null && page !== undefined) {
            queryParameters['page'] = <string><any>page;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.UsageResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.UsageResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

}
