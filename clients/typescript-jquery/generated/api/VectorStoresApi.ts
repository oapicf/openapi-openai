/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as $ from 'jquery';
import * as models from '../model/models';
import { COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


export class VectorStoresApi {
    protected basePath = 'https://api.openai.com/v1';
    public defaultHeaders: Array<string> = [];
    public defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings = undefined;
    public configuration: Configuration = new Configuration();

    constructor(basePath?: string, configuration?: Configuration, defaultExtraJQueryAjaxSettings?: JQueryAjaxSettings) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
        if (defaultExtraJQueryAjaxSettings) {
            this.defaultExtraJQueryAjaxSettings = defaultExtraJQueryAjaxSettings;
        }
    }

    private extendObj<T1 extends object, T2 extends T1>(objA: T2, objB: T2): T1|T2 {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                objA[key] = objB[key];
            }
        }
        return objA;
    }

    /**
     * 
     * @summary Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
     * @param vectorStoreId The ID of the vector store that the file batch belongs to.
     * @param batchId The ID of the file batch to cancel.
     */
    public cancelVectorStoreFileBatch(vectorStoreId: string, batchId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.VectorStoreFileBatchObject;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/vector_stores/{vector_store_id}/file_batches/{batch_id}/cancel'.replace('{' + 'vector_store_id' + '}', encodeURIComponent(String(vectorStoreId))).replace('{' + 'batch_id' + '}', encodeURIComponent(String(batchId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'vectorStoreId' is not null or undefined
        if (vectorStoreId === null || vectorStoreId === undefined) {
            throw new Error('Required parameter vectorStoreId was null or undefined when calling cancelVectorStoreFileBatch.');
        }

        // verify required parameter 'batchId' is not null or undefined
        if (batchId === null || batchId === undefined) {
            throw new Error('Required parameter batchId was null or undefined when calling cancelVectorStoreFileBatch.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.VectorStoreFileBatchObject;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.VectorStoreFileBatchObject, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Create a vector store.
     * @param createVectorStoreRequest 
     */
    public createVectorStore(createVectorStoreRequest: models.CreateVectorStoreRequest, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.VectorStoreObject;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/vector_stores';

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'createVectorStoreRequest' is not null or undefined
        if (createVectorStoreRequest === null || createVectorStoreRequest === undefined) {
            throw new Error('Required parameter createVectorStoreRequest was null or undefined when calling createVectorStore.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(createVectorStoreRequest);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.VectorStoreObject;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.VectorStoreObject, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
     * @param vectorStoreId The ID of the vector store for which to create a File. 
     * @param createVectorStoreFileRequest 
     */
    public createVectorStoreFile(vectorStoreId: string, createVectorStoreFileRequest: models.CreateVectorStoreFileRequest, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.VectorStoreFileObject;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/vector_stores/{vector_store_id}/files'.replace('{' + 'vector_store_id' + '}', encodeURIComponent(String(vectorStoreId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'vectorStoreId' is not null or undefined
        if (vectorStoreId === null || vectorStoreId === undefined) {
            throw new Error('Required parameter vectorStoreId was null or undefined when calling createVectorStoreFile.');
        }

        // verify required parameter 'createVectorStoreFileRequest' is not null or undefined
        if (createVectorStoreFileRequest === null || createVectorStoreFileRequest === undefined) {
            throw new Error('Required parameter createVectorStoreFileRequest was null or undefined when calling createVectorStoreFile.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(createVectorStoreFileRequest);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.VectorStoreFileObject;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.VectorStoreFileObject, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Create a vector store file batch.
     * @param vectorStoreId The ID of the vector store for which to create a File Batch. 
     * @param createVectorStoreFileBatchRequest 
     */
    public createVectorStoreFileBatch(vectorStoreId: string, createVectorStoreFileBatchRequest: models.CreateVectorStoreFileBatchRequest, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.VectorStoreFileBatchObject;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/vector_stores/{vector_store_id}/file_batches'.replace('{' + 'vector_store_id' + '}', encodeURIComponent(String(vectorStoreId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'vectorStoreId' is not null or undefined
        if (vectorStoreId === null || vectorStoreId === undefined) {
            throw new Error('Required parameter vectorStoreId was null or undefined when calling createVectorStoreFileBatch.');
        }

        // verify required parameter 'createVectorStoreFileBatchRequest' is not null or undefined
        if (createVectorStoreFileBatchRequest === null || createVectorStoreFileBatchRequest === undefined) {
            throw new Error('Required parameter createVectorStoreFileBatchRequest was null or undefined when calling createVectorStoreFileBatch.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(createVectorStoreFileBatchRequest);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.VectorStoreFileBatchObject;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.VectorStoreFileBatchObject, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Delete a vector store.
     * @param vectorStoreId The ID of the vector store to delete.
     */
    public deleteVectorStore(vectorStoreId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.DeleteVectorStoreResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/vector_stores/{vector_store_id}'.replace('{' + 'vector_store_id' + '}', encodeURIComponent(String(vectorStoreId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'vectorStoreId' is not null or undefined
        if (vectorStoreId === null || vectorStoreId === undefined) {
            throw new Error('Required parameter vectorStoreId was null or undefined when calling deleteVectorStore.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'DELETE',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.DeleteVectorStoreResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.DeleteVectorStoreResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
     * @param vectorStoreId The ID of the vector store that the file belongs to.
     * @param fileId The ID of the file to delete.
     */
    public deleteVectorStoreFile(vectorStoreId: string, fileId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.DeleteVectorStoreFileResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/vector_stores/{vector_store_id}/files/{file_id}'.replace('{' + 'vector_store_id' + '}', encodeURIComponent(String(vectorStoreId))).replace('{' + 'file_id' + '}', encodeURIComponent(String(fileId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'vectorStoreId' is not null or undefined
        if (vectorStoreId === null || vectorStoreId === undefined) {
            throw new Error('Required parameter vectorStoreId was null or undefined when calling deleteVectorStoreFile.');
        }

        // verify required parameter 'fileId' is not null or undefined
        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling deleteVectorStoreFile.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'DELETE',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.DeleteVectorStoreFileResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.DeleteVectorStoreFileResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Retrieves a vector store.
     * @param vectorStoreId The ID of the vector store to retrieve.
     */
    public getVectorStore(vectorStoreId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.VectorStoreObject;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/vector_stores/{vector_store_id}'.replace('{' + 'vector_store_id' + '}', encodeURIComponent(String(vectorStoreId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'vectorStoreId' is not null or undefined
        if (vectorStoreId === null || vectorStoreId === undefined) {
            throw new Error('Required parameter vectorStoreId was null or undefined when calling getVectorStore.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.VectorStoreObject;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.VectorStoreObject, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Retrieves a vector store file.
     * @param vectorStoreId The ID of the vector store that the file belongs to.
     * @param fileId The ID of the file being retrieved.
     */
    public getVectorStoreFile(vectorStoreId: string, fileId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.VectorStoreFileObject;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/vector_stores/{vector_store_id}/files/{file_id}'.replace('{' + 'vector_store_id' + '}', encodeURIComponent(String(vectorStoreId))).replace('{' + 'file_id' + '}', encodeURIComponent(String(fileId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'vectorStoreId' is not null or undefined
        if (vectorStoreId === null || vectorStoreId === undefined) {
            throw new Error('Required parameter vectorStoreId was null or undefined when calling getVectorStoreFile.');
        }

        // verify required parameter 'fileId' is not null or undefined
        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling getVectorStoreFile.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.VectorStoreFileObject;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.VectorStoreFileObject, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Retrieves a vector store file batch.
     * @param vectorStoreId The ID of the vector store that the file batch belongs to.
     * @param batchId The ID of the file batch being retrieved.
     */
    public getVectorStoreFileBatch(vectorStoreId: string, batchId: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.VectorStoreFileBatchObject;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/vector_stores/{vector_store_id}/file_batches/{batch_id}'.replace('{' + 'vector_store_id' + '}', encodeURIComponent(String(vectorStoreId))).replace('{' + 'batch_id' + '}', encodeURIComponent(String(batchId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'vectorStoreId' is not null or undefined
        if (vectorStoreId === null || vectorStoreId === undefined) {
            throw new Error('Required parameter vectorStoreId was null or undefined when calling getVectorStoreFileBatch.');
        }

        // verify required parameter 'batchId' is not null or undefined
        if (batchId === null || batchId === undefined) {
            throw new Error('Required parameter batchId was null or undefined when calling getVectorStoreFileBatch.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.VectorStoreFileBatchObject;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.VectorStoreFileBatchObject, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Returns a list of vector store files in a batch.
     * @param vectorStoreId The ID of the vector store that the files belong to.
     * @param batchId The ID of the file batch that the files belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param filter Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
     */
    public listFilesInVectorStoreBatch(vectorStoreId: string, batchId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, filter?: 'in_progress' | 'completed' | 'failed' | 'cancelled', extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.ListVectorStoreFilesResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/vector_stores/{vector_store_id}/file_batches/{batch_id}/files'.replace('{' + 'vector_store_id' + '}', encodeURIComponent(String(vectorStoreId))).replace('{' + 'batch_id' + '}', encodeURIComponent(String(batchId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'vectorStoreId' is not null or undefined
        if (vectorStoreId === null || vectorStoreId === undefined) {
            throw new Error('Required parameter vectorStoreId was null or undefined when calling listFilesInVectorStoreBatch.');
        }

        // verify required parameter 'batchId' is not null or undefined
        if (batchId === null || batchId === undefined) {
            throw new Error('Required parameter batchId was null or undefined when calling listFilesInVectorStoreBatch.');
        }

        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (order !== null && order !== undefined) {
            queryParameters['order'] = <string><any>order;
        }
        if (after !== null && after !== undefined) {
            queryParameters['after'] = <string><any>after;
        }
        if (before !== null && before !== undefined) {
            queryParameters['before'] = <string><any>before;
        }
        if (filter !== null && filter !== undefined) {
            queryParameters['filter'] = <string><any>filter;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.ListVectorStoreFilesResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.ListVectorStoreFilesResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Returns a list of vector store files.
     * @param vectorStoreId The ID of the vector store that the files belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param filter Filter by file status. One of &#x60;in_progress&#x60;, &#x60;completed&#x60;, &#x60;failed&#x60;, &#x60;cancelled&#x60;.
     */
    public listVectorStoreFiles(vectorStoreId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, filter?: 'in_progress' | 'completed' | 'failed' | 'cancelled', extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.ListVectorStoreFilesResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/vector_stores/{vector_store_id}/files'.replace('{' + 'vector_store_id' + '}', encodeURIComponent(String(vectorStoreId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'vectorStoreId' is not null or undefined
        if (vectorStoreId === null || vectorStoreId === undefined) {
            throw new Error('Required parameter vectorStoreId was null or undefined when calling listVectorStoreFiles.');
        }

        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (order !== null && order !== undefined) {
            queryParameters['order'] = <string><any>order;
        }
        if (after !== null && after !== undefined) {
            queryParameters['after'] = <string><any>after;
        }
        if (before !== null && before !== undefined) {
            queryParameters['before'] = <string><any>before;
        }
        if (filter !== null && filter !== undefined) {
            queryParameters['filter'] = <string><any>filter;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.ListVectorStoreFilesResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.ListVectorStoreFilesResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Returns a list of vector stores.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     */
    public listVectorStores(limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.ListVectorStoresResponse;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/vector_stores';

        let queryParameters: any = {};
        let headerParams: any = {};
        if (limit !== null && limit !== undefined) {
            queryParameters['limit'] = <string><any>limit;
        }
        if (order !== null && order !== undefined) {
            queryParameters['order'] = <string><any>order;
        }
        if (after !== null && after !== undefined) {
            queryParameters['after'] = <string><any>after;
        }
        if (before !== null && before !== undefined) {
            queryParameters['before'] = <string><any>before;
        }

        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'GET',
            headers: headerParams,
            processData: false
        };

        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.ListVectorStoresResponse;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.ListVectorStoresResponse, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

    /**
     * 
     * @summary Modifies a vector store.
     * @param vectorStoreId The ID of the vector store to modify.
     * @param updateVectorStoreRequest 
     */
    public modifyVectorStore(vectorStoreId: string, updateVectorStoreRequest: models.UpdateVectorStoreRequest, extraJQueryAjaxSettings?: JQueryAjaxSettings): JQuery.Promise<
    { response: JQueryXHR; body: models.VectorStoreObject;  },
    { response: JQueryXHR; errorThrown: string }
    > {
        let localVarPath = this.basePath + '/vector_stores/{vector_store_id}'.replace('{' + 'vector_store_id' + '}', encodeURIComponent(String(vectorStoreId)));

        let queryParameters: any = {};
        let headerParams: any = {};
        // verify required parameter 'vectorStoreId' is not null or undefined
        if (vectorStoreId === null || vectorStoreId === undefined) {
            throw new Error('Required parameter vectorStoreId was null or undefined when calling modifyVectorStore.');
        }

        // verify required parameter 'updateVectorStoreRequest' is not null or undefined
        if (updateVectorStoreRequest === null || updateVectorStoreRequest === undefined) {
            throw new Error('Required parameter updateVectorStoreRequest was null or undefined when calling modifyVectorStore.');
        }


        localVarPath = localVarPath + "?" + $.param(queryParameters);
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (ApiKeyAuth) required

        headerParams['Content-Type'] = 'application/json';

        let requestOptions: JQueryAjaxSettings = {
            url: localVarPath,
            type: 'POST',
            headers: headerParams,
            processData: false
        };

        requestOptions.data = JSON.stringify(updateVectorStoreRequest);
        if (headerParams['Content-Type']) {
            requestOptions.contentType = headerParams['Content-Type'];
        }

        if (extraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, extraJQueryAjaxSettings);
        }

        if (this.defaultExtraJQueryAjaxSettings) {
            requestOptions = (<any>Object).assign(requestOptions, this.defaultExtraJQueryAjaxSettings);
        }

        let dfd = $.Deferred<
            { response: JQueryXHR; body: models.VectorStoreObject;  },
            { response: JQueryXHR; errorThrown: string }
        >();
        $.ajax(requestOptions).then(
            (data: models.VectorStoreObject, textStatus: string, jqXHR: JQueryXHR) =>
                dfd.resolve({response: jqXHR, body: data}),
            (xhr: JQueryXHR, textStatus: string, errorThrown: string) =>
                dfd.reject({response: xhr, errorThrown: errorThrown})
        );
        return dfd.promise();
    }

}
