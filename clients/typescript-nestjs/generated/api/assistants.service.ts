/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { AssistantFileObject } from '../model/assistantFileObject';
import { AssistantObject } from '../model/assistantObject';
import { CreateAssistantFileRequest } from '../model/createAssistantFileRequest';
import { CreateAssistantRequest } from '../model/createAssistantRequest';
import { CreateMessageRequest } from '../model/createMessageRequest';
import { CreateRunRequest } from '../model/createRunRequest';
import { CreateThreadAndRunRequest } from '../model/createThreadAndRunRequest';
import { CreateThreadRequest } from '../model/createThreadRequest';
import { DeleteAssistantFileResponse } from '../model/deleteAssistantFileResponse';
import { DeleteAssistantResponse } from '../model/deleteAssistantResponse';
import { DeleteThreadResponse } from '../model/deleteThreadResponse';
import { ListAssistantFilesResponse } from '../model/listAssistantFilesResponse';
import { ListAssistantsResponse } from '../model/listAssistantsResponse';
import { ListMessageFilesResponse } from '../model/listMessageFilesResponse';
import { ListMessagesResponse } from '../model/listMessagesResponse';
import { ListRunStepsResponse } from '../model/listRunStepsResponse';
import { ListRunsResponse } from '../model/listRunsResponse';
import { MessageFileObject } from '../model/messageFileObject';
import { MessageObject } from '../model/messageObject';
import { ModifyAssistantRequest } from '../model/modifyAssistantRequest';
import { ModifyMessageRequest } from '../model/modifyMessageRequest';
import { ModifyRunRequest } from '../model/modifyRunRequest';
import { ModifyThreadRequest } from '../model/modifyThreadRequest';
import { RunObject } from '../model/runObject';
import { RunStepObject } from '../model/runStepObject';
import { SubmitToolOutputsRunRequest } from '../model/submitToolOutputsRunRequest';
import { ThreadObject } from '../model/threadObject';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class AssistantsService {

    protected basePath = 'https://api.openai.com/v1';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();
    protected httpClient: HttpService;

    constructor(httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
        this.httpClient = configuration?.httpClient || httpClient;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Cancels a run that is &#x60;in_progress&#x60;.
     * 
     * @param threadId The ID of the thread to which this run belongs.
     * @param runId The ID of the run to cancel.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [cancelRunOpts.config] Override http request option.
     */
    public cancelRun(threadId: string, runId: string, cancelRunOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<RunObject>>;
    public cancelRun(threadId: string, runId: string, cancelRunOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling cancelRun.');
        }

        if (runId === null || runId === undefined) {
            throw new Error('Required parameter runId was null or undefined when calling cancelRun.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<RunObject>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}/runs/${encodeURIComponent(String(run_id))}/cancel`,
                    null,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...cancelRunOpts?.config,
                        headers: {...headers, ...cancelRunOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Create an assistant with a model and instructions.
     * 
     * @param createAssistantRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [createAssistantOpts.config] Override http request option.
     */
    public createAssistant(createAssistantRequest: CreateAssistantRequest, createAssistantOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<AssistantObject>>;
    public createAssistant(createAssistantRequest: CreateAssistantRequest, createAssistantOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (createAssistantRequest === null || createAssistantRequest === undefined) {
            throw new Error('Required parameter createAssistantRequest was null or undefined when calling createAssistant.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<AssistantObject>(`${this.basePath}/assistants`,
                    createAssistantRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...createAssistantOpts?.config,
                        headers: {...headers, ...createAssistantOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants).
     * 
     * @param assistantId The ID of the assistant for which to create a File. 
     * @param createAssistantFileRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [createAssistantFileOpts.config] Override http request option.
     */
    public createAssistantFile(assistantId: string, createAssistantFileRequest: CreateAssistantFileRequest, createAssistantFileOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<AssistantFileObject>>;
    public createAssistantFile(assistantId: string, createAssistantFileRequest: CreateAssistantFileRequest, createAssistantFileOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (assistantId === null || assistantId === undefined) {
            throw new Error('Required parameter assistantId was null or undefined when calling createAssistantFile.');
        }

        if (createAssistantFileRequest === null || createAssistantFileRequest === undefined) {
            throw new Error('Required parameter createAssistantFileRequest was null or undefined when calling createAssistantFile.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<AssistantFileObject>(`${this.basePath}/assistants/${encodeURIComponent(String(assistant_id))}/files`,
                    createAssistantFileRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...createAssistantFileOpts?.config,
                        headers: {...headers, ...createAssistantFileOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Create a message.
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) to create a message for.
     * @param createMessageRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [createMessageOpts.config] Override http request option.
     */
    public createMessage(threadId: string, createMessageRequest: CreateMessageRequest, createMessageOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MessageObject>>;
    public createMessage(threadId: string, createMessageRequest: CreateMessageRequest, createMessageOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling createMessage.');
        }

        if (createMessageRequest === null || createMessageRequest === undefined) {
            throw new Error('Required parameter createMessageRequest was null or undefined when calling createMessage.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<MessageObject>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}/messages`,
                    createMessageRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...createMessageOpts?.config,
                        headers: {...headers, ...createMessageOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Create a run.
     * 
     * @param threadId The ID of the thread to run.
     * @param createRunRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [createRunOpts.config] Override http request option.
     */
    public createRun(threadId: string, createRunRequest: CreateRunRequest, createRunOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<RunObject>>;
    public createRun(threadId: string, createRunRequest: CreateRunRequest, createRunOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling createRun.');
        }

        if (createRunRequest === null || createRunRequest === undefined) {
            throw new Error('Required parameter createRunRequest was null or undefined when calling createRun.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<RunObject>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}/runs`,
                    createRunRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...createRunOpts?.config,
                        headers: {...headers, ...createRunOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Create a thread.
     * 
     * @param createThreadRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [createThreadOpts.config] Override http request option.
     */
    public createThread(createThreadRequest?: CreateThreadRequest, createThreadOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ThreadObject>>;
    public createThread(createThreadRequest?: CreateThreadRequest, createThreadOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ThreadObject>(`${this.basePath}/threads`,
                    createThreadRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...createThreadOpts?.config,
                        headers: {...headers, ...createThreadOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Create a thread and run it in one request.
     * 
     * @param createThreadAndRunRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [createThreadAndRunOpts.config] Override http request option.
     */
    public createThreadAndRun(createThreadAndRunRequest: CreateThreadAndRunRequest, createThreadAndRunOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<RunObject>>;
    public createThreadAndRun(createThreadAndRunRequest: CreateThreadAndRunRequest, createThreadAndRunOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (createThreadAndRunRequest === null || createThreadAndRunRequest === undefined) {
            throw new Error('Required parameter createThreadAndRunRequest was null or undefined when calling createThreadAndRun.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<RunObject>(`${this.basePath}/threads/runs`,
                    createThreadAndRunRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...createThreadAndRunOpts?.config,
                        headers: {...headers, ...createThreadAndRunOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Delete an assistant.
     * 
     * @param assistantId The ID of the assistant to delete.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [deleteAssistantOpts.config] Override http request option.
     */
    public deleteAssistant(assistantId: string, deleteAssistantOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<DeleteAssistantResponse>>;
    public deleteAssistant(assistantId: string, deleteAssistantOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (assistantId === null || assistantId === undefined) {
            throw new Error('Required parameter assistantId was null or undefined when calling deleteAssistant.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<DeleteAssistantResponse>(`${this.basePath}/assistants/${encodeURIComponent(String(assistant_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...deleteAssistantOpts?.config,
                        headers: {...headers, ...deleteAssistantOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Delete an assistant file.
     * 
     * @param assistantId The ID of the assistant that the file belongs to.
     * @param fileId The ID of the file to delete.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [deleteAssistantFileOpts.config] Override http request option.
     */
    public deleteAssistantFile(assistantId: string, fileId: string, deleteAssistantFileOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<DeleteAssistantFileResponse>>;
    public deleteAssistantFile(assistantId: string, fileId: string, deleteAssistantFileOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (assistantId === null || assistantId === undefined) {
            throw new Error('Required parameter assistantId was null or undefined when calling deleteAssistantFile.');
        }

        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling deleteAssistantFile.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<DeleteAssistantFileResponse>(`${this.basePath}/assistants/${encodeURIComponent(String(assistant_id))}/files/${encodeURIComponent(String(file_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...deleteAssistantFileOpts?.config,
                        headers: {...headers, ...deleteAssistantFileOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Delete a thread.
     * 
     * @param threadId The ID of the thread to delete.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [deleteThreadOpts.config] Override http request option.
     */
    public deleteThread(threadId: string, deleteThreadOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<DeleteThreadResponse>>;
    public deleteThread(threadId: string, deleteThreadOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling deleteThread.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<DeleteThreadResponse>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...deleteThreadOpts?.config,
                        headers: {...headers, ...deleteThreadOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Retrieves an assistant.
     * 
     * @param assistantId The ID of the assistant to retrieve.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getAssistantOpts.config] Override http request option.
     */
    public getAssistant(assistantId: string, getAssistantOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<AssistantObject>>;
    public getAssistant(assistantId: string, getAssistantOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (assistantId === null || assistantId === undefined) {
            throw new Error('Required parameter assistantId was null or undefined when calling getAssistant.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<AssistantObject>(`${this.basePath}/assistants/${encodeURIComponent(String(assistant_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getAssistantOpts?.config,
                        headers: {...headers, ...getAssistantOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Retrieves an AssistantFile.
     * 
     * @param assistantId The ID of the assistant who the file belongs to.
     * @param fileId The ID of the file we\&#39;re getting.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getAssistantFileOpts.config] Override http request option.
     */
    public getAssistantFile(assistantId: string, fileId: string, getAssistantFileOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<AssistantFileObject>>;
    public getAssistantFile(assistantId: string, fileId: string, getAssistantFileOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (assistantId === null || assistantId === undefined) {
            throw new Error('Required parameter assistantId was null or undefined when calling getAssistantFile.');
        }

        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling getAssistantFile.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<AssistantFileObject>(`${this.basePath}/assistants/${encodeURIComponent(String(assistant_id))}/files/${encodeURIComponent(String(file_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getAssistantFileOpts?.config,
                        headers: {...headers, ...getAssistantFileOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Retrieve a message.
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this message belongs.
     * @param messageId The ID of the message to retrieve.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getMessageOpts.config] Override http request option.
     */
    public getMessage(threadId: string, messageId: string, getMessageOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MessageObject>>;
    public getMessage(threadId: string, messageId: string, getMessageOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling getMessage.');
        }

        if (messageId === null || messageId === undefined) {
            throw new Error('Required parameter messageId was null or undefined when calling getMessage.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<MessageObject>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}/messages/${encodeURIComponent(String(message_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getMessageOpts?.config,
                        headers: {...headers, ...getMessageOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Retrieves a message file.
     * 
     * @param threadId The ID of the thread to which the message and File belong.
     * @param messageId The ID of the message the file belongs to.
     * @param fileId The ID of the file being retrieved.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getMessageFileOpts.config] Override http request option.
     */
    public getMessageFile(threadId: string, messageId: string, fileId: string, getMessageFileOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MessageFileObject>>;
    public getMessageFile(threadId: string, messageId: string, fileId: string, getMessageFileOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling getMessageFile.');
        }

        if (messageId === null || messageId === undefined) {
            throw new Error('Required parameter messageId was null or undefined when calling getMessageFile.');
        }

        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling getMessageFile.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<MessageFileObject>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}/messages/${encodeURIComponent(String(message_id))}/files/${encodeURIComponent(String(file_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getMessageFileOpts?.config,
                        headers: {...headers, ...getMessageFileOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Retrieves a run.
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run.
     * @param runId The ID of the run to retrieve.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getRunOpts.config] Override http request option.
     */
    public getRun(threadId: string, runId: string, getRunOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<RunObject>>;
    public getRun(threadId: string, runId: string, getRunOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling getRun.');
        }

        if (runId === null || runId === undefined) {
            throw new Error('Required parameter runId was null or undefined when calling getRun.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<RunObject>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}/runs/${encodeURIComponent(String(run_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getRunOpts?.config,
                        headers: {...headers, ...getRunOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Retrieves a run step.
     * 
     * @param threadId The ID of the thread to which the run and run step belongs.
     * @param runId The ID of the run to which the run step belongs.
     * @param stepId The ID of the run step to retrieve.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getRunStepOpts.config] Override http request option.
     */
    public getRunStep(threadId: string, runId: string, stepId: string, getRunStepOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<RunStepObject>>;
    public getRunStep(threadId: string, runId: string, stepId: string, getRunStepOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling getRunStep.');
        }

        if (runId === null || runId === undefined) {
            throw new Error('Required parameter runId was null or undefined when calling getRunStep.');
        }

        if (stepId === null || stepId === undefined) {
            throw new Error('Required parameter stepId was null or undefined when calling getRunStep.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<RunStepObject>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}/runs/${encodeURIComponent(String(run_id))}/steps/${encodeURIComponent(String(step_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getRunStepOpts?.config,
                        headers: {...headers, ...getRunStepOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Retrieves a thread.
     * 
     * @param threadId The ID of the thread to retrieve.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getThreadOpts.config] Override http request option.
     */
    public getThread(threadId: string, getThreadOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ThreadObject>>;
    public getThread(threadId: string, getThreadOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling getThread.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ThreadObject>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getThreadOpts?.config,
                        headers: {...headers, ...getThreadOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Returns a list of assistant files.
     * 
     * @param assistantId The ID of the assistant the file belongs to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [listAssistantFilesOpts.config] Override http request option.
     */
    public listAssistantFiles(assistantId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, listAssistantFilesOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ListAssistantFilesResponse>>;
    public listAssistantFiles(assistantId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, listAssistantFilesOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (assistantId === null || assistantId === undefined) {
            throw new Error('Required parameter assistantId was null or undefined when calling listAssistantFiles.');
        }

        let queryParameters = new URLSearchParams();
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (order !== undefined && order !== null) {
            queryParameters.append('order', <any>order);
        }
        if (after !== undefined && after !== null) {
            queryParameters.append('after', <any>after);
        }
        if (before !== undefined && before !== null) {
            queryParameters.append('before', <any>before);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ListAssistantFilesResponse>(`${this.basePath}/assistants/${encodeURIComponent(String(assistant_id))}/files`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...listAssistantFilesOpts?.config,
                        headers: {...headers, ...listAssistantFilesOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Returns a list of assistants.
     * 
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [listAssistantsOpts.config] Override http request option.
     */
    public listAssistants(limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, listAssistantsOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ListAssistantsResponse>>;
    public listAssistants(limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, listAssistantsOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (order !== undefined && order !== null) {
            queryParameters.append('order', <any>order);
        }
        if (after !== undefined && after !== null) {
            queryParameters.append('after', <any>after);
        }
        if (before !== undefined && before !== null) {
            queryParameters.append('before', <any>before);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ListAssistantsResponse>(`${this.basePath}/assistants`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...listAssistantsOpts?.config,
                        headers: {...headers, ...listAssistantsOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Returns a list of message files.
     * 
     * @param threadId The ID of the thread that the message and files belong to.
     * @param messageId The ID of the message that the files belongs to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [listMessageFilesOpts.config] Override http request option.
     */
    public listMessageFiles(threadId: string, messageId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, listMessageFilesOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ListMessageFilesResponse>>;
    public listMessageFiles(threadId: string, messageId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, listMessageFilesOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling listMessageFiles.');
        }

        if (messageId === null || messageId === undefined) {
            throw new Error('Required parameter messageId was null or undefined when calling listMessageFiles.');
        }

        let queryParameters = new URLSearchParams();
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (order !== undefined && order !== null) {
            queryParameters.append('order', <any>order);
        }
        if (after !== undefined && after !== null) {
            queryParameters.append('after', <any>after);
        }
        if (before !== undefined && before !== null) {
            queryParameters.append('before', <any>before);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ListMessageFilesResponse>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}/messages/${encodeURIComponent(String(message_id))}/files`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...listMessageFilesOpts?.config,
                        headers: {...headers, ...listMessageFilesOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Returns a list of messages for a given thread.
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) the messages belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param runId Filter messages by the run ID that generated them. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [listMessagesOpts.config] Override http request option.
     */
    public listMessages(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, runId?: string, listMessagesOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ListMessagesResponse>>;
    public listMessages(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, runId?: string, listMessagesOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling listMessages.');
        }

        let queryParameters = new URLSearchParams();
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (order !== undefined && order !== null) {
            queryParameters.append('order', <any>order);
        }
        if (after !== undefined && after !== null) {
            queryParameters.append('after', <any>after);
        }
        if (before !== undefined && before !== null) {
            queryParameters.append('before', <any>before);
        }
        if (runId !== undefined && runId !== null) {
            queryParameters.append('run_id', <any>runId);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ListMessagesResponse>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}/messages`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...listMessagesOpts?.config,
                        headers: {...headers, ...listMessagesOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Returns a list of run steps belonging to a run.
     * 
     * @param threadId The ID of the thread the run and run steps belong to.
     * @param runId The ID of the run the run steps belong to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [listRunStepsOpts.config] Override http request option.
     */
    public listRunSteps(threadId: string, runId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, listRunStepsOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ListRunStepsResponse>>;
    public listRunSteps(threadId: string, runId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, listRunStepsOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling listRunSteps.');
        }

        if (runId === null || runId === undefined) {
            throw new Error('Required parameter runId was null or undefined when calling listRunSteps.');
        }

        let queryParameters = new URLSearchParams();
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (order !== undefined && order !== null) {
            queryParameters.append('order', <any>order);
        }
        if (after !== undefined && after !== null) {
            queryParameters.append('after', <any>after);
        }
        if (before !== undefined && before !== null) {
            queryParameters.append('before', <any>before);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ListRunStepsResponse>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}/runs/${encodeURIComponent(String(run_id))}/steps`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...listRunStepsOpts?.config,
                        headers: {...headers, ...listRunStepsOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Returns a list of runs belonging to a thread.
     * 
     * @param threadId The ID of the thread the run belongs to.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order. 
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [listRunsOpts.config] Override http request option.
     */
    public listRuns(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, listRunsOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ListRunsResponse>>;
    public listRuns(threadId: string, limit?: number, order?: 'asc' | 'desc', after?: string, before?: string, listRunsOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling listRuns.');
        }

        let queryParameters = new URLSearchParams();
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (order !== undefined && order !== null) {
            queryParameters.append('order', <any>order);
        }
        if (after !== undefined && after !== null) {
            queryParameters.append('after', <any>after);
        }
        if (before !== undefined && before !== null) {
            queryParameters.append('before', <any>before);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ListRunsResponse>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}/runs`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...listRunsOpts?.config,
                        headers: {...headers, ...listRunsOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Modifies an assistant.
     * 
     * @param assistantId The ID of the assistant to modify.
     * @param modifyAssistantRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [modifyAssistantOpts.config] Override http request option.
     */
    public modifyAssistant(assistantId: string, modifyAssistantRequest: ModifyAssistantRequest, modifyAssistantOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<AssistantObject>>;
    public modifyAssistant(assistantId: string, modifyAssistantRequest: ModifyAssistantRequest, modifyAssistantOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (assistantId === null || assistantId === undefined) {
            throw new Error('Required parameter assistantId was null or undefined when calling modifyAssistant.');
        }

        if (modifyAssistantRequest === null || modifyAssistantRequest === undefined) {
            throw new Error('Required parameter modifyAssistantRequest was null or undefined when calling modifyAssistant.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<AssistantObject>(`${this.basePath}/assistants/${encodeURIComponent(String(assistant_id))}`,
                    modifyAssistantRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...modifyAssistantOpts?.config,
                        headers: {...headers, ...modifyAssistantOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Modifies a message.
     * 
     * @param threadId The ID of the thread to which this message belongs.
     * @param messageId The ID of the message to modify.
     * @param modifyMessageRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [modifyMessageOpts.config] Override http request option.
     */
    public modifyMessage(threadId: string, messageId: string, modifyMessageRequest: ModifyMessageRequest, modifyMessageOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MessageObject>>;
    public modifyMessage(threadId: string, messageId: string, modifyMessageRequest: ModifyMessageRequest, modifyMessageOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling modifyMessage.');
        }

        if (messageId === null || messageId === undefined) {
            throw new Error('Required parameter messageId was null or undefined when calling modifyMessage.');
        }

        if (modifyMessageRequest === null || modifyMessageRequest === undefined) {
            throw new Error('Required parameter modifyMessageRequest was null or undefined when calling modifyMessage.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<MessageObject>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}/messages/${encodeURIComponent(String(message_id))}`,
                    modifyMessageRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...modifyMessageOpts?.config,
                        headers: {...headers, ...modifyMessageOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Modifies a run.
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run.
     * @param runId The ID of the run to modify.
     * @param modifyRunRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [modifyRunOpts.config] Override http request option.
     */
    public modifyRun(threadId: string, runId: string, modifyRunRequest: ModifyRunRequest, modifyRunOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<RunObject>>;
    public modifyRun(threadId: string, runId: string, modifyRunRequest: ModifyRunRequest, modifyRunOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling modifyRun.');
        }

        if (runId === null || runId === undefined) {
            throw new Error('Required parameter runId was null or undefined when calling modifyRun.');
        }

        if (modifyRunRequest === null || modifyRunRequest === undefined) {
            throw new Error('Required parameter modifyRunRequest was null or undefined when calling modifyRun.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<RunObject>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}/runs/${encodeURIComponent(String(run_id))}`,
                    modifyRunRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...modifyRunOpts?.config,
                        headers: {...headers, ...modifyRunOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Modifies a thread.
     * 
     * @param threadId The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified.
     * @param modifyThreadRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [modifyThreadOpts.config] Override http request option.
     */
    public modifyThread(threadId: string, modifyThreadRequest: ModifyThreadRequest, modifyThreadOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ThreadObject>>;
    public modifyThread(threadId: string, modifyThreadRequest: ModifyThreadRequest, modifyThreadOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling modifyThread.');
        }

        if (modifyThreadRequest === null || modifyThreadRequest === undefined) {
            throw new Error('Required parameter modifyThreadRequest was null or undefined when calling modifyThread.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ThreadObject>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}`,
                    modifyThreadRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...modifyThreadOpts?.config,
                        headers: {...headers, ...modifyThreadOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * When a run has the &#x60;status: \&quot;requires_action\&quot;&#x60; and &#x60;required_action.type&#x60; is &#x60;submit_tool_outputs&#x60;, this endpoint can be used to submit the outputs from the tool calls once they\&#39;re all completed. All outputs must be submitted in a single request. 
     * 
     * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this run belongs.
     * @param runId The ID of the run that requires the tool output submission.
     * @param submitToolOutputsRunRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [submitToolOuputsToRunOpts.config] Override http request option.
     */
    public submitToolOuputsToRun(threadId: string, runId: string, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest, submitToolOuputsToRunOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<RunObject>>;
    public submitToolOuputsToRun(threadId: string, runId: string, submitToolOutputsRunRequest: SubmitToolOutputsRunRequest, submitToolOuputsToRunOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (threadId === null || threadId === undefined) {
            throw new Error('Required parameter threadId was null or undefined when calling submitToolOuputsToRun.');
        }

        if (runId === null || runId === undefined) {
            throw new Error('Required parameter runId was null or undefined when calling submitToolOuputsToRun.');
        }

        if (submitToolOutputsRunRequest === null || submitToolOutputsRunRequest === undefined) {
            throw new Error('Required parameter submitToolOutputsRunRequest was null or undefined when calling submitToolOuputsToRun.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<RunObject>(`${this.basePath}/threads/${encodeURIComponent(String(thread_id))}/runs/${encodeURIComponent(String(run_id))}/submit_tool_outputs`,
                    submitToolOutputsRunRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...submitToolOuputsToRunOpts?.config,
                        headers: {...headers, ...submitToolOuputsToRunOpts?.config?.headers},
                    }
                );
            })
        );
    }
}
