/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { ErrorResponse } from '../model/errorResponse';
import { Project } from '../model/project';
import { ProjectApiKey } from '../model/projectApiKey';
import { ProjectApiKeyDeleteResponse } from '../model/projectApiKeyDeleteResponse';
import { ProjectApiKeyListResponse } from '../model/projectApiKeyListResponse';
import { ProjectCreateRequest } from '../model/projectCreateRequest';
import { ProjectListResponse } from '../model/projectListResponse';
import { ProjectRateLimit } from '../model/projectRateLimit';
import { ProjectRateLimitListResponse } from '../model/projectRateLimitListResponse';
import { ProjectRateLimitUpdateRequest } from '../model/projectRateLimitUpdateRequest';
import { ProjectServiceAccount } from '../model/projectServiceAccount';
import { ProjectServiceAccountCreateRequest } from '../model/projectServiceAccountCreateRequest';
import { ProjectServiceAccountCreateResponse } from '../model/projectServiceAccountCreateResponse';
import { ProjectServiceAccountDeleteResponse } from '../model/projectServiceAccountDeleteResponse';
import { ProjectServiceAccountListResponse } from '../model/projectServiceAccountListResponse';
import { ProjectUpdateRequest } from '../model/projectUpdateRequest';
import { ProjectUser } from '../model/projectUser';
import { ProjectUserCreateRequest } from '../model/projectUserCreateRequest';
import { ProjectUserDeleteResponse } from '../model/projectUserDeleteResponse';
import { ProjectUserListResponse } from '../model/projectUserListResponse';
import { ProjectUserUpdateRequest } from '../model/projectUserUpdateRequest';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class ProjectsService {

    protected basePath = 'https://api.openai.com/v1';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();
    protected httpClient: HttpService;

    constructor(httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
        this.httpClient = configuration?.httpClient || httpClient;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Archives a project in the organization. Archived projects cannot be used or updated.
     * 
     * @param projectId The ID of the project.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [archiveProjectOpts.config] Override http request option.
     */
    public archiveProject(projectId: string, archiveProjectOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Project>>;
    public archiveProject(projectId: string, archiveProjectOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling archiveProject.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<Project>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}/archive`,
                    null,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...archiveProjectOpts?.config,
                        headers: {...headers, ...archiveProjectOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Create a new project in the organization. Projects can be created and archived, but cannot be deleted.
     * 
     * @param projectCreateRequest The project create request payload.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [createProjectOpts.config] Override http request option.
     */
    public createProject(projectCreateRequest: ProjectCreateRequest, createProjectOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Project>>;
    public createProject(projectCreateRequest: ProjectCreateRequest, createProjectOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectCreateRequest === null || projectCreateRequest === undefined) {
            throw new Error('Required parameter projectCreateRequest was null or undefined when calling createProject.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<Project>(`${this.basePath}/organization/projects`,
                    projectCreateRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...createProjectOpts?.config,
                        headers: {...headers, ...createProjectOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Creates a new service account in the project. This also returns an unredacted API key for the service account.
     * 
     * @param projectId The ID of the project.
     * @param projectServiceAccountCreateRequest The project service account create request payload.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [createProjectServiceAccountOpts.config] Override http request option.
     */
    public createProjectServiceAccount(projectId: string, projectServiceAccountCreateRequest: ProjectServiceAccountCreateRequest, createProjectServiceAccountOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ProjectServiceAccountCreateResponse>>;
    public createProjectServiceAccount(projectId: string, projectServiceAccountCreateRequest: ProjectServiceAccountCreateRequest, createProjectServiceAccountOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createProjectServiceAccount.');
        }

        if (projectServiceAccountCreateRequest === null || projectServiceAccountCreateRequest === undefined) {
            throw new Error('Required parameter projectServiceAccountCreateRequest was null or undefined when calling createProjectServiceAccount.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ProjectServiceAccountCreateResponse>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}/service_accounts`,
                    projectServiceAccountCreateRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...createProjectServiceAccountOpts?.config,
                        headers: {...headers, ...createProjectServiceAccountOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Adds a user to the project. Users must already be members of the organization to be added to a project.
     * 
     * @param projectId The ID of the project.
     * @param projectUserCreateRequest The project user create request payload.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [createProjectUserOpts.config] Override http request option.
     */
    public createProjectUser(projectId: string, projectUserCreateRequest: ProjectUserCreateRequest, createProjectUserOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ProjectUser>>;
    public createProjectUser(projectId: string, projectUserCreateRequest: ProjectUserCreateRequest, createProjectUserOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createProjectUser.');
        }

        if (projectUserCreateRequest === null || projectUserCreateRequest === undefined) {
            throw new Error('Required parameter projectUserCreateRequest was null or undefined when calling createProjectUser.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ProjectUser>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}/users`,
                    projectUserCreateRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...createProjectUserOpts?.config,
                        headers: {...headers, ...createProjectUserOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Deletes an API key from the project.
     * 
     * @param projectId The ID of the project.
     * @param keyId The ID of the API key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [deleteProjectApiKeyOpts.config] Override http request option.
     */
    public deleteProjectApiKey(projectId: string, keyId: string, deleteProjectApiKeyOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ProjectApiKeyDeleteResponse>>;
    public deleteProjectApiKey(projectId: string, keyId: string, deleteProjectApiKeyOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteProjectApiKey.');
        }

        if (keyId === null || keyId === undefined) {
            throw new Error('Required parameter keyId was null or undefined when calling deleteProjectApiKey.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<ProjectApiKeyDeleteResponse>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}/api_keys/${encodeURIComponent(String(key_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...deleteProjectApiKeyOpts?.config,
                        headers: {...headers, ...deleteProjectApiKeyOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Deletes a service account from the project.
     * 
     * @param projectId The ID of the project.
     * @param serviceAccountId The ID of the service account.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [deleteProjectServiceAccountOpts.config] Override http request option.
     */
    public deleteProjectServiceAccount(projectId: string, serviceAccountId: string, deleteProjectServiceAccountOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ProjectServiceAccountDeleteResponse>>;
    public deleteProjectServiceAccount(projectId: string, serviceAccountId: string, deleteProjectServiceAccountOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteProjectServiceAccount.');
        }

        if (serviceAccountId === null || serviceAccountId === undefined) {
            throw new Error('Required parameter serviceAccountId was null or undefined when calling deleteProjectServiceAccount.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<ProjectServiceAccountDeleteResponse>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}/service_accounts/${encodeURIComponent(String(service_account_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...deleteProjectServiceAccountOpts?.config,
                        headers: {...headers, ...deleteProjectServiceAccountOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Deletes a user from the project.
     * 
     * @param projectId The ID of the project.
     * @param userId The ID of the user.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [deleteProjectUserOpts.config] Override http request option.
     */
    public deleteProjectUser(projectId: string, userId: string, deleteProjectUserOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ProjectUserDeleteResponse>>;
    public deleteProjectUser(projectId: string, userId: string, deleteProjectUserOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteProjectUser.');
        }

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deleteProjectUser.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<ProjectUserDeleteResponse>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}/users/${encodeURIComponent(String(user_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...deleteProjectUserOpts?.config,
                        headers: {...headers, ...deleteProjectUserOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Returns a list of API keys in the project.
     * 
     * @param projectId The ID of the project.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [listProjectApiKeysOpts.config] Override http request option.
     */
    public listProjectApiKeys(projectId: string, limit?: number, after?: string, listProjectApiKeysOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ProjectApiKeyListResponse>>;
    public listProjectApiKeys(projectId: string, limit?: number, after?: string, listProjectApiKeysOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling listProjectApiKeys.');
        }

        let queryParameters = new URLSearchParams();
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (after !== undefined && after !== null) {
            queryParameters.append('after', <any>after);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ProjectApiKeyListResponse>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}/api_keys`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...listProjectApiKeysOpts?.config,
                        headers: {...headers, ...listProjectApiKeysOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Returns the rate limits per model for a project.
     * 
     * @param projectId The ID of the project.
     * @param limit A limit on the number of objects to be returned. The default is 100. 
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, beginning with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [listProjectRateLimitsOpts.config] Override http request option.
     */
    public listProjectRateLimits(projectId: string, limit?: number, after?: string, before?: string, listProjectRateLimitsOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ProjectRateLimitListResponse>>;
    public listProjectRateLimits(projectId: string, limit?: number, after?: string, before?: string, listProjectRateLimitsOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling listProjectRateLimits.');
        }

        let queryParameters = new URLSearchParams();
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (after !== undefined && after !== null) {
            queryParameters.append('after', <any>after);
        }
        if (before !== undefined && before !== null) {
            queryParameters.append('before', <any>before);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ProjectRateLimitListResponse>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}/rate_limits`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...listProjectRateLimitsOpts?.config,
                        headers: {...headers, ...listProjectRateLimitsOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Returns a list of service accounts in the project.
     * 
     * @param projectId The ID of the project.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [listProjectServiceAccountsOpts.config] Override http request option.
     */
    public listProjectServiceAccounts(projectId: string, limit?: number, after?: string, listProjectServiceAccountsOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ProjectServiceAccountListResponse>>;
    public listProjectServiceAccounts(projectId: string, limit?: number, after?: string, listProjectServiceAccountsOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling listProjectServiceAccounts.');
        }

        let queryParameters = new URLSearchParams();
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (after !== undefined && after !== null) {
            queryParameters.append('after', <any>after);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ProjectServiceAccountListResponse>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}/service_accounts`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...listProjectServiceAccountsOpts?.config,
                        headers: {...headers, ...listProjectServiceAccountsOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Returns a list of users in the project.
     * 
     * @param projectId The ID of the project.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [listProjectUsersOpts.config] Override http request option.
     */
    public listProjectUsers(projectId: string, limit?: number, after?: string, listProjectUsersOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ProjectUserListResponse>>;
    public listProjectUsers(projectId: string, limit?: number, after?: string, listProjectUsersOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling listProjectUsers.');
        }

        let queryParameters = new URLSearchParams();
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (after !== undefined && after !== null) {
            queryParameters.append('after', <any>after);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ProjectUserListResponse>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}/users`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...listProjectUsersOpts?.config,
                        headers: {...headers, ...listProjectUsersOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Returns a list of projects.
     * 
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20. 
     * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list. 
     * @param includeArchived If &#x60;true&#x60; returns all projects including those that have been &#x60;archived&#x60;. Archived projects are not included by default.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [listProjectsOpts.config] Override http request option.
     */
    public listProjects(limit?: number, after?: string, includeArchived?: boolean, listProjectsOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ProjectListResponse>>;
    public listProjects(limit?: number, after?: string, includeArchived?: boolean, listProjectsOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (after !== undefined && after !== null) {
            queryParameters.append('after', <any>after);
        }
        if (includeArchived !== undefined && includeArchived !== null) {
            queryParameters.append('include_archived', <any>includeArchived);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ProjectListResponse>(`${this.basePath}/organization/projects`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...listProjectsOpts?.config,
                        headers: {...headers, ...listProjectsOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Modifies a project in the organization.
     * 
     * @param projectId The ID of the project.
     * @param projectUpdateRequest The project update request payload.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [modifyProjectOpts.config] Override http request option.
     */
    public modifyProject(projectId: string, projectUpdateRequest: ProjectUpdateRequest, modifyProjectOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Project>>;
    public modifyProject(projectId: string, projectUpdateRequest: ProjectUpdateRequest, modifyProjectOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling modifyProject.');
        }

        if (projectUpdateRequest === null || projectUpdateRequest === undefined) {
            throw new Error('Required parameter projectUpdateRequest was null or undefined when calling modifyProject.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<Project>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}`,
                    projectUpdateRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...modifyProjectOpts?.config,
                        headers: {...headers, ...modifyProjectOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Modifies a user\&#39;s role in the project.
     * 
     * @param projectId The ID of the project.
     * @param userId The ID of the user.
     * @param projectUserUpdateRequest The project user update request payload.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [modifyProjectUserOpts.config] Override http request option.
     */
    public modifyProjectUser(projectId: string, userId: string, projectUserUpdateRequest: ProjectUserUpdateRequest, modifyProjectUserOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ProjectUser>>;
    public modifyProjectUser(projectId: string, userId: string, projectUserUpdateRequest: ProjectUserUpdateRequest, modifyProjectUserOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling modifyProjectUser.');
        }

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling modifyProjectUser.');
        }

        if (projectUserUpdateRequest === null || projectUserUpdateRequest === undefined) {
            throw new Error('Required parameter projectUserUpdateRequest was null or undefined when calling modifyProjectUser.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ProjectUser>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}/users/${encodeURIComponent(String(user_id))}`,
                    projectUserUpdateRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...modifyProjectUserOpts?.config,
                        headers: {...headers, ...modifyProjectUserOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Retrieves a project.
     * 
     * @param projectId The ID of the project.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [retrieveProjectOpts.config] Override http request option.
     */
    public retrieveProject(projectId: string, retrieveProjectOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Project>>;
    public retrieveProject(projectId: string, retrieveProjectOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling retrieveProject.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Project>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...retrieveProjectOpts?.config,
                        headers: {...headers, ...retrieveProjectOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Retrieves an API key in the project.
     * 
     * @param projectId The ID of the project.
     * @param keyId The ID of the API key.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [retrieveProjectApiKeyOpts.config] Override http request option.
     */
    public retrieveProjectApiKey(projectId: string, keyId: string, retrieveProjectApiKeyOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ProjectApiKey>>;
    public retrieveProjectApiKey(projectId: string, keyId: string, retrieveProjectApiKeyOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling retrieveProjectApiKey.');
        }

        if (keyId === null || keyId === undefined) {
            throw new Error('Required parameter keyId was null or undefined when calling retrieveProjectApiKey.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ProjectApiKey>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}/api_keys/${encodeURIComponent(String(key_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...retrieveProjectApiKeyOpts?.config,
                        headers: {...headers, ...retrieveProjectApiKeyOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Retrieves a service account in the project.
     * 
     * @param projectId The ID of the project.
     * @param serviceAccountId The ID of the service account.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [retrieveProjectServiceAccountOpts.config] Override http request option.
     */
    public retrieveProjectServiceAccount(projectId: string, serviceAccountId: string, retrieveProjectServiceAccountOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ProjectServiceAccount>>;
    public retrieveProjectServiceAccount(projectId: string, serviceAccountId: string, retrieveProjectServiceAccountOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling retrieveProjectServiceAccount.');
        }

        if (serviceAccountId === null || serviceAccountId === undefined) {
            throw new Error('Required parameter serviceAccountId was null or undefined when calling retrieveProjectServiceAccount.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ProjectServiceAccount>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}/service_accounts/${encodeURIComponent(String(service_account_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...retrieveProjectServiceAccountOpts?.config,
                        headers: {...headers, ...retrieveProjectServiceAccountOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Retrieves a user in the project.
     * 
     * @param projectId The ID of the project.
     * @param userId The ID of the user.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [retrieveProjectUserOpts.config] Override http request option.
     */
    public retrieveProjectUser(projectId: string, userId: string, retrieveProjectUserOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ProjectUser>>;
    public retrieveProjectUser(projectId: string, userId: string, retrieveProjectUserOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling retrieveProjectUser.');
        }

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling retrieveProjectUser.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ProjectUser>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}/users/${encodeURIComponent(String(user_id))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...retrieveProjectUserOpts?.config,
                        headers: {...headers, ...retrieveProjectUserOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Updates a project rate limit.
     * 
     * @param projectId The ID of the project.
     * @param rateLimitId The ID of the rate limit.
     * @param projectRateLimitUpdateRequest The project rate limit update request payload.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [updateProjectRateLimitsOpts.config] Override http request option.
     */
    public updateProjectRateLimits(projectId: string, rateLimitId: string, projectRateLimitUpdateRequest: ProjectRateLimitUpdateRequest, updateProjectRateLimitsOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ProjectRateLimit>>;
    public updateProjectRateLimits(projectId: string, rateLimitId: string, projectRateLimitUpdateRequest: ProjectRateLimitUpdateRequest, updateProjectRateLimitsOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateProjectRateLimits.');
        }

        if (rateLimitId === null || rateLimitId === undefined) {
            throw new Error('Required parameter rateLimitId was null or undefined when calling updateProjectRateLimits.');
        }

        if (projectRateLimitUpdateRequest === null || projectRateLimitUpdateRequest === undefined) {
            throw new Error('Required parameter projectRateLimitUpdateRequest was null or undefined when calling updateProjectRateLimits.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (ApiKeyAuth) required
        if (typeof this.configuration.accessToken === 'function') {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken()));
        } else if (this.configuration.accessToken) {
            accessTokenObservable = from(Promise.resolve(this.configuration.accessToken));
        }
        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ProjectRateLimit>(`${this.basePath}/organization/projects/${encodeURIComponent(String(project_id))}/rate_limits/${encodeURIComponent(String(rate_limit_id))}`,
                    projectRateLimitUpdateRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...updateProjectRateLimitsOpts?.config,
                        headers: {...headers, ...updateProjectRateLimitsOpts?.config?.headers},
                    }
                );
            })
        );
    }
}
