// tslint:disable
/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    AssistantFileObject,
    AssistantFileObjectFromJSON,
    AssistantFileObjectToJSON,
    AssistantObject,
    AssistantObjectFromJSON,
    AssistantObjectToJSON,
    CreateAssistantFileRequest,
    CreateAssistantFileRequestFromJSON,
    CreateAssistantFileRequestToJSON,
    CreateAssistantRequest,
    CreateAssistantRequestFromJSON,
    CreateAssistantRequestToJSON,
    CreateMessageRequest,
    CreateMessageRequestFromJSON,
    CreateMessageRequestToJSON,
    CreateRunRequest,
    CreateRunRequestFromJSON,
    CreateRunRequestToJSON,
    CreateThreadAndRunRequest,
    CreateThreadAndRunRequestFromJSON,
    CreateThreadAndRunRequestToJSON,
    CreateThreadRequest,
    CreateThreadRequestFromJSON,
    CreateThreadRequestToJSON,
    DeleteAssistantFileResponse,
    DeleteAssistantFileResponseFromJSON,
    DeleteAssistantFileResponseToJSON,
    DeleteAssistantResponse,
    DeleteAssistantResponseFromJSON,
    DeleteAssistantResponseToJSON,
    DeleteThreadResponse,
    DeleteThreadResponseFromJSON,
    DeleteThreadResponseToJSON,
    ListAssistantFilesResponse,
    ListAssistantFilesResponseFromJSON,
    ListAssistantFilesResponseToJSON,
    ListAssistantsResponse,
    ListAssistantsResponseFromJSON,
    ListAssistantsResponseToJSON,
    ListMessageFilesResponse,
    ListMessageFilesResponseFromJSON,
    ListMessageFilesResponseToJSON,
    ListMessagesResponse,
    ListMessagesResponseFromJSON,
    ListMessagesResponseToJSON,
    ListRunStepsResponse,
    ListRunStepsResponseFromJSON,
    ListRunStepsResponseToJSON,
    ListRunsResponse,
    ListRunsResponseFromJSON,
    ListRunsResponseToJSON,
    MessageFileObject,
    MessageFileObjectFromJSON,
    MessageFileObjectToJSON,
    MessageObject,
    MessageObjectFromJSON,
    MessageObjectToJSON,
    ModifyAssistantRequest,
    ModifyAssistantRequestFromJSON,
    ModifyAssistantRequestToJSON,
    ModifyMessageRequest,
    ModifyMessageRequestFromJSON,
    ModifyMessageRequestToJSON,
    ModifyRunRequest,
    ModifyRunRequestFromJSON,
    ModifyRunRequestToJSON,
    ModifyThreadRequest,
    ModifyThreadRequestFromJSON,
    ModifyThreadRequestToJSON,
    RunObject,
    RunObjectFromJSON,
    RunObjectToJSON,
    RunStepObject,
    RunStepObjectFromJSON,
    RunStepObjectToJSON,
    SubmitToolOutputsRunRequest,
    SubmitToolOutputsRunRequestFromJSON,
    SubmitToolOutputsRunRequestToJSON,
    ThreadObject,
    ThreadObjectFromJSON,
    ThreadObjectToJSON,
} from '../models';

export interface CancelRunRequest {
    threadId: string;
    runId: string;
}

export interface CreateAssistantRequest {
    createAssistantRequest: CreateAssistantRequest;
}

export interface CreateAssistantFileRequest {
    assistantId: string;
    createAssistantFileRequest: CreateAssistantFileRequest;
}

export interface CreateMessageRequest {
    threadId: string;
    createMessageRequest: CreateMessageRequest;
}

export interface CreateRunRequest {
    threadId: string;
    createRunRequest: CreateRunRequest;
}

export interface CreateThreadRequest {
    createThreadRequest?: CreateThreadRequest;
}

export interface CreateThreadAndRunRequest {
    createThreadAndRunRequest: CreateThreadAndRunRequest;
}

export interface DeleteAssistantRequest {
    assistantId: string;
}

export interface DeleteAssistantFileRequest {
    assistantId: string;
    fileId: string;
}

export interface DeleteThreadRequest {
    threadId: string;
}

export interface GetAssistantRequest {
    assistantId: string;
}

export interface GetAssistantFileRequest {
    assistantId: string;
    fileId: string;
}

export interface GetMessageRequest {
    threadId: string;
    messageId: string;
}

export interface GetMessageFileRequest {
    threadId: string;
    messageId: string;
    fileId: string;
}

export interface GetRunRequest {
    threadId: string;
    runId: string;
}

export interface GetRunStepRequest {
    threadId: string;
    runId: string;
    stepId: string;
}

export interface GetThreadRequest {
    threadId: string;
}

export interface ListAssistantFilesRequest {
    assistantId: string;
    limit?: number;
    order?: ListAssistantFilesOrderEnum;
    after?: string;
    before?: string;
}

export interface ListAssistantsRequest {
    limit?: number;
    order?: ListAssistantsOrderEnum;
    after?: string;
    before?: string;
}

export interface ListMessageFilesRequest {
    threadId: string;
    messageId: string;
    limit?: number;
    order?: ListMessageFilesOrderEnum;
    after?: string;
    before?: string;
}

export interface ListMessagesRequest {
    threadId: string;
    limit?: number;
    order?: ListMessagesOrderEnum;
    after?: string;
    before?: string;
    runId?: string;
}

export interface ListRunStepsRequest {
    threadId: string;
    runId: string;
    limit?: number;
    order?: ListRunStepsOrderEnum;
    after?: string;
    before?: string;
}

export interface ListRunsRequest {
    threadId: string;
    limit?: number;
    order?: ListRunsOrderEnum;
    after?: string;
    before?: string;
}

export interface ModifyAssistantRequest {
    assistantId: string;
    modifyAssistantRequest: ModifyAssistantRequest;
}

export interface ModifyMessageRequest {
    threadId: string;
    messageId: string;
    modifyMessageRequest: ModifyMessageRequest;
}

export interface ModifyRunRequest {
    threadId: string;
    runId: string;
    modifyRunRequest: ModifyRunRequest;
}

export interface ModifyThreadRequest {
    threadId: string;
    modifyThreadRequest: ModifyThreadRequest;
}

export interface SubmitToolOuputsToRunRequest {
    threadId: string;
    runId: string;
    submitToolOutputsRunRequest: SubmitToolOutputsRunRequest;
}


/**
 * Cancels a run that is `in_progress`.
 */
function cancelRunRaw<T>(requestParameters: CancelRunRequest, requestConfig: runtime.TypedQueryConfig<T, RunObject> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling cancelRun.');
    }

    if (requestParameters.runId === null || requestParameters.runId === undefined) {
        throw new runtime.RequiredError('runId','Required parameter requestParameters.runId was null or undefined when calling cancelRun.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}/runs/{run_id}/cancel`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))).replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters.runId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(RunObjectFromJSON(body), text);
    }

    return config;
}

/**
* Cancels a run that is `in_progress`.
*/
export function cancelRun<T>(requestParameters: CancelRunRequest, requestConfig?: runtime.TypedQueryConfig<T, RunObject>): QueryConfig<T> {
    return cancelRunRaw(requestParameters, requestConfig);
}

/**
 * Create an assistant with a model and instructions.
 */
function createAssistantRaw<T>(requestParameters: CreateAssistantRequest, requestConfig: runtime.TypedQueryConfig<T, AssistantObject> = {}): QueryConfig<T> {
    if (requestParameters.createAssistantRequest === null || requestParameters.createAssistantRequest === undefined) {
        throw new runtime.RequiredError('createAssistantRequest','Required parameter requestParameters.createAssistantRequest was null or undefined when calling createAssistant.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/assistants`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateAssistantRequestToJSON(requestParameters.createAssistantRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(AssistantObjectFromJSON(body), text);
    }

    return config;
}

/**
* Create an assistant with a model and instructions.
*/
export function createAssistant<T>(requestParameters: CreateAssistantRequest, requestConfig?: runtime.TypedQueryConfig<T, AssistantObject>): QueryConfig<T> {
    return createAssistantRaw(requestParameters, requestConfig);
}

/**
 * Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants).
 */
function createAssistantFileRaw<T>(requestParameters: CreateAssistantFileRequest, requestConfig: runtime.TypedQueryConfig<T, AssistantFileObject> = {}): QueryConfig<T> {
    if (requestParameters.assistantId === null || requestParameters.assistantId === undefined) {
        throw new runtime.RequiredError('assistantId','Required parameter requestParameters.assistantId was null or undefined when calling createAssistantFile.');
    }

    if (requestParameters.createAssistantFileRequest === null || requestParameters.createAssistantFileRequest === undefined) {
        throw new runtime.RequiredError('createAssistantFileRequest','Required parameter requestParameters.createAssistantFileRequest was null or undefined when calling createAssistantFile.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/assistants/{assistant_id}/files`.replace(`{${"assistant_id"}}`, encodeURIComponent(String(requestParameters.assistantId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateAssistantFileRequestToJSON(requestParameters.createAssistantFileRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(AssistantFileObjectFromJSON(body), text);
    }

    return config;
}

/**
* Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants).
*/
export function createAssistantFile<T>(requestParameters: CreateAssistantFileRequest, requestConfig?: runtime.TypedQueryConfig<T, AssistantFileObject>): QueryConfig<T> {
    return createAssistantFileRaw(requestParameters, requestConfig);
}

/**
 * Create a message.
 */
function createMessageRaw<T>(requestParameters: CreateMessageRequest, requestConfig: runtime.TypedQueryConfig<T, MessageObject> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling createMessage.');
    }

    if (requestParameters.createMessageRequest === null || requestParameters.createMessageRequest === undefined) {
        throw new runtime.RequiredError('createMessageRequest','Required parameter requestParameters.createMessageRequest was null or undefined when calling createMessage.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}/messages`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateMessageRequestToJSON(requestParameters.createMessageRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(MessageObjectFromJSON(body), text);
    }

    return config;
}

/**
* Create a message.
*/
export function createMessage<T>(requestParameters: CreateMessageRequest, requestConfig?: runtime.TypedQueryConfig<T, MessageObject>): QueryConfig<T> {
    return createMessageRaw(requestParameters, requestConfig);
}

/**
 * Create a run.
 */
function createRunRaw<T>(requestParameters: CreateRunRequest, requestConfig: runtime.TypedQueryConfig<T, RunObject> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling createRun.');
    }

    if (requestParameters.createRunRequest === null || requestParameters.createRunRequest === undefined) {
        throw new runtime.RequiredError('createRunRequest','Required parameter requestParameters.createRunRequest was null or undefined when calling createRun.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}/runs`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateRunRequestToJSON(requestParameters.createRunRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(RunObjectFromJSON(body), text);
    }

    return config;
}

/**
* Create a run.
*/
export function createRun<T>(requestParameters: CreateRunRequest, requestConfig?: runtime.TypedQueryConfig<T, RunObject>): QueryConfig<T> {
    return createRunRaw(requestParameters, requestConfig);
}

/**
 * Create a thread.
 */
function createThreadRaw<T>(requestParameters: CreateThreadRequest, requestConfig: runtime.TypedQueryConfig<T, ThreadObject> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateThreadRequestToJSON(requestParameters.createThreadRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ThreadObjectFromJSON(body), text);
    }

    return config;
}

/**
* Create a thread.
*/
export function createThread<T>(requestParameters: CreateThreadRequest, requestConfig?: runtime.TypedQueryConfig<T, ThreadObject>): QueryConfig<T> {
    return createThreadRaw(requestParameters, requestConfig);
}

/**
 * Create a thread and run it in one request.
 */
function createThreadAndRunRaw<T>(requestParameters: CreateThreadAndRunRequest, requestConfig: runtime.TypedQueryConfig<T, RunObject> = {}): QueryConfig<T> {
    if (requestParameters.createThreadAndRunRequest === null || requestParameters.createThreadAndRunRequest === undefined) {
        throw new runtime.RequiredError('createThreadAndRunRequest','Required parameter requestParameters.createThreadAndRunRequest was null or undefined when calling createThreadAndRun.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/runs`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateThreadAndRunRequestToJSON(requestParameters.createThreadAndRunRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(RunObjectFromJSON(body), text);
    }

    return config;
}

/**
* Create a thread and run it in one request.
*/
export function createThreadAndRun<T>(requestParameters: CreateThreadAndRunRequest, requestConfig?: runtime.TypedQueryConfig<T, RunObject>): QueryConfig<T> {
    return createThreadAndRunRaw(requestParameters, requestConfig);
}

/**
 * Delete an assistant.
 */
function deleteAssistantRaw<T>(requestParameters: DeleteAssistantRequest, requestConfig: runtime.TypedQueryConfig<T, DeleteAssistantResponse> = {}): QueryConfig<T> {
    if (requestParameters.assistantId === null || requestParameters.assistantId === undefined) {
        throw new runtime.RequiredError('assistantId','Required parameter requestParameters.assistantId was null or undefined when calling deleteAssistant.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/assistants/{assistant_id}`.replace(`{${"assistant_id"}}`, encodeURIComponent(String(requestParameters.assistantId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DeleteAssistantResponseFromJSON(body), text);
    }

    return config;
}

/**
* Delete an assistant.
*/
export function deleteAssistant<T>(requestParameters: DeleteAssistantRequest, requestConfig?: runtime.TypedQueryConfig<T, DeleteAssistantResponse>): QueryConfig<T> {
    return deleteAssistantRaw(requestParameters, requestConfig);
}

/**
 * Delete an assistant file.
 */
function deleteAssistantFileRaw<T>(requestParameters: DeleteAssistantFileRequest, requestConfig: runtime.TypedQueryConfig<T, DeleteAssistantFileResponse> = {}): QueryConfig<T> {
    if (requestParameters.assistantId === null || requestParameters.assistantId === undefined) {
        throw new runtime.RequiredError('assistantId','Required parameter requestParameters.assistantId was null or undefined when calling deleteAssistantFile.');
    }

    if (requestParameters.fileId === null || requestParameters.fileId === undefined) {
        throw new runtime.RequiredError('fileId','Required parameter requestParameters.fileId was null or undefined when calling deleteAssistantFile.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/assistants/{assistant_id}/files/{file_id}`.replace(`{${"assistant_id"}}`, encodeURIComponent(String(requestParameters.assistantId))).replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters.fileId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DeleteAssistantFileResponseFromJSON(body), text);
    }

    return config;
}

/**
* Delete an assistant file.
*/
export function deleteAssistantFile<T>(requestParameters: DeleteAssistantFileRequest, requestConfig?: runtime.TypedQueryConfig<T, DeleteAssistantFileResponse>): QueryConfig<T> {
    return deleteAssistantFileRaw(requestParameters, requestConfig);
}

/**
 * Delete a thread.
 */
function deleteThreadRaw<T>(requestParameters: DeleteThreadRequest, requestConfig: runtime.TypedQueryConfig<T, DeleteThreadResponse> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling deleteThread.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DeleteThreadResponseFromJSON(body), text);
    }

    return config;
}

/**
* Delete a thread.
*/
export function deleteThread<T>(requestParameters: DeleteThreadRequest, requestConfig?: runtime.TypedQueryConfig<T, DeleteThreadResponse>): QueryConfig<T> {
    return deleteThreadRaw(requestParameters, requestConfig);
}

/**
 * Retrieves an assistant.
 */
function getAssistantRaw<T>(requestParameters: GetAssistantRequest, requestConfig: runtime.TypedQueryConfig<T, AssistantObject> = {}): QueryConfig<T> {
    if (requestParameters.assistantId === null || requestParameters.assistantId === undefined) {
        throw new runtime.RequiredError('assistantId','Required parameter requestParameters.assistantId was null or undefined when calling getAssistant.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/assistants/{assistant_id}`.replace(`{${"assistant_id"}}`, encodeURIComponent(String(requestParameters.assistantId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(AssistantObjectFromJSON(body), text);
    }

    return config;
}

/**
* Retrieves an assistant.
*/
export function getAssistant<T>(requestParameters: GetAssistantRequest, requestConfig?: runtime.TypedQueryConfig<T, AssistantObject>): QueryConfig<T> {
    return getAssistantRaw(requestParameters, requestConfig);
}

/**
 * Retrieves an AssistantFile.
 */
function getAssistantFileRaw<T>(requestParameters: GetAssistantFileRequest, requestConfig: runtime.TypedQueryConfig<T, AssistantFileObject> = {}): QueryConfig<T> {
    if (requestParameters.assistantId === null || requestParameters.assistantId === undefined) {
        throw new runtime.RequiredError('assistantId','Required parameter requestParameters.assistantId was null or undefined when calling getAssistantFile.');
    }

    if (requestParameters.fileId === null || requestParameters.fileId === undefined) {
        throw new runtime.RequiredError('fileId','Required parameter requestParameters.fileId was null or undefined when calling getAssistantFile.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/assistants/{assistant_id}/files/{file_id}`.replace(`{${"assistant_id"}}`, encodeURIComponent(String(requestParameters.assistantId))).replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters.fileId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(AssistantFileObjectFromJSON(body), text);
    }

    return config;
}

/**
* Retrieves an AssistantFile.
*/
export function getAssistantFile<T>(requestParameters: GetAssistantFileRequest, requestConfig?: runtime.TypedQueryConfig<T, AssistantFileObject>): QueryConfig<T> {
    return getAssistantFileRaw(requestParameters, requestConfig);
}

/**
 * Retrieve a message.
 */
function getMessageRaw<T>(requestParameters: GetMessageRequest, requestConfig: runtime.TypedQueryConfig<T, MessageObject> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling getMessage.');
    }

    if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
        throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling getMessage.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}/messages/{message_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))).replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(MessageObjectFromJSON(body), text);
    }

    return config;
}

/**
* Retrieve a message.
*/
export function getMessage<T>(requestParameters: GetMessageRequest, requestConfig?: runtime.TypedQueryConfig<T, MessageObject>): QueryConfig<T> {
    return getMessageRaw(requestParameters, requestConfig);
}

/**
 * Retrieves a message file.
 */
function getMessageFileRaw<T>(requestParameters: GetMessageFileRequest, requestConfig: runtime.TypedQueryConfig<T, MessageFileObject> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling getMessageFile.');
    }

    if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
        throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling getMessageFile.');
    }

    if (requestParameters.fileId === null || requestParameters.fileId === undefined) {
        throw new runtime.RequiredError('fileId','Required parameter requestParameters.fileId was null or undefined when calling getMessageFile.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}/messages/{message_id}/files/{file_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))).replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))).replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters.fileId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(MessageFileObjectFromJSON(body), text);
    }

    return config;
}

/**
* Retrieves a message file.
*/
export function getMessageFile<T>(requestParameters: GetMessageFileRequest, requestConfig?: runtime.TypedQueryConfig<T, MessageFileObject>): QueryConfig<T> {
    return getMessageFileRaw(requestParameters, requestConfig);
}

/**
 * Retrieves a run.
 */
function getRunRaw<T>(requestParameters: GetRunRequest, requestConfig: runtime.TypedQueryConfig<T, RunObject> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling getRun.');
    }

    if (requestParameters.runId === null || requestParameters.runId === undefined) {
        throw new runtime.RequiredError('runId','Required parameter requestParameters.runId was null or undefined when calling getRun.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}/runs/{run_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))).replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters.runId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(RunObjectFromJSON(body), text);
    }

    return config;
}

/**
* Retrieves a run.
*/
export function getRun<T>(requestParameters: GetRunRequest, requestConfig?: runtime.TypedQueryConfig<T, RunObject>): QueryConfig<T> {
    return getRunRaw(requestParameters, requestConfig);
}

/**
 * Retrieves a run step.
 */
function getRunStepRaw<T>(requestParameters: GetRunStepRequest, requestConfig: runtime.TypedQueryConfig<T, RunStepObject> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling getRunStep.');
    }

    if (requestParameters.runId === null || requestParameters.runId === undefined) {
        throw new runtime.RequiredError('runId','Required parameter requestParameters.runId was null or undefined when calling getRunStep.');
    }

    if (requestParameters.stepId === null || requestParameters.stepId === undefined) {
        throw new runtime.RequiredError('stepId','Required parameter requestParameters.stepId was null or undefined when calling getRunStep.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}/runs/{run_id}/steps/{step_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))).replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters.runId))).replace(`{${"step_id"}}`, encodeURIComponent(String(requestParameters.stepId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(RunStepObjectFromJSON(body), text);
    }

    return config;
}

/**
* Retrieves a run step.
*/
export function getRunStep<T>(requestParameters: GetRunStepRequest, requestConfig?: runtime.TypedQueryConfig<T, RunStepObject>): QueryConfig<T> {
    return getRunStepRaw(requestParameters, requestConfig);
}

/**
 * Retrieves a thread.
 */
function getThreadRaw<T>(requestParameters: GetThreadRequest, requestConfig: runtime.TypedQueryConfig<T, ThreadObject> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling getThread.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ThreadObjectFromJSON(body), text);
    }

    return config;
}

/**
* Retrieves a thread.
*/
export function getThread<T>(requestParameters: GetThreadRequest, requestConfig?: runtime.TypedQueryConfig<T, ThreadObject>): QueryConfig<T> {
    return getThreadRaw(requestParameters, requestConfig);
}

/**
 * Returns a list of assistant files.
 */
function listAssistantFilesRaw<T>(requestParameters: ListAssistantFilesRequest, requestConfig: runtime.TypedQueryConfig<T, ListAssistantFilesResponse> = {}): QueryConfig<T> {
    if (requestParameters.assistantId === null || requestParameters.assistantId === undefined) {
        throw new runtime.RequiredError('assistantId','Required parameter requestParameters.assistantId was null or undefined when calling listAssistantFiles.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.order !== undefined) {
        queryParameters['order'] = requestParameters.order;
    }


    if (requestParameters.after !== undefined) {
        queryParameters['after'] = requestParameters.after;
    }


    if (requestParameters.before !== undefined) {
        queryParameters['before'] = requestParameters.before;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/assistants/{assistant_id}/files`.replace(`{${"assistant_id"}}`, encodeURIComponent(String(requestParameters.assistantId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ListAssistantFilesResponseFromJSON(body), text);
    }

    return config;
}

/**
* Returns a list of assistant files.
*/
export function listAssistantFiles<T>(requestParameters: ListAssistantFilesRequest, requestConfig?: runtime.TypedQueryConfig<T, ListAssistantFilesResponse>): QueryConfig<T> {
    return listAssistantFilesRaw(requestParameters, requestConfig);
}

/**
 * Returns a list of assistants.
 */
function listAssistantsRaw<T>(requestParameters: ListAssistantsRequest, requestConfig: runtime.TypedQueryConfig<T, ListAssistantsResponse> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.order !== undefined) {
        queryParameters['order'] = requestParameters.order;
    }


    if (requestParameters.after !== undefined) {
        queryParameters['after'] = requestParameters.after;
    }


    if (requestParameters.before !== undefined) {
        queryParameters['before'] = requestParameters.before;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/assistants`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ListAssistantsResponseFromJSON(body), text);
    }

    return config;
}

/**
* Returns a list of assistants.
*/
export function listAssistants<T>(requestParameters: ListAssistantsRequest, requestConfig?: runtime.TypedQueryConfig<T, ListAssistantsResponse>): QueryConfig<T> {
    return listAssistantsRaw(requestParameters, requestConfig);
}

/**
 * Returns a list of message files.
 */
function listMessageFilesRaw<T>(requestParameters: ListMessageFilesRequest, requestConfig: runtime.TypedQueryConfig<T, ListMessageFilesResponse> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling listMessageFiles.');
    }

    if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
        throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling listMessageFiles.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.order !== undefined) {
        queryParameters['order'] = requestParameters.order;
    }


    if (requestParameters.after !== undefined) {
        queryParameters['after'] = requestParameters.after;
    }


    if (requestParameters.before !== undefined) {
        queryParameters['before'] = requestParameters.before;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}/messages/{message_id}/files`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))).replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ListMessageFilesResponseFromJSON(body), text);
    }

    return config;
}

/**
* Returns a list of message files.
*/
export function listMessageFiles<T>(requestParameters: ListMessageFilesRequest, requestConfig?: runtime.TypedQueryConfig<T, ListMessageFilesResponse>): QueryConfig<T> {
    return listMessageFilesRaw(requestParameters, requestConfig);
}

/**
 * Returns a list of messages for a given thread.
 */
function listMessagesRaw<T>(requestParameters: ListMessagesRequest, requestConfig: runtime.TypedQueryConfig<T, ListMessagesResponse> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling listMessages.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.order !== undefined) {
        queryParameters['order'] = requestParameters.order;
    }


    if (requestParameters.after !== undefined) {
        queryParameters['after'] = requestParameters.after;
    }


    if (requestParameters.before !== undefined) {
        queryParameters['before'] = requestParameters.before;
    }


    if (requestParameters.runId !== undefined) {
        queryParameters['run_id'] = requestParameters.runId;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}/messages`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ListMessagesResponseFromJSON(body), text);
    }

    return config;
}

/**
* Returns a list of messages for a given thread.
*/
export function listMessages<T>(requestParameters: ListMessagesRequest, requestConfig?: runtime.TypedQueryConfig<T, ListMessagesResponse>): QueryConfig<T> {
    return listMessagesRaw(requestParameters, requestConfig);
}

/**
 * Returns a list of run steps belonging to a run.
 */
function listRunStepsRaw<T>(requestParameters: ListRunStepsRequest, requestConfig: runtime.TypedQueryConfig<T, ListRunStepsResponse> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling listRunSteps.');
    }

    if (requestParameters.runId === null || requestParameters.runId === undefined) {
        throw new runtime.RequiredError('runId','Required parameter requestParameters.runId was null or undefined when calling listRunSteps.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.order !== undefined) {
        queryParameters['order'] = requestParameters.order;
    }


    if (requestParameters.after !== undefined) {
        queryParameters['after'] = requestParameters.after;
    }


    if (requestParameters.before !== undefined) {
        queryParameters['before'] = requestParameters.before;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}/runs/{run_id}/steps`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))).replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters.runId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ListRunStepsResponseFromJSON(body), text);
    }

    return config;
}

/**
* Returns a list of run steps belonging to a run.
*/
export function listRunSteps<T>(requestParameters: ListRunStepsRequest, requestConfig?: runtime.TypedQueryConfig<T, ListRunStepsResponse>): QueryConfig<T> {
    return listRunStepsRaw(requestParameters, requestConfig);
}

/**
 * Returns a list of runs belonging to a thread.
 */
function listRunsRaw<T>(requestParameters: ListRunsRequest, requestConfig: runtime.TypedQueryConfig<T, ListRunsResponse> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling listRuns.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.order !== undefined) {
        queryParameters['order'] = requestParameters.order;
    }


    if (requestParameters.after !== undefined) {
        queryParameters['after'] = requestParameters.after;
    }


    if (requestParameters.before !== undefined) {
        queryParameters['before'] = requestParameters.before;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}/runs`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ListRunsResponseFromJSON(body), text);
    }

    return config;
}

/**
* Returns a list of runs belonging to a thread.
*/
export function listRuns<T>(requestParameters: ListRunsRequest, requestConfig?: runtime.TypedQueryConfig<T, ListRunsResponse>): QueryConfig<T> {
    return listRunsRaw(requestParameters, requestConfig);
}

/**
 * Modifies an assistant.
 */
function modifyAssistantRaw<T>(requestParameters: ModifyAssistantRequest, requestConfig: runtime.TypedQueryConfig<T, AssistantObject> = {}): QueryConfig<T> {
    if (requestParameters.assistantId === null || requestParameters.assistantId === undefined) {
        throw new runtime.RequiredError('assistantId','Required parameter requestParameters.assistantId was null or undefined when calling modifyAssistant.');
    }

    if (requestParameters.modifyAssistantRequest === null || requestParameters.modifyAssistantRequest === undefined) {
        throw new runtime.RequiredError('modifyAssistantRequest','Required parameter requestParameters.modifyAssistantRequest was null or undefined when calling modifyAssistant.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/assistants/{assistant_id}`.replace(`{${"assistant_id"}}`, encodeURIComponent(String(requestParameters.assistantId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || ModifyAssistantRequestToJSON(requestParameters.modifyAssistantRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(AssistantObjectFromJSON(body), text);
    }

    return config;
}

/**
* Modifies an assistant.
*/
export function modifyAssistant<T>(requestParameters: ModifyAssistantRequest, requestConfig?: runtime.TypedQueryConfig<T, AssistantObject>): QueryConfig<T> {
    return modifyAssistantRaw(requestParameters, requestConfig);
}

/**
 * Modifies a message.
 */
function modifyMessageRaw<T>(requestParameters: ModifyMessageRequest, requestConfig: runtime.TypedQueryConfig<T, MessageObject> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling modifyMessage.');
    }

    if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
        throw new runtime.RequiredError('messageId','Required parameter requestParameters.messageId was null or undefined when calling modifyMessage.');
    }

    if (requestParameters.modifyMessageRequest === null || requestParameters.modifyMessageRequest === undefined) {
        throw new runtime.RequiredError('modifyMessageRequest','Required parameter requestParameters.modifyMessageRequest was null or undefined when calling modifyMessage.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}/messages/{message_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))).replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters.messageId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || ModifyMessageRequestToJSON(requestParameters.modifyMessageRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(MessageObjectFromJSON(body), text);
    }

    return config;
}

/**
* Modifies a message.
*/
export function modifyMessage<T>(requestParameters: ModifyMessageRequest, requestConfig?: runtime.TypedQueryConfig<T, MessageObject>): QueryConfig<T> {
    return modifyMessageRaw(requestParameters, requestConfig);
}

/**
 * Modifies a run.
 */
function modifyRunRaw<T>(requestParameters: ModifyRunRequest, requestConfig: runtime.TypedQueryConfig<T, RunObject> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling modifyRun.');
    }

    if (requestParameters.runId === null || requestParameters.runId === undefined) {
        throw new runtime.RequiredError('runId','Required parameter requestParameters.runId was null or undefined when calling modifyRun.');
    }

    if (requestParameters.modifyRunRequest === null || requestParameters.modifyRunRequest === undefined) {
        throw new runtime.RequiredError('modifyRunRequest','Required parameter requestParameters.modifyRunRequest was null or undefined when calling modifyRun.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}/runs/{run_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))).replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters.runId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || ModifyRunRequestToJSON(requestParameters.modifyRunRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(RunObjectFromJSON(body), text);
    }

    return config;
}

/**
* Modifies a run.
*/
export function modifyRun<T>(requestParameters: ModifyRunRequest, requestConfig?: runtime.TypedQueryConfig<T, RunObject>): QueryConfig<T> {
    return modifyRunRaw(requestParameters, requestConfig);
}

/**
 * Modifies a thread.
 */
function modifyThreadRaw<T>(requestParameters: ModifyThreadRequest, requestConfig: runtime.TypedQueryConfig<T, ThreadObject> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling modifyThread.');
    }

    if (requestParameters.modifyThreadRequest === null || requestParameters.modifyThreadRequest === undefined) {
        throw new runtime.RequiredError('modifyThreadRequest','Required parameter requestParameters.modifyThreadRequest was null or undefined when calling modifyThread.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || ModifyThreadRequestToJSON(requestParameters.modifyThreadRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ThreadObjectFromJSON(body), text);
    }

    return config;
}

/**
* Modifies a thread.
*/
export function modifyThread<T>(requestParameters: ModifyThreadRequest, requestConfig?: runtime.TypedQueryConfig<T, ThreadObject>): QueryConfig<T> {
    return modifyThreadRaw(requestParameters, requestConfig);
}

/**
 * When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they\'re all completed. All outputs must be submitted in a single request. 
 */
function submitToolOuputsToRunRaw<T>(requestParameters: SubmitToolOuputsToRunRequest, requestConfig: runtime.TypedQueryConfig<T, RunObject> = {}): QueryConfig<T> {
    if (requestParameters.threadId === null || requestParameters.threadId === undefined) {
        throw new runtime.RequiredError('threadId','Required parameter requestParameters.threadId was null or undefined when calling submitToolOuputsToRun.');
    }

    if (requestParameters.runId === null || requestParameters.runId === undefined) {
        throw new runtime.RequiredError('runId','Required parameter requestParameters.runId was null or undefined when calling submitToolOuputsToRun.');
    }

    if (requestParameters.submitToolOutputsRunRequest === null || requestParameters.submitToolOutputsRunRequest === undefined) {
        throw new runtime.RequiredError('submitToolOutputsRunRequest','Required parameter requestParameters.submitToolOutputsRunRequest was null or undefined when calling submitToolOuputsToRun.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/threads/{thread_id}/runs/{run_id}/submit_tool_outputs`.replace(`{${"thread_id"}}`, encodeURIComponent(String(requestParameters.threadId))).replace(`{${"run_id"}}`, encodeURIComponent(String(requestParameters.runId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || SubmitToolOutputsRunRequestToJSON(requestParameters.submitToolOutputsRunRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(RunObjectFromJSON(body), text);
    }

    return config;
}

/**
* When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they\'re all completed. All outputs must be submitted in a single request. 
*/
export function submitToolOuputsToRun<T>(requestParameters: SubmitToolOuputsToRunRequest, requestConfig?: runtime.TypedQueryConfig<T, RunObject>): QueryConfig<T> {
    return submitToolOuputsToRunRaw(requestParameters, requestConfig);
}


/**
    * @export
    * @enum {string}
    */
export enum ListAssistantFilesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
    * @export
    * @enum {string}
    */
export enum ListAssistantsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
    * @export
    * @enum {string}
    */
export enum ListMessageFilesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
    * @export
    * @enum {string}
    */
export enum ListMessagesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
    * @export
    * @enum {string}
    */
export enum ListRunStepsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
    * @export
    * @enum {string}
    */
export enum ListRunsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
