// tslint:disable
/**
 * OpenAI API
 * APIs for sampling from and fine-tuning language models
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    CreateChatCompletionRequest,
    CreateChatCompletionRequestFromJSON,
    CreateChatCompletionRequestToJSON,
    CreateChatCompletionResponse,
    CreateChatCompletionResponseFromJSON,
    CreateChatCompletionResponseToJSON,
    CreateCompletionRequest,
    CreateCompletionRequestFromJSON,
    CreateCompletionRequestToJSON,
    CreateCompletionResponse,
    CreateCompletionResponseFromJSON,
    CreateCompletionResponseToJSON,
    CreateEditRequest,
    CreateEditRequestFromJSON,
    CreateEditRequestToJSON,
    CreateEditResponse,
    CreateEditResponseFromJSON,
    CreateEditResponseToJSON,
    CreateEmbeddingRequest,
    CreateEmbeddingRequestFromJSON,
    CreateEmbeddingRequestToJSON,
    CreateEmbeddingResponse,
    CreateEmbeddingResponseFromJSON,
    CreateEmbeddingResponseToJSON,
    CreateFineTuneRequest,
    CreateFineTuneRequestFromJSON,
    CreateFineTuneRequestToJSON,
    CreateImageRequest,
    CreateImageRequestFromJSON,
    CreateImageRequestToJSON,
    CreateModerationRequest,
    CreateModerationRequestFromJSON,
    CreateModerationRequestToJSON,
    CreateModerationResponse,
    CreateModerationResponseFromJSON,
    CreateModerationResponseToJSON,
    CreateTranscriptionRequestModel,
    CreateTranscriptionRequestModelFromJSON,
    CreateTranscriptionRequestModelToJSON,
    CreateTranscriptionResponse,
    CreateTranscriptionResponseFromJSON,
    CreateTranscriptionResponseToJSON,
    CreateTranslationResponse,
    CreateTranslationResponseFromJSON,
    CreateTranslationResponseToJSON,
    DeleteFileResponse,
    DeleteFileResponseFromJSON,
    DeleteFileResponseToJSON,
    DeleteModelResponse,
    DeleteModelResponseFromJSON,
    DeleteModelResponseToJSON,
    FineTune,
    FineTuneFromJSON,
    FineTuneToJSON,
    ImagesResponse,
    ImagesResponseFromJSON,
    ImagesResponseToJSON,
    ListFilesResponse,
    ListFilesResponseFromJSON,
    ListFilesResponseToJSON,
    ListFineTuneEventsResponse,
    ListFineTuneEventsResponseFromJSON,
    ListFineTuneEventsResponseToJSON,
    ListFineTunesResponse,
    ListFineTunesResponseFromJSON,
    ListFineTunesResponseToJSON,
    ListModelsResponse,
    ListModelsResponseFromJSON,
    ListModelsResponseToJSON,
    Model,
    ModelFromJSON,
    ModelToJSON,
    OpenAIFile,
    OpenAIFileFromJSON,
    OpenAIFileToJSON,
} from '../models';

export interface CancelFineTuneRequest {
    fineTuneId: string;
}

export interface CreateChatCompletionRequest {
    createChatCompletionRequest: CreateChatCompletionRequest;
}

export interface CreateCompletionRequest {
    createCompletionRequest: CreateCompletionRequest;
}

export interface CreateEditRequest {
    createEditRequest: CreateEditRequest;
}

export interface CreateEmbeddingRequest {
    createEmbeddingRequest: CreateEmbeddingRequest;
}

export interface CreateFileRequest {
    file: Blob;
    purpose: string;
}

export interface CreateFineTuneRequest {
    createFineTuneRequest: CreateFineTuneRequest;
}

export interface CreateImageRequest {
    createImageRequest: CreateImageRequest;
}

export interface CreateImageEditRequest {
    image: Blob;
    prompt: string;
    mask?: Blob;
    n?: number;
    size?: CreateImageEditSizeEnum;
    responseFormat?: CreateImageEditResponseFormatEnum;
    user?: string;
}

export interface CreateImageVariationRequest {
    image: Blob;
    n?: number;
    size?: CreateImageVariationSizeEnum;
    responseFormat?: CreateImageVariationResponseFormatEnum;
    user?: string;
}

export interface CreateModerationRequest {
    createModerationRequest: CreateModerationRequest;
}

export interface CreateTranscriptionRequest {
    file: Blob;
    model: CreateTranscriptionRequestModel;
    prompt?: string;
    responseFormat?: string;
    temperature?: number;
    language?: string;
}

export interface CreateTranslationRequest {
    file: Blob;
    model: CreateTranscriptionRequestModel;
    prompt?: string;
    responseFormat?: string;
    temperature?: number;
}

export interface DeleteFileRequest {
    fileId: string;
}

export interface DeleteModelRequest {
    model: string;
}

export interface DownloadFileRequest {
    fileId: string;
}

export interface ListFineTuneEventsRequest {
    fineTuneId: string;
    stream?: boolean;
}

export interface RetrieveFileRequest {
    fileId: string;
}

export interface RetrieveFineTuneRequest {
    fineTuneId: string;
}

export interface RetrieveModelRequest {
    model: string;
}


/**
 * Immediately cancel a fine-tune job. 
 */
function cancelFineTuneRaw<T>(requestParameters: CancelFineTuneRequest, requestConfig: runtime.TypedQueryConfig<T, FineTune> = {}): QueryConfig<T> {
    if (requestParameters.fineTuneId === null || requestParameters.fineTuneId === undefined) {
        throw new runtime.RequiredError('fineTuneId','Required parameter requestParameters.fineTuneId was null or undefined when calling cancelFineTune.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/fine-tunes/{fine_tune_id}/cancel`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(requestParameters.fineTuneId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(FineTuneFromJSON(body), text);
    }

    return config;
}

/**
* Immediately cancel a fine-tune job. 
*/
export function cancelFineTune<T>(requestParameters: CancelFineTuneRequest, requestConfig?: runtime.TypedQueryConfig<T, FineTune>): QueryConfig<T> {
    return cancelFineTuneRaw(requestParameters, requestConfig);
}

/**
 * Creates a model response for the given chat conversation.
 */
function createChatCompletionRaw<T>(requestParameters: CreateChatCompletionRequest, requestConfig: runtime.TypedQueryConfig<T, CreateChatCompletionResponse> = {}): QueryConfig<T> {
    if (requestParameters.createChatCompletionRequest === null || requestParameters.createChatCompletionRequest === undefined) {
        throw new runtime.RequiredError('createChatCompletionRequest','Required parameter requestParameters.createChatCompletionRequest was null or undefined when calling createChatCompletion.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/chat/completions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateChatCompletionRequestToJSON(requestParameters.createChatCompletionRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CreateChatCompletionResponseFromJSON(body), text);
    }

    return config;
}

/**
* Creates a model response for the given chat conversation.
*/
export function createChatCompletion<T>(requestParameters: CreateChatCompletionRequest, requestConfig?: runtime.TypedQueryConfig<T, CreateChatCompletionResponse>): QueryConfig<T> {
    return createChatCompletionRaw(requestParameters, requestConfig);
}

/**
 * Creates a completion for the provided prompt and parameters.
 */
function createCompletionRaw<T>(requestParameters: CreateCompletionRequest, requestConfig: runtime.TypedQueryConfig<T, CreateCompletionResponse> = {}): QueryConfig<T> {
    if (requestParameters.createCompletionRequest === null || requestParameters.createCompletionRequest === undefined) {
        throw new runtime.RequiredError('createCompletionRequest','Required parameter requestParameters.createCompletionRequest was null or undefined when calling createCompletion.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/completions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateCompletionRequestToJSON(requestParameters.createCompletionRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CreateCompletionResponseFromJSON(body), text);
    }

    return config;
}

/**
* Creates a completion for the provided prompt and parameters.
*/
export function createCompletion<T>(requestParameters: CreateCompletionRequest, requestConfig?: runtime.TypedQueryConfig<T, CreateCompletionResponse>): QueryConfig<T> {
    return createCompletionRaw(requestParameters, requestConfig);
}

/**
 * Creates a new edit for the provided input, instruction, and parameters.
 */
function createEditRaw<T>(requestParameters: CreateEditRequest, requestConfig: runtime.TypedQueryConfig<T, CreateEditResponse> = {}): QueryConfig<T> {
    if (requestParameters.createEditRequest === null || requestParameters.createEditRequest === undefined) {
        throw new runtime.RequiredError('createEditRequest','Required parameter requestParameters.createEditRequest was null or undefined when calling createEdit.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/edits`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateEditRequestToJSON(requestParameters.createEditRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CreateEditResponseFromJSON(body), text);
    }

    return config;
}

/**
* Creates a new edit for the provided input, instruction, and parameters.
*/
export function createEdit<T>(requestParameters: CreateEditRequest, requestConfig?: runtime.TypedQueryConfig<T, CreateEditResponse>): QueryConfig<T> {
    return createEditRaw(requestParameters, requestConfig);
}

/**
 * Creates an embedding vector representing the input text.
 */
function createEmbeddingRaw<T>(requestParameters: CreateEmbeddingRequest, requestConfig: runtime.TypedQueryConfig<T, CreateEmbeddingResponse> = {}): QueryConfig<T> {
    if (requestParameters.createEmbeddingRequest === null || requestParameters.createEmbeddingRequest === undefined) {
        throw new runtime.RequiredError('createEmbeddingRequest','Required parameter requestParameters.createEmbeddingRequest was null or undefined when calling createEmbedding.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/embeddings`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateEmbeddingRequestToJSON(requestParameters.createEmbeddingRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CreateEmbeddingResponseFromJSON(body), text);
    }

    return config;
}

/**
* Creates an embedding vector representing the input text.
*/
export function createEmbedding<T>(requestParameters: CreateEmbeddingRequest, requestConfig?: runtime.TypedQueryConfig<T, CreateEmbeddingResponse>): QueryConfig<T> {
    return createEmbeddingRaw(requestParameters, requestConfig);
}

/**
 * Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit. 
 */
function createFileRaw<T>(requestParameters: CreateFileRequest, requestConfig: runtime.TypedQueryConfig<T, OpenAIFile> = {}): QueryConfig<T> {
    if (requestParameters.file === null || requestParameters.file === undefined) {
        throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling createFile.');
    }

    if (requestParameters.purpose === null || requestParameters.purpose === undefined) {
        throw new runtime.RequiredError('purpose','Required parameter requestParameters.purpose was null or undefined when calling createFile.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const formData = new FormData();
    if (requestParameters.file !== undefined) {
        formData.append('file', requestParameters.file as any);
    }

    if (requestParameters.purpose !== undefined) {
        formData.append('purpose', requestParameters.purpose as any);
    }

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/files`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: formData,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(OpenAIFileFromJSON(body), text);
    }

    return config;
}

/**
* Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit. 
*/
export function createFile<T>(requestParameters: CreateFileRequest, requestConfig?: runtime.TypedQueryConfig<T, OpenAIFile>): QueryConfig<T> {
    return createFileRaw(requestParameters, requestConfig);
}

/**
 * Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning) 
 */
function createFineTuneRaw<T>(requestParameters: CreateFineTuneRequest, requestConfig: runtime.TypedQueryConfig<T, FineTune> = {}): QueryConfig<T> {
    if (requestParameters.createFineTuneRequest === null || requestParameters.createFineTuneRequest === undefined) {
        throw new runtime.RequiredError('createFineTuneRequest','Required parameter requestParameters.createFineTuneRequest was null or undefined when calling createFineTune.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/fine-tunes`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateFineTuneRequestToJSON(requestParameters.createFineTuneRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(FineTuneFromJSON(body), text);
    }

    return config;
}

/**
* Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning) 
*/
export function createFineTune<T>(requestParameters: CreateFineTuneRequest, requestConfig?: runtime.TypedQueryConfig<T, FineTune>): QueryConfig<T> {
    return createFineTuneRaw(requestParameters, requestConfig);
}

/**
 * Creates an image given a prompt.
 */
function createImageRaw<T>(requestParameters: CreateImageRequest, requestConfig: runtime.TypedQueryConfig<T, ImagesResponse> = {}): QueryConfig<T> {
    if (requestParameters.createImageRequest === null || requestParameters.createImageRequest === undefined) {
        throw new runtime.RequiredError('createImageRequest','Required parameter requestParameters.createImageRequest was null or undefined when calling createImage.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/images/generations`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateImageRequestToJSON(requestParameters.createImageRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ImagesResponseFromJSON(body), text);
    }

    return config;
}

/**
* Creates an image given a prompt.
*/
export function createImage<T>(requestParameters: CreateImageRequest, requestConfig?: runtime.TypedQueryConfig<T, ImagesResponse>): QueryConfig<T> {
    return createImageRaw(requestParameters, requestConfig);
}

/**
 * Creates an edited or extended image given an original image and a prompt.
 */
function createImageEditRaw<T>(requestParameters: CreateImageEditRequest, requestConfig: runtime.TypedQueryConfig<T, ImagesResponse> = {}): QueryConfig<T> {
    if (requestParameters.image === null || requestParameters.image === undefined) {
        throw new runtime.RequiredError('image','Required parameter requestParameters.image was null or undefined when calling createImageEdit.');
    }

    if (requestParameters.prompt === null || requestParameters.prompt === undefined) {
        throw new runtime.RequiredError('prompt','Required parameter requestParameters.prompt was null or undefined when calling createImageEdit.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const formData = new FormData();
    if (requestParameters.image !== undefined) {
        formData.append('image', requestParameters.image as any);
    }

    if (requestParameters.mask !== undefined) {
        formData.append('mask', requestParameters.mask as any);
    }

    if (requestParameters.prompt !== undefined) {
        formData.append('prompt', requestParameters.prompt as any);
    }

    if (requestParameters.n !== undefined) {
        formData.append('n', requestParameters.n as any);
    }

    if (requestParameters.size !== undefined) {
        formData.append('size', requestParameters.size as any);
    }

    if (requestParameters.responseFormat !== undefined) {
        formData.append('response_format', requestParameters.responseFormat as any);
    }

    if (requestParameters.user !== undefined) {
        formData.append('user', requestParameters.user as any);
    }

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/images/edits`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: formData,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ImagesResponseFromJSON(body), text);
    }

    return config;
}

/**
* Creates an edited or extended image given an original image and a prompt.
*/
export function createImageEdit<T>(requestParameters: CreateImageEditRequest, requestConfig?: runtime.TypedQueryConfig<T, ImagesResponse>): QueryConfig<T> {
    return createImageEditRaw(requestParameters, requestConfig);
}

/**
 * Creates a variation of a given image.
 */
function createImageVariationRaw<T>(requestParameters: CreateImageVariationRequest, requestConfig: runtime.TypedQueryConfig<T, ImagesResponse> = {}): QueryConfig<T> {
    if (requestParameters.image === null || requestParameters.image === undefined) {
        throw new runtime.RequiredError('image','Required parameter requestParameters.image was null or undefined when calling createImageVariation.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const formData = new FormData();
    if (requestParameters.image !== undefined) {
        formData.append('image', requestParameters.image as any);
    }

    if (requestParameters.n !== undefined) {
        formData.append('n', requestParameters.n as any);
    }

    if (requestParameters.size !== undefined) {
        formData.append('size', requestParameters.size as any);
    }

    if (requestParameters.responseFormat !== undefined) {
        formData.append('response_format', requestParameters.responseFormat as any);
    }

    if (requestParameters.user !== undefined) {
        formData.append('user', requestParameters.user as any);
    }

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/images/variations`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: formData,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ImagesResponseFromJSON(body), text);
    }

    return config;
}

/**
* Creates a variation of a given image.
*/
export function createImageVariation<T>(requestParameters: CreateImageVariationRequest, requestConfig?: runtime.TypedQueryConfig<T, ImagesResponse>): QueryConfig<T> {
    return createImageVariationRaw(requestParameters, requestConfig);
}

/**
 * Classifies if text violates OpenAI\'s Content Policy
 */
function createModerationRaw<T>(requestParameters: CreateModerationRequest, requestConfig: runtime.TypedQueryConfig<T, CreateModerationResponse> = {}): QueryConfig<T> {
    if (requestParameters.createModerationRequest === null || requestParameters.createModerationRequest === undefined) {
        throw new runtime.RequiredError('createModerationRequest','Required parameter requestParameters.createModerationRequest was null or undefined when calling createModeration.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/moderations`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateModerationRequestToJSON(requestParameters.createModerationRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CreateModerationResponseFromJSON(body), text);
    }

    return config;
}

/**
* Classifies if text violates OpenAI\'s Content Policy
*/
export function createModeration<T>(requestParameters: CreateModerationRequest, requestConfig?: runtime.TypedQueryConfig<T, CreateModerationResponse>): QueryConfig<T> {
    return createModerationRaw(requestParameters, requestConfig);
}

/**
 * Transcribes audio into the input language.
 */
function createTranscriptionRaw<T>(requestParameters: CreateTranscriptionRequest, requestConfig: runtime.TypedQueryConfig<T, CreateTranscriptionResponse> = {}): QueryConfig<T> {
    if (requestParameters.file === null || requestParameters.file === undefined) {
        throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling createTranscription.');
    }

    if (requestParameters.model === null || requestParameters.model === undefined) {
        throw new runtime.RequiredError('model','Required parameter requestParameters.model was null or undefined when calling createTranscription.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const formData = new FormData();
    if (requestParameters.file !== undefined) {
        formData.append('file', requestParameters.file as any);
    }

    if (requestParameters.model !== undefined) {
        formData.append('model', requestParameters.model as any);
    }

    if (requestParameters.prompt !== undefined) {
        formData.append('prompt', requestParameters.prompt as any);
    }

    if (requestParameters.responseFormat !== undefined) {
        formData.append('response_format', requestParameters.responseFormat as any);
    }

    if (requestParameters.temperature !== undefined) {
        formData.append('temperature', requestParameters.temperature as any);
    }

    if (requestParameters.language !== undefined) {
        formData.append('language', requestParameters.language as any);
    }

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/audio/transcriptions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: formData,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CreateTranscriptionResponseFromJSON(body), text);
    }

    return config;
}

/**
* Transcribes audio into the input language.
*/
export function createTranscription<T>(requestParameters: CreateTranscriptionRequest, requestConfig?: runtime.TypedQueryConfig<T, CreateTranscriptionResponse>): QueryConfig<T> {
    return createTranscriptionRaw(requestParameters, requestConfig);
}

/**
 * Translates audio into English.
 */
function createTranslationRaw<T>(requestParameters: CreateTranslationRequest, requestConfig: runtime.TypedQueryConfig<T, CreateTranslationResponse> = {}): QueryConfig<T> {
    if (requestParameters.file === null || requestParameters.file === undefined) {
        throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling createTranslation.');
    }

    if (requestParameters.model === null || requestParameters.model === undefined) {
        throw new runtime.RequiredError('model','Required parameter requestParameters.model was null or undefined when calling createTranslation.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const formData = new FormData();
    if (requestParameters.file !== undefined) {
        formData.append('file', requestParameters.file as any);
    }

    if (requestParameters.model !== undefined) {
        formData.append('model', requestParameters.model as any);
    }

    if (requestParameters.prompt !== undefined) {
        formData.append('prompt', requestParameters.prompt as any);
    }

    if (requestParameters.responseFormat !== undefined) {
        formData.append('response_format', requestParameters.responseFormat as any);
    }

    if (requestParameters.temperature !== undefined) {
        formData.append('temperature', requestParameters.temperature as any);
    }

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/audio/translations`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: formData,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CreateTranslationResponseFromJSON(body), text);
    }

    return config;
}

/**
* Translates audio into English.
*/
export function createTranslation<T>(requestParameters: CreateTranslationRequest, requestConfig?: runtime.TypedQueryConfig<T, CreateTranslationResponse>): QueryConfig<T> {
    return createTranslationRaw(requestParameters, requestConfig);
}

/**
 * Delete a file.
 */
function deleteFileRaw<T>(requestParameters: DeleteFileRequest, requestConfig: runtime.TypedQueryConfig<T, DeleteFileResponse> = {}): QueryConfig<T> {
    if (requestParameters.fileId === null || requestParameters.fileId === undefined) {
        throw new runtime.RequiredError('fileId','Required parameter requestParameters.fileId was null or undefined when calling deleteFile.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/files/{file_id}`.replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters.fileId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DeleteFileResponseFromJSON(body), text);
    }

    return config;
}

/**
* Delete a file.
*/
export function deleteFile<T>(requestParameters: DeleteFileRequest, requestConfig?: runtime.TypedQueryConfig<T, DeleteFileResponse>): QueryConfig<T> {
    return deleteFileRaw(requestParameters, requestConfig);
}

/**
 * Delete a fine-tuned model. You must have the Owner role in your organization.
 */
function deleteModelRaw<T>(requestParameters: DeleteModelRequest, requestConfig: runtime.TypedQueryConfig<T, DeleteModelResponse> = {}): QueryConfig<T> {
    if (requestParameters.model === null || requestParameters.model === undefined) {
        throw new runtime.RequiredError('model','Required parameter requestParameters.model was null or undefined when calling deleteModel.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/models/{model}`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters.model))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DeleteModelResponseFromJSON(body), text);
    }

    return config;
}

/**
* Delete a fine-tuned model. You must have the Owner role in your organization.
*/
export function deleteModel<T>(requestParameters: DeleteModelRequest, requestConfig?: runtime.TypedQueryConfig<T, DeleteModelResponse>): QueryConfig<T> {
    return deleteModelRaw(requestParameters, requestConfig);
}

/**
 * Returns the contents of the specified file
 */
function downloadFileRaw<T>(requestParameters: DownloadFileRequest, requestConfig: runtime.TypedQueryConfig<T, string> = {}): QueryConfig<T> {
    if (requestParameters.fileId === null || requestParameters.fileId === undefined) {
        throw new runtime.RequiredError('fileId','Required parameter requestParameters.fileId was null or undefined when calling downloadFile.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/files/{file_id}/content`.replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters.fileId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        throw "OH NO";
    }

    return config;
}

/**
* Returns the contents of the specified file
*/
export function downloadFile<T>(requestParameters: DownloadFileRequest, requestConfig?: runtime.TypedQueryConfig<T, string>): QueryConfig<T> {
    return downloadFileRaw(requestParameters, requestConfig);
}

/**
 * Returns a list of files that belong to the user\'s organization.
 */
function listFilesRaw<T>( requestConfig: runtime.TypedQueryConfig<T, ListFilesResponse> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/files`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ListFilesResponseFromJSON(body), text);
    }

    return config;
}

/**
* Returns a list of files that belong to the user\'s organization.
*/
export function listFiles<T>( requestConfig?: runtime.TypedQueryConfig<T, ListFilesResponse>): QueryConfig<T> {
    return listFilesRaw( requestConfig);
}

/**
 * Get fine-grained status updates for a fine-tune job. 
 */
function listFineTuneEventsRaw<T>(requestParameters: ListFineTuneEventsRequest, requestConfig: runtime.TypedQueryConfig<T, ListFineTuneEventsResponse> = {}): QueryConfig<T> {
    if (requestParameters.fineTuneId === null || requestParameters.fineTuneId === undefined) {
        throw new runtime.RequiredError('fineTuneId','Required parameter requestParameters.fineTuneId was null or undefined when calling listFineTuneEvents.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.stream !== undefined) {
        queryParameters['stream'] = requestParameters.stream;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/fine-tunes/{fine_tune_id}/events`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(requestParameters.fineTuneId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ListFineTuneEventsResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get fine-grained status updates for a fine-tune job. 
*/
export function listFineTuneEvents<T>(requestParameters: ListFineTuneEventsRequest, requestConfig?: runtime.TypedQueryConfig<T, ListFineTuneEventsResponse>): QueryConfig<T> {
    return listFineTuneEventsRaw(requestParameters, requestConfig);
}

/**
 * List your organization\'s fine-tuning jobs 
 */
function listFineTunesRaw<T>( requestConfig: runtime.TypedQueryConfig<T, ListFineTunesResponse> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/fine-tunes`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ListFineTunesResponseFromJSON(body), text);
    }

    return config;
}

/**
* List your organization\'s fine-tuning jobs 
*/
export function listFineTunes<T>( requestConfig?: runtime.TypedQueryConfig<T, ListFineTunesResponse>): QueryConfig<T> {
    return listFineTunesRaw( requestConfig);
}

/**
 * Lists the currently available models, and provides basic information about each one such as the owner and availability.
 */
function listModelsRaw<T>( requestConfig: runtime.TypedQueryConfig<T, ListModelsResponse> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/models`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ListModelsResponseFromJSON(body), text);
    }

    return config;
}

/**
* Lists the currently available models, and provides basic information about each one such as the owner and availability.
*/
export function listModels<T>( requestConfig?: runtime.TypedQueryConfig<T, ListModelsResponse>): QueryConfig<T> {
    return listModelsRaw( requestConfig);
}

/**
 * Returns information about a specific file.
 */
function retrieveFileRaw<T>(requestParameters: RetrieveFileRequest, requestConfig: runtime.TypedQueryConfig<T, OpenAIFile> = {}): QueryConfig<T> {
    if (requestParameters.fileId === null || requestParameters.fileId === undefined) {
        throw new runtime.RequiredError('fileId','Required parameter requestParameters.fileId was null or undefined when calling retrieveFile.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/files/{file_id}`.replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters.fileId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(OpenAIFileFromJSON(body), text);
    }

    return config;
}

/**
* Returns information about a specific file.
*/
export function retrieveFile<T>(requestParameters: RetrieveFileRequest, requestConfig?: runtime.TypedQueryConfig<T, OpenAIFile>): QueryConfig<T> {
    return retrieveFileRaw(requestParameters, requestConfig);
}

/**
 * Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning) 
 */
function retrieveFineTuneRaw<T>(requestParameters: RetrieveFineTuneRequest, requestConfig: runtime.TypedQueryConfig<T, FineTune> = {}): QueryConfig<T> {
    if (requestParameters.fineTuneId === null || requestParameters.fineTuneId === undefined) {
        throw new runtime.RequiredError('fineTuneId','Required parameter requestParameters.fineTuneId was null or undefined when calling retrieveFineTune.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/fine-tunes/{fine_tune_id}`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(requestParameters.fineTuneId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(FineTuneFromJSON(body), text);
    }

    return config;
}

/**
* Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning) 
*/
export function retrieveFineTune<T>(requestParameters: RetrieveFineTuneRequest, requestConfig?: runtime.TypedQueryConfig<T, FineTune>): QueryConfig<T> {
    return retrieveFineTuneRaw(requestParameters, requestConfig);
}

/**
 * Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
 */
function retrieveModelRaw<T>(requestParameters: RetrieveModelRequest, requestConfig: runtime.TypedQueryConfig<T, Model> = {}): QueryConfig<T> {
    if (requestParameters.model === null || requestParameters.model === undefined) {
        throw new runtime.RequiredError('model','Required parameter requestParameters.model was null or undefined when calling retrieveModel.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/models/{model}`.replace(`{${"model"}}`, encodeURIComponent(String(requestParameters.model))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ModelFromJSON(body), text);
    }

    return config;
}

/**
* Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
*/
export function retrieveModel<T>(requestParameters: RetrieveModelRequest, requestConfig?: runtime.TypedQueryConfig<T, Model>): QueryConfig<T> {
    return retrieveModelRaw(requestParameters, requestConfig);
}


/**
    * @export
    * @enum {string}
    */
export enum CreateImageEditSizeEnum {
    _256x256 = '256x256',
    _512x512 = '512x512',
    _1024x1024 = '1024x1024'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateImageEditResponseFormatEnum {
    Url = 'url',
    B64Json = 'b64_json'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateImageVariationSizeEnum {
    _256x256 = '256x256',
    _512x512 = '512x512',
    _1024x1024 = '1024x1024'
}
/**
    * @export
    * @enum {string}
    */
export enum CreateImageVariationResponseFormatEnum {
    Url = 'url',
    B64Json = 'b64_json'
}
