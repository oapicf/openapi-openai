// tslint:disable
/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    ErrorResponse,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    Project,
    ProjectFromJSON,
    ProjectToJSON,
    ProjectApiKey,
    ProjectApiKeyFromJSON,
    ProjectApiKeyToJSON,
    ProjectApiKeyDeleteResponse,
    ProjectApiKeyDeleteResponseFromJSON,
    ProjectApiKeyDeleteResponseToJSON,
    ProjectApiKeyListResponse,
    ProjectApiKeyListResponseFromJSON,
    ProjectApiKeyListResponseToJSON,
    ProjectCreateRequest,
    ProjectCreateRequestFromJSON,
    ProjectCreateRequestToJSON,
    ProjectListResponse,
    ProjectListResponseFromJSON,
    ProjectListResponseToJSON,
    ProjectRateLimit,
    ProjectRateLimitFromJSON,
    ProjectRateLimitToJSON,
    ProjectRateLimitListResponse,
    ProjectRateLimitListResponseFromJSON,
    ProjectRateLimitListResponseToJSON,
    ProjectRateLimitUpdateRequest,
    ProjectRateLimitUpdateRequestFromJSON,
    ProjectRateLimitUpdateRequestToJSON,
    ProjectServiceAccount,
    ProjectServiceAccountFromJSON,
    ProjectServiceAccountToJSON,
    ProjectServiceAccountCreateRequest,
    ProjectServiceAccountCreateRequestFromJSON,
    ProjectServiceAccountCreateRequestToJSON,
    ProjectServiceAccountCreateResponse,
    ProjectServiceAccountCreateResponseFromJSON,
    ProjectServiceAccountCreateResponseToJSON,
    ProjectServiceAccountDeleteResponse,
    ProjectServiceAccountDeleteResponseFromJSON,
    ProjectServiceAccountDeleteResponseToJSON,
    ProjectServiceAccountListResponse,
    ProjectServiceAccountListResponseFromJSON,
    ProjectServiceAccountListResponseToJSON,
    ProjectUpdateRequest,
    ProjectUpdateRequestFromJSON,
    ProjectUpdateRequestToJSON,
    ProjectUser,
    ProjectUserFromJSON,
    ProjectUserToJSON,
    ProjectUserCreateRequest,
    ProjectUserCreateRequestFromJSON,
    ProjectUserCreateRequestToJSON,
    ProjectUserDeleteResponse,
    ProjectUserDeleteResponseFromJSON,
    ProjectUserDeleteResponseToJSON,
    ProjectUserListResponse,
    ProjectUserListResponseFromJSON,
    ProjectUserListResponseToJSON,
    ProjectUserUpdateRequest,
    ProjectUserUpdateRequestFromJSON,
    ProjectUserUpdateRequestToJSON,
} from '../models';

export interface ArchiveProjectRequest {
    projectId: string;
}

export interface CreateProjectRequest {
    projectCreateRequest: ProjectCreateRequest;
}

export interface CreateProjectServiceAccountRequest {
    projectId: string;
    projectServiceAccountCreateRequest: ProjectServiceAccountCreateRequest;
}

export interface CreateProjectUserRequest {
    projectId: string;
    projectUserCreateRequest: ProjectUserCreateRequest;
}

export interface DeleteProjectApiKeyRequest {
    projectId: string;
    keyId: string;
}

export interface DeleteProjectServiceAccountRequest {
    projectId: string;
    serviceAccountId: string;
}

export interface DeleteProjectUserRequest {
    projectId: string;
    userId: string;
}

export interface ListProjectApiKeysRequest {
    projectId: string;
    limit?: number;
    after?: string;
}

export interface ListProjectRateLimitsRequest {
    projectId: string;
    limit?: number;
    after?: string;
    before?: string;
}

export interface ListProjectServiceAccountsRequest {
    projectId: string;
    limit?: number;
    after?: string;
}

export interface ListProjectUsersRequest {
    projectId: string;
    limit?: number;
    after?: string;
}

export interface ListProjectsRequest {
    limit?: number;
    after?: string;
    includeArchived?: boolean;
}

export interface ModifyProjectRequest {
    projectId: string;
    projectUpdateRequest: ProjectUpdateRequest;
}

export interface ModifyProjectUserRequest {
    projectId: string;
    userId: string;
    projectUserUpdateRequest: ProjectUserUpdateRequest;
}

export interface RetrieveProjectRequest {
    projectId: string;
}

export interface RetrieveProjectApiKeyRequest {
    projectId: string;
    keyId: string;
}

export interface RetrieveProjectServiceAccountRequest {
    projectId: string;
    serviceAccountId: string;
}

export interface RetrieveProjectUserRequest {
    projectId: string;
    userId: string;
}

export interface UpdateProjectRateLimitsRequest {
    projectId: string;
    rateLimitId: string;
    projectRateLimitUpdateRequest: ProjectRateLimitUpdateRequest;
}


/**
 * Archives a project in the organization. Archived projects cannot be used or updated.
 */
function archiveProjectRaw<T>(requestParameters: ArchiveProjectRequest, requestConfig: runtime.TypedQueryConfig<T, Project> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling archiveProject.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}/archive`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectFromJSON(body), text);
    }

    return config;
}

/**
* Archives a project in the organization. Archived projects cannot be used or updated.
*/
export function archiveProject<T>(requestParameters: ArchiveProjectRequest, requestConfig?: runtime.TypedQueryConfig<T, Project>): QueryConfig<T> {
    return archiveProjectRaw(requestParameters, requestConfig);
}

/**
 * Create a new project in the organization. Projects can be created and archived, but cannot be deleted.
 */
function createProjectRaw<T>(requestParameters: CreateProjectRequest, requestConfig: runtime.TypedQueryConfig<T, Project> = {}): QueryConfig<T> {
    if (requestParameters.projectCreateRequest === null || requestParameters.projectCreateRequest === undefined) {
        throw new runtime.RequiredError('projectCreateRequest','Required parameter requestParameters.projectCreateRequest was null or undefined when calling createProject.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || ProjectCreateRequestToJSON(requestParameters.projectCreateRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectFromJSON(body), text);
    }

    return config;
}

/**
* Create a new project in the organization. Projects can be created and archived, but cannot be deleted.
*/
export function createProject<T>(requestParameters: CreateProjectRequest, requestConfig?: runtime.TypedQueryConfig<T, Project>): QueryConfig<T> {
    return createProjectRaw(requestParameters, requestConfig);
}

/**
 * Creates a new service account in the project. This also returns an unredacted API key for the service account.
 */
function createProjectServiceAccountRaw<T>(requestParameters: CreateProjectServiceAccountRequest, requestConfig: runtime.TypedQueryConfig<T, ProjectServiceAccountCreateResponse> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling createProjectServiceAccount.');
    }

    if (requestParameters.projectServiceAccountCreateRequest === null || requestParameters.projectServiceAccountCreateRequest === undefined) {
        throw new runtime.RequiredError('projectServiceAccountCreateRequest','Required parameter requestParameters.projectServiceAccountCreateRequest was null or undefined when calling createProjectServiceAccount.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}/service_accounts`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || ProjectServiceAccountCreateRequestToJSON(requestParameters.projectServiceAccountCreateRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectServiceAccountCreateResponseFromJSON(body), text);
    }

    return config;
}

/**
* Creates a new service account in the project. This also returns an unredacted API key for the service account.
*/
export function createProjectServiceAccount<T>(requestParameters: CreateProjectServiceAccountRequest, requestConfig?: runtime.TypedQueryConfig<T, ProjectServiceAccountCreateResponse>): QueryConfig<T> {
    return createProjectServiceAccountRaw(requestParameters, requestConfig);
}

/**
 * Adds a user to the project. Users must already be members of the organization to be added to a project.
 */
function createProjectUserRaw<T>(requestParameters: CreateProjectUserRequest, requestConfig: runtime.TypedQueryConfig<T, ProjectUser> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling createProjectUser.');
    }

    if (requestParameters.projectUserCreateRequest === null || requestParameters.projectUserCreateRequest === undefined) {
        throw new runtime.RequiredError('projectUserCreateRequest','Required parameter requestParameters.projectUserCreateRequest was null or undefined when calling createProjectUser.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}/users`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || ProjectUserCreateRequestToJSON(requestParameters.projectUserCreateRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectUserFromJSON(body), text);
    }

    return config;
}

/**
* Adds a user to the project. Users must already be members of the organization to be added to a project.
*/
export function createProjectUser<T>(requestParameters: CreateProjectUserRequest, requestConfig?: runtime.TypedQueryConfig<T, ProjectUser>): QueryConfig<T> {
    return createProjectUserRaw(requestParameters, requestConfig);
}

/**
 * Deletes an API key from the project.
 */
function deleteProjectApiKeyRaw<T>(requestParameters: DeleteProjectApiKeyRequest, requestConfig: runtime.TypedQueryConfig<T, ProjectApiKeyDeleteResponse> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling deleteProjectApiKey.');
    }

    if (requestParameters.keyId === null || requestParameters.keyId === undefined) {
        throw new runtime.RequiredError('keyId','Required parameter requestParameters.keyId was null or undefined when calling deleteProjectApiKey.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}/api_keys/{key_id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"key_id"}}`, encodeURIComponent(String(requestParameters.keyId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectApiKeyDeleteResponseFromJSON(body), text);
    }

    return config;
}

/**
* Deletes an API key from the project.
*/
export function deleteProjectApiKey<T>(requestParameters: DeleteProjectApiKeyRequest, requestConfig?: runtime.TypedQueryConfig<T, ProjectApiKeyDeleteResponse>): QueryConfig<T> {
    return deleteProjectApiKeyRaw(requestParameters, requestConfig);
}

/**
 * Deletes a service account from the project.
 */
function deleteProjectServiceAccountRaw<T>(requestParameters: DeleteProjectServiceAccountRequest, requestConfig: runtime.TypedQueryConfig<T, ProjectServiceAccountDeleteResponse> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling deleteProjectServiceAccount.');
    }

    if (requestParameters.serviceAccountId === null || requestParameters.serviceAccountId === undefined) {
        throw new runtime.RequiredError('serviceAccountId','Required parameter requestParameters.serviceAccountId was null or undefined when calling deleteProjectServiceAccount.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}/service_accounts/{service_account_id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"service_account_id"}}`, encodeURIComponent(String(requestParameters.serviceAccountId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectServiceAccountDeleteResponseFromJSON(body), text);
    }

    return config;
}

/**
* Deletes a service account from the project.
*/
export function deleteProjectServiceAccount<T>(requestParameters: DeleteProjectServiceAccountRequest, requestConfig?: runtime.TypedQueryConfig<T, ProjectServiceAccountDeleteResponse>): QueryConfig<T> {
    return deleteProjectServiceAccountRaw(requestParameters, requestConfig);
}

/**
 * Deletes a user from the project.
 */
function deleteProjectUserRaw<T>(requestParameters: DeleteProjectUserRequest, requestConfig: runtime.TypedQueryConfig<T, ProjectUserDeleteResponse> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling deleteProjectUser.');
    }

    if (requestParameters.userId === null || requestParameters.userId === undefined) {
        throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deleteProjectUser.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}/users/{user_id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectUserDeleteResponseFromJSON(body), text);
    }

    return config;
}

/**
* Deletes a user from the project.
*/
export function deleteProjectUser<T>(requestParameters: DeleteProjectUserRequest, requestConfig?: runtime.TypedQueryConfig<T, ProjectUserDeleteResponse>): QueryConfig<T> {
    return deleteProjectUserRaw(requestParameters, requestConfig);
}

/**
 * Returns a list of API keys in the project.
 */
function listProjectApiKeysRaw<T>(requestParameters: ListProjectApiKeysRequest, requestConfig: runtime.TypedQueryConfig<T, ProjectApiKeyListResponse> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling listProjectApiKeys.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.after !== undefined) {
        queryParameters['after'] = requestParameters.after;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}/api_keys`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectApiKeyListResponseFromJSON(body), text);
    }

    return config;
}

/**
* Returns a list of API keys in the project.
*/
export function listProjectApiKeys<T>(requestParameters: ListProjectApiKeysRequest, requestConfig?: runtime.TypedQueryConfig<T, ProjectApiKeyListResponse>): QueryConfig<T> {
    return listProjectApiKeysRaw(requestParameters, requestConfig);
}

/**
 * Returns the rate limits per model for a project.
 */
function listProjectRateLimitsRaw<T>(requestParameters: ListProjectRateLimitsRequest, requestConfig: runtime.TypedQueryConfig<T, ProjectRateLimitListResponse> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling listProjectRateLimits.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.after !== undefined) {
        queryParameters['after'] = requestParameters.after;
    }


    if (requestParameters.before !== undefined) {
        queryParameters['before'] = requestParameters.before;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}/rate_limits`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectRateLimitListResponseFromJSON(body), text);
    }

    return config;
}

/**
* Returns the rate limits per model for a project.
*/
export function listProjectRateLimits<T>(requestParameters: ListProjectRateLimitsRequest, requestConfig?: runtime.TypedQueryConfig<T, ProjectRateLimitListResponse>): QueryConfig<T> {
    return listProjectRateLimitsRaw(requestParameters, requestConfig);
}

/**
 * Returns a list of service accounts in the project.
 */
function listProjectServiceAccountsRaw<T>(requestParameters: ListProjectServiceAccountsRequest, requestConfig: runtime.TypedQueryConfig<T, ProjectServiceAccountListResponse> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling listProjectServiceAccounts.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.after !== undefined) {
        queryParameters['after'] = requestParameters.after;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}/service_accounts`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectServiceAccountListResponseFromJSON(body), text);
    }

    return config;
}

/**
* Returns a list of service accounts in the project.
*/
export function listProjectServiceAccounts<T>(requestParameters: ListProjectServiceAccountsRequest, requestConfig?: runtime.TypedQueryConfig<T, ProjectServiceAccountListResponse>): QueryConfig<T> {
    return listProjectServiceAccountsRaw(requestParameters, requestConfig);
}

/**
 * Returns a list of users in the project.
 */
function listProjectUsersRaw<T>(requestParameters: ListProjectUsersRequest, requestConfig: runtime.TypedQueryConfig<T, ProjectUserListResponse> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling listProjectUsers.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.after !== undefined) {
        queryParameters['after'] = requestParameters.after;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}/users`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectUserListResponseFromJSON(body), text);
    }

    return config;
}

/**
* Returns a list of users in the project.
*/
export function listProjectUsers<T>(requestParameters: ListProjectUsersRequest, requestConfig?: runtime.TypedQueryConfig<T, ProjectUserListResponse>): QueryConfig<T> {
    return listProjectUsersRaw(requestParameters, requestConfig);
}

/**
 * Returns a list of projects.
 */
function listProjectsRaw<T>(requestParameters: ListProjectsRequest, requestConfig: runtime.TypedQueryConfig<T, ProjectListResponse> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.after !== undefined) {
        queryParameters['after'] = requestParameters.after;
    }


    if (requestParameters.includeArchived !== undefined) {
        queryParameters['include_archived'] = requestParameters.includeArchived;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectListResponseFromJSON(body), text);
    }

    return config;
}

/**
* Returns a list of projects.
*/
export function listProjects<T>(requestParameters: ListProjectsRequest, requestConfig?: runtime.TypedQueryConfig<T, ProjectListResponse>): QueryConfig<T> {
    return listProjectsRaw(requestParameters, requestConfig);
}

/**
 * Modifies a project in the organization.
 */
function modifyProjectRaw<T>(requestParameters: ModifyProjectRequest, requestConfig: runtime.TypedQueryConfig<T, Project> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling modifyProject.');
    }

    if (requestParameters.projectUpdateRequest === null || requestParameters.projectUpdateRequest === undefined) {
        throw new runtime.RequiredError('projectUpdateRequest','Required parameter requestParameters.projectUpdateRequest was null or undefined when calling modifyProject.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || ProjectUpdateRequestToJSON(requestParameters.projectUpdateRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectFromJSON(body), text);
    }

    return config;
}

/**
* Modifies a project in the organization.
*/
export function modifyProject<T>(requestParameters: ModifyProjectRequest, requestConfig?: runtime.TypedQueryConfig<T, Project>): QueryConfig<T> {
    return modifyProjectRaw(requestParameters, requestConfig);
}

/**
 * Modifies a user\'s role in the project.
 */
function modifyProjectUserRaw<T>(requestParameters: ModifyProjectUserRequest, requestConfig: runtime.TypedQueryConfig<T, ProjectUser> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling modifyProjectUser.');
    }

    if (requestParameters.userId === null || requestParameters.userId === undefined) {
        throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling modifyProjectUser.');
    }

    if (requestParameters.projectUserUpdateRequest === null || requestParameters.projectUserUpdateRequest === undefined) {
        throw new runtime.RequiredError('projectUserUpdateRequest','Required parameter requestParameters.projectUserUpdateRequest was null or undefined when calling modifyProjectUser.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}/users/{user_id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || ProjectUserUpdateRequestToJSON(requestParameters.projectUserUpdateRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectUserFromJSON(body), text);
    }

    return config;
}

/**
* Modifies a user\'s role in the project.
*/
export function modifyProjectUser<T>(requestParameters: ModifyProjectUserRequest, requestConfig?: runtime.TypedQueryConfig<T, ProjectUser>): QueryConfig<T> {
    return modifyProjectUserRaw(requestParameters, requestConfig);
}

/**
 * Retrieves a project.
 */
function retrieveProjectRaw<T>(requestParameters: RetrieveProjectRequest, requestConfig: runtime.TypedQueryConfig<T, Project> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling retrieveProject.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectFromJSON(body), text);
    }

    return config;
}

/**
* Retrieves a project.
*/
export function retrieveProject<T>(requestParameters: RetrieveProjectRequest, requestConfig?: runtime.TypedQueryConfig<T, Project>): QueryConfig<T> {
    return retrieveProjectRaw(requestParameters, requestConfig);
}

/**
 * Retrieves an API key in the project.
 */
function retrieveProjectApiKeyRaw<T>(requestParameters: RetrieveProjectApiKeyRequest, requestConfig: runtime.TypedQueryConfig<T, ProjectApiKey> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling retrieveProjectApiKey.');
    }

    if (requestParameters.keyId === null || requestParameters.keyId === undefined) {
        throw new runtime.RequiredError('keyId','Required parameter requestParameters.keyId was null or undefined when calling retrieveProjectApiKey.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}/api_keys/{key_id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"key_id"}}`, encodeURIComponent(String(requestParameters.keyId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectApiKeyFromJSON(body), text);
    }

    return config;
}

/**
* Retrieves an API key in the project.
*/
export function retrieveProjectApiKey<T>(requestParameters: RetrieveProjectApiKeyRequest, requestConfig?: runtime.TypedQueryConfig<T, ProjectApiKey>): QueryConfig<T> {
    return retrieveProjectApiKeyRaw(requestParameters, requestConfig);
}

/**
 * Retrieves a service account in the project.
 */
function retrieveProjectServiceAccountRaw<T>(requestParameters: RetrieveProjectServiceAccountRequest, requestConfig: runtime.TypedQueryConfig<T, ProjectServiceAccount> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling retrieveProjectServiceAccount.');
    }

    if (requestParameters.serviceAccountId === null || requestParameters.serviceAccountId === undefined) {
        throw new runtime.RequiredError('serviceAccountId','Required parameter requestParameters.serviceAccountId was null or undefined when calling retrieveProjectServiceAccount.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}/service_accounts/{service_account_id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"service_account_id"}}`, encodeURIComponent(String(requestParameters.serviceAccountId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectServiceAccountFromJSON(body), text);
    }

    return config;
}

/**
* Retrieves a service account in the project.
*/
export function retrieveProjectServiceAccount<T>(requestParameters: RetrieveProjectServiceAccountRequest, requestConfig?: runtime.TypedQueryConfig<T, ProjectServiceAccount>): QueryConfig<T> {
    return retrieveProjectServiceAccountRaw(requestParameters, requestConfig);
}

/**
 * Retrieves a user in the project.
 */
function retrieveProjectUserRaw<T>(requestParameters: RetrieveProjectUserRequest, requestConfig: runtime.TypedQueryConfig<T, ProjectUser> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling retrieveProjectUser.');
    }

    if (requestParameters.userId === null || requestParameters.userId === undefined) {
        throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling retrieveProjectUser.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}/users/{user_id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectUserFromJSON(body), text);
    }

    return config;
}

/**
* Retrieves a user in the project.
*/
export function retrieveProjectUser<T>(requestParameters: RetrieveProjectUserRequest, requestConfig?: runtime.TypedQueryConfig<T, ProjectUser>): QueryConfig<T> {
    return retrieveProjectUserRaw(requestParameters, requestConfig);
}

/**
 * Updates a project rate limit.
 */
function updateProjectRateLimitsRaw<T>(requestParameters: UpdateProjectRateLimitsRequest, requestConfig: runtime.TypedQueryConfig<T, ProjectRateLimit> = {}): QueryConfig<T> {
    if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
        throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling updateProjectRateLimits.');
    }

    if (requestParameters.rateLimitId === null || requestParameters.rateLimitId === undefined) {
        throw new runtime.RequiredError('rateLimitId','Required parameter requestParameters.rateLimitId was null or undefined when calling updateProjectRateLimits.');
    }

    if (requestParameters.projectRateLimitUpdateRequest === null || requestParameters.projectRateLimitUpdateRequest === undefined) {
        throw new runtime.RequiredError('projectRateLimitUpdateRequest','Required parameter requestParameters.projectRateLimitUpdateRequest was null or undefined when calling updateProjectRateLimits.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/projects/{project_id}/rate_limits/{rate_limit_id}`.replace(`{${"project_id"}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${"rate_limit_id"}}`, encodeURIComponent(String(requestParameters.rateLimitId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || ProjectRateLimitUpdateRequestToJSON(requestParameters.projectRateLimitUpdateRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ProjectRateLimitFromJSON(body), text);
    }

    return config;
}

/**
* Updates a project rate limit.
*/
export function updateProjectRateLimits<T>(requestParameters: UpdateProjectRateLimitsRequest, requestConfig?: runtime.TypedQueryConfig<T, ProjectRateLimit>): QueryConfig<T> {
    return updateProjectRateLimitsRaw(requestParameters, requestConfig);
}

