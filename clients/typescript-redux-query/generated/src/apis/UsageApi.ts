// tslint:disable
/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    UsageResponse,
    UsageResponseFromJSON,
    UsageResponseToJSON,
} from '../models';

export interface UsageAudioSpeechesRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageAudioSpeechesBucketWidthEnum;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    groupBy?: Array<UsageAudioSpeechesGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageAudioTranscriptionsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageAudioTranscriptionsBucketWidthEnum;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    groupBy?: Array<UsageAudioTranscriptionsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageCodeInterpreterSessionsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageCodeInterpreterSessionsBucketWidthEnum;
    projectIds?: Array<string>;
    groupBy?: Array<UsageCodeInterpreterSessionsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageCompletionsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageCompletionsBucketWidthEnum;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    batch?: boolean;
    groupBy?: Array<UsageCompletionsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageCostsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageCostsBucketWidthEnum;
    projectIds?: Array<string>;
    groupBy?: Array<UsageCostsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageEmbeddingsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageEmbeddingsBucketWidthEnum;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    groupBy?: Array<UsageEmbeddingsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageImagesRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageImagesBucketWidthEnum;
    sources?: Array<UsageImagesSourcesEnum>;
    sizes?: Array<UsageImagesSizesEnum>;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    groupBy?: Array<UsageImagesGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageModerationsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageModerationsBucketWidthEnum;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    groupBy?: Array<UsageModerationsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageVectorStoresRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageVectorStoresBucketWidthEnum;
    projectIds?: Array<string>;
    groupBy?: Array<UsageVectorStoresGroupByEnum>;
    limit?: number;
    page?: string;
}


/**
 * Get audio speeches usage details for the organization.
 */
function usageAudioSpeechesRaw<T>(requestParameters: UsageAudioSpeechesRequest, requestConfig: runtime.TypedQueryConfig<T, UsageResponse> = {}): QueryConfig<T> {
    if (requestParameters.startTime === null || requestParameters.startTime === undefined) {
        throw new runtime.RequiredError('startTime','Required parameter requestParameters.startTime was null or undefined when calling usageAudioSpeeches.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startTime !== undefined) {
        queryParameters['start_time'] = requestParameters.startTime;
    }


    if (requestParameters.endTime !== undefined) {
        queryParameters['end_time'] = requestParameters.endTime;
    }


    if (requestParameters.bucketWidth !== undefined) {
        queryParameters['bucket_width'] = requestParameters.bucketWidth;
    }


    if (requestParameters.projectIds) {
        queryParameters['project_ids'] = requestParameters.projectIds;
    }


    if (requestParameters.userIds) {
        queryParameters['user_ids'] = requestParameters.userIds;
    }


    if (requestParameters.apiKeyIds) {
        queryParameters['api_key_ids'] = requestParameters.apiKeyIds;
    }


    if (requestParameters.models) {
        queryParameters['models'] = requestParameters.models;
    }


    if (requestParameters.groupBy) {
        queryParameters['group_by'] = requestParameters.groupBy;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.page !== undefined) {
        queryParameters['page'] = requestParameters.page;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/usage/audio_speeches`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UsageResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get audio speeches usage details for the organization.
*/
export function usageAudioSpeeches<T>(requestParameters: UsageAudioSpeechesRequest, requestConfig?: runtime.TypedQueryConfig<T, UsageResponse>): QueryConfig<T> {
    return usageAudioSpeechesRaw(requestParameters, requestConfig);
}

/**
 * Get audio transcriptions usage details for the organization.
 */
function usageAudioTranscriptionsRaw<T>(requestParameters: UsageAudioTranscriptionsRequest, requestConfig: runtime.TypedQueryConfig<T, UsageResponse> = {}): QueryConfig<T> {
    if (requestParameters.startTime === null || requestParameters.startTime === undefined) {
        throw new runtime.RequiredError('startTime','Required parameter requestParameters.startTime was null or undefined when calling usageAudioTranscriptions.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startTime !== undefined) {
        queryParameters['start_time'] = requestParameters.startTime;
    }


    if (requestParameters.endTime !== undefined) {
        queryParameters['end_time'] = requestParameters.endTime;
    }


    if (requestParameters.bucketWidth !== undefined) {
        queryParameters['bucket_width'] = requestParameters.bucketWidth;
    }


    if (requestParameters.projectIds) {
        queryParameters['project_ids'] = requestParameters.projectIds;
    }


    if (requestParameters.userIds) {
        queryParameters['user_ids'] = requestParameters.userIds;
    }


    if (requestParameters.apiKeyIds) {
        queryParameters['api_key_ids'] = requestParameters.apiKeyIds;
    }


    if (requestParameters.models) {
        queryParameters['models'] = requestParameters.models;
    }


    if (requestParameters.groupBy) {
        queryParameters['group_by'] = requestParameters.groupBy;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.page !== undefined) {
        queryParameters['page'] = requestParameters.page;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/usage/audio_transcriptions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UsageResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get audio transcriptions usage details for the organization.
*/
export function usageAudioTranscriptions<T>(requestParameters: UsageAudioTranscriptionsRequest, requestConfig?: runtime.TypedQueryConfig<T, UsageResponse>): QueryConfig<T> {
    return usageAudioTranscriptionsRaw(requestParameters, requestConfig);
}

/**
 * Get code interpreter sessions usage details for the organization.
 */
function usageCodeInterpreterSessionsRaw<T>(requestParameters: UsageCodeInterpreterSessionsRequest, requestConfig: runtime.TypedQueryConfig<T, UsageResponse> = {}): QueryConfig<T> {
    if (requestParameters.startTime === null || requestParameters.startTime === undefined) {
        throw new runtime.RequiredError('startTime','Required parameter requestParameters.startTime was null or undefined when calling usageCodeInterpreterSessions.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startTime !== undefined) {
        queryParameters['start_time'] = requestParameters.startTime;
    }


    if (requestParameters.endTime !== undefined) {
        queryParameters['end_time'] = requestParameters.endTime;
    }


    if (requestParameters.bucketWidth !== undefined) {
        queryParameters['bucket_width'] = requestParameters.bucketWidth;
    }


    if (requestParameters.projectIds) {
        queryParameters['project_ids'] = requestParameters.projectIds;
    }


    if (requestParameters.groupBy) {
        queryParameters['group_by'] = requestParameters.groupBy;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.page !== undefined) {
        queryParameters['page'] = requestParameters.page;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/usage/code_interpreter_sessions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UsageResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get code interpreter sessions usage details for the organization.
*/
export function usageCodeInterpreterSessions<T>(requestParameters: UsageCodeInterpreterSessionsRequest, requestConfig?: runtime.TypedQueryConfig<T, UsageResponse>): QueryConfig<T> {
    return usageCodeInterpreterSessionsRaw(requestParameters, requestConfig);
}

/**
 * Get completions usage details for the organization.
 */
function usageCompletionsRaw<T>(requestParameters: UsageCompletionsRequest, requestConfig: runtime.TypedQueryConfig<T, UsageResponse> = {}): QueryConfig<T> {
    if (requestParameters.startTime === null || requestParameters.startTime === undefined) {
        throw new runtime.RequiredError('startTime','Required parameter requestParameters.startTime was null or undefined when calling usageCompletions.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startTime !== undefined) {
        queryParameters['start_time'] = requestParameters.startTime;
    }


    if (requestParameters.endTime !== undefined) {
        queryParameters['end_time'] = requestParameters.endTime;
    }


    if (requestParameters.bucketWidth !== undefined) {
        queryParameters['bucket_width'] = requestParameters.bucketWidth;
    }


    if (requestParameters.projectIds) {
        queryParameters['project_ids'] = requestParameters.projectIds;
    }


    if (requestParameters.userIds) {
        queryParameters['user_ids'] = requestParameters.userIds;
    }


    if (requestParameters.apiKeyIds) {
        queryParameters['api_key_ids'] = requestParameters.apiKeyIds;
    }


    if (requestParameters.models) {
        queryParameters['models'] = requestParameters.models;
    }


    if (requestParameters.batch !== undefined) {
        queryParameters['batch'] = requestParameters.batch;
    }


    if (requestParameters.groupBy) {
        queryParameters['group_by'] = requestParameters.groupBy;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.page !== undefined) {
        queryParameters['page'] = requestParameters.page;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/usage/completions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UsageResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get completions usage details for the organization.
*/
export function usageCompletions<T>(requestParameters: UsageCompletionsRequest, requestConfig?: runtime.TypedQueryConfig<T, UsageResponse>): QueryConfig<T> {
    return usageCompletionsRaw(requestParameters, requestConfig);
}

/**
 * Get costs details for the organization.
 */
function usageCostsRaw<T>(requestParameters: UsageCostsRequest, requestConfig: runtime.TypedQueryConfig<T, UsageResponse> = {}): QueryConfig<T> {
    if (requestParameters.startTime === null || requestParameters.startTime === undefined) {
        throw new runtime.RequiredError('startTime','Required parameter requestParameters.startTime was null or undefined when calling usageCosts.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startTime !== undefined) {
        queryParameters['start_time'] = requestParameters.startTime;
    }


    if (requestParameters.endTime !== undefined) {
        queryParameters['end_time'] = requestParameters.endTime;
    }


    if (requestParameters.bucketWidth !== undefined) {
        queryParameters['bucket_width'] = requestParameters.bucketWidth;
    }


    if (requestParameters.projectIds) {
        queryParameters['project_ids'] = requestParameters.projectIds;
    }


    if (requestParameters.groupBy) {
        queryParameters['group_by'] = requestParameters.groupBy;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.page !== undefined) {
        queryParameters['page'] = requestParameters.page;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/costs`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UsageResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get costs details for the organization.
*/
export function usageCosts<T>(requestParameters: UsageCostsRequest, requestConfig?: runtime.TypedQueryConfig<T, UsageResponse>): QueryConfig<T> {
    return usageCostsRaw(requestParameters, requestConfig);
}

/**
 * Get embeddings usage details for the organization.
 */
function usageEmbeddingsRaw<T>(requestParameters: UsageEmbeddingsRequest, requestConfig: runtime.TypedQueryConfig<T, UsageResponse> = {}): QueryConfig<T> {
    if (requestParameters.startTime === null || requestParameters.startTime === undefined) {
        throw new runtime.RequiredError('startTime','Required parameter requestParameters.startTime was null or undefined when calling usageEmbeddings.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startTime !== undefined) {
        queryParameters['start_time'] = requestParameters.startTime;
    }


    if (requestParameters.endTime !== undefined) {
        queryParameters['end_time'] = requestParameters.endTime;
    }


    if (requestParameters.bucketWidth !== undefined) {
        queryParameters['bucket_width'] = requestParameters.bucketWidth;
    }


    if (requestParameters.projectIds) {
        queryParameters['project_ids'] = requestParameters.projectIds;
    }


    if (requestParameters.userIds) {
        queryParameters['user_ids'] = requestParameters.userIds;
    }


    if (requestParameters.apiKeyIds) {
        queryParameters['api_key_ids'] = requestParameters.apiKeyIds;
    }


    if (requestParameters.models) {
        queryParameters['models'] = requestParameters.models;
    }


    if (requestParameters.groupBy) {
        queryParameters['group_by'] = requestParameters.groupBy;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.page !== undefined) {
        queryParameters['page'] = requestParameters.page;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/usage/embeddings`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UsageResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get embeddings usage details for the organization.
*/
export function usageEmbeddings<T>(requestParameters: UsageEmbeddingsRequest, requestConfig?: runtime.TypedQueryConfig<T, UsageResponse>): QueryConfig<T> {
    return usageEmbeddingsRaw(requestParameters, requestConfig);
}

/**
 * Get images usage details for the organization.
 */
function usageImagesRaw<T>(requestParameters: UsageImagesRequest, requestConfig: runtime.TypedQueryConfig<T, UsageResponse> = {}): QueryConfig<T> {
    if (requestParameters.startTime === null || requestParameters.startTime === undefined) {
        throw new runtime.RequiredError('startTime','Required parameter requestParameters.startTime was null or undefined when calling usageImages.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startTime !== undefined) {
        queryParameters['start_time'] = requestParameters.startTime;
    }


    if (requestParameters.endTime !== undefined) {
        queryParameters['end_time'] = requestParameters.endTime;
    }


    if (requestParameters.bucketWidth !== undefined) {
        queryParameters['bucket_width'] = requestParameters.bucketWidth;
    }


    if (requestParameters.sources) {
        queryParameters['sources'] = requestParameters.sources;
    }


    if (requestParameters.sizes) {
        queryParameters['sizes'] = requestParameters.sizes;
    }


    if (requestParameters.projectIds) {
        queryParameters['project_ids'] = requestParameters.projectIds;
    }


    if (requestParameters.userIds) {
        queryParameters['user_ids'] = requestParameters.userIds;
    }


    if (requestParameters.apiKeyIds) {
        queryParameters['api_key_ids'] = requestParameters.apiKeyIds;
    }


    if (requestParameters.models) {
        queryParameters['models'] = requestParameters.models;
    }


    if (requestParameters.groupBy) {
        queryParameters['group_by'] = requestParameters.groupBy;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.page !== undefined) {
        queryParameters['page'] = requestParameters.page;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/usage/images`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UsageResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get images usage details for the organization.
*/
export function usageImages<T>(requestParameters: UsageImagesRequest, requestConfig?: runtime.TypedQueryConfig<T, UsageResponse>): QueryConfig<T> {
    return usageImagesRaw(requestParameters, requestConfig);
}

/**
 * Get moderations usage details for the organization.
 */
function usageModerationsRaw<T>(requestParameters: UsageModerationsRequest, requestConfig: runtime.TypedQueryConfig<T, UsageResponse> = {}): QueryConfig<T> {
    if (requestParameters.startTime === null || requestParameters.startTime === undefined) {
        throw new runtime.RequiredError('startTime','Required parameter requestParameters.startTime was null or undefined when calling usageModerations.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startTime !== undefined) {
        queryParameters['start_time'] = requestParameters.startTime;
    }


    if (requestParameters.endTime !== undefined) {
        queryParameters['end_time'] = requestParameters.endTime;
    }


    if (requestParameters.bucketWidth !== undefined) {
        queryParameters['bucket_width'] = requestParameters.bucketWidth;
    }


    if (requestParameters.projectIds) {
        queryParameters['project_ids'] = requestParameters.projectIds;
    }


    if (requestParameters.userIds) {
        queryParameters['user_ids'] = requestParameters.userIds;
    }


    if (requestParameters.apiKeyIds) {
        queryParameters['api_key_ids'] = requestParameters.apiKeyIds;
    }


    if (requestParameters.models) {
        queryParameters['models'] = requestParameters.models;
    }


    if (requestParameters.groupBy) {
        queryParameters['group_by'] = requestParameters.groupBy;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.page !== undefined) {
        queryParameters['page'] = requestParameters.page;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/usage/moderations`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UsageResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get moderations usage details for the organization.
*/
export function usageModerations<T>(requestParameters: UsageModerationsRequest, requestConfig?: runtime.TypedQueryConfig<T, UsageResponse>): QueryConfig<T> {
    return usageModerationsRaw(requestParameters, requestConfig);
}

/**
 * Get vector stores usage details for the organization.
 */
function usageVectorStoresRaw<T>(requestParameters: UsageVectorStoresRequest, requestConfig: runtime.TypedQueryConfig<T, UsageResponse> = {}): QueryConfig<T> {
    if (requestParameters.startTime === null || requestParameters.startTime === undefined) {
        throw new runtime.RequiredError('startTime','Required parameter requestParameters.startTime was null or undefined when calling usageVectorStores.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startTime !== undefined) {
        queryParameters['start_time'] = requestParameters.startTime;
    }


    if (requestParameters.endTime !== undefined) {
        queryParameters['end_time'] = requestParameters.endTime;
    }


    if (requestParameters.bucketWidth !== undefined) {
        queryParameters['bucket_width'] = requestParameters.bucketWidth;
    }


    if (requestParameters.projectIds) {
        queryParameters['project_ids'] = requestParameters.projectIds;
    }


    if (requestParameters.groupBy) {
        queryParameters['group_by'] = requestParameters.groupBy;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.page !== undefined) {
        queryParameters['page'] = requestParameters.page;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/organization/usage/vector_stores`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UsageResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get vector stores usage details for the organization.
*/
export function usageVectorStores<T>(requestParameters: UsageVectorStoresRequest, requestConfig?: runtime.TypedQueryConfig<T, UsageResponse>): QueryConfig<T> {
    return usageVectorStoresRaw(requestParameters, requestConfig);
}


/**
    * @export
    * @enum {string}
    */
export enum UsageAudioSpeechesBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageAudioSpeechesGroupByEnum {
    ProjectId = 'project_id',
    UserId = 'user_id',
    ApiKeyId = 'api_key_id',
    Model = 'model'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageAudioTranscriptionsBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageAudioTranscriptionsGroupByEnum {
    ProjectId = 'project_id',
    UserId = 'user_id',
    ApiKeyId = 'api_key_id',
    Model = 'model'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageCodeInterpreterSessionsBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageCodeInterpreterSessionsGroupByEnum {
    ProjectId = 'project_id'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageCompletionsBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageCompletionsGroupByEnum {
    ProjectId = 'project_id',
    UserId = 'user_id',
    ApiKeyId = 'api_key_id',
    Model = 'model',
    Batch = 'batch'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageCostsBucketWidthEnum {
    _1d = '1d'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageCostsGroupByEnum {
    ProjectId = 'project_id',
    LineItem = 'line_item'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageEmbeddingsBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageEmbeddingsGroupByEnum {
    ProjectId = 'project_id',
    UserId = 'user_id',
    ApiKeyId = 'api_key_id',
    Model = 'model'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageImagesBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageImagesSourcesEnum {
    ImageGeneration = 'image.generation',
    ImageEdit = 'image.edit',
    ImageVariation = 'image.variation'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageImagesSizesEnum {
    _256x256 = '256x256',
    _512x512 = '512x512',
    _1024x1024 = '1024x1024',
    _1792x1792 = '1792x1792',
    _1024x1792 = '1024x1792'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageImagesGroupByEnum {
    ProjectId = 'project_id',
    UserId = 'user_id',
    ApiKeyId = 'api_key_id',
    Model = 'model',
    Size = 'size',
    Source = 'source'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageModerationsBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageModerationsGroupByEnum {
    ProjectId = 'project_id',
    UserId = 'user_id',
    ApiKeyId = 'api_key_id',
    Model = 'model'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageVectorStoresBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
    * @export
    * @enum {string}
    */
export enum UsageVectorStoresGroupByEnum {
    ProjectId = 'project_id'
}
