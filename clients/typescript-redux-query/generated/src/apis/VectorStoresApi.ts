// tslint:disable
/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    CreateVectorStoreFileBatchRequest,
    CreateVectorStoreFileBatchRequestFromJSON,
    CreateVectorStoreFileBatchRequestToJSON,
    CreateVectorStoreFileRequest,
    CreateVectorStoreFileRequestFromJSON,
    CreateVectorStoreFileRequestToJSON,
    CreateVectorStoreRequest,
    CreateVectorStoreRequestFromJSON,
    CreateVectorStoreRequestToJSON,
    DeleteVectorStoreFileResponse,
    DeleteVectorStoreFileResponseFromJSON,
    DeleteVectorStoreFileResponseToJSON,
    DeleteVectorStoreResponse,
    DeleteVectorStoreResponseFromJSON,
    DeleteVectorStoreResponseToJSON,
    ListVectorStoreFilesResponse,
    ListVectorStoreFilesResponseFromJSON,
    ListVectorStoreFilesResponseToJSON,
    ListVectorStoresResponse,
    ListVectorStoresResponseFromJSON,
    ListVectorStoresResponseToJSON,
    UpdateVectorStoreRequest,
    UpdateVectorStoreRequestFromJSON,
    UpdateVectorStoreRequestToJSON,
    VectorStoreFileBatchObject,
    VectorStoreFileBatchObjectFromJSON,
    VectorStoreFileBatchObjectToJSON,
    VectorStoreFileObject,
    VectorStoreFileObjectFromJSON,
    VectorStoreFileObjectToJSON,
    VectorStoreObject,
    VectorStoreObjectFromJSON,
    VectorStoreObjectToJSON,
} from '../models';

export interface CancelVectorStoreFileBatchRequest {
    vectorStoreId: string;
    batchId: string;
}

export interface CreateVectorStoreRequest {
    createVectorStoreRequest: CreateVectorStoreRequest;
}

export interface CreateVectorStoreFileRequest {
    vectorStoreId: string;
    createVectorStoreFileRequest: CreateVectorStoreFileRequest;
}

export interface CreateVectorStoreFileBatchRequest {
    vectorStoreId: string;
    createVectorStoreFileBatchRequest: CreateVectorStoreFileBatchRequest;
}

export interface DeleteVectorStoreRequest {
    vectorStoreId: string;
}

export interface DeleteVectorStoreFileRequest {
    vectorStoreId: string;
    fileId: string;
}

export interface GetVectorStoreRequest {
    vectorStoreId: string;
}

export interface GetVectorStoreFileRequest {
    vectorStoreId: string;
    fileId: string;
}

export interface GetVectorStoreFileBatchRequest {
    vectorStoreId: string;
    batchId: string;
}

export interface ListFilesInVectorStoreBatchRequest {
    vectorStoreId: string;
    batchId: string;
    limit?: number;
    order?: ListFilesInVectorStoreBatchOrderEnum;
    after?: string;
    before?: string;
    filter?: ListFilesInVectorStoreBatchFilterEnum;
}

export interface ListVectorStoreFilesRequest {
    vectorStoreId: string;
    limit?: number;
    order?: ListVectorStoreFilesOrderEnum;
    after?: string;
    before?: string;
    filter?: ListVectorStoreFilesFilterEnum;
}

export interface ListVectorStoresRequest {
    limit?: number;
    order?: ListVectorStoresOrderEnum;
    after?: string;
    before?: string;
}

export interface ModifyVectorStoreRequest {
    vectorStoreId: string;
    updateVectorStoreRequest: UpdateVectorStoreRequest;
}


/**
 * Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
 */
function cancelVectorStoreFileBatchRaw<T>(requestParameters: CancelVectorStoreFileBatchRequest, requestConfig: runtime.TypedQueryConfig<T, VectorStoreFileBatchObject> = {}): QueryConfig<T> {
    if (requestParameters.vectorStoreId === null || requestParameters.vectorStoreId === undefined) {
        throw new runtime.RequiredError('vectorStoreId','Required parameter requestParameters.vectorStoreId was null or undefined when calling cancelVectorStoreFileBatch.');
    }

    if (requestParameters.batchId === null || requestParameters.batchId === undefined) {
        throw new runtime.RequiredError('batchId','Required parameter requestParameters.batchId was null or undefined when calling cancelVectorStoreFileBatch.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vector_stores/{vector_store_id}/file_batches/{batch_id}/cancel`.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters.vectorStoreId))).replace(`{${"batch_id"}}`, encodeURIComponent(String(requestParameters.batchId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(VectorStoreFileBatchObjectFromJSON(body), text);
    }

    return config;
}

/**
* Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
*/
export function cancelVectorStoreFileBatch<T>(requestParameters: CancelVectorStoreFileBatchRequest, requestConfig?: runtime.TypedQueryConfig<T, VectorStoreFileBatchObject>): QueryConfig<T> {
    return cancelVectorStoreFileBatchRaw(requestParameters, requestConfig);
}

/**
 * Create a vector store.
 */
function createVectorStoreRaw<T>(requestParameters: CreateVectorStoreRequest, requestConfig: runtime.TypedQueryConfig<T, VectorStoreObject> = {}): QueryConfig<T> {
    if (requestParameters.createVectorStoreRequest === null || requestParameters.createVectorStoreRequest === undefined) {
        throw new runtime.RequiredError('createVectorStoreRequest','Required parameter requestParameters.createVectorStoreRequest was null or undefined when calling createVectorStore.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vector_stores`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateVectorStoreRequestToJSON(requestParameters.createVectorStoreRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(VectorStoreObjectFromJSON(body), text);
    }

    return config;
}

/**
* Create a vector store.
*/
export function createVectorStore<T>(requestParameters: CreateVectorStoreRequest, requestConfig?: runtime.TypedQueryConfig<T, VectorStoreObject>): QueryConfig<T> {
    return createVectorStoreRaw(requestParameters, requestConfig);
}

/**
 * Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
 */
function createVectorStoreFileRaw<T>(requestParameters: CreateVectorStoreFileRequest, requestConfig: runtime.TypedQueryConfig<T, VectorStoreFileObject> = {}): QueryConfig<T> {
    if (requestParameters.vectorStoreId === null || requestParameters.vectorStoreId === undefined) {
        throw new runtime.RequiredError('vectorStoreId','Required parameter requestParameters.vectorStoreId was null or undefined when calling createVectorStoreFile.');
    }

    if (requestParameters.createVectorStoreFileRequest === null || requestParameters.createVectorStoreFileRequest === undefined) {
        throw new runtime.RequiredError('createVectorStoreFileRequest','Required parameter requestParameters.createVectorStoreFileRequest was null or undefined when calling createVectorStoreFile.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vector_stores/{vector_store_id}/files`.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters.vectorStoreId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateVectorStoreFileRequestToJSON(requestParameters.createVectorStoreFileRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(VectorStoreFileObjectFromJSON(body), text);
    }

    return config;
}

/**
* Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
*/
export function createVectorStoreFile<T>(requestParameters: CreateVectorStoreFileRequest, requestConfig?: runtime.TypedQueryConfig<T, VectorStoreFileObject>): QueryConfig<T> {
    return createVectorStoreFileRaw(requestParameters, requestConfig);
}

/**
 * Create a vector store file batch.
 */
function createVectorStoreFileBatchRaw<T>(requestParameters: CreateVectorStoreFileBatchRequest, requestConfig: runtime.TypedQueryConfig<T, VectorStoreFileBatchObject> = {}): QueryConfig<T> {
    if (requestParameters.vectorStoreId === null || requestParameters.vectorStoreId === undefined) {
        throw new runtime.RequiredError('vectorStoreId','Required parameter requestParameters.vectorStoreId was null or undefined when calling createVectorStoreFileBatch.');
    }

    if (requestParameters.createVectorStoreFileBatchRequest === null || requestParameters.createVectorStoreFileBatchRequest === undefined) {
        throw new runtime.RequiredError('createVectorStoreFileBatchRequest','Required parameter requestParameters.createVectorStoreFileBatchRequest was null or undefined when calling createVectorStoreFileBatch.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vector_stores/{vector_store_id}/file_batches`.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters.vectorStoreId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || CreateVectorStoreFileBatchRequestToJSON(requestParameters.createVectorStoreFileBatchRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(VectorStoreFileBatchObjectFromJSON(body), text);
    }

    return config;
}

/**
* Create a vector store file batch.
*/
export function createVectorStoreFileBatch<T>(requestParameters: CreateVectorStoreFileBatchRequest, requestConfig?: runtime.TypedQueryConfig<T, VectorStoreFileBatchObject>): QueryConfig<T> {
    return createVectorStoreFileBatchRaw(requestParameters, requestConfig);
}

/**
 * Delete a vector store.
 */
function deleteVectorStoreRaw<T>(requestParameters: DeleteVectorStoreRequest, requestConfig: runtime.TypedQueryConfig<T, DeleteVectorStoreResponse> = {}): QueryConfig<T> {
    if (requestParameters.vectorStoreId === null || requestParameters.vectorStoreId === undefined) {
        throw new runtime.RequiredError('vectorStoreId','Required parameter requestParameters.vectorStoreId was null or undefined when calling deleteVectorStore.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vector_stores/{vector_store_id}`.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters.vectorStoreId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DeleteVectorStoreResponseFromJSON(body), text);
    }

    return config;
}

/**
* Delete a vector store.
*/
export function deleteVectorStore<T>(requestParameters: DeleteVectorStoreRequest, requestConfig?: runtime.TypedQueryConfig<T, DeleteVectorStoreResponse>): QueryConfig<T> {
    return deleteVectorStoreRaw(requestParameters, requestConfig);
}

/**
 * Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
 */
function deleteVectorStoreFileRaw<T>(requestParameters: DeleteVectorStoreFileRequest, requestConfig: runtime.TypedQueryConfig<T, DeleteVectorStoreFileResponse> = {}): QueryConfig<T> {
    if (requestParameters.vectorStoreId === null || requestParameters.vectorStoreId === undefined) {
        throw new runtime.RequiredError('vectorStoreId','Required parameter requestParameters.vectorStoreId was null or undefined when calling deleteVectorStoreFile.');
    }

    if (requestParameters.fileId === null || requestParameters.fileId === undefined) {
        throw new runtime.RequiredError('fileId','Required parameter requestParameters.fileId was null or undefined when calling deleteVectorStoreFile.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vector_stores/{vector_store_id}/files/{file_id}`.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters.vectorStoreId))).replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters.fileId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(DeleteVectorStoreFileResponseFromJSON(body), text);
    }

    return config;
}

/**
* Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
*/
export function deleteVectorStoreFile<T>(requestParameters: DeleteVectorStoreFileRequest, requestConfig?: runtime.TypedQueryConfig<T, DeleteVectorStoreFileResponse>): QueryConfig<T> {
    return deleteVectorStoreFileRaw(requestParameters, requestConfig);
}

/**
 * Retrieves a vector store.
 */
function getVectorStoreRaw<T>(requestParameters: GetVectorStoreRequest, requestConfig: runtime.TypedQueryConfig<T, VectorStoreObject> = {}): QueryConfig<T> {
    if (requestParameters.vectorStoreId === null || requestParameters.vectorStoreId === undefined) {
        throw new runtime.RequiredError('vectorStoreId','Required parameter requestParameters.vectorStoreId was null or undefined when calling getVectorStore.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vector_stores/{vector_store_id}`.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters.vectorStoreId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(VectorStoreObjectFromJSON(body), text);
    }

    return config;
}

/**
* Retrieves a vector store.
*/
export function getVectorStore<T>(requestParameters: GetVectorStoreRequest, requestConfig?: runtime.TypedQueryConfig<T, VectorStoreObject>): QueryConfig<T> {
    return getVectorStoreRaw(requestParameters, requestConfig);
}

/**
 * Retrieves a vector store file.
 */
function getVectorStoreFileRaw<T>(requestParameters: GetVectorStoreFileRequest, requestConfig: runtime.TypedQueryConfig<T, VectorStoreFileObject> = {}): QueryConfig<T> {
    if (requestParameters.vectorStoreId === null || requestParameters.vectorStoreId === undefined) {
        throw new runtime.RequiredError('vectorStoreId','Required parameter requestParameters.vectorStoreId was null or undefined when calling getVectorStoreFile.');
    }

    if (requestParameters.fileId === null || requestParameters.fileId === undefined) {
        throw new runtime.RequiredError('fileId','Required parameter requestParameters.fileId was null or undefined when calling getVectorStoreFile.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vector_stores/{vector_store_id}/files/{file_id}`.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters.vectorStoreId))).replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters.fileId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(VectorStoreFileObjectFromJSON(body), text);
    }

    return config;
}

/**
* Retrieves a vector store file.
*/
export function getVectorStoreFile<T>(requestParameters: GetVectorStoreFileRequest, requestConfig?: runtime.TypedQueryConfig<T, VectorStoreFileObject>): QueryConfig<T> {
    return getVectorStoreFileRaw(requestParameters, requestConfig);
}

/**
 * Retrieves a vector store file batch.
 */
function getVectorStoreFileBatchRaw<T>(requestParameters: GetVectorStoreFileBatchRequest, requestConfig: runtime.TypedQueryConfig<T, VectorStoreFileBatchObject> = {}): QueryConfig<T> {
    if (requestParameters.vectorStoreId === null || requestParameters.vectorStoreId === undefined) {
        throw new runtime.RequiredError('vectorStoreId','Required parameter requestParameters.vectorStoreId was null or undefined when calling getVectorStoreFileBatch.');
    }

    if (requestParameters.batchId === null || requestParameters.batchId === undefined) {
        throw new runtime.RequiredError('batchId','Required parameter requestParameters.batchId was null or undefined when calling getVectorStoreFileBatch.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vector_stores/{vector_store_id}/file_batches/{batch_id}`.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters.vectorStoreId))).replace(`{${"batch_id"}}`, encodeURIComponent(String(requestParameters.batchId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(VectorStoreFileBatchObjectFromJSON(body), text);
    }

    return config;
}

/**
* Retrieves a vector store file batch.
*/
export function getVectorStoreFileBatch<T>(requestParameters: GetVectorStoreFileBatchRequest, requestConfig?: runtime.TypedQueryConfig<T, VectorStoreFileBatchObject>): QueryConfig<T> {
    return getVectorStoreFileBatchRaw(requestParameters, requestConfig);
}

/**
 * Returns a list of vector store files in a batch.
 */
function listFilesInVectorStoreBatchRaw<T>(requestParameters: ListFilesInVectorStoreBatchRequest, requestConfig: runtime.TypedQueryConfig<T, ListVectorStoreFilesResponse> = {}): QueryConfig<T> {
    if (requestParameters.vectorStoreId === null || requestParameters.vectorStoreId === undefined) {
        throw new runtime.RequiredError('vectorStoreId','Required parameter requestParameters.vectorStoreId was null or undefined when calling listFilesInVectorStoreBatch.');
    }

    if (requestParameters.batchId === null || requestParameters.batchId === undefined) {
        throw new runtime.RequiredError('batchId','Required parameter requestParameters.batchId was null or undefined when calling listFilesInVectorStoreBatch.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.order !== undefined) {
        queryParameters['order'] = requestParameters.order;
    }


    if (requestParameters.after !== undefined) {
        queryParameters['after'] = requestParameters.after;
    }


    if (requestParameters.before !== undefined) {
        queryParameters['before'] = requestParameters.before;
    }


    if (requestParameters.filter !== undefined) {
        queryParameters['filter'] = requestParameters.filter;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vector_stores/{vector_store_id}/file_batches/{batch_id}/files`.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters.vectorStoreId))).replace(`{${"batch_id"}}`, encodeURIComponent(String(requestParameters.batchId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ListVectorStoreFilesResponseFromJSON(body), text);
    }

    return config;
}

/**
* Returns a list of vector store files in a batch.
*/
export function listFilesInVectorStoreBatch<T>(requestParameters: ListFilesInVectorStoreBatchRequest, requestConfig?: runtime.TypedQueryConfig<T, ListVectorStoreFilesResponse>): QueryConfig<T> {
    return listFilesInVectorStoreBatchRaw(requestParameters, requestConfig);
}

/**
 * Returns a list of vector store files.
 */
function listVectorStoreFilesRaw<T>(requestParameters: ListVectorStoreFilesRequest, requestConfig: runtime.TypedQueryConfig<T, ListVectorStoreFilesResponse> = {}): QueryConfig<T> {
    if (requestParameters.vectorStoreId === null || requestParameters.vectorStoreId === undefined) {
        throw new runtime.RequiredError('vectorStoreId','Required parameter requestParameters.vectorStoreId was null or undefined when calling listVectorStoreFiles.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.order !== undefined) {
        queryParameters['order'] = requestParameters.order;
    }


    if (requestParameters.after !== undefined) {
        queryParameters['after'] = requestParameters.after;
    }


    if (requestParameters.before !== undefined) {
        queryParameters['before'] = requestParameters.before;
    }


    if (requestParameters.filter !== undefined) {
        queryParameters['filter'] = requestParameters.filter;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vector_stores/{vector_store_id}/files`.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters.vectorStoreId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ListVectorStoreFilesResponseFromJSON(body), text);
    }

    return config;
}

/**
* Returns a list of vector store files.
*/
export function listVectorStoreFiles<T>(requestParameters: ListVectorStoreFilesRequest, requestConfig?: runtime.TypedQueryConfig<T, ListVectorStoreFilesResponse>): QueryConfig<T> {
    return listVectorStoreFilesRaw(requestParameters, requestConfig);
}

/**
 * Returns a list of vector stores.
 */
function listVectorStoresRaw<T>(requestParameters: ListVectorStoresRequest, requestConfig: runtime.TypedQueryConfig<T, ListVectorStoresResponse> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.order !== undefined) {
        queryParameters['order'] = requestParameters.order;
    }


    if (requestParameters.after !== undefined) {
        queryParameters['after'] = requestParameters.after;
    }


    if (requestParameters.before !== undefined) {
        queryParameters['before'] = requestParameters.before;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vector_stores`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ListVectorStoresResponseFromJSON(body), text);
    }

    return config;
}

/**
* Returns a list of vector stores.
*/
export function listVectorStores<T>(requestParameters: ListVectorStoresRequest, requestConfig?: runtime.TypedQueryConfig<T, ListVectorStoresResponse>): QueryConfig<T> {
    return listVectorStoresRaw(requestParameters, requestConfig);
}

/**
 * Modifies a vector store.
 */
function modifyVectorStoreRaw<T>(requestParameters: ModifyVectorStoreRequest, requestConfig: runtime.TypedQueryConfig<T, VectorStoreObject> = {}): QueryConfig<T> {
    if (requestParameters.vectorStoreId === null || requestParameters.vectorStoreId === undefined) {
        throw new runtime.RequiredError('vectorStoreId','Required parameter requestParameters.vectorStoreId was null or undefined when calling modifyVectorStore.');
    }

    if (requestParameters.updateVectorStoreRequest === null || requestParameters.updateVectorStoreRequest === undefined) {
        throw new runtime.RequiredError('updateVectorStoreRequest','Required parameter requestParameters.updateVectorStoreRequest was null or undefined when calling modifyVectorStore.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['bearer'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vector_stores/{vector_store_id}`.replace(`{${"vector_store_id"}}`, encodeURIComponent(String(requestParameters.vectorStoreId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || UpdateVectorStoreRequestToJSON(requestParameters.updateVectorStoreRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(VectorStoreObjectFromJSON(body), text);
    }

    return config;
}

/**
* Modifies a vector store.
*/
export function modifyVectorStore<T>(requestParameters: ModifyVectorStoreRequest, requestConfig?: runtime.TypedQueryConfig<T, VectorStoreObject>): QueryConfig<T> {
    return modifyVectorStoreRaw(requestParameters, requestConfig);
}


/**
    * @export
    * @enum {string}
    */
export enum ListFilesInVectorStoreBatchOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
    * @export
    * @enum {string}
    */
export enum ListFilesInVectorStoreBatchFilterEnum {
    InProgress = 'in_progress',
    Completed = 'completed',
    Failed = 'failed',
    Cancelled = 'cancelled'
}
/**
    * @export
    * @enum {string}
    */
export enum ListVectorStoreFilesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
    * @export
    * @enum {string}
    */
export enum ListVectorStoreFilesFilterEnum {
    InProgress = 'in_progress',
    Completed = 'completed',
    Failed = 'failed',
    Cancelled = 'cancelled'
}
/**
    * @export
    * @enum {string}
    */
export enum ListVectorStoresOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
