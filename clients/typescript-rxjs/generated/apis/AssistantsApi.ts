// tslint:disable
/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Observable } from 'rxjs';
import type { AjaxResponse } from 'rxjs/ajax';
import { BaseAPI, throwIfNullOrUndefined, encodeURI } from '../runtime';
import type { OperationOpts, HttpHeaders, HttpQuery } from '../runtime';
import type {
    AssistantFileObject,
    AssistantObject,
    CreateAssistantFileRequest,
    CreateAssistantRequest,
    CreateMessageRequest,
    CreateRunRequest,
    CreateThreadAndRunRequest,
    CreateThreadRequest,
    DeleteAssistantFileResponse,
    DeleteAssistantResponse,
    DeleteThreadResponse,
    ListAssistantFilesResponse,
    ListAssistantsResponse,
    ListMessageFilesResponse,
    ListMessagesResponse,
    ListRunStepsResponse,
    ListRunsResponse,
    MessageFileObject,
    MessageObject,
    ModifyAssistantRequest,
    ModifyMessageRequest,
    ModifyRunRequest,
    ModifyThreadRequest,
    RunObject,
    RunStepObject,
    SubmitToolOutputsRunRequest,
    ThreadObject,
} from '../models';

export interface CancelRunRequest {
    threadId: string;
    runId: string;
}

export interface CreateAssistantRequest {
    createAssistantRequest: CreateAssistantRequest;
}

export interface CreateAssistantFileRequest {
    assistantId: string;
    createAssistantFileRequest: CreateAssistantFileRequest;
}

export interface CreateMessageRequest {
    threadId: string;
    createMessageRequest: CreateMessageRequest;
}

export interface CreateRunRequest {
    threadId: string;
    createRunRequest: CreateRunRequest;
}

export interface CreateThreadRequest {
    createThreadRequest?: CreateThreadRequest;
}

export interface CreateThreadAndRunRequest {
    createThreadAndRunRequest: CreateThreadAndRunRequest;
}

export interface DeleteAssistantRequest {
    assistantId: string;
}

export interface DeleteAssistantFileRequest {
    assistantId: string;
    fileId: string;
}

export interface DeleteThreadRequest {
    threadId: string;
}

export interface GetAssistantRequest {
    assistantId: string;
}

export interface GetAssistantFileRequest {
    assistantId: string;
    fileId: string;
}

export interface GetMessageRequest {
    threadId: string;
    messageId: string;
}

export interface GetMessageFileRequest {
    threadId: string;
    messageId: string;
    fileId: string;
}

export interface GetRunRequest {
    threadId: string;
    runId: string;
}

export interface GetRunStepRequest {
    threadId: string;
    runId: string;
    stepId: string;
}

export interface GetThreadRequest {
    threadId: string;
}

export interface ListAssistantFilesRequest {
    assistantId: string;
    limit?: number;
    order?: ListAssistantFilesOrderEnum;
    after?: string;
    before?: string;
}

export interface ListAssistantsRequest {
    limit?: number;
    order?: ListAssistantsOrderEnum;
    after?: string;
    before?: string;
}

export interface ListMessageFilesRequest {
    threadId: string;
    messageId: string;
    limit?: number;
    order?: ListMessageFilesOrderEnum;
    after?: string;
    before?: string;
}

export interface ListMessagesRequest {
    threadId: string;
    limit?: number;
    order?: ListMessagesOrderEnum;
    after?: string;
    before?: string;
    runId?: string;
}

export interface ListRunStepsRequest {
    threadId: string;
    runId: string;
    limit?: number;
    order?: ListRunStepsOrderEnum;
    after?: string;
    before?: string;
}

export interface ListRunsRequest {
    threadId: string;
    limit?: number;
    order?: ListRunsOrderEnum;
    after?: string;
    before?: string;
}

export interface ModifyAssistantRequest {
    assistantId: string;
    modifyAssistantRequest: ModifyAssistantRequest;
}

export interface ModifyMessageRequest {
    threadId: string;
    messageId: string;
    modifyMessageRequest: ModifyMessageRequest;
}

export interface ModifyRunRequest {
    threadId: string;
    runId: string;
    modifyRunRequest: ModifyRunRequest;
}

export interface ModifyThreadRequest {
    threadId: string;
    modifyThreadRequest: ModifyThreadRequest;
}

export interface SubmitToolOuputsToRunRequest {
    threadId: string;
    runId: string;
    submitToolOutputsRunRequest: SubmitToolOutputsRunRequest;
}

/**
 * no description
 */
export class AssistantsApi extends BaseAPI {

    /**
     * Cancels a run that is `in_progress`.
     */
    cancelRun({ threadId, runId }: CancelRunRequest): Observable<RunObject>
    cancelRun({ threadId, runId }: CancelRunRequest, opts?: OperationOpts): Observable<AjaxResponse<RunObject>>
    cancelRun({ threadId, runId }: CancelRunRequest, opts?: OperationOpts): Observable<RunObject | AjaxResponse<RunObject>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'cancelRun');
        throwIfNullOrUndefined(runId, 'runId', 'cancelRun');

        const headers: HttpHeaders = {
        };

        return this.request<RunObject>({
            url: '/threads/{thread_id}/runs/{run_id}/cancel'.replace('{thread_id}', encodeURI(threadId)).replace('{run_id}', encodeURI(runId)),
            method: 'POST',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Create an assistant with a model and instructions.
     */
    createAssistant({ createAssistantRequest }: CreateAssistantRequest): Observable<AssistantObject>
    createAssistant({ createAssistantRequest }: CreateAssistantRequest, opts?: OperationOpts): Observable<AjaxResponse<AssistantObject>>
    createAssistant({ createAssistantRequest }: CreateAssistantRequest, opts?: OperationOpts): Observable<AssistantObject | AjaxResponse<AssistantObject>> {
        throwIfNullOrUndefined(createAssistantRequest, 'createAssistantRequest', 'createAssistant');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
        };

        return this.request<AssistantObject>({
            url: '/assistants',
            method: 'POST',
            headers,
            body: createAssistantRequest,
        }, opts?.responseOpts);
    };

    /**
     * Create an assistant file by attaching a [File](/docs/api-reference/files) to an [assistant](/docs/api-reference/assistants).
     */
    createAssistantFile({ assistantId, createAssistantFileRequest }: CreateAssistantFileRequest): Observable<AssistantFileObject>
    createAssistantFile({ assistantId, createAssistantFileRequest }: CreateAssistantFileRequest, opts?: OperationOpts): Observable<AjaxResponse<AssistantFileObject>>
    createAssistantFile({ assistantId, createAssistantFileRequest }: CreateAssistantFileRequest, opts?: OperationOpts): Observable<AssistantFileObject | AjaxResponse<AssistantFileObject>> {
        throwIfNullOrUndefined(assistantId, 'assistantId', 'createAssistantFile');
        throwIfNullOrUndefined(createAssistantFileRequest, 'createAssistantFileRequest', 'createAssistantFile');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
        };

        return this.request<AssistantFileObject>({
            url: '/assistants/{assistant_id}/files'.replace('{assistant_id}', encodeURI(assistantId)),
            method: 'POST',
            headers,
            body: createAssistantFileRequest,
        }, opts?.responseOpts);
    };

    /**
     * Create a message.
     */
    createMessage({ threadId, createMessageRequest }: CreateMessageRequest): Observable<MessageObject>
    createMessage({ threadId, createMessageRequest }: CreateMessageRequest, opts?: OperationOpts): Observable<AjaxResponse<MessageObject>>
    createMessage({ threadId, createMessageRequest }: CreateMessageRequest, opts?: OperationOpts): Observable<MessageObject | AjaxResponse<MessageObject>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'createMessage');
        throwIfNullOrUndefined(createMessageRequest, 'createMessageRequest', 'createMessage');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
        };

        return this.request<MessageObject>({
            url: '/threads/{thread_id}/messages'.replace('{thread_id}', encodeURI(threadId)),
            method: 'POST',
            headers,
            body: createMessageRequest,
        }, opts?.responseOpts);
    };

    /**
     * Create a run.
     */
    createRun({ threadId, createRunRequest }: CreateRunRequest): Observable<RunObject>
    createRun({ threadId, createRunRequest }: CreateRunRequest, opts?: OperationOpts): Observable<AjaxResponse<RunObject>>
    createRun({ threadId, createRunRequest }: CreateRunRequest, opts?: OperationOpts): Observable<RunObject | AjaxResponse<RunObject>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'createRun');
        throwIfNullOrUndefined(createRunRequest, 'createRunRequest', 'createRun');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
        };

        return this.request<RunObject>({
            url: '/threads/{thread_id}/runs'.replace('{thread_id}', encodeURI(threadId)),
            method: 'POST',
            headers,
            body: createRunRequest,
        }, opts?.responseOpts);
    };

    /**
     * Create a thread.
     */
    createThread({ createThreadRequest }: CreateThreadRequest): Observable<ThreadObject>
    createThread({ createThreadRequest }: CreateThreadRequest, opts?: OperationOpts): Observable<AjaxResponse<ThreadObject>>
    createThread({ createThreadRequest }: CreateThreadRequest, opts?: OperationOpts): Observable<ThreadObject | AjaxResponse<ThreadObject>> {

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
        };

        return this.request<ThreadObject>({
            url: '/threads',
            method: 'POST',
            headers,
            body: createThreadRequest,
        }, opts?.responseOpts);
    };

    /**
     * Create a thread and run it in one request.
     */
    createThreadAndRun({ createThreadAndRunRequest }: CreateThreadAndRunRequest): Observable<RunObject>
    createThreadAndRun({ createThreadAndRunRequest }: CreateThreadAndRunRequest, opts?: OperationOpts): Observable<AjaxResponse<RunObject>>
    createThreadAndRun({ createThreadAndRunRequest }: CreateThreadAndRunRequest, opts?: OperationOpts): Observable<RunObject | AjaxResponse<RunObject>> {
        throwIfNullOrUndefined(createThreadAndRunRequest, 'createThreadAndRunRequest', 'createThreadAndRun');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
        };

        return this.request<RunObject>({
            url: '/threads/runs',
            method: 'POST',
            headers,
            body: createThreadAndRunRequest,
        }, opts?.responseOpts);
    };

    /**
     * Delete an assistant.
     */
    deleteAssistant({ assistantId }: DeleteAssistantRequest): Observable<DeleteAssistantResponse>
    deleteAssistant({ assistantId }: DeleteAssistantRequest, opts?: OperationOpts): Observable<AjaxResponse<DeleteAssistantResponse>>
    deleteAssistant({ assistantId }: DeleteAssistantRequest, opts?: OperationOpts): Observable<DeleteAssistantResponse | AjaxResponse<DeleteAssistantResponse>> {
        throwIfNullOrUndefined(assistantId, 'assistantId', 'deleteAssistant');

        const headers: HttpHeaders = {
        };

        return this.request<DeleteAssistantResponse>({
            url: '/assistants/{assistant_id}'.replace('{assistant_id}', encodeURI(assistantId)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Delete an assistant file.
     */
    deleteAssistantFile({ assistantId, fileId }: DeleteAssistantFileRequest): Observable<DeleteAssistantFileResponse>
    deleteAssistantFile({ assistantId, fileId }: DeleteAssistantFileRequest, opts?: OperationOpts): Observable<AjaxResponse<DeleteAssistantFileResponse>>
    deleteAssistantFile({ assistantId, fileId }: DeleteAssistantFileRequest, opts?: OperationOpts): Observable<DeleteAssistantFileResponse | AjaxResponse<DeleteAssistantFileResponse>> {
        throwIfNullOrUndefined(assistantId, 'assistantId', 'deleteAssistantFile');
        throwIfNullOrUndefined(fileId, 'fileId', 'deleteAssistantFile');

        const headers: HttpHeaders = {
        };

        return this.request<DeleteAssistantFileResponse>({
            url: '/assistants/{assistant_id}/files/{file_id}'.replace('{assistant_id}', encodeURI(assistantId)).replace('{file_id}', encodeURI(fileId)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Delete a thread.
     */
    deleteThread({ threadId }: DeleteThreadRequest): Observable<DeleteThreadResponse>
    deleteThread({ threadId }: DeleteThreadRequest, opts?: OperationOpts): Observable<AjaxResponse<DeleteThreadResponse>>
    deleteThread({ threadId }: DeleteThreadRequest, opts?: OperationOpts): Observable<DeleteThreadResponse | AjaxResponse<DeleteThreadResponse>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'deleteThread');

        const headers: HttpHeaders = {
        };

        return this.request<DeleteThreadResponse>({
            url: '/threads/{thread_id}'.replace('{thread_id}', encodeURI(threadId)),
            method: 'DELETE',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Retrieves an assistant.
     */
    getAssistant({ assistantId }: GetAssistantRequest): Observable<AssistantObject>
    getAssistant({ assistantId }: GetAssistantRequest, opts?: OperationOpts): Observable<AjaxResponse<AssistantObject>>
    getAssistant({ assistantId }: GetAssistantRequest, opts?: OperationOpts): Observable<AssistantObject | AjaxResponse<AssistantObject>> {
        throwIfNullOrUndefined(assistantId, 'assistantId', 'getAssistant');

        const headers: HttpHeaders = {
        };

        return this.request<AssistantObject>({
            url: '/assistants/{assistant_id}'.replace('{assistant_id}', encodeURI(assistantId)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Retrieves an AssistantFile.
     */
    getAssistantFile({ assistantId, fileId }: GetAssistantFileRequest): Observable<AssistantFileObject>
    getAssistantFile({ assistantId, fileId }: GetAssistantFileRequest, opts?: OperationOpts): Observable<AjaxResponse<AssistantFileObject>>
    getAssistantFile({ assistantId, fileId }: GetAssistantFileRequest, opts?: OperationOpts): Observable<AssistantFileObject | AjaxResponse<AssistantFileObject>> {
        throwIfNullOrUndefined(assistantId, 'assistantId', 'getAssistantFile');
        throwIfNullOrUndefined(fileId, 'fileId', 'getAssistantFile');

        const headers: HttpHeaders = {
        };

        return this.request<AssistantFileObject>({
            url: '/assistants/{assistant_id}/files/{file_id}'.replace('{assistant_id}', encodeURI(assistantId)).replace('{file_id}', encodeURI(fileId)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Retrieve a message.
     */
    getMessage({ threadId, messageId }: GetMessageRequest): Observable<MessageObject>
    getMessage({ threadId, messageId }: GetMessageRequest, opts?: OperationOpts): Observable<AjaxResponse<MessageObject>>
    getMessage({ threadId, messageId }: GetMessageRequest, opts?: OperationOpts): Observable<MessageObject | AjaxResponse<MessageObject>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'getMessage');
        throwIfNullOrUndefined(messageId, 'messageId', 'getMessage');

        const headers: HttpHeaders = {
        };

        return this.request<MessageObject>({
            url: '/threads/{thread_id}/messages/{message_id}'.replace('{thread_id}', encodeURI(threadId)).replace('{message_id}', encodeURI(messageId)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Retrieves a message file.
     */
    getMessageFile({ threadId, messageId, fileId }: GetMessageFileRequest): Observable<MessageFileObject>
    getMessageFile({ threadId, messageId, fileId }: GetMessageFileRequest, opts?: OperationOpts): Observable<AjaxResponse<MessageFileObject>>
    getMessageFile({ threadId, messageId, fileId }: GetMessageFileRequest, opts?: OperationOpts): Observable<MessageFileObject | AjaxResponse<MessageFileObject>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'getMessageFile');
        throwIfNullOrUndefined(messageId, 'messageId', 'getMessageFile');
        throwIfNullOrUndefined(fileId, 'fileId', 'getMessageFile');

        const headers: HttpHeaders = {
        };

        return this.request<MessageFileObject>({
            url: '/threads/{thread_id}/messages/{message_id}/files/{file_id}'.replace('{thread_id}', encodeURI(threadId)).replace('{message_id}', encodeURI(messageId)).replace('{file_id}', encodeURI(fileId)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Retrieves a run.
     */
    getRun({ threadId, runId }: GetRunRequest): Observable<RunObject>
    getRun({ threadId, runId }: GetRunRequest, opts?: OperationOpts): Observable<AjaxResponse<RunObject>>
    getRun({ threadId, runId }: GetRunRequest, opts?: OperationOpts): Observable<RunObject | AjaxResponse<RunObject>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'getRun');
        throwIfNullOrUndefined(runId, 'runId', 'getRun');

        const headers: HttpHeaders = {
        };

        return this.request<RunObject>({
            url: '/threads/{thread_id}/runs/{run_id}'.replace('{thread_id}', encodeURI(threadId)).replace('{run_id}', encodeURI(runId)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Retrieves a run step.
     */
    getRunStep({ threadId, runId, stepId }: GetRunStepRequest): Observable<RunStepObject>
    getRunStep({ threadId, runId, stepId }: GetRunStepRequest, opts?: OperationOpts): Observable<AjaxResponse<RunStepObject>>
    getRunStep({ threadId, runId, stepId }: GetRunStepRequest, opts?: OperationOpts): Observable<RunStepObject | AjaxResponse<RunStepObject>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'getRunStep');
        throwIfNullOrUndefined(runId, 'runId', 'getRunStep');
        throwIfNullOrUndefined(stepId, 'stepId', 'getRunStep');

        const headers: HttpHeaders = {
        };

        return this.request<RunStepObject>({
            url: '/threads/{thread_id}/runs/{run_id}/steps/{step_id}'.replace('{thread_id}', encodeURI(threadId)).replace('{run_id}', encodeURI(runId)).replace('{step_id}', encodeURI(stepId)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Retrieves a thread.
     */
    getThread({ threadId }: GetThreadRequest): Observable<ThreadObject>
    getThread({ threadId }: GetThreadRequest, opts?: OperationOpts): Observable<AjaxResponse<ThreadObject>>
    getThread({ threadId }: GetThreadRequest, opts?: OperationOpts): Observable<ThreadObject | AjaxResponse<ThreadObject>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'getThread');

        const headers: HttpHeaders = {
        };

        return this.request<ThreadObject>({
            url: '/threads/{thread_id}'.replace('{thread_id}', encodeURI(threadId)),
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Returns a list of assistant files.
     */
    listAssistantFiles({ assistantId, limit, order, after, before }: ListAssistantFilesRequest): Observable<ListAssistantFilesResponse>
    listAssistantFiles({ assistantId, limit, order, after, before }: ListAssistantFilesRequest, opts?: OperationOpts): Observable<AjaxResponse<ListAssistantFilesResponse>>
    listAssistantFiles({ assistantId, limit, order, after, before }: ListAssistantFilesRequest, opts?: OperationOpts): Observable<ListAssistantFilesResponse | AjaxResponse<ListAssistantFilesResponse>> {
        throwIfNullOrUndefined(assistantId, 'assistantId', 'listAssistantFiles');

        const headers: HttpHeaders = {
        };

        const query: HttpQuery = {};

        if (limit != null) { query['limit'] = limit; }
        if (order != null) { query['order'] = order; }
        if (after != null) { query['after'] = after; }
        if (before != null) { query['before'] = before; }

        return this.request<ListAssistantFilesResponse>({
            url: '/assistants/{assistant_id}/files'.replace('{assistant_id}', encodeURI(assistantId)),
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Returns a list of assistants.
     */
    listAssistants({ limit, order, after, before }: ListAssistantsRequest): Observable<ListAssistantsResponse>
    listAssistants({ limit, order, after, before }: ListAssistantsRequest, opts?: OperationOpts): Observable<AjaxResponse<ListAssistantsResponse>>
    listAssistants({ limit, order, after, before }: ListAssistantsRequest, opts?: OperationOpts): Observable<ListAssistantsResponse | AjaxResponse<ListAssistantsResponse>> {

        const headers: HttpHeaders = {
        };

        const query: HttpQuery = {};

        if (limit != null) { query['limit'] = limit; }
        if (order != null) { query['order'] = order; }
        if (after != null) { query['after'] = after; }
        if (before != null) { query['before'] = before; }

        return this.request<ListAssistantsResponse>({
            url: '/assistants',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Returns a list of message files.
     */
    listMessageFiles({ threadId, messageId, limit, order, after, before }: ListMessageFilesRequest): Observable<ListMessageFilesResponse>
    listMessageFiles({ threadId, messageId, limit, order, after, before }: ListMessageFilesRequest, opts?: OperationOpts): Observable<AjaxResponse<ListMessageFilesResponse>>
    listMessageFiles({ threadId, messageId, limit, order, after, before }: ListMessageFilesRequest, opts?: OperationOpts): Observable<ListMessageFilesResponse | AjaxResponse<ListMessageFilesResponse>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'listMessageFiles');
        throwIfNullOrUndefined(messageId, 'messageId', 'listMessageFiles');

        const headers: HttpHeaders = {
        };

        const query: HttpQuery = {};

        if (limit != null) { query['limit'] = limit; }
        if (order != null) { query['order'] = order; }
        if (after != null) { query['after'] = after; }
        if (before != null) { query['before'] = before; }

        return this.request<ListMessageFilesResponse>({
            url: '/threads/{thread_id}/messages/{message_id}/files'.replace('{thread_id}', encodeURI(threadId)).replace('{message_id}', encodeURI(messageId)),
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Returns a list of messages for a given thread.
     */
    listMessages({ threadId, limit, order, after, before, runId }: ListMessagesRequest): Observable<ListMessagesResponse>
    listMessages({ threadId, limit, order, after, before, runId }: ListMessagesRequest, opts?: OperationOpts): Observable<AjaxResponse<ListMessagesResponse>>
    listMessages({ threadId, limit, order, after, before, runId }: ListMessagesRequest, opts?: OperationOpts): Observable<ListMessagesResponse | AjaxResponse<ListMessagesResponse>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'listMessages');

        const headers: HttpHeaders = {
        };

        const query: HttpQuery = {};

        if (limit != null) { query['limit'] = limit; }
        if (order != null) { query['order'] = order; }
        if (after != null) { query['after'] = after; }
        if (before != null) { query['before'] = before; }
        if (runId != null) { query['run_id'] = runId; }

        return this.request<ListMessagesResponse>({
            url: '/threads/{thread_id}/messages'.replace('{thread_id}', encodeURI(threadId)),
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Returns a list of run steps belonging to a run.
     */
    listRunSteps({ threadId, runId, limit, order, after, before }: ListRunStepsRequest): Observable<ListRunStepsResponse>
    listRunSteps({ threadId, runId, limit, order, after, before }: ListRunStepsRequest, opts?: OperationOpts): Observable<AjaxResponse<ListRunStepsResponse>>
    listRunSteps({ threadId, runId, limit, order, after, before }: ListRunStepsRequest, opts?: OperationOpts): Observable<ListRunStepsResponse | AjaxResponse<ListRunStepsResponse>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'listRunSteps');
        throwIfNullOrUndefined(runId, 'runId', 'listRunSteps');

        const headers: HttpHeaders = {
        };

        const query: HttpQuery = {};

        if (limit != null) { query['limit'] = limit; }
        if (order != null) { query['order'] = order; }
        if (after != null) { query['after'] = after; }
        if (before != null) { query['before'] = before; }

        return this.request<ListRunStepsResponse>({
            url: '/threads/{thread_id}/runs/{run_id}/steps'.replace('{thread_id}', encodeURI(threadId)).replace('{run_id}', encodeURI(runId)),
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Returns a list of runs belonging to a thread.
     */
    listRuns({ threadId, limit, order, after, before }: ListRunsRequest): Observable<ListRunsResponse>
    listRuns({ threadId, limit, order, after, before }: ListRunsRequest, opts?: OperationOpts): Observable<AjaxResponse<ListRunsResponse>>
    listRuns({ threadId, limit, order, after, before }: ListRunsRequest, opts?: OperationOpts): Observable<ListRunsResponse | AjaxResponse<ListRunsResponse>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'listRuns');

        const headers: HttpHeaders = {
        };

        const query: HttpQuery = {};

        if (limit != null) { query['limit'] = limit; }
        if (order != null) { query['order'] = order; }
        if (after != null) { query['after'] = after; }
        if (before != null) { query['before'] = before; }

        return this.request<ListRunsResponse>({
            url: '/threads/{thread_id}/runs'.replace('{thread_id}', encodeURI(threadId)),
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Modifies an assistant.
     */
    modifyAssistant({ assistantId, modifyAssistantRequest }: ModifyAssistantRequest): Observable<AssistantObject>
    modifyAssistant({ assistantId, modifyAssistantRequest }: ModifyAssistantRequest, opts?: OperationOpts): Observable<AjaxResponse<AssistantObject>>
    modifyAssistant({ assistantId, modifyAssistantRequest }: ModifyAssistantRequest, opts?: OperationOpts): Observable<AssistantObject | AjaxResponse<AssistantObject>> {
        throwIfNullOrUndefined(assistantId, 'assistantId', 'modifyAssistant');
        throwIfNullOrUndefined(modifyAssistantRequest, 'modifyAssistantRequest', 'modifyAssistant');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
        };

        return this.request<AssistantObject>({
            url: '/assistants/{assistant_id}'.replace('{assistant_id}', encodeURI(assistantId)),
            method: 'POST',
            headers,
            body: modifyAssistantRequest,
        }, opts?.responseOpts);
    };

    /**
     * Modifies a message.
     */
    modifyMessage({ threadId, messageId, modifyMessageRequest }: ModifyMessageRequest): Observable<MessageObject>
    modifyMessage({ threadId, messageId, modifyMessageRequest }: ModifyMessageRequest, opts?: OperationOpts): Observable<AjaxResponse<MessageObject>>
    modifyMessage({ threadId, messageId, modifyMessageRequest }: ModifyMessageRequest, opts?: OperationOpts): Observable<MessageObject | AjaxResponse<MessageObject>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'modifyMessage');
        throwIfNullOrUndefined(messageId, 'messageId', 'modifyMessage');
        throwIfNullOrUndefined(modifyMessageRequest, 'modifyMessageRequest', 'modifyMessage');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
        };

        return this.request<MessageObject>({
            url: '/threads/{thread_id}/messages/{message_id}'.replace('{thread_id}', encodeURI(threadId)).replace('{message_id}', encodeURI(messageId)),
            method: 'POST',
            headers,
            body: modifyMessageRequest,
        }, opts?.responseOpts);
    };

    /**
     * Modifies a run.
     */
    modifyRun({ threadId, runId, modifyRunRequest }: ModifyRunRequest): Observable<RunObject>
    modifyRun({ threadId, runId, modifyRunRequest }: ModifyRunRequest, opts?: OperationOpts): Observable<AjaxResponse<RunObject>>
    modifyRun({ threadId, runId, modifyRunRequest }: ModifyRunRequest, opts?: OperationOpts): Observable<RunObject | AjaxResponse<RunObject>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'modifyRun');
        throwIfNullOrUndefined(runId, 'runId', 'modifyRun');
        throwIfNullOrUndefined(modifyRunRequest, 'modifyRunRequest', 'modifyRun');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
        };

        return this.request<RunObject>({
            url: '/threads/{thread_id}/runs/{run_id}'.replace('{thread_id}', encodeURI(threadId)).replace('{run_id}', encodeURI(runId)),
            method: 'POST',
            headers,
            body: modifyRunRequest,
        }, opts?.responseOpts);
    };

    /**
     * Modifies a thread.
     */
    modifyThread({ threadId, modifyThreadRequest }: ModifyThreadRequest): Observable<ThreadObject>
    modifyThread({ threadId, modifyThreadRequest }: ModifyThreadRequest, opts?: OperationOpts): Observable<AjaxResponse<ThreadObject>>
    modifyThread({ threadId, modifyThreadRequest }: ModifyThreadRequest, opts?: OperationOpts): Observable<ThreadObject | AjaxResponse<ThreadObject>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'modifyThread');
        throwIfNullOrUndefined(modifyThreadRequest, 'modifyThreadRequest', 'modifyThread');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
        };

        return this.request<ThreadObject>({
            url: '/threads/{thread_id}'.replace('{thread_id}', encodeURI(threadId)),
            method: 'POST',
            headers,
            body: modifyThreadRequest,
        }, opts?.responseOpts);
    };

    /**
     * When a run has the `status: \"requires_action\"` and `required_action.type` is `submit_tool_outputs`, this endpoint can be used to submit the outputs from the tool calls once they\'re all completed. All outputs must be submitted in a single request. 
     */
    submitToolOuputsToRun({ threadId, runId, submitToolOutputsRunRequest }: SubmitToolOuputsToRunRequest): Observable<RunObject>
    submitToolOuputsToRun({ threadId, runId, submitToolOutputsRunRequest }: SubmitToolOuputsToRunRequest, opts?: OperationOpts): Observable<AjaxResponse<RunObject>>
    submitToolOuputsToRun({ threadId, runId, submitToolOutputsRunRequest }: SubmitToolOuputsToRunRequest, opts?: OperationOpts): Observable<RunObject | AjaxResponse<RunObject>> {
        throwIfNullOrUndefined(threadId, 'threadId', 'submitToolOuputsToRun');
        throwIfNullOrUndefined(runId, 'runId', 'submitToolOuputsToRun');
        throwIfNullOrUndefined(submitToolOutputsRunRequest, 'submitToolOutputsRunRequest', 'submitToolOuputsToRun');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
        };

        return this.request<RunObject>({
            url: '/threads/{thread_id}/runs/{run_id}/submit_tool_outputs'.replace('{thread_id}', encodeURI(threadId)).replace('{run_id}', encodeURI(runId)),
            method: 'POST',
            headers,
            body: submitToolOutputsRunRequest,
        }, opts?.responseOpts);
    };

}

/**
 * @export
 * @enum {string}
 */
export enum ListAssistantFilesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
 * @export
 * @enum {string}
 */
export enum ListAssistantsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
 * @export
 * @enum {string}
 */
export enum ListMessageFilesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
 * @export
 * @enum {string}
 */
export enum ListMessagesOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
 * @export
 * @enum {string}
 */
export enum ListRunStepsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
 * @export
 * @enum {string}
 */
export enum ListRunsOrderEnum {
    Asc = 'asc',
    Desc = 'desc'
}
