// tslint:disable
/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Observable } from 'rxjs';
import type { AjaxResponse } from 'rxjs/ajax';
import { BaseAPI, throwIfNullOrUndefined, COLLECTION_FORMATS } from '../runtime';
import type { OperationOpts, HttpHeaders } from '../runtime';
import type {
    CreateSpeechRequest,
    CreateTranscription200Response,
    CreateTranscriptionRequestModel,
    CreateTranslation200Response,
} from '../models';

export interface CreateSpeechRequest {
    createSpeechRequest: CreateSpeechRequest;
}

export interface CreateTranscriptionRequest {
    file: Blob;
    model: CreateTranscriptionRequestModel;
    language?: string;
    prompt?: string;
    responseFormat?: CreateTranscriptionResponseFormatEnum;
    temperature?: number;
    timestampGranularities?: Array<CreateTranscriptionTimestampGranularitiesEnum>;
}

export interface CreateTranslationRequest {
    file: Blob;
    model: CreateTranscriptionRequestModel;
    prompt?: string;
    responseFormat?: string;
    temperature?: number;
}

/**
 * no description
 */
export class AudioApi extends BaseAPI {

    /**
     * Generates audio from the input text.
     */
    createSpeech({ createSpeechRequest }: CreateSpeechRequest): Observable<Blob>
    createSpeech({ createSpeechRequest }: CreateSpeechRequest, opts?: OperationOpts): Observable<AjaxResponse<Blob>>
    createSpeech({ createSpeechRequest }: CreateSpeechRequest, opts?: OperationOpts): Observable<Blob | AjaxResponse<Blob>> {
        throwIfNullOrUndefined(createSpeechRequest, 'createSpeechRequest', 'createSpeech');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
        };

        return this.request<Blob>({
            url: '/audio/speech',
            method: 'POST',
            headers,
            body: createSpeechRequest,
            responseType: 'blob',
        }, opts?.responseOpts);
    };

    /**
     * Transcribes audio into the input language.
     */
    createTranscription({ file, model, language, prompt, responseFormat, temperature, timestampGranularities }: CreateTranscriptionRequest): Observable<CreateTranscription200Response>
    createTranscription({ file, model, language, prompt, responseFormat, temperature, timestampGranularities }: CreateTranscriptionRequest, opts?: OperationOpts): Observable<AjaxResponse<CreateTranscription200Response>>
    createTranscription({ file, model, language, prompt, responseFormat, temperature, timestampGranularities }: CreateTranscriptionRequest, opts?: OperationOpts): Observable<CreateTranscription200Response | AjaxResponse<CreateTranscription200Response>> {
        throwIfNullOrUndefined(file, 'file', 'createTranscription');
        throwIfNullOrUndefined(model, 'model', 'createTranscription');

        const headers: HttpHeaders = {
        };

        const formData = new FormData();
        if (file !== undefined) { formData.append('file', file as any); }
        if (model !== undefined) { formData.append('model', model as any); }
        if (language !== undefined) { formData.append('language', language as any); }
        if (prompt !== undefined) { formData.append('prompt', prompt as any); }
        if (responseFormat !== undefined) { formData.append('response_format', responseFormat as any); }
        if (temperature !== undefined) { formData.append('temperature', temperature as any); }
        if (timestampGranularities !== undefined) {
            formData.append('timestamp_granularities[]', timestampGranularities.join(COLLECTION_FORMATS['csv']));
        }


        return this.request<CreateTranscription200Response>({
            url: '/audio/transcriptions',
            method: 'POST',
            headers,
            body: formData,
        }, opts?.responseOpts);
    };

    /**
     * Translates audio into English.
     */
    createTranslation({ file, model, prompt, responseFormat, temperature }: CreateTranslationRequest): Observable<CreateTranslation200Response>
    createTranslation({ file, model, prompt, responseFormat, temperature }: CreateTranslationRequest, opts?: OperationOpts): Observable<AjaxResponse<CreateTranslation200Response>>
    createTranslation({ file, model, prompt, responseFormat, temperature }: CreateTranslationRequest, opts?: OperationOpts): Observable<CreateTranslation200Response | AjaxResponse<CreateTranslation200Response>> {
        throwIfNullOrUndefined(file, 'file', 'createTranslation');
        throwIfNullOrUndefined(model, 'model', 'createTranslation');

        const headers: HttpHeaders = {
        };

        const formData = new FormData();
        if (file !== undefined) { formData.append('file', file as any); }
        if (model !== undefined) { formData.append('model', model as any); }
        if (prompt !== undefined) { formData.append('prompt', prompt as any); }
        if (responseFormat !== undefined) { formData.append('response_format', responseFormat as any); }
        if (temperature !== undefined) { formData.append('temperature', temperature as any); }

        return this.request<CreateTranslation200Response>({
            url: '/audio/translations',
            method: 'POST',
            headers,
            body: formData,
        }, opts?.responseOpts);
    };

}

/**
 * @export
 * @enum {string}
 */
export enum CreateTranscriptionResponseFormatEnum {
    Json = 'json',
    Text = 'text',
    Srt = 'srt',
    VerboseJson = 'verbose_json',
    Vtt = 'vtt'
}
/**
 * @export
 * @enum {string}
 */
export enum CreateTranscriptionTimestampGranularitiesEnum {
    Word = 'word',
    Segment = 'segment'
}
