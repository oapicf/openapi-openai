// tslint:disable
/**
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Observable } from 'rxjs';
import type { AjaxResponse } from 'rxjs/ajax';
import { BaseAPI, throwIfNullOrUndefined } from '../runtime';
import type { OperationOpts, HttpHeaders, HttpQuery } from '../runtime';
import type {
    UsageResponse,
} from '../models';

export interface UsageAudioSpeechesRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageAudioSpeechesBucketWidthEnum;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    groupBy?: Array<UsageAudioSpeechesGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageAudioTranscriptionsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageAudioTranscriptionsBucketWidthEnum;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    groupBy?: Array<UsageAudioTranscriptionsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageCodeInterpreterSessionsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageCodeInterpreterSessionsBucketWidthEnum;
    projectIds?: Array<string>;
    groupBy?: Array<UsageCodeInterpreterSessionsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageCompletionsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageCompletionsBucketWidthEnum;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    batch?: boolean;
    groupBy?: Array<UsageCompletionsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageCostsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageCostsBucketWidthEnum;
    projectIds?: Array<string>;
    groupBy?: Array<UsageCostsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageEmbeddingsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageEmbeddingsBucketWidthEnum;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    groupBy?: Array<UsageEmbeddingsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageImagesRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageImagesBucketWidthEnum;
    sources?: Array<UsageImagesSourcesEnum>;
    sizes?: Array<UsageImagesSizesEnum>;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    groupBy?: Array<UsageImagesGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageModerationsRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageModerationsBucketWidthEnum;
    projectIds?: Array<string>;
    userIds?: Array<string>;
    apiKeyIds?: Array<string>;
    models?: Array<string>;
    groupBy?: Array<UsageModerationsGroupByEnum>;
    limit?: number;
    page?: string;
}

export interface UsageVectorStoresRequest {
    startTime: number;
    endTime?: number;
    bucketWidth?: UsageVectorStoresBucketWidthEnum;
    projectIds?: Array<string>;
    groupBy?: Array<UsageVectorStoresGroupByEnum>;
    limit?: number;
    page?: string;
}

/**
 * no description
 */
export class UsageApi extends BaseAPI {

    /**
     * Get audio speeches usage details for the organization.
     */
    usageAudioSpeeches({ startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page }: UsageAudioSpeechesRequest): Observable<UsageResponse>
    usageAudioSpeeches({ startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page }: UsageAudioSpeechesRequest, opts?: OperationOpts): Observable<AjaxResponse<UsageResponse>>
    usageAudioSpeeches({ startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page }: UsageAudioSpeechesRequest, opts?: OperationOpts): Observable<UsageResponse | AjaxResponse<UsageResponse>> {
        throwIfNullOrUndefined(startTime, 'startTime', 'usageAudioSpeeches');

        const headers: HttpHeaders = {
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'start_time': startTime,
        };

        if (endTime != null) { query['end_time'] = endTime; }
        if (bucketWidth != null) { query['bucket_width'] = bucketWidth; }
        if (projectIds != null) { query['project_ids'] = projectIds; }
        if (userIds != null) { query['user_ids'] = userIds; }
        if (apiKeyIds != null) { query['api_key_ids'] = apiKeyIds; }
        if (models != null) { query['models'] = models; }
        if (groupBy != null) { query['group_by'] = groupBy; }
        if (limit != null) { query['limit'] = limit; }
        if (page != null) { query['page'] = page; }

        return this.request<UsageResponse>({
            url: '/organization/usage/audio_speeches',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get audio transcriptions usage details for the organization.
     */
    usageAudioTranscriptions({ startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page }: UsageAudioTranscriptionsRequest): Observable<UsageResponse>
    usageAudioTranscriptions({ startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page }: UsageAudioTranscriptionsRequest, opts?: OperationOpts): Observable<AjaxResponse<UsageResponse>>
    usageAudioTranscriptions({ startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page }: UsageAudioTranscriptionsRequest, opts?: OperationOpts): Observable<UsageResponse | AjaxResponse<UsageResponse>> {
        throwIfNullOrUndefined(startTime, 'startTime', 'usageAudioTranscriptions');

        const headers: HttpHeaders = {
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'start_time': startTime,
        };

        if (endTime != null) { query['end_time'] = endTime; }
        if (bucketWidth != null) { query['bucket_width'] = bucketWidth; }
        if (projectIds != null) { query['project_ids'] = projectIds; }
        if (userIds != null) { query['user_ids'] = userIds; }
        if (apiKeyIds != null) { query['api_key_ids'] = apiKeyIds; }
        if (models != null) { query['models'] = models; }
        if (groupBy != null) { query['group_by'] = groupBy; }
        if (limit != null) { query['limit'] = limit; }
        if (page != null) { query['page'] = page; }

        return this.request<UsageResponse>({
            url: '/organization/usage/audio_transcriptions',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get code interpreter sessions usage details for the organization.
     */
    usageCodeInterpreterSessions({ startTime, endTime, bucketWidth, projectIds, groupBy, limit, page }: UsageCodeInterpreterSessionsRequest): Observable<UsageResponse>
    usageCodeInterpreterSessions({ startTime, endTime, bucketWidth, projectIds, groupBy, limit, page }: UsageCodeInterpreterSessionsRequest, opts?: OperationOpts): Observable<AjaxResponse<UsageResponse>>
    usageCodeInterpreterSessions({ startTime, endTime, bucketWidth, projectIds, groupBy, limit, page }: UsageCodeInterpreterSessionsRequest, opts?: OperationOpts): Observable<UsageResponse | AjaxResponse<UsageResponse>> {
        throwIfNullOrUndefined(startTime, 'startTime', 'usageCodeInterpreterSessions');

        const headers: HttpHeaders = {
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'start_time': startTime,
        };

        if (endTime != null) { query['end_time'] = endTime; }
        if (bucketWidth != null) { query['bucket_width'] = bucketWidth; }
        if (projectIds != null) { query['project_ids'] = projectIds; }
        if (groupBy != null) { query['group_by'] = groupBy; }
        if (limit != null) { query['limit'] = limit; }
        if (page != null) { query['page'] = page; }

        return this.request<UsageResponse>({
            url: '/organization/usage/code_interpreter_sessions',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get completions usage details for the organization.
     */
    usageCompletions({ startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, batch, groupBy, limit, page }: UsageCompletionsRequest): Observable<UsageResponse>
    usageCompletions({ startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, batch, groupBy, limit, page }: UsageCompletionsRequest, opts?: OperationOpts): Observable<AjaxResponse<UsageResponse>>
    usageCompletions({ startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, batch, groupBy, limit, page }: UsageCompletionsRequest, opts?: OperationOpts): Observable<UsageResponse | AjaxResponse<UsageResponse>> {
        throwIfNullOrUndefined(startTime, 'startTime', 'usageCompletions');

        const headers: HttpHeaders = {
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'start_time': startTime,
        };

        if (endTime != null) { query['end_time'] = endTime; }
        if (bucketWidth != null) { query['bucket_width'] = bucketWidth; }
        if (projectIds != null) { query['project_ids'] = projectIds; }
        if (userIds != null) { query['user_ids'] = userIds; }
        if (apiKeyIds != null) { query['api_key_ids'] = apiKeyIds; }
        if (models != null) { query['models'] = models; }
        if (batch != null) { query['batch'] = batch; }
        if (groupBy != null) { query['group_by'] = groupBy; }
        if (limit != null) { query['limit'] = limit; }
        if (page != null) { query['page'] = page; }

        return this.request<UsageResponse>({
            url: '/organization/usage/completions',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get costs details for the organization.
     */
    usageCosts({ startTime, endTime, bucketWidth, projectIds, groupBy, limit, page }: UsageCostsRequest): Observable<UsageResponse>
    usageCosts({ startTime, endTime, bucketWidth, projectIds, groupBy, limit, page }: UsageCostsRequest, opts?: OperationOpts): Observable<AjaxResponse<UsageResponse>>
    usageCosts({ startTime, endTime, bucketWidth, projectIds, groupBy, limit, page }: UsageCostsRequest, opts?: OperationOpts): Observable<UsageResponse | AjaxResponse<UsageResponse>> {
        throwIfNullOrUndefined(startTime, 'startTime', 'usageCosts');

        const headers: HttpHeaders = {
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'start_time': startTime,
        };

        if (endTime != null) { query['end_time'] = endTime; }
        if (bucketWidth != null) { query['bucket_width'] = bucketWidth; }
        if (projectIds != null) { query['project_ids'] = projectIds; }
        if (groupBy != null) { query['group_by'] = groupBy; }
        if (limit != null) { query['limit'] = limit; }
        if (page != null) { query['page'] = page; }

        return this.request<UsageResponse>({
            url: '/organization/costs',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get embeddings usage details for the organization.
     */
    usageEmbeddings({ startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page }: UsageEmbeddingsRequest): Observable<UsageResponse>
    usageEmbeddings({ startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page }: UsageEmbeddingsRequest, opts?: OperationOpts): Observable<AjaxResponse<UsageResponse>>
    usageEmbeddings({ startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page }: UsageEmbeddingsRequest, opts?: OperationOpts): Observable<UsageResponse | AjaxResponse<UsageResponse>> {
        throwIfNullOrUndefined(startTime, 'startTime', 'usageEmbeddings');

        const headers: HttpHeaders = {
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'start_time': startTime,
        };

        if (endTime != null) { query['end_time'] = endTime; }
        if (bucketWidth != null) { query['bucket_width'] = bucketWidth; }
        if (projectIds != null) { query['project_ids'] = projectIds; }
        if (userIds != null) { query['user_ids'] = userIds; }
        if (apiKeyIds != null) { query['api_key_ids'] = apiKeyIds; }
        if (models != null) { query['models'] = models; }
        if (groupBy != null) { query['group_by'] = groupBy; }
        if (limit != null) { query['limit'] = limit; }
        if (page != null) { query['page'] = page; }

        return this.request<UsageResponse>({
            url: '/organization/usage/embeddings',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get images usage details for the organization.
     */
    usageImages({ startTime, endTime, bucketWidth, sources, sizes, projectIds, userIds, apiKeyIds, models, groupBy, limit, page }: UsageImagesRequest): Observable<UsageResponse>
    usageImages({ startTime, endTime, bucketWidth, sources, sizes, projectIds, userIds, apiKeyIds, models, groupBy, limit, page }: UsageImagesRequest, opts?: OperationOpts): Observable<AjaxResponse<UsageResponse>>
    usageImages({ startTime, endTime, bucketWidth, sources, sizes, projectIds, userIds, apiKeyIds, models, groupBy, limit, page }: UsageImagesRequest, opts?: OperationOpts): Observable<UsageResponse | AjaxResponse<UsageResponse>> {
        throwIfNullOrUndefined(startTime, 'startTime', 'usageImages');

        const headers: HttpHeaders = {
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'start_time': startTime,
        };

        if (endTime != null) { query['end_time'] = endTime; }
        if (bucketWidth != null) { query['bucket_width'] = bucketWidth; }
        if (sources != null) { query['sources'] = sources; }
        if (sizes != null) { query['sizes'] = sizes; }
        if (projectIds != null) { query['project_ids'] = projectIds; }
        if (userIds != null) { query['user_ids'] = userIds; }
        if (apiKeyIds != null) { query['api_key_ids'] = apiKeyIds; }
        if (models != null) { query['models'] = models; }
        if (groupBy != null) { query['group_by'] = groupBy; }
        if (limit != null) { query['limit'] = limit; }
        if (page != null) { query['page'] = page; }

        return this.request<UsageResponse>({
            url: '/organization/usage/images',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get moderations usage details for the organization.
     */
    usageModerations({ startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page }: UsageModerationsRequest): Observable<UsageResponse>
    usageModerations({ startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page }: UsageModerationsRequest, opts?: OperationOpts): Observable<AjaxResponse<UsageResponse>>
    usageModerations({ startTime, endTime, bucketWidth, projectIds, userIds, apiKeyIds, models, groupBy, limit, page }: UsageModerationsRequest, opts?: OperationOpts): Observable<UsageResponse | AjaxResponse<UsageResponse>> {
        throwIfNullOrUndefined(startTime, 'startTime', 'usageModerations');

        const headers: HttpHeaders = {
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'start_time': startTime,
        };

        if (endTime != null) { query['end_time'] = endTime; }
        if (bucketWidth != null) { query['bucket_width'] = bucketWidth; }
        if (projectIds != null) { query['project_ids'] = projectIds; }
        if (userIds != null) { query['user_ids'] = userIds; }
        if (apiKeyIds != null) { query['api_key_ids'] = apiKeyIds; }
        if (models != null) { query['models'] = models; }
        if (groupBy != null) { query['group_by'] = groupBy; }
        if (limit != null) { query['limit'] = limit; }
        if (page != null) { query['page'] = page; }

        return this.request<UsageResponse>({
            url: '/organization/usage/moderations',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get vector stores usage details for the organization.
     */
    usageVectorStores({ startTime, endTime, bucketWidth, projectIds, groupBy, limit, page }: UsageVectorStoresRequest): Observable<UsageResponse>
    usageVectorStores({ startTime, endTime, bucketWidth, projectIds, groupBy, limit, page }: UsageVectorStoresRequest, opts?: OperationOpts): Observable<AjaxResponse<UsageResponse>>
    usageVectorStores({ startTime, endTime, bucketWidth, projectIds, groupBy, limit, page }: UsageVectorStoresRequest, opts?: OperationOpts): Observable<UsageResponse | AjaxResponse<UsageResponse>> {
        throwIfNullOrUndefined(startTime, 'startTime', 'usageVectorStores');

        const headers: HttpHeaders = {
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'start_time': startTime,
        };

        if (endTime != null) { query['end_time'] = endTime; }
        if (bucketWidth != null) { query['bucket_width'] = bucketWidth; }
        if (projectIds != null) { query['project_ids'] = projectIds; }
        if (groupBy != null) { query['group_by'] = groupBy; }
        if (limit != null) { query['limit'] = limit; }
        if (page != null) { query['page'] = page; }

        return this.request<UsageResponse>({
            url: '/organization/usage/vector_stores',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

}

/**
 * @export
 * @enum {string}
 */
export enum UsageAudioSpeechesBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageAudioSpeechesGroupByEnum {
    ProjectId = 'project_id',
    UserId = 'user_id',
    ApiKeyId = 'api_key_id',
    Model = 'model'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageAudioTranscriptionsBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageAudioTranscriptionsGroupByEnum {
    ProjectId = 'project_id',
    UserId = 'user_id',
    ApiKeyId = 'api_key_id',
    Model = 'model'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageCodeInterpreterSessionsBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageCodeInterpreterSessionsGroupByEnum {
    ProjectId = 'project_id'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageCompletionsBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageCompletionsGroupByEnum {
    ProjectId = 'project_id',
    UserId = 'user_id',
    ApiKeyId = 'api_key_id',
    Model = 'model',
    Batch = 'batch'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageCostsBucketWidthEnum {
    _1d = '1d'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageCostsGroupByEnum {
    ProjectId = 'project_id',
    LineItem = 'line_item'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageEmbeddingsBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageEmbeddingsGroupByEnum {
    ProjectId = 'project_id',
    UserId = 'user_id',
    ApiKeyId = 'api_key_id',
    Model = 'model'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageImagesBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageImagesSourcesEnum {
    ImageGeneration = 'image.generation',
    ImageEdit = 'image.edit',
    ImageVariation = 'image.variation'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageImagesSizesEnum {
    _256x256 = '256x256',
    _512x512 = '512x512',
    _1024x1024 = '1024x1024',
    _1792x1792 = '1792x1792',
    _1024x1792 = '1024x1792'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageImagesGroupByEnum {
    ProjectId = 'project_id',
    UserId = 'user_id',
    ApiKeyId = 'api_key_id',
    Model = 'model',
    Size = 'size',
    Source = 'source'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageModerationsBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageModerationsGroupByEnum {
    ProjectId = 'project_id',
    UserId = 'user_id',
    ApiKeyId = 'api_key_id',
    Model = 'model'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageVectorStoresBucketWidthEnum {
    _1m = '1m',
    _1h = '1h',
    _1d = '1d'
}
/**
 * @export
 * @enum {string}
 */
export enum UsageVectorStoresGroupByEnum {
    ProjectId = 'project_id'
}
